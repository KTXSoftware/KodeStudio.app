import { DebugProtocol } from 'vscode-debugprotocol';
import { DebugSession } from 'vscode-debugadapter';
import { ChromeDebugAdapter } from './chromeDebugAdapter';
import { ITargetFilter, ChromeConnection } from './chromeConnection';
import { BasePathTransformer } from '../transformers/basePathTransformer';
import { BaseSourceMapTransformer } from '../transformers/baseSourceMapTransformer';
import { LineColTransformer } from '../transformers/lineNumberTransformer';
export interface IChromeDebugAdapterOpts {
    targetFilter?: ITargetFilter;
    logFilePath?: string;
    chromeConnection?: typeof ChromeConnection;
    pathTransformer?: typeof BasePathTransformer;
    sourceMapTransformer?: typeof BaseSourceMapTransformer;
    lineColTransformer?: typeof LineColTransformer;
}
export interface IChromeDebugSessionOpts extends IChromeDebugAdapterOpts {
    /** The class of the adapter, which is instantiated for each session */
    adapter: typeof ChromeDebugAdapter;
    extensionName: string;
}
export declare class ChromeDebugSession extends DebugSession {
    private _debugAdapter;
    private _extensionName;
    /**
     * This needs a bit of explanation -
     * The Session is reinstantiated for each session, but consumers need to configure their instance of
     * ChromeDebugSession. Consumers should call getSession with their config options, then call
     * DebugSession.run with the result. Alternatively they could subclass ChromeDebugSession and pass
     * their options to the super constructor, but I think this is easier to follow.
     */
    static getSession(opts: IChromeDebugSessionOpts): typeof ChromeDebugSession;
    constructor(debuggerLinesAndColumnsStartAt1?: boolean, isServer?: boolean, opts?: IChromeDebugSessionOpts);
    /**
     * Overload sendEvent to log
     */
    sendEvent(event: DebugProtocol.Event): void;
    /**
     * Overload sendRequest to log
     */
    sendRequest(command: string, args: any, timeout: number, cb: (response: DebugProtocol.Response) => void): void;
    /**
     * Overload sendResponse to log
     */
    sendResponse(response: DebugProtocol.Response): void;
    private onLog(msg, level);
    /**
     * Takes a response and a promise to the response body. If the promise is successful, assigns the response body and sends the response.
     * If the promise fails, sets the appropriate response parameters and sends the response.
     */
    private sendResponseAsync(request, response, responseP);
    /**
     * Overload dispatchRequest to the debug adapters' Promise-based methods instead of DebugSession's callback-based methods
     */
    protected dispatchRequest(request: DebugProtocol.Request): void;
    private failedRequest(requestType, response, error);
}
