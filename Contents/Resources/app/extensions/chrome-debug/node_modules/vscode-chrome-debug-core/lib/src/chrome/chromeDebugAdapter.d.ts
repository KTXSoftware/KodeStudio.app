import { DebugProtocol } from 'vscode-debugprotocol';
import { ICommonRequestArgs, ILaunchRequestArgs, ISetBreakpointsArgs, ISetBreakpointsResponseBody, IStackTraceResponseBody, IAttachRequestArgs, IScopesResponseBody, IVariablesResponseBody, ISourceResponseBody, IThreadsResponseBody, IEvaluateResponseBody, ISetVariableResponseBody, IDebugAdapter, ICompletionsResponseBody } from '../debugAdapterInterfaces';
import { IChromeDebugAdapterOpts, ChromeDebugSession } from './chromeDebugSession';
import Crdp from '../../crdp/crdp';
import { BaseSourceMapTransformer } from '../transformers/baseSourceMapTransformer';
/**
 * Represents a reference to a source/script. `contents` is set if there are inlined sources.
 * Otherwise, scriptId can be used to retrieve the contents from the runtime.
 */
export interface ISourceContainer {
    /** The runtime-side scriptId of this script */
    scriptId?: Crdp.Runtime.ScriptId;
    /** The contents of this script, if they are inlined in the sourcemap */
    contents?: string;
    /** The authored path to this script (only set if the contents are inlined) */
    mappedPath?: string;
}
export declare abstract class ChromeDebugAdapter implements IDebugAdapter {
    static PLACEHOLDER_URL_PROTOCOL: string;
    private static SCRIPTS_COMMAND;
    private static THREAD_ID;
    private static SET_BREAKPOINTS_TIMEOUT;
    private static HITCONDITION_MATCHER;
    protected _session: ChromeDebugSession;
    private _clientAttached;
    private _currentStack;
    private _committedBreakpointsByUrl;
    private _exception;
    private _setBreakpointsRequestQ;
    private _expectingResumedEvent;
    protected _expectingStopReason: string;
    private _frameHandles;
    private _variableHandles;
    private _breakpointIdHandles;
    private _sourceHandles;
    private _scriptsById;
    private _scriptsByUrl;
    private _pendingBreakpointsByUrl;
    private _hitConditionBreakpointsById;
    private _chromeConnection;
    private _lineColTransformer;
    protected _sourceMapTransformer: BaseSourceMapTransformer;
    private _pathTransformer;
    private _hasTerminated;
    protected _inShutdown: boolean;
    protected _attachMode: boolean;
    protected _launchAttachArgs: ICommonRequestArgs;
    private _blackboxedRegexes;
    private _currentStep;
    private _nextUnboundBreakpointId;
    private _smartStepCount;
    private _initialSourceMapsP;
    constructor({chromeConnection, lineColTransformer, sourceMapTransformer, pathTransformer}: IChromeDebugAdapterOpts, session: ChromeDebugSession);
    protected readonly chrome: Crdp.CrdpClient;
    /**
     * Called on 'clearEverything' or on a navigation/refresh
     */
    protected clearTargetContext(): void;
    initialize(args: DebugProtocol.InitializeRequestArguments): DebugProtocol.Capabilities;
    configurationDone(): Promise<void>;
    launch(args: ILaunchRequestArgs): Promise<void>;
    attach(args: IAttachRequestArgs): Promise<void>;
    commonArgs(args: ICommonRequestArgs): void;
    shutdown(): void;
    /**
     * Chrome is closing, or error'd somehow, stop the debug session
     */
    protected terminateSession(reason: string, restart?: boolean): void;
    /**
     * Hook up all connection events
     */
    protected hookConnectionEvents(): void;
    /**
     * Enable clients and run connection
     */
    protected runConnection(): Promise<void>[];
    protected doAttach(port: number, targetUrl?: string, address?: string, timeout?: number): Promise<void>;
    /**
     * This event tells the client to begin sending setBP requests, etc. Some consumers need to override this
     * to send it at a later time of their choosing.
     */
    protected sendInitializedEvent(): void;
    /**
     * e.g. the target navigated
     */
    private onExecutionContextsCleared();
    protected onPaused(notification: Crdp.Debugger.PausedEvent): void;
    private shouldSmartStep(frame);
    private stopReasonText(reason);
    protected onResumed(): void;
    protected onScriptParsed(script: Crdp.Debugger.ScriptParsedEvent): void;
    private resolveSkipFiles(scriptId, mappedUrl, sources);
    private shouldSkipFile(sourcePath);
    private resolvePendingBreakpoint(pendingBP);
    protected onBreakpointResolved(params: Crdp.Debugger.BreakpointResolvedEvent): void;
    protected onConsoleAPICalled(params: Crdp.Runtime.ConsoleAPICalledEvent): void;
    /**
     * For backcompat, also listen to Console.messageAdded, only if it looks like the old format.
     */
    protected onMessageAdded(params: any): void;
    disconnect(): void;
    setBreakpoints(args: ISetBreakpointsArgs, requestSeq: number, ids?: number[]): Promise<ISetBreakpointsResponseBody>;
    private reportBpTelemetry(args);
    private validateBreakpointsPath(args);
    private unverifiedBpResponse(args, requestSeq, message?);
    private clearAllBreakpoints(url);
    /**
     * Makes the actual call to either Debugger.setBreakpoint or Debugger.setBreakpointByUrl, and returns the response.
     * Responses from setBreakpointByUrl are transformed to look like the response from setBreakpoint, so they can be
     * handled the same.
     */
    protected addBreakpoints(url: string, breakpoints: DebugProtocol.SourceBreakpoint[]): Promise<Crdp.Debugger.SetBreakpointResponse[]>;
    private chromeBreakpointResponsesToODPBreakpoints(url, responses, requestBps, ids?);
    private addHitConditionBreakpoint(requestBp, response);
    setExceptionBreakpoints(args: DebugProtocol.SetExceptionBreakpointsArguments): Promise<void>;
    /**
     * internal -> suppress telemetry
     */
    continue(internal?: boolean): Promise<void>;
    next(): Promise<void>;
    stepIn(): Promise<void>;
    stepOut(): Promise<void>;
    pause(): Promise<void>;
    stackTrace(args: DebugProtocol.StackTraceArguments): IStackTraceResponseBody;
    private callFrameToStackFrame(frame);
    /**
     * Get the existing handle for this script, identified by runtime scriptId, or create a new one
     */
    private getSourceReferenceForScriptId(scriptId);
    scopes(args: DebugProtocol.ScopesArguments): IScopesResponseBody;
    variables(args: DebugProtocol.VariablesArguments): Promise<IVariablesResponseBody>;
    propertyDescriptorToVariable(propDesc: Crdp.Runtime.PropertyDescriptor, owningObjectId?: string, parentEvaluateName?: string): Promise<DebugProtocol.Variable>;
    getVariablesForObjectId(objectId: string, evaluateName?: string, filter?: string, start?: number, count?: number): Promise<DebugProtocol.Variable[]>;
    private internalPropertyDescriptorToVariable(propDesc, parentEvaluateName);
    private getFilteredVariablesForObject(objectId, evaluateName, filter, start, count);
    private getFilteredVariablesForObjectId(objectId, evaluateName, getVarsFn, filter, start, count);
    source(args: DebugProtocol.SourceArguments): Promise<ISourceResponseBody>;
    threads(): IThreadsResponseBody;
    evaluate(args: DebugProtocol.EvaluateArguments): Promise<IEvaluateResponseBody>;
    /**
     * Handle the .scripts command, which can be used as `.scripts` to return a list of all script details,
     * or `.scripts <url>` to show the contents of the given script.
     */
    private handleScriptsCommand(args);
    private getAllScriptsString();
    private getOneScriptString(runtimeScriptPath);
    /**
     * Allow consumers to override just because of https://github.com/nodejs/node/issues/8426
     */
    protected globalEvaluate(args: Crdp.Runtime.EvaluateRequest): Promise<Crdp.Runtime.EvaluateResponse>;
    setVariable(args: DebugProtocol.SetVariableArguments): Promise<ISetVariableResponseBody>;
    setVariableValue(callFrameId: string, scopeNumber: number, variableName: string, value: string): Promise<string>;
    setPropertyValue(objectId: string, propName: string, value: string): Promise<string>;
    remoteObjectToVariable(name: string, object: Crdp.Runtime.RemoteObject, parentEvaluateName?: string, stringify?: boolean, context?: string): Promise<DebugProtocol.Variable>;
    createFunctionVariable(name: string, object: Crdp.Runtime.RemoteObject, parentEvaluateName?: string): DebugProtocol.Variable;
    createObjectVariable(name: string, object: Crdp.Runtime.RemoteObject, parentEvaluateName: string, context: string): Promise<DebugProtocol.Variable>;
    completions(args: DebugProtocol.CompletionsArguments): Promise<ICompletionsResponseBody>;
    private getFlatAndUniqueCompletionItems(arrays);
    private getArrayNumPropsByEval(objectId);
    private getArrayNumPropsByPreview(object);
    private getCollectionNumPropsByEval(objectId);
    private getCollectionNumPropsByPreview(object);
    private getNumPropsByEval(objectId, getNumPropsFn);
    private shouldIgnoreScript(script);
}
