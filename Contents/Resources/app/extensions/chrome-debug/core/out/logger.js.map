{"version":3,"file":"logger.js","sourceRoot":"../src","sources":["logger.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nexport enum LogLevel {\n    Verbose = 0,\n    Log = 1,\n    Error = 2\n}\n\nexport type ILogCallback = (msg: string, level: LogLevel) => void;\n\ninterface ILogItem {\n    msg: string;\n    level: LogLevel;\n}\n\n/** Logger singleton */\nlet _logger: Logger;\nlet _pendingLogQ: ILogItem[] = [];\nexport function log(msg: string, level = LogLevel.Log, forceDiagnosticLogging = false): void {\n    if (_pendingLogQ) {\n        _pendingLogQ.push({ msg, level });\n    } else {\n        _logger.log(msg, level, forceDiagnosticLogging);\n    }\n}\n\nexport function verbose(msg: string): void {\n    log(msg, LogLevel.Verbose);\n}\n\nexport function error(msg: string, forceDiagnosticLogging = true): void {\n    log(msg, LogLevel.Error, forceDiagnosticLogging);\n}\n\n/**\n * Set the logger's minimum level to log. Log messages are queued before this is\n * called the first time, because minLogLevel defaults to Error.\n */\nexport function setMinLogLevel(logLevel: LogLevel): void {\n    if (_logger) {\n        _logger.minLogLevel = logLevel;\n\n        // Clear out the queue of pending messages\n        if (_pendingLogQ) {\n            const logQ = _pendingLogQ;\n            _pendingLogQ = null;\n            logQ.forEach(item => log(item.msg, item.level));\n        }\n    }\n}\n\nexport function init(logCallback: ILogCallback, logFileDirectory?: string): void {\n    if (!_logger) {\n        _logger = new Logger(logCallback, logFileDirectory);\n    }\n}\n\n/**\n * Manages logging, whether to console.log, file, or VS Code console.\n */\nclass Logger {\n    /** The directory in which to log vscode-chrome-debug.txt */\n    private _logFileDirectory: string;\n\n    /** True when logging is enabled outside of server mode */\n    private _minLogLevel: LogLevel;\n\n    /** When not in server mode, the log msg is sent to this callback. */\n    private _diagnosticLogCallback: ILogCallback;\n\n    /** Write steam for log file */\n    private _logFileStream: fs.WriteStream;\n\n    public get minLogLevel(): LogLevel { return this._minLogLevel; }\n\n    public set minLogLevel(logLevel: LogLevel) {\n        this._minLogLevel = logLevel;\n\n        // Open a log file in the specified location. Overwritten on each run.\n        if (logLevel < LogLevel.Error && this._logFileDirectory) {\n            const logPath = path.join(this._logFileDirectory, 'vscode-chrome-debug.txt');\n            this._logFileStream = fs.createWriteStream(logPath);\n            this._logFileStream.on('error', e => {\n                this.sendLog(`Error involving log file at path: ${logPath}. Error: ${e.toString()}`, LogLevel.Error);\n            });\n        }\n    }\n\n    constructor(logCallback: ILogCallback, logFileDirectory?: string) {\n        this._diagnosticLogCallback = logCallback;\n        this._logFileDirectory = logFileDirectory;\n\n        this.minLogLevel = LogLevel.Error;\n    }\n\n    /**\n     * @param forceDiagnosticLogging - Writes to the diagnostic logging channel, even if diagnostic logging is not enabled.\n     *      (For warnings/errors that appear whether logging is enabled or not.)\n     */\n    public log(msg: string, level: LogLevel, forceDiagnosticLogging: boolean): void {\n        this.sendLog(msg, level);\n\n        // If an error, prepend with '[LogLevel]'\n        if (level === LogLevel.Error) {\n            msg = `[${LogLevel[level]}] ${msg}`;\n        }\n\n        if (this._logFileStream) {\n            this._logFileStream.write(msg + '\\n');\n        }\n    }\n\n    private sendLog(msg: string, level: LogLevel): void {\n        if (level < this.minLogLevel) return;\n\n        // Truncate long messages, they can hang VS Code\n        if (msg.length > 1500) msg = msg.substr(0, 1500) + '[...]';\n\n        if (this._diagnosticLogCallback) {\n            this._diagnosticLogCallback(msg, level);\n        }\n    }\n}\n"]}