{"version":3,"file":"transformers/pathTransformer.js","sourceRoot":"../../src","sources":["transformers/pathTransformer.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n\nimport {DebugProtocol} from 'vscode-debugprotocol';\n\nimport {ISetBreakpointsArgs, IDebugTransformer, ILaunchRequestArgs, IAttachRequestArgs, IStackTraceResponseBody} from '../chrome/debugAdapterInterfaces';\nimport * as utils from '../utils';\nimport * as logger from '../logger';\nimport * as ChromeUtils from '../chrome/chromeUtils';\n\ninterface IPendingBreakpoint {\n    resolve: () => void;\n    reject: (e: Error) => void;\n    args: ISetBreakpointsArgs;\n}\n\n/**\n * Converts a local path from Code to a path on the target.\n */\nexport class PathTransformer implements IDebugTransformer {\n    private _webRoot: string;\n    private _clientPathToTargetUrl = new Map<string, string>();\n    private _targetUrlToClientPath = new Map<string, string>();\n    private _pendingBreakpointsByPath = new Map<string, IPendingBreakpoint>();\n\n    public launch(args: ILaunchRequestArgs): void {\n        this._webRoot = args.webRoot;\n    }\n\n    public attach(args: IAttachRequestArgs): void {\n        this._webRoot = args.webRoot;\n    }\n\n    public setBreakpoints(args: ISetBreakpointsArgs): Promise<void> {\n        return new Promise<void>((resolve, reject) => {\n            if (!args.source.path) {\n                resolve();\n                return;\n            }\n\n            if (utils.isURL(args.source.path)) {\n                // already a url, use as-is\n                logger.log(`Paths.setBP: ${args.source.path} is already a URL`);\n                resolve();\n                return;\n            }\n\n            const path = utils.canonicalizeUrl(args.source.path);\n            if (this._clientPathToTargetUrl.has(path)) {\n                args.source.path = this._clientPathToTargetUrl.get(path);\n                logger.log(`Paths.setBP: Resolved ${path} to ${args.source.path}`);\n                resolve();\n            } else {\n                logger.log(`Paths.setBP: No target url cached for client path: ${path}, waiting for target script to be loaded.`);\n                args.source.path = path;\n                this._pendingBreakpointsByPath.set(args.source.path, { resolve, reject, args });\n            }\n        });\n    }\n\n    public clearClientContext(): void {\n        this._pendingBreakpointsByPath = new Map<string, IPendingBreakpoint>();\n    }\n\n    public clearTargetContext(): void {\n        this._clientPathToTargetUrl = new Map<string, string>();\n        this._targetUrlToClientPath = new Map<string, string>();\n    }\n\n    public scriptParsed(event: DebugProtocol.Event): void {\n        const targetUrl: string = event.body.scriptUrl;\n        const clientPath = ChromeUtils.targetUrlToClientPath(this._webRoot, targetUrl);\n\n        if (!clientPath) {\n            // It's expected that eval scripts (debugadapter:) won't be resolved\n            if (!targetUrl.startsWith('debugadapter://')) {\n                logger.log(`Paths.scriptParsed: could not resolve ${targetUrl} to a file under webRoot: ${this._webRoot}. It may be external or served directly from the server's memory (and that's OK).`);\n            }\n        } else {\n            logger.log(`Paths.scriptParsed: resolved ${targetUrl} to ${clientPath}. webRoot: ${this._webRoot}`);\n            this._clientPathToTargetUrl.set(clientPath, targetUrl);\n            this._targetUrlToClientPath.set(targetUrl, clientPath);\n\n            event.body.scriptUrl = clientPath;\n        }\n\n        if (this._pendingBreakpointsByPath.has(event.body.scriptUrl)) {\n            logger.log(`Paths.scriptParsed: Resolving pending breakpoints for ${event.body.scriptUrl}`);\n            const pendingBreakpoint = this._pendingBreakpointsByPath.get(event.body.scriptUrl);\n            this._pendingBreakpointsByPath.delete(event.body.scriptUrl);\n            this.setBreakpoints(pendingBreakpoint.args).then(pendingBreakpoint.resolve, pendingBreakpoint.reject);\n        }\n    }\n\n    public stackTraceResponse(response: IStackTraceResponseBody): void {\n        response.stackFrames.forEach(frame => {\n            if (frame.source.path) {\n                // Try to resolve the url to a path in the workspace. If it's not in the workspace,\n                // just use the script.url as-is. It will be resolved or cleared by the SourceMapTransformer.\n                const clientPath = this._targetUrlToClientPath.has(frame.source.path) ?\n                    this._targetUrlToClientPath.get(frame.source.path) :\n                    ChromeUtils.targetUrlToClientPath(this._webRoot, frame.source.path);\n\n                // Incoming stackFrames have sourceReference and path set. If the path was resolved to a file in the workspace,\n                // clear the sourceReference since it's not needed.\n                if (clientPath) {\n                    frame.source.path = clientPath;\n                    frame.source.sourceReference = 0;\n                }\n            }\n        });\n    }\n}\n"]}