{"version":3,"file":"transformers/sourceMapTransformer.js","sourceRoot":"../../src","sources":["transformers/sourceMapTransformer.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n\nimport * as path from 'path';\n\nimport {DebugProtocol} from 'vscode-debugprotocol';\n\nimport {IDebugTransformer, ISetBreakpointsArgs, ILaunchRequestArgs, IAttachRequestArgs,\n    ISetBreakpointsResponseBody, IStackTraceResponseBody} from '../chrome/debugAdapterInterfaces';\nimport {SourceMaps} from '../sourceMaps/sourceMaps';\nimport * as utils from '../utils';\nimport * as logger from '../logger';\n\ninterface IPendingBreakpoint {\n    resolve: () => void;\n    reject: (e: Error) => void;\n    args: ISetBreakpointsArgs;\n    requestSeq: number;\n}\n\n/**\n * If sourcemaps are enabled, converts from source files on the client side to runtime files on the target side\n */\nexport class SourceMapTransformer implements IDebugTransformer {\n    private _sourceMaps: SourceMaps;\n    private _requestSeqToSetBreakpointsArgs: Map<number, ISetBreakpointsArgs>;\n    private _allRuntimeScriptPaths: Set<string>;\n    private _pendingBreakpointsByPath = new Map<string, IPendingBreakpoint>();\n    private _webRoot: string;\n    private _authoredPathsToMappedBPLines: Map<string, number[]>;\n    private _authoredPathsToMappedBPCols: Map<string, number[]>;\n\n    public launch(args: ILaunchRequestArgs): void {\n        this.init(args);\n    }\n\n    public attach(args: IAttachRequestArgs): void {\n        this.init(args);\n    }\n\n    private init(args: ILaunchRequestArgs | IAttachRequestArgs): void {\n        if (args.sourceMaps) {\n            this._webRoot = args.webRoot;\n            this._sourceMaps = new SourceMaps(this._webRoot);\n            this._requestSeqToSetBreakpointsArgs = new Map<number, ISetBreakpointsArgs>();\n            this._allRuntimeScriptPaths = new Set<string>();\n            this._authoredPathsToMappedBPLines = new Map<string, number[]>();\n            this._authoredPathsToMappedBPCols = new Map<string, number[]>();\n        }\n    }\n\n    public clearTargetContext(): void {\n        this._allRuntimeScriptPaths = new Set<string>();\n    }\n\n    /**\n     * Apply sourcemapping to the setBreakpoints request path/lines\n     */\n    public setBreakpoints(args: ISetBreakpointsArgs, requestSeq: number): Promise<void> {\n        return new Promise<void>((resolve, reject) => {\n            if (this._sourceMaps && args.source.path) {\n                const argsPath = args.source.path;\n                const mappedPath = this._sourceMaps.getGeneratedPathFromAuthoredPath(argsPath);\n                if (mappedPath) {\n                    logger.log(`SourceMaps.setBP: Mapped ${argsPath} to ${mappedPath}`);\n                    args.authoredPath = argsPath;\n                    args.source.path = mappedPath;\n\n                    // DebugProtocol doesn't send cols, but they need to be added from sourcemaps\n                    const mappedCols = [];\n                    const mappedLines = args.lines.map((line, i) => {\n                        const mapped = this._sourceMaps.mapToGenerated(argsPath, line, /*column=*/0);\n                        if (mapped) {\n                            logger.log(`SourceMaps.setBP: Mapped ${argsPath}:${line}:0 to ${mappedPath}:${mapped.line}:${mapped.column}`);\n                            mappedCols[i] = mapped.column;\n                            return mapped.line;\n                        } else {\n                            logger.log(`SourceMaps.setBP: Mapped ${argsPath} but not line ${line}, column 0`);\n                            mappedCols[i] = 0;\n                            return line;\n                        }\n                    });\n\n                    this._authoredPathsToMappedBPLines.set(argsPath, mappedLines);\n                    this._authoredPathsToMappedBPCols.set(argsPath, mappedCols);\n\n                    // Include BPs from other files that map to the same file. Ensure the current file's breakpoints go first\n                    args.lines = mappedLines;\n                    args.cols = mappedCols;\n                    this._sourceMaps.allMappedSources(mappedPath).forEach(sourcePath => {\n                        if (sourcePath === argsPath) {\n                            return;\n                        }\n\n                        const sourceBPLines = this._authoredPathsToMappedBPLines.get(sourcePath);\n                        const sourceBPCols = this._authoredPathsToMappedBPCols.get(sourcePath);\n\n                        if (sourceBPLines && sourceBPCols) {\n                            // Don't modify the cached array\n                            args.lines = args.lines.concat(sourceBPLines);\n                            args.cols = args.cols.concat(sourceBPCols);\n                        }\n                    });\n                } else if (this._allRuntimeScriptPaths.has(argsPath)) {\n                    // It's a generated file which is loaded\n                    logger.log(`SourceMaps.setBP: SourceMaps are enabled but ${argsPath} is a runtime script`);\n                } else {\n                    // Source (or generated) file which is not loaded, need to wait\n                    logger.log(`SourceMaps.setBP: ${argsPath} can't be resolved to a loaded script. It may just not be loaded yet.`);\n                    this._pendingBreakpointsByPath.set(argsPath, { resolve, reject, args, requestSeq });\n                    return;\n                }\n\n                this._requestSeqToSetBreakpointsArgs.set(requestSeq, JSON.parse(JSON.stringify(args)));\n                resolve();\n            } else {\n                resolve();\n            }\n        });\n    }\n\n    /**\n     * Apply sourcemapping back to authored files from the response\n     */\n    public setBreakpointsResponse(response: ISetBreakpointsResponseBody, requestSeq: number): void {\n        if (this._sourceMaps && this._requestSeqToSetBreakpointsArgs.has(requestSeq)) {\n            const args = this._requestSeqToSetBreakpointsArgs.get(requestSeq);\n            if (args.authoredPath) {\n                const sourceBPLines = this._authoredPathsToMappedBPLines.get(args.authoredPath);\n                if (sourceBPLines) {\n                    // authoredPath is set, so the file was mapped to source.\n                    // Remove breakpoints from files that map to the same file, and map back to source.\n                    response.breakpoints = response.breakpoints.filter((_, i) => i < sourceBPLines.length);\n                    response.breakpoints.forEach(bp => {\n                        const mapped = this._sourceMaps.mapToAuthored(args.source.path, bp.line, bp.column);\n                        if (mapped) {\n                            logger.log(`SourceMaps.setBP: Mapped ${args.source.path}:${bp.line}:${bp.column} to ${mapped.source}:${mapped.line}`);\n                            bp.line = mapped.line;\n                        } else {\n                            logger.log(`SourceMaps.setBP: Can't map ${args.source.path}:${bp.line}:${bp.column}, keeping the line number as-is.`);\n                        }\n\n                        this._requestSeqToSetBreakpointsArgs.delete(requestSeq);\n                    });\n                }\n            }\n        }\n\n        // Cleanup column, which is passed in here in case it's needed for sourcemaps, but isn't actually\n        // part of the DebugProtocol\n        response.breakpoints.forEach(bp => {\n            delete bp.column;\n        });\n    }\n\n    /**\n     * Apply sourcemapping to the stacktrace response\n     */\n    public stackTraceResponse(response: IStackTraceResponseBody): void {\n        if (this._sourceMaps) {\n            response.stackFrames.forEach(stackFrame => {\n                const mapped = this._sourceMaps.mapToAuthored(stackFrame.source.path, stackFrame.line, stackFrame.column);\n                if (mapped && utils.existsSync(mapped.source)) {\n                    // Script was mapped to a valid path\n                    stackFrame.source.path = mapped.source;\n                    stackFrame.source.sourceReference = 0;\n                    stackFrame.source.name = path.basename(mapped.source);\n                    stackFrame.line = mapped.line;\n                    stackFrame.column = mapped.column;\n                } else if (utils.existsSync(stackFrame.source.path)) {\n                    // Script could not be mapped, but does exist on disk. Keep it and clear the sourceReference.\n                    stackFrame.source.sourceReference = 0;\n                } else {\n                    // Script could not be mapped and doesn't exist on disk. Clear the path, use sourceReference.\n                    stackFrame.source.name = 'eval: ' + stackFrame.source.sourceReference;\n                    stackFrame.source.path = undefined;\n                }\n            });\n        } else {\n            response.stackFrames.forEach(stackFrame => {\n                // PathTransformer needs to leave the frame in an unfinished state because it doesn't know whether sourcemaps are enabled\n                if (stackFrame.source.path && stackFrame.source.sourceReference) {\n                    stackFrame.source.path = undefined;\n                }\n            });\n        }\n    }\n\n    public scriptParsed(event: DebugProtocol.Event): void {\n        if (this._sourceMaps) {\n            this._allRuntimeScriptPaths.add(event.body.scriptUrl);\n\n            if (!event.body.sourceMapURL) {\n                // If a file does not have a source map, check if we've seen any breakpoints\n                // for it anyway and make sure to enable them\n                this.resolvePendingBreakpointsForScript(event.body.scriptUrl);\n                return;\n            }\n\n            this._sourceMaps.processNewSourceMap(event.body.scriptUrl, event.body.sourceMapURL).then(() => {\n                const sources = this._sourceMaps.allMappedSources(event.body.scriptUrl);\n                if (sources) {\n                    logger.log(`SourceMaps.scriptParsed: ${event.body.scriptUrl} was just loaded and has mapped sources: ${JSON.stringify(sources) }`);\n                    sources.forEach(sourcePath => {\n                        this.resolvePendingBreakpointsForScript(sourcePath);\n                    });\n                }\n            });\n        }\n    }\n\n    /**\n     * Resolve any pending breakpoints for this script\n     */\n    private resolvePendingBreakpointsForScript(scriptUrl: string): void {\n        if (this._pendingBreakpointsByPath.has(scriptUrl)) {\n            logger.log(`SourceMaps.scriptParsed: Resolving pending breakpoints for ${scriptUrl}`);\n\n            let pendingBreakpoints = this._pendingBreakpointsByPath.get(scriptUrl);\n            this._pendingBreakpointsByPath.delete(scriptUrl);\n\n            // If there's a setBreakpoints request waiting on this script, go through setBreakpoints again\n            this.setBreakpoints(pendingBreakpoints.args, pendingBreakpoints.requestSeq)\n                .then(pendingBreakpoints.resolve, pendingBreakpoints.reject);\n        }\n    }\n}\n"]}