// Generated by Haxe 3.4.0
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); };
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = ["EReg"];
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw new js__$Boot_HaxeError("EReg::matched");
		}
	}
	,matchedRight: function() {
		if(this.r.m == null) {
			throw new js__$Boot_HaxeError("No string matched");
		}
		var sz = this.r.m.index + this.r.m[0].length;
		return HxOverrides.substr(this.r.s,sz,this.r.s.length - sz);
	}
	,matchedPos: function() {
		if(this.r.m == null) {
			throw new js__$Boot_HaxeError("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	,matchSub: function(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			var tmp = this.r;
			var tmp1 = len < 0 ? s : HxOverrides.substr(s,0,pos + len);
			this.r.m = tmp.exec(tmp1);
			var b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			var b1 = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b1) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b1;
		}
	}
	,map: function(s,f) {
		var offset = 0;
		var buf_b = "";
		while(true) {
			if(offset >= s.length) {
				break;
			} else if(!this.matchSub(s,offset)) {
				buf_b += Std.string(HxOverrides.substr(s,offset,null));
				break;
			}
			var p = this.matchedPos();
			buf_b += Std.string(HxOverrides.substr(s,offset,p.pos - offset));
			buf_b += Std.string(f(this));
			if(p.len == 0) {
				buf_b += Std.string(HxOverrides.substr(s,p.pos,1));
				offset = p.pos + 1;
			} else {
				offset = p.pos + p.len;
			}
			if(!this.r.global) {
				break;
			}
		}
		if(!this.r.global && offset > 0 && offset < s.length) {
			buf_b += Std.string(HxOverrides.substr(s,offset,null));
		}
		return buf_b;
	}
	,__class__: EReg
};
var HxOverrides = function() { };
HxOverrides.__name__ = ["HxOverrides"];
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
Math.__name__ = ["Math"];
var Reflect = function() { };
Reflect.__name__ = ["Reflect"];
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( e ) {
		haxe_CallStack.lastException = e;
		return null;
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.compare = function(a,b) {
	if(a == b) {
		return 0;
	} else if(a > b) {
		return 1;
	} else {
		return -1;
	}
};
var Std = function() { };
Std.__name__ = ["Std"];
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x,10);
	if(v == 0 && (HxOverrides.cca(x,1) == 120 || HxOverrides.cca(x,1) == 88)) {
		v = parseInt(x);
	}
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var StringBuf = function() {
	this.b = "";
};
StringBuf.__name__ = ["StringBuf"];
StringBuf.prototype = {
	__class__: StringBuf
};
var StringTools = function() { };
StringTools.__name__ = ["StringTools"];
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return HxOverrides.substr(s,0,start.length) == start;
	} else {
		return false;
	}
};
StringTools.endsWith = function(s,end) {
	var elen = end.length;
	var slen = s.length;
	if(slen >= elen) {
		return HxOverrides.substr(s,slen - elen,elen) == end;
	} else {
		return false;
	}
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
StringTools.hex = function(n,digits) {
	var s = "";
	while(true) {
		s = "0123456789ABCDEF".charAt(n & 15) + s;
		n >>>= 4;
		if(!(n > 0)) {
			break;
		}
	}
	if(digits != null) {
		while(s.length < digits) s = "0" + s;
	}
	return s;
};
var Sys = function() { };
Sys.__name__ = ["Sys"];
Sys.systemName = function() {
	var _g = process.platform;
	switch(_g) {
	case "darwin":
		return "Mac";
	case "freebsd":
		return "BSD";
	case "linux":
		return "Linux";
	case "win32":
		return "Windows";
	default:
		return _g;
	}
};
var Type = function() { };
Type.__name__ = ["Type"];
Type.getClassName = function(c) {
	var a = c.__name__;
	if(a == null) {
		return null;
	}
	return a.join(".");
};
var Xml = function(nodeType) {
	this.nodeType = nodeType;
	this.children = [];
	this.attributeMap = new haxe_ds_StringMap();
};
Xml.__name__ = ["Xml"];
Xml.parse = function(str) {
	return haxe_xml_Parser.parse(str);
};
Xml.createElement = function(name) {
	var xml = new Xml(Xml.Element);
	if(xml.nodeType != Xml.Element) {
		throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + xml.nodeType);
	}
	xml.nodeName = name;
	return xml;
};
Xml.createPCData = function(data) {
	var xml = new Xml(Xml.PCData);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw new js__$Boot_HaxeError("Bad node type, unexpected " + xml.nodeType);
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createCData = function(data) {
	var xml = new Xml(Xml.CData);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw new js__$Boot_HaxeError("Bad node type, unexpected " + xml.nodeType);
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createComment = function(data) {
	var xml = new Xml(Xml.Comment);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw new js__$Boot_HaxeError("Bad node type, unexpected " + xml.nodeType);
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createDocType = function(data) {
	var xml = new Xml(Xml.DocType);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw new js__$Boot_HaxeError("Bad node type, unexpected " + xml.nodeType);
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createProcessingInstruction = function(data) {
	var xml = new Xml(Xml.ProcessingInstruction);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw new js__$Boot_HaxeError("Bad node type, unexpected " + xml.nodeType);
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createDocument = function() {
	return new Xml(Xml.Document);
};
Xml.prototype = {
	get: function(att) {
		if(this.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + this.nodeType);
		}
		var _this = this.attributeMap;
		if(__map_reserved[att] != null) {
			return _this.getReserved(att);
		} else {
			return _this.h[att];
		}
	}
	,set: function(att,value) {
		if(this.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + this.nodeType);
		}
		var _this = this.attributeMap;
		if(__map_reserved[att] != null) {
			_this.setReserved(att,value);
		} else {
			_this.h[att] = value;
		}
	}
	,exists: function(att) {
		if(this.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + this.nodeType);
		}
		var _this = this.attributeMap;
		if(__map_reserved[att] != null) {
			return _this.existsReserved(att);
		} else {
			return _this.h.hasOwnProperty(att);
		}
	}
	,elements: function() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + this.nodeType);
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.children;
		while(_g1 < _g2.length) {
			var child = _g2[_g1];
			++_g1;
			if(child.nodeType == Xml.Element) {
				_g.push(child);
			}
		}
		return HxOverrides.iter(_g);
	}
	,firstElement: function() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + this.nodeType);
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			if(child.nodeType == Xml.Element) {
				return child;
			}
		}
		return null;
	}
	,addChild: function(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + this.nodeType);
		}
		if(x.parent != null) {
			x.parent.removeChild(x);
		}
		this.children.push(x);
		x.parent = this;
	}
	,removeChild: function(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + this.nodeType);
		}
		if(HxOverrides.remove(this.children,x)) {
			x.parent = null;
			return true;
		}
		return false;
	}
	,__class__: Xml
};
var haxe_StackItem = { __ename__ : true, __constructs__ : ["CFunction","Module","FilePos","Method","LocalFunction"] };
haxe_StackItem.CFunction = ["CFunction",0];
haxe_StackItem.CFunction.toString = $estr;
haxe_StackItem.CFunction.__enum__ = haxe_StackItem;
haxe_StackItem.Module = function(m) { var $x = ["Module",1,m]; $x.__enum__ = haxe_StackItem; $x.toString = $estr; return $x; };
haxe_StackItem.FilePos = function(s,file,line) { var $x = ["FilePos",2,s,file,line]; $x.__enum__ = haxe_StackItem; $x.toString = $estr; return $x; };
haxe_StackItem.Method = function(classname,method) { var $x = ["Method",3,classname,method]; $x.__enum__ = haxe_StackItem; $x.toString = $estr; return $x; };
haxe_StackItem.LocalFunction = function(v) { var $x = ["LocalFunction",4,v]; $x.__enum__ = haxe_StackItem; $x.toString = $estr; return $x; };
var haxe_CallStack = function() { };
haxe_CallStack.__name__ = ["haxe","CallStack"];
haxe_CallStack.getStack = function(e) {
	if(e == null) {
		return [];
	}
	var oldValue = Error.prepareStackTrace;
	Error.prepareStackTrace = function(error,callsites) {
		var stack = [];
		var _g = 0;
		while(_g < callsites.length) {
			var site = callsites[_g];
			++_g;
			if(haxe_CallStack.wrapCallSite != null) {
				site = haxe_CallStack.wrapCallSite(site);
			}
			var method = null;
			var fullName = site.getFunctionName();
			if(fullName != null) {
				var idx = fullName.lastIndexOf(".");
				if(idx >= 0) {
					var className = HxOverrides.substr(fullName,0,idx);
					var methodName = HxOverrides.substr(fullName,idx + 1,null);
					method = haxe_StackItem.Method(className,methodName);
				}
			}
			stack.push(haxe_StackItem.FilePos(method,site.getFileName(),site.getLineNumber()));
		}
		return stack;
	};
	var a = haxe_CallStack.makeStack(e.stack);
	Error.prepareStackTrace = oldValue;
	return a;
};
haxe_CallStack.exceptionStack = function() {
	return haxe_CallStack.getStack(haxe_CallStack.lastException);
};
haxe_CallStack.toString = function(stack) {
	var b = new StringBuf();
	var _g = 0;
	while(_g < stack.length) {
		var s = stack[_g];
		++_g;
		b.b += "\nCalled from ";
		haxe_CallStack.itemToString(b,s);
	}
	return b.b;
};
haxe_CallStack.itemToString = function(b,s) {
	switch(s[1]) {
	case 0:
		b.b += "a C function";
		break;
	case 1:
		var m = s[2];
		b.b = (b.b += "module ") + (m == null ? "null" : "" + m);
		break;
	case 2:
		var line = s[4];
		var file = s[3];
		var s1 = s[2];
		if(s1 != null) {
			haxe_CallStack.itemToString(b,s1);
			b.b += " (";
		}
		b.b = (b.b += file == null ? "null" : "" + file) + " line ";
		b.b += line == null ? "null" : "" + line;
		if(s1 != null) {
			b.b += ")";
		}
		break;
	case 3:
		var meth = s[3];
		var cname = s[2];
		b.b = (b.b += cname == null ? "null" : "" + cname) + ".";
		b.b += meth == null ? "null" : "" + meth;
		break;
	case 4:
		var n = s[2];
		b.b = (b.b += "local function #") + (n == null ? "null" : "" + n);
		break;
	}
};
haxe_CallStack.makeStack = function(s) {
	if(s == null) {
		return [];
	} else if(typeof(s) == "string") {
		var stack = s.split("\n");
		if(stack[0] == "Error") {
			stack.shift();
		}
		var m = [];
		var rie10 = new EReg("^   at ([A-Za-z0-9_. ]+) \\(([^)]+):([0-9]+):([0-9]+)\\)$","");
		var _g = 0;
		while(_g < stack.length) {
			var line = stack[_g];
			++_g;
			if(rie10.match(line)) {
				var path = rie10.matched(1).split(".");
				var meth = path.pop();
				var file = rie10.matched(2);
				var line1 = Std.parseInt(rie10.matched(3));
				m.push(haxe_StackItem.FilePos(meth == "Anonymous function" ? haxe_StackItem.LocalFunction() : meth == "Global code" ? null : haxe_StackItem.Method(path.join("."),meth),file,line1));
			} else {
				m.push(haxe_StackItem.Module(StringTools.trim(line)));
			}
		}
		return m;
	} else {
		return s;
	}
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = ["haxe","IMap"];
haxe_IMap.prototype = {
	__class__: haxe_IMap
};
var haxe_Log = function() { };
haxe_Log.__name__ = ["haxe","Log"];
haxe_Log.trace = function(v,infos) {
	js_Boot.__trace(v,infos);
};
var haxe_ds_BalancedTree = function() {
};
haxe_ds_BalancedTree.__name__ = ["haxe","ds","BalancedTree"];
haxe_ds_BalancedTree.prototype = {
	set: function(key,value) {
		this.root = this.setLoop(key,value,this.root);
	}
	,get: function(key) {
		var node = this.root;
		while(node != null) {
			var c = this.compare(key,node.key);
			if(c == 0) {
				return node.value;
			}
			if(c < 0) {
				node = node.left;
			} else {
				node = node.right;
			}
		}
		return null;
	}
	,remove: function(key) {
		try {
			this.root = this.removeLoop(key,this.root);
			return true;
		} catch( e ) {
			haxe_CallStack.lastException = e;
			if (e instanceof js__$Boot_HaxeError) e = e.val;
			if( js_Boot.__instanceof(e,String) ) {
				return false;
			} else throw(e);
		}
	}
	,iterator: function() {
		var ret = [];
		this.iteratorLoop(this.root,ret);
		return HxOverrides.iter(ret);
	}
	,setLoop: function(k,v,node) {
		if(node == null) {
			return new haxe_ds_TreeNode(null,k,v,null);
		}
		var c = this.compare(k,node.key);
		if(c == 0) {
			return new haxe_ds_TreeNode(node.left,k,v,node.right,node == null ? 0 : node._height);
		} else if(c < 0) {
			var nl = this.setLoop(k,v,node.left);
			return this.balance(nl,node.key,node.value,node.right);
		} else {
			var nr = this.setLoop(k,v,node.right);
			return this.balance(node.left,node.key,node.value,nr);
		}
	}
	,removeLoop: function(k,node) {
		if(node == null) {
			throw new js__$Boot_HaxeError("Not_found");
		}
		var c = this.compare(k,node.key);
		if(c == 0) {
			return this.merge(node.left,node.right);
		} else if(c < 0) {
			return this.balance(this.removeLoop(k,node.left),node.key,node.value,node.right);
		} else {
			return this.balance(node.left,node.key,node.value,this.removeLoop(k,node.right));
		}
	}
	,iteratorLoop: function(node,acc) {
		if(node != null) {
			this.iteratorLoop(node.left,acc);
			acc.push(node.value);
			this.iteratorLoop(node.right,acc);
		}
	}
	,merge: function(t1,t2) {
		if(t1 == null) {
			return t2;
		}
		if(t2 == null) {
			return t1;
		}
		var t = this.minBinding(t2);
		return this.balance(t1,t.key,t.value,this.removeMinBinding(t2));
	}
	,minBinding: function(t) {
		if(t == null) {
			throw new js__$Boot_HaxeError("Not_found");
		} else if(t.left == null) {
			return t;
		} else {
			return this.minBinding(t.left);
		}
	}
	,removeMinBinding: function(t) {
		if(t.left == null) {
			return t.right;
		} else {
			return this.balance(this.removeMinBinding(t.left),t.key,t.value,t.right);
		}
	}
	,balance: function(l,k,v,r) {
		var hl = l == null ? 0 : l._height;
		var hr = r == null ? 0 : r._height;
		if(hl > hr + 2) {
			var _this = l.left;
			var _this1 = l.right;
			if((_this == null ? 0 : _this._height) >= (_this1 == null ? 0 : _this1._height)) {
				return new haxe_ds_TreeNode(l.left,l.key,l.value,new haxe_ds_TreeNode(l.right,k,v,r));
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l.left,l.key,l.value,l.right.left),l.right.key,l.right.value,new haxe_ds_TreeNode(l.right.right,k,v,r));
			}
		} else if(hr > hl + 2) {
			var _this2 = r.right;
			var _this3 = r.left;
			if((_this2 == null ? 0 : _this2._height) > (_this3 == null ? 0 : _this3._height)) {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left),r.key,r.value,r.right);
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left.left),r.left.key,r.left.value,new haxe_ds_TreeNode(r.left.right,r.key,r.value,r.right));
			}
		} else {
			return new haxe_ds_TreeNode(l,k,v,r,(hl > hr ? hl : hr) + 1);
		}
	}
	,compare: function(k1,k2) {
		return Reflect.compare(k1,k2);
	}
	,__class__: haxe_ds_BalancedTree
};
var haxe_ds_TreeNode = function(l,k,v,r,h) {
	if(h == null) {
		h = -1;
	}
	this.left = l;
	this.key = k;
	this.value = v;
	this.right = r;
	if(h == -1) {
		var tmp;
		var _this = this.left;
		var _this1 = this.right;
		if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
			var _this2 = this.left;
			if(_this2 == null) {
				tmp = 0;
			} else {
				tmp = _this2._height;
			}
		} else {
			var _this3 = this.right;
			if(_this3 == null) {
				tmp = 0;
			} else {
				tmp = _this3._height;
			}
		}
		this._height = tmp + 1;
	} else {
		this._height = h;
	}
};
haxe_ds_TreeNode.__name__ = ["haxe","ds","TreeNode"];
haxe_ds_TreeNode.prototype = {
	__class__: haxe_ds_TreeNode
};
var haxe_ds_GenericCell = function(elt,next) {
	this.elt = elt;
	this.next = next;
};
haxe_ds_GenericCell.__name__ = ["haxe","ds","GenericCell"];
haxe_ds_GenericCell.prototype = {
	__class__: haxe_ds_GenericCell
};
var haxe_ds_GenericStack = function() {
};
haxe_ds_GenericStack.__name__ = ["haxe","ds","GenericStack"];
haxe_ds_GenericStack.prototype = {
	__class__: haxe_ds_GenericStack
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = ["haxe","ds","IntMap"];
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	set: function(key,value) {
		this.h[key] = value;
	}
	,get: function(key) {
		return this.h[key];
	}
	,remove: function(key) {
		if(!this.h.hasOwnProperty(key)) {
			return false;
		}
		delete(this.h[key]);
		return true;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) {
			a.push(key | 0);
		}
		return HxOverrides.iter(a);
	}
	,iterator: function() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			var i = this.it.next();
			return this.ref[i];
		}};
	}
	,__class__: haxe_ds_IntMap
};
var haxe_ds__$StringMap_StringMapIterator = function(map,keys) {
	this.map = map;
	this.keys = keys;
	this.index = 0;
	this.count = keys.length;
};
haxe_ds__$StringMap_StringMapIterator.__name__ = ["haxe","ds","_StringMap","StringMapIterator"];
haxe_ds__$StringMap_StringMapIterator.prototype = {
	hasNext: function() {
		return this.index < this.count;
	}
	,next: function() {
		var _this = this.map;
		var key = this.keys[this.index++];
		if(__map_reserved[key] != null) {
			return _this.getReserved(key);
		} else {
			return _this.h[key];
		}
	}
	,__class__: haxe_ds__$StringMap_StringMapIterator
};
var haxe_ds_StringMap = function() {
	this.h = { };
};
haxe_ds_StringMap.__name__ = ["haxe","ds","StringMap"];
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	set: function(key,value) {
		if(__map_reserved[key] != null) {
			this.setReserved(key,value);
		} else {
			this.h[key] = value;
		}
	}
	,get: function(key) {
		if(__map_reserved[key] != null) {
			return this.getReserved(key);
		}
		return this.h[key];
	}
	,setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	,existsReserved: function(key) {
		if(this.rh == null) {
			return false;
		}
		return this.rh.hasOwnProperty("$" + key);
	}
	,remove: function(key) {
		if(__map_reserved[key] != null) {
			key = "$" + key;
			if(this.rh == null || !this.rh.hasOwnProperty(key)) {
				return false;
			}
			delete(this.rh[key]);
			return true;
		} else {
			if(!this.h.hasOwnProperty(key)) {
				return false;
			}
			delete(this.h[key]);
			return true;
		}
	}
	,keys: function() {
		return HxOverrides.iter(this.arrayKeys());
	}
	,arrayKeys: function() {
		var out = [];
		for( var key in this.h ) {
		if(this.h.hasOwnProperty(key)) {
			out.push(key);
		}
		}
		if(this.rh != null) {
			for( var key in this.rh ) {
			if(key.charCodeAt(0) == 36) {
				out.push(key.substr(1));
			}
			}
		}
		return out;
	}
	,iterator: function() {
		return new haxe_ds__$StringMap_StringMapIterator(this,this.arrayKeys());
	}
	,__class__: haxe_ds_StringMap
};
var haxe_io_Bytes = function() { };
haxe_io_Bytes.__name__ = ["haxe","io","Bytes"];
haxe_io_Bytes.prototype = {
	__class__: haxe_io_Bytes
};
var haxe_io_Path = function() { };
haxe_io_Path.__name__ = ["haxe","io","Path"];
haxe_io_Path.normalize = function(path) {
	path = path.split("\\").join("/");
	if(path == "/") {
		return "/";
	}
	var target = [];
	var _g = 0;
	var _g1 = path.split("/");
	while(_g < _g1.length) {
		var token = _g1[_g];
		++_g;
		if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
			target.pop();
		} else if(token != ".") {
			target.push(token);
		}
	}
	var tmp = target.join("/");
	var regex_r = new RegExp("([^:])/+","g".split("u").join(""));
	tmp.replace(regex_r,"$1" + "/");
	var acc_b = "";
	var colon = false;
	var slashes = false;
	var _g11 = 0;
	var _g2 = tmp.length;
	while(_g11 < _g2) {
		var i = _g11++;
		var _g21 = HxOverrides.cca(tmp,i);
		if(_g21 == null) {
			colon = false;
			if(slashes) {
				acc_b += "/";
				slashes = false;
			}
			acc_b += Std.string(String.fromCharCode(_g21));
		} else {
			switch(_g21) {
			case 47:
				if(!colon) {
					slashes = true;
				} else {
					colon = false;
					if(slashes) {
						acc_b += "/";
						slashes = false;
					}
					acc_b += Std.string(String.fromCharCode(_g21));
				}
				break;
			case 58:
				acc_b += ":";
				colon = true;
				break;
			default:
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += Std.string(String.fromCharCode(_g21));
			}
		}
	}
	return acc_b;
};
var haxe_xml_XmlParserException = function(message,xml,position) {
	this.xml = xml;
	this.message = message;
	this.position = position;
	this.lineNumber = 1;
	this.positionAtLine = 0;
	var _g1 = 0;
	while(_g1 < position) {
		var i = _g1++;
		var c = xml.charCodeAt(i);
		if(c == 10) {
			this.lineNumber++;
			this.positionAtLine = 0;
		} else if(c != 13) {
			this.positionAtLine++;
		}
	}
};
haxe_xml_XmlParserException.__name__ = ["haxe","xml","XmlParserException"];
haxe_xml_XmlParserException.prototype = {
	toString: function() {
		return Type.getClassName(js_Boot.getClass(this)) + ": " + this.message + " at line " + this.lineNumber + " char " + this.positionAtLine;
	}
	,__class__: haxe_xml_XmlParserException
};
var haxe_xml_Parser = function() { };
haxe_xml_Parser.__name__ = ["haxe","xml","Parser"];
haxe_xml_Parser.parse = function(str,strict) {
	if(strict == null) {
		strict = false;
	}
	var doc = Xml.createDocument();
	haxe_xml_Parser.doParse(str,strict,0,doc);
	return doc;
};
haxe_xml_Parser.doParse = function(str,strict,p,parent) {
	if(p == null) {
		p = 0;
	}
	var xml = null;
	var state = 1;
	var next = 1;
	var aname = null;
	var start = 0;
	var nsubs = 0;
	var nbrackets = 0;
	var c = str.charCodeAt(p);
	var buf = new StringBuf();
	var escapeNext = 1;
	var attrValQuote = -1;
	while(c == c) {
		switch(state) {
		case 0:
			switch(c) {
			case 9:case 10:case 13:case 32:
				break;
			default:
				state = next;
				continue;
			}
			break;
		case 1:
			if(c == 60) {
				state = 0;
				next = 2;
			} else {
				start = p;
				state = 13;
				continue;
			}
			break;
		case 2:
			switch(c) {
			case 33:
				if(str.charCodeAt(p + 1) == 91) {
					p += 2;
					if(HxOverrides.substr(str,p,6).toUpperCase() != "CDATA[") {
						throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Expected <![CDATA[",str,p));
					}
					p += 5;
					state = 17;
					start = p + 1;
				} else if(str.charCodeAt(p + 1) == 68 || str.charCodeAt(p + 1) == 100) {
					if(HxOverrides.substr(str,p + 2,6).toUpperCase() != "OCTYPE") {
						throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Expected <!DOCTYPE",str,p));
					}
					p += 8;
					state = 16;
					start = p + 1;
				} else if(str.charCodeAt(p + 1) != 45 || str.charCodeAt(p + 2) != 45) {
					throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Expected <!--",str,p));
				} else {
					p += 2;
					state = 15;
					start = p + 1;
				}
				break;
			case 47:
				if(parent == null) {
					throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Expected node name",str,p));
				}
				start = p + 1;
				state = 0;
				next = 10;
				break;
			case 63:
				state = 14;
				start = p;
				break;
			default:
				state = 3;
				start = p;
				continue;
			}
			break;
		case 3:
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
				if(p == start) {
					throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Expected node name",str,p));
				}
				xml = Xml.createElement(HxOverrides.substr(str,start,p - start));
				parent.addChild(xml);
				++nsubs;
				state = 0;
				next = 4;
				continue;
			}
			break;
		case 4:
			switch(c) {
			case 47:
				state = 11;
				break;
			case 62:
				state = 9;
				break;
			default:
				state = 5;
				start = p;
				continue;
			}
			break;
		case 5:
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
				var tmp;
				if(start == p) {
					throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Expected attribute name",str,p));
				}
				tmp = HxOverrides.substr(str,start,p - start);
				aname = tmp;
				if(xml.exists(tmp)) {
					throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Duplicate attribute [" + tmp + "]",str,p));
				}
				state = 0;
				next = 6;
				continue;
			}
			break;
		case 6:
			if(c == 61) {
				state = 0;
				next = 7;
			} else {
				throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Expected =",str,p));
			}
			break;
		case 7:
			switch(c) {
			case 34:case 39:
				buf = new StringBuf();
				state = 8;
				start = p + 1;
				attrValQuote = c;
				break;
			default:
				throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Expected \"",str,p));
			}
			break;
		case 8:
			switch(c) {
			case 38:
				var len = p - start;
				buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
				state = 18;
				escapeNext = 8;
				start = p + 1;
				break;
			case 60:case 62:
				if(strict) {
					throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Invalid unescaped " + String.fromCharCode(c) + " in attribute value",str,p));
				} else if(c == attrValQuote) {
					var len1 = p - start;
					buf.b += len1 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len1);
					var val = buf.b;
					buf = new StringBuf();
					xml.set(aname,val);
					state = 0;
					next = 4;
				}
				break;
			default:
				if(c == attrValQuote) {
					var len2 = p - start;
					buf.b += len2 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len2);
					var val1 = buf.b;
					buf = new StringBuf();
					xml.set(aname,val1);
					state = 0;
					next = 4;
				}
			}
			break;
		case 9:
			p = haxe_xml_Parser.doParse(str,strict,p,xml);
			start = p;
			state = 1;
			break;
		case 10:
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
				if(start == p) {
					throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Expected node name",str,p));
				}
				var v = HxOverrides.substr(str,start,p - start);
				if(parent.nodeType != Xml.Element) {
					throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + parent.nodeType);
				}
				if(v != parent.nodeName) {
					if(parent.nodeType != Xml.Element) {
						throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + parent.nodeType);
					}
					throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Expected </" + parent.nodeName + ">",str,p));
				}
				state = 0;
				next = 12;
				continue;
			}
			break;
		case 11:
			if(c == 62) {
				state = 1;
			} else {
				throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Expected >",str,p));
			}
			break;
		case 12:
			if(c == 62) {
				if(nsubs == 0) {
					parent.addChild(Xml.createPCData(""));
				}
				return p;
			} else {
				throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Expected >",str,p));
			}
			break;
		case 13:
			if(c == 60) {
				var len3 = p - start;
				buf.b += len3 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len3);
				var child = Xml.createPCData(buf.b);
				buf = new StringBuf();
				parent.addChild(child);
				++nsubs;
				state = 0;
				next = 2;
			} else if(c == 38) {
				var len4 = p - start;
				buf.b += len4 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len4);
				state = 18;
				escapeNext = 13;
				start = p + 1;
			}
			break;
		case 14:
			if(c == 63 && str.charCodeAt(p + 1) == 62) {
				++p;
				var str1 = HxOverrides.substr(str,start + 1,p - start - 2);
				parent.addChild(Xml.createProcessingInstruction(str1));
				++nsubs;
				state = 1;
			}
			break;
		case 15:
			if(c == 45 && str.charCodeAt(p + 1) == 45 && str.charCodeAt(p + 2) == 62) {
				parent.addChild(Xml.createComment(HxOverrides.substr(str,start,p - start)));
				++nsubs;
				p += 2;
				state = 1;
			}
			break;
		case 16:
			if(c == 91) {
				++nbrackets;
			} else if(c == 93) {
				--nbrackets;
			} else if(c == 62 && nbrackets == 0) {
				parent.addChild(Xml.createDocType(HxOverrides.substr(str,start,p - start)));
				++nsubs;
				state = 1;
			}
			break;
		case 17:
			if(c == 93 && str.charCodeAt(p + 1) == 93 && str.charCodeAt(p + 2) == 62) {
				var child1 = Xml.createCData(HxOverrides.substr(str,start,p - start));
				parent.addChild(child1);
				++nsubs;
				p += 2;
				state = 1;
			}
			break;
		case 18:
			if(c == 59) {
				var s = HxOverrides.substr(str,start,p - start);
				if(s.charCodeAt(0) == 35) {
					var c1 = s.charCodeAt(1) == 120 ? Std.parseInt("0" + HxOverrides.substr(s,1,s.length - 1)) : Std.parseInt(HxOverrides.substr(s,1,s.length - 1));
					buf.b += String.fromCharCode(c1);
				} else {
					var _this = haxe_xml_Parser.escapes;
					if(!(__map_reserved[s] != null ? _this.existsReserved(s) : _this.h.hasOwnProperty(s))) {
						if(strict) {
							throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Undefined entity: " + s,str,p));
						}
						buf.b += Std.string("&" + s + ";");
					} else {
						var _this1 = haxe_xml_Parser.escapes;
						buf.b += Std.string(__map_reserved[s] != null ? _this1.getReserved(s) : _this1.h[s]);
					}
				}
				start = p + 1;
				state = escapeNext;
			} else if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45) && c != 35) {
				if(strict) {
					throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Invalid character in entity: " + String.fromCharCode(c),str,p));
				}
				buf.b += "&";
				var len5 = p - start;
				buf.b += len5 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len5);
				start = p--;
				state = escapeNext;
			}
			break;
		}
		c = str.charCodeAt(++p);
	}
	if(state == 1) {
		start = p;
		state = 13;
	}
	if(state == 13) {
		if(p != start || nsubs == 0) {
			var len6 = p - start;
			buf.b += len6 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len6);
			parent.addChild(Xml.createPCData(buf.b));
		}
		return p;
	}
	if(!strict && state == 18 && escapeNext == 13) {
		buf.b += "&";
		var len7 = p - start;
		buf.b += len7 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len7);
		parent.addChild(Xml.createPCData(buf.b));
		return p;
	}
	throw new js__$Boot_HaxeError(new haxe_xml_XmlParserException("Unexpected end",str,p));
};
var haxeLanguageServer_Context = function(protocol) {
	this.protocol = protocol;
	this.haxeServer = new haxeLanguageServer_HaxeServer(this);
	var handler = $bind(this,this.onInitialize);
	protocol.requestHandlers.set("initialize",handler);
	var handler1 = $bind(this,this.onShutdown);
	protocol.requestHandlers.set("shutdown",handler1);
	var handler2 = $bind(this,this.onDidChangeConfiguration);
	protocol.notificationHandlers.set("workspace/didChangeConfiguration",handler2);
	var handler3 = $bind(this,this.onDidOpenTextDocument);
	protocol.notificationHandlers.set("textDocument/didOpen",handler3);
	var handler4 = $bind(this,this.onDidSaveTextDocument);
	protocol.notificationHandlers.set("textDocument/didSave",handler4);
	var handler5 = $bind(this,this.onDidChangeDisplayConfigurationIndex);
	protocol.notificationHandlers.set("vshaxe/didChangeDisplayConfigurationIndex",handler5);
};
haxeLanguageServer_Context.__name__ = ["haxeLanguageServer","Context"];
haxeLanguageServer_Context.findHaxe = function(kha) {
	var executableExtension;
	if(process.platform == "win32") {
		executableExtension = ".exe";
	} else if(process.platform == "linux") {
		if(process.arch == "x64") {
			executableExtension = "-linux64";
		} else if(process.arch == "arm") {
			executableExtension = "-linuxarm";
		} else {
			executableExtension = "-linux32";
		}
	} else {
		executableExtension = "-osx";
	}
	return js_node_Path.join(kha,"Tools","haxe","haxe" + executableExtension);
};
haxeLanguageServer_Context.prototype = {
	onInitialize: function(params,token,resolve,reject) {
		this.workspacePath = params.rootPath;
		this.haxePath = haxeLanguageServer_Context.findHaxe(params.initializationOptions.kha);
		this.displayConfigurationIndex = params.initializationOptions.displayConfigurationIndex;
		this.documents = new haxeLanguageServer_TextDocuments(this.protocol);
		resolve({ capabilities : { textDocumentSync : 2, completionProvider : { triggerCharacters : [".","@",":"]}, signatureHelpProvider : { triggerCharacters : ["(",","]}, definitionProvider : true, hoverProvider : true, referencesProvider : true, documentSymbolProvider : true, workspaceSymbolProvider : true, codeActionProvider : true, codeLensProvider : { resolveProvider : true}}});
		return;
	}
	,onDidChangeDisplayConfigurationIndex: function(params) {
		this.displayConfigurationIndex = params.index;
		this.haxeServer.restart("selected configuration was changed");
	}
	,onShutdown: function(_,token,resolve,_1) {
		this.haxeServer.stop();
		this.haxeServer = null;
		resolve(null);
		return;
	}
	,onDidChangeConfiguration: function(newConfig) {
		var _gthis = this;
		var firstInit = this.config == null;
		this.config = newConfig.settings.haxe;
		this.updateDisplayServerConfig();
		this.updateCodeGenerationConfig();
		if(firstInit) {
			this.haxeServer.start(this.haxePath,function() {
				_gthis.codeActions = new haxeLanguageServer_features_CodeActionFeature(_gthis);
				new haxeLanguageServer_features_CompletionFeature(_gthis);
				new haxeLanguageServer_features_HoverFeature(_gthis);
				_gthis.signatureHelp = new haxeLanguageServer_features_SignatureHelpFeature(_gthis);
				new haxeLanguageServer_features_GotoDefinitionFeature(_gthis);
				new haxeLanguageServer_features_FindReferencesFeature(_gthis);
				new haxeLanguageServer_features_DocumentSymbolsFeature(_gthis);
				new haxeLanguageServer_features_DeterminePackageFeature(_gthis);
				_gthis.diagnostics = new haxeLanguageServer_features_DiagnosticsManager(_gthis);
				new haxeLanguageServer_features_CodeLensFeature(_gthis);
				new haxeLanguageServer_features_CodeGenerationFeature(_gthis);
				if(_gthis.config.enableDiagnostics) {
					var doc = _gthis.documents.documents.iterator();
					while(doc.hasNext()) {
						var doc1 = doc.next();
						_gthis.diagnostics.publishDiagnostics(doc1.uri);
					}
				}
			});
		} else {
			this.haxeServer.restart("configuration was changed");
		}
	}
	,updateDisplayServerConfig: function() {
		var _gthis = this;
		this.displayServerConfig = { haxePath : "haxe", 'arguments' : [], env : { }};
		var merge = function(conf) {
			if(conf.haxePath != null) {
				_gthis.displayServerConfig.haxePath = conf.haxePath;
			}
			if(conf["arguments"] != null) {
				_gthis.displayServerConfig["arguments"] = conf["arguments"];
			}
			if(conf.env != null) {
				_gthis.displayServerConfig.env = conf.env;
			}
		};
		var conf1 = this.config.displayServer;
		if(conf1 != null) {
			merge(conf1);
			var sysConf = Reflect.field(conf1,haxeLanguageServer_Context.systemKey);
			if(sysConf != null) {
				merge(sysConf);
			}
		}
	}
	,updateCodeGenerationConfig: function() {
		var codeGen = this.config.codeGeneration;
		if(codeGen.functions == null) {
			codeGen.functions = { };
		}
		var functions = codeGen.functions;
		if(functions.anonymous == null) {
			functions.anonymous = { argumentTypeHints : false, returnTypeHint : "never"};
		}
	}
	,onDidOpenTextDocument: function(event) {
		this.documents.onDidOpenTextDocument(event);
		if(this.diagnostics != null && this.config.enableDiagnostics) {
			this.diagnostics.publishDiagnostics(event.textDocument.uri);
		}
	}
	,onDidSaveTextDocument: function(event) {
		if(this.diagnostics != null && this.config.enableDiagnostics) {
			this.diagnostics.publishDiagnostics(event.textDocument.uri);
		}
	}
	,callDisplay: function(args,stdin,token,callback,errback) {
		var actualArgs = ["--cwd",this.workspacePath + "/build"];
		actualArgs = actualArgs.concat(this.config.displayConfigurations[this.displayConfigurationIndex]);
		actualArgs = actualArgs.concat(["-D","display-details","--no-output"]);
		actualArgs = actualArgs.concat(args);
		this.haxeServer.process(actualArgs,token,stdin,callback,errback);
	}
	,__class__: haxeLanguageServer_Context
};
var haxeLanguageServer_HaxePosition = function() { };
haxeLanguageServer_HaxePosition.__name__ = ["haxeLanguageServer","HaxePosition"];
haxeLanguageServer_HaxePosition.parse = function(pos,doc,cache) {
	if(!haxeLanguageServer_HaxePosition.positionRe.match(pos)) {
		return null;
	}
	var file = haxeLanguageServer_HaxePosition.getProperFileNameCase(haxeLanguageServer_HaxePosition.positionRe.matched(1));
	var s = haxeLanguageServer_HaxePosition.positionRe.matched(3);
	if(s != null) {
		var startLine = Std.parseInt(s);
		var endLine = Std.parseInt(haxeLanguageServer_HaxePosition.positionRe.matched(4));
		return { uri : file == doc.fsPath ? doc.uri : haxeLanguageServer_Uri.fsPathToUri(file), range : { start : { line : startLine - 1, character : 0}, end : { line : endLine, character : 0}}};
	} else {
		var line = Std.parseInt(haxeLanguageServer_HaxePosition.positionRe.matched(2));
		--line;
		var lineContent;
		var uri;
		if(file == doc.fsPath) {
			lineContent = doc.lineAt(line);
			uri = doc.uri;
		} else {
			var lines;
			if(cache == null) {
				lines = js_node_Fs.readFileSync(file,{ encoding : "utf8"}).split("\n");
			} else {
				lines = __map_reserved[file] != null ? cache.getReserved(file) : cache.h[file];
				if(lines == null) {
					var v = js_node_Fs.readFileSync(file,{ encoding : "utf8"}).split("\n");
					if(__map_reserved[file] != null) {
						cache.setReserved(file,v);
					} else {
						cache.h[file] = v;
					}
					lines = v;
				}
			}
			lineContent = lines[line];
			uri = haxeLanguageServer_Uri.fsPathToUri(file);
		}
		var endByte = Std.parseInt(haxeLanguageServer_HaxePosition.positionRe.matched(6));
		var buf = new js_node_buffer_Buffer(lineContent,"utf-8");
		var endChar = buf.toString("utf-8",0,endByte).length;
		s = haxeLanguageServer_HaxePosition.positionRe.matched(5);
		var startChar;
		if(s != null) {
			var startByte = Std.parseInt(s);
			var buf1 = new js_node_buffer_Buffer(lineContent,"utf-8");
			startChar = buf1.toString("utf-8",0,startByte).length;
		} else {
			startChar = endChar;
		}
		return { uri : uri, range : { start : { line : line, character : startChar}, end : { line : line, character : endChar}}};
	}
};
haxeLanguageServer_HaxePosition.getProperFileNameCase = function(normalizedPath) {
	if(!haxeLanguageServer_HaxePosition.isWindows) {
		return normalizedPath;
	}
	if(haxeLanguageServer_HaxePosition.properFileNameCaseCache == null) {
		haxeLanguageServer_HaxePosition.properFileNameCaseCache = new haxe_ds_StringMap();
	} else {
		var _this = haxeLanguageServer_HaxePosition.properFileNameCaseCache;
		var cached = __map_reserved[normalizedPath] != null ? _this.getReserved(normalizedPath) : _this.h[normalizedPath];
		if(cached != null) {
			return cached;
		}
	}
	var result = normalizedPath;
	var parts = normalizedPath.split("\\");
	if(parts.length > 1) {
		var acc = parts[0];
		var _g1 = 1;
		var _g = parts.length;
		while(_g1 < _g) {
			var i = _g1++;
			var part = parts[i];
			var _g2 = 0;
			var _g3 = js_node_Fs.readdirSync(acc);
			while(_g2 < _g3.length) {
				var realFile = _g3[_g2];
				++_g2;
				if(realFile.toLowerCase() == part) {
					part = realFile;
					break;
				}
			}
			acc = acc + "/" + part;
		}
		result = acc;
	}
	var _this1 = haxeLanguageServer_HaxePosition.properFileNameCaseCache;
	if(__map_reserved[normalizedPath] != null) {
		_this1.setReserved(normalizedPath,result);
	} else {
		_this1.h[normalizedPath] = result;
	}
	return result;
};
var js_node_buffer_Buffer = require("buffer").Buffer;
var haxeLanguageServer__$HaxeServer_DisplayRequest = function(token,args,stdin,callback,errback,socket) {
	this.token = token;
	this.args = args;
	this.stdin = stdin;
	this.callback = callback;
	this.errback = errback;
	this.socket = socket;
};
haxeLanguageServer__$HaxeServer_DisplayRequest.__name__ = ["haxeLanguageServer","_HaxeServer","DisplayRequest"];
haxeLanguageServer__$HaxeServer_DisplayRequest.prototype = {
	prepareBody: function() {
		if(this.stdin != null) {
			this.args.push("-D");
			this.args.push("display-stdin");
		}
		var lenBuf = new js_node_buffer_Buffer(4);
		var chunks = [lenBuf];
		var length = 0;
		var _g = 0;
		var _g1 = this.args;
		while(_g < _g1.length) {
			var arg = _g1[_g];
			++_g;
			var buf = new js_node_buffer_Buffer(arg + "\n");
			chunks.push(buf);
			length += buf.length;
		}
		if(this.stdin != null) {
			chunks.push(haxeLanguageServer__$HaxeServer_DisplayRequest.stdinSepBuf);
			var buf1 = new js_node_buffer_Buffer(this.stdin);
			chunks.push(buf1);
			length += buf1.length + haxeLanguageServer__$HaxeServer_DisplayRequest.stdinSepBuf.length;
		}
		lenBuf.writeInt32LE(length,0);
		return js_node_buffer_Buffer.concat(chunks,length + 4);
	}
	,processResult: function(data) {
		if(data == null || this.token != null && this.token.canceled) {
			this.callback(null);
			return;
		}
		var buf_b = "";
		var hasError = false;
		var _g = 0;
		var _g1 = data.split("\n");
		while(_g < _g1.length) {
			var line = _g1[_g];
			++_g;
			var _g2 = line.charCodeAt(0);
			switch(_g2) {
			case 1:
				var line1 = StringTools.replace(line.substring(1),"\x01","\n");
				if(this.socket != null) {
					this.socket.write(line1);
				} else {
					haxe_Log.trace("Haxe print:\n" + line1,{ fileName : "HaxeServer.hx", lineNumber : 75, className : "haxeLanguageServer._HaxeServer.DisplayRequest", methodName : "processResult"});
				}
				break;
			case 2:
				hasError = true;
				break;
			default:
				buf_b += line == null ? "null" : "" + line;
				buf_b += "\n";
			}
		}
		var data1 = StringTools.trim(buf_b);
		if(hasError) {
			this.errback("Error from Haxe server: " + data1);
			return;
		}
		try {
			this.callback(data1);
		} catch( e ) {
			haxe_CallStack.lastException = e;
			if (e instanceof js__$Boot_HaxeError) e = e.val;
			this.errback(jsonrpc_ErrorUtils.errorToString(e,"Exception while handling Haxe completion response: "));
		}
	}
	,__class__: haxeLanguageServer__$HaxeServer_DisplayRequest
};
var haxeLanguageServer_HaxeServer = function(context) {
	this.context = context;
};
haxeLanguageServer_HaxeServer.__name__ = ["haxeLanguageServer","HaxeServer"];
haxeLanguageServer_HaxeServer.prototype = {
	start: function(haxePath,callback) {
		var _gthis = this;
		this.stop();
		var this1 = { };
		var env = this1;
		var _g = 0;
		var _g1 = Reflect.fields(process.env);
		while(_g < _g1.length) {
			var key = _g1[_g];
			++_g;
			env[key] = process.env[key];
		}
		var _g2 = 0;
		var _g11 = Reflect.fields(this.context.displayServerConfig.env);
		while(_g2 < _g11.length) {
			var key1 = _g11[_g2];
			++_g2;
			env[key1] = this.context.displayServerConfig.env[key1];
		}
		env["HAXE_STD_PATH"] = js_node_Path.normalize(js_node_Path.join(haxePath,"..","std"));
		var checkRun = js_node_ChildProcess.spawnSync(haxePath,["-version"],{ env : env});
		if(checkRun.error != null) {
			var params = { type : 1, message : "Error starting Haxe server: " + Std.string(checkRun.error)};
			var message = { jsonrpc : "2.0", method : "window/showMessage"};
			if(params != null) {
				message.params = params;
			}
			_gthis.context.protocol.writeMessage(message);
			return;
		}
		var output = StringTools.trim(checkRun.stderr.toString());
		if(checkRun.status != 0) {
			var params1 = { type : 1, message : "Haxe version check failed: " + output};
			var message1 = { jsonrpc : "2.0", method : "window/showMessage"};
			if(params1 != null) {
				message1.params = params1;
			}
			_gthis.context.protocol.writeMessage(message1);
			return;
		}
		if(!haxeLanguageServer_HaxeServer.reVersion.match(output)) {
			var params2 = { type : 1, message : "Error parsing Haxe version " + JSON.stringify(output)};
			var message2 = { jsonrpc : "2.0", method : "window/showMessage"};
			if(params2 != null) {
				message2.params = params2;
			}
			_gthis.context.protocol.writeMessage(message2);
			return;
		}
		var major = Std.parseInt(haxeLanguageServer_HaxeServer.reVersion.matched(1));
		var minor = Std.parseInt(haxeLanguageServer_HaxeServer.reVersion.matched(2));
		haxeLanguageServer_HaxeServer.reVersion.matched(3);
		if(major < 3 || minor < 4) {
			var params3 = { type : 1, message : "Unsupported Haxe version! Minimum version required: 3.4.0"};
			var message3 = { jsonrpc : "2.0", method : "window/showMessage"};
			if(params3 != null) {
				message3.params = params3;
			}
			_gthis.context.protocol.writeMessage(message3);
			return;
		}
		this.buffer = new haxeLanguageServer__$HaxeServer_MessageBuffer();
		this.nextMessageLength = -1;
		this.proc = js_node_ChildProcess.spawn(haxePath,this.context.displayServerConfig["arguments"].concat(["--wait","stdio"]),{ env : env});
		this.proc.stdout.on("data",function(buf) {
			var _this = _gthis.context;
			var _this1 = haxeLanguageServer_HaxeServer.reTrailingNewline;
			var params4 = { type : 4, message : buf.toString().replace(_this1.r,"")};
			var message4 = { jsonrpc : "2.0", method : "window/logMessage"};
			if(params4 != null) {
				message4.params = params4;
			}
			_this.protocol.writeMessage(message4);
		});
		this.proc.stderr.on("data",$bind(this,this.onData));
		this.proc.on("exit",$bind(this,this.onExit));
		if(this.context.config.buildCompletionCache) {
			haxe_Log.trace("Initializing completion cache...",{ fileName : "HaxeServer.hx", lineNumber : 160, className : "haxeLanguageServer.HaxeServer", methodName : "start"});
			var _this2 = this.context;
			this.process(_this2.config.displayConfigurations[_this2.displayConfigurationIndex].concat(["--no-output"]),null,null,function(_) {
				haxe_Log.trace("Done.",{ fileName : "HaxeServer.hx", lineNumber : 162, className : "haxeLanguageServer.HaxeServer", methodName : "start"});
			},function(errorMessage) {
				haxe_Log.trace("Failed - try fixing the error(s) and restarting the language server:\n\n" + errorMessage,{ fileName : "HaxeServer.hx", lineNumber : 164, className : "haxeLanguageServer.HaxeServer", methodName : "start"});
			});
		}
		if(this.context.config.displayPort != null) {
			this.startSocketServer(this.context.config.displayPort);
		}
		callback();
	}
	,startSocketServer: function(port) {
		var _gthis = this;
		if(this.socketListener != null) {
			this.socketListener.close();
		}
		this.socketListener = js_node_Net.createServer(function(socket) {
			haxe_Log.trace("Client connected",{ fileName : "HaxeServer.hx", lineNumber : 179, className : "haxeLanguageServer.HaxeServer", methodName : "startSocketServer"});
			socket.on("data",function(data) {
				var s = data.toString();
				var split = s.split("\n");
				split.pop();
				var send = function(message) {
					socket.write(message);
					socket.end();
					socket.destroy();
					haxe_Log.trace("Client disconnected",{ fileName : "HaxeServer.hx", lineNumber : 188, className : "haxeLanguageServer.HaxeServer", methodName : "startSocketServer"});
				};
				_gthis.process(split,null,null,send,send,socket);
			});
			socket.on("error",function(err) {
				haxe_Log.trace("Socket error: " + err,{ fileName : "HaxeServer.hx", lineNumber : 193, className : "haxeLanguageServer.HaxeServer", methodName : "startSocketServer"});
			});
		});
		this.socketListener.listen(port);
		var params = { type : 4, message : "Listening on port " + port};
		var message1 = { jsonrpc : "2.0", method : "window/logMessage"};
		if(params != null) {
			message1.params = params;
		}
		this.context.protocol.writeMessage(message1);
	}
	,stop: function() {
		if(this.proc != null) {
			this.proc.removeAllListeners();
			this.proc.kill();
			this.proc = null;
		}
		if(this.socketListener != null) {
			this.socketListener.close();
		}
		var request = this.requestsHead;
		while(request != null) {
			request.processResult(null);
			request = request.next;
		}
		this.requestsHead = this.requestsTail = this.currentRequest = null;
	}
	,restart: function(reason) {
		var params = { type : 4, message : "Restarting Haxe completion server: " + reason};
		var message = { jsonrpc : "2.0", method : "window/logMessage"};
		if(params != null) {
			message.params = params;
		}
		this.context.protocol.writeMessage(message);
		this.start(this.context.haxePath,function() {
		});
	}
	,onExit: function(_,_1) {
		this.restart("Haxe process was killed");
	}
	,onData: function(data) {
		this.buffer.append(data);
		while(true) {
			if(this.nextMessageLength == -1) {
				var length = this.buffer.tryReadLength();
				if(length == -1) {
					return;
				}
				this.nextMessageLength = length;
			}
			var msg = this.buffer.tryReadContent(this.nextMessageLength);
			if(msg == null) {
				return;
			}
			this.nextMessageLength = -1;
			if(this.currentRequest != null) {
				var request = this.currentRequest;
				this.currentRequest = null;
				request.processResult(msg);
				this.checkQueue();
			}
		}
	}
	,process: function(args,token,stdin,callback,errback,socket) {
		var _gthis = this;
		var request = new haxeLanguageServer__$HaxeServer_DisplayRequest(token,args,stdin,callback,errback,socket);
		if(token != null) {
			token.callback = function() {
				if(request == _gthis.currentRequest) {
					return;
				}
				if(request == _gthis.requestsHead) {
					_gthis.requestsHead = request.next;
				}
				if(request == _gthis.requestsTail) {
					_gthis.requestsTail = request.prev;
				}
				if(request.prev != null) {
					request.prev.next = request.next;
				}
				if(request.next != null) {
					request.next.prev = request.prev;
				}
			};
		}
		if(this.requestsHead == null) {
			this.requestsHead = this.requestsTail = request;
		} else {
			this.requestsTail.next = request;
			request.prev = this.requestsTail;
			this.requestsTail = request;
		}
		this.checkQueue();
	}
	,checkQueue: function() {
		if(this.currentRequest != null) {
			return;
		}
		if(this.requestsHead != null) {
			this.currentRequest = this.requestsHead;
			this.requestsHead = this.currentRequest.next;
			this.proc.stdin.write(this.currentRequest.prepareBody());
		}
	}
	,__class__: haxeLanguageServer_HaxeServer
};
var haxeLanguageServer__$HaxeServer_MessageBuffer = function() {
	this.index = 0;
	this.buffer = new js_node_buffer_Buffer(8192);
};
haxeLanguageServer__$HaxeServer_MessageBuffer.__name__ = ["haxeLanguageServer","_HaxeServer","MessageBuffer"];
haxeLanguageServer__$HaxeServer_MessageBuffer.prototype = {
	append: function(chunk) {
		if(this.buffer.length - this.index >= chunk.length) {
			chunk.copy(this.buffer,this.index,0,chunk.length);
		} else {
			var newSize = (Math.ceil((this.index + chunk.length) / 8192) + 1) * 8192;
			if(this.index == 0) {
				this.buffer = new js_node_buffer_Buffer(newSize);
				chunk.copy(this.buffer,0,0,chunk.length);
			} else {
				this.buffer = js_node_buffer_Buffer.concat([this.buffer.slice(0,this.index),chunk],newSize);
			}
		}
		this.index += chunk.length;
	}
	,tryReadLength: function() {
		if(this.index < 4) {
			return -1;
		}
		var length = this.buffer.readInt32LE(0);
		this.buffer = this.buffer.slice(4);
		this.index -= 4;
		return length;
	}
	,tryReadContent: function(length) {
		if(this.index < length) {
			return null;
		}
		var result = this.buffer.toString("utf-8",0,length);
		this.buffer.copy(this.buffer,0,length);
		this.index -= length;
		return result;
	}
	,__class__: haxeLanguageServer__$HaxeServer_MessageBuffer
};
var haxeLanguageServer_Main = function() { };
haxeLanguageServer_Main.__name__ = ["haxeLanguageServer","Main"];
haxeLanguageServer_Main.main = function() {
	var reader = new jsonrpc_node_MessageReader(process.stdin);
	var writer = new jsonrpc_node_MessageWriter(process.stdout);
	var protocol = new jsonrpc_Protocol($bind(writer,writer.write));
	protocol.logError = function(message) {
		var params = { type : 2, message : message};
		var message1 = { jsonrpc : "2.0", method : "window/logMessage"};
		if(params != null) {
			message1.params = params;
		}
		protocol.writeMessage(message1);
	};
	haxeLanguageServer_Main.setupTrace(protocol);
	new haxeLanguageServer_Context(protocol);
	reader.listen($bind(protocol,protocol.handleMessage));
};
haxeLanguageServer_Main.setupTrace = function(protocol) {
	haxe_Log.trace = function(v,i) {
		var r = [Std.string(v)];
		if(i != null && i.customParams != null) {
			var _g = 0;
			var _g1 = i.customParams;
			while(_g < _g1.length) {
				var v1 = _g1[_g];
				++_g;
				r.push(Std.string(v1));
			}
		}
		var params = { type : 4, message : r.join(" ")};
		var message = { jsonrpc : "2.0", method : "window/logMessage"};
		if(params != null) {
			message.params = params;
		}
		protocol.writeMessage(message);
	};
};
var haxeLanguageServer_TextDocument = function(uri,languageId,version,content) {
	this.uri = uri;
	this.fsPath = haxeLanguageServer_Uri.uriToFsPath(uri);
	this.languageId = languageId;
	this.version = version;
	this.content = content;
};
haxeLanguageServer_TextDocument.__name__ = ["haxeLanguageServer","TextDocument"];
haxeLanguageServer_TextDocument.prototype = {
	update: function(events,version) {
		this.version = version;
		var _g = 0;
		while(_g < events.length) {
			var event = events[_g];
			++_g;
			if(event.range == null || event.rangeLength == null) {
				this.content = event.text;
			} else {
				var offset = this.offsetAt(event.range.start);
				var before = this.content.substring(0,offset);
				var after = this.content.substring(offset + event.rangeLength);
				this.content = before + event.text + after;
			}
		}
		this.lineOffsets = null;
	}
	,offsetToByteOffset: function(offset) {
		if(offset == 0) {
			return 0;
		}
		if(offset == this.content.length) {
			return js_node_buffer_Buffer.byteLength(this.content);
		}
		return js_node_buffer_Buffer.byteLength(HxOverrides.substr(this.content,0,offset));
	}
	,lineAt: function(line) {
		var lineOffsets = this.getLineOffsets();
		if(line >= lineOffsets.length) {
			return "";
		} else if(line == lineOffsets.length - 1) {
			return this.content.substring(lineOffsets[line]);
		} else {
			return this.content.substring(lineOffsets[line],lineOffsets[line + 1]);
		}
	}
	,offsetAt: function(position) {
		var lineOffsets = this.getLineOffsets();
		if(position.line >= lineOffsets.length) {
			return this.content.length;
		} else if(position.line < 0) {
			return 0;
		}
		var lineOffset = lineOffsets[position.line];
		var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this.content.length;
		return Math.max(Math.min(lineOffset + position.character,nextLineOffset),lineOffset) | 0;
	}
	,indentAt: function(line) {
		var re = new EReg("^\\s*","");
		re.match(this.lineAt(line));
		return re.matched(0);
	}
	,getText: function(range) {
		return this.content.substring(this.offsetToByteOffset(this.offsetAt(range.start)),this.offsetToByteOffset(this.offsetAt(range.end)));
	}
	,getLineOffsets: function() {
		if(this.lineOffsets == null) {
			var offsets = [];
			var text = this.content;
			var isLineStart = true;
			var i = 0;
			while(i < text.length) {
				if(isLineStart) {
					offsets.push(i);
					isLineStart = false;
				}
				var ch = HxOverrides.cca(text,i);
				if(ch != 13) {
					isLineStart = ch == 10;
				} else {
					isLineStart = true;
				}
				if(ch == 13 && i + 1 < text.length && HxOverrides.cca(text,i + 1) == 10) {
					++i;
				}
				++i;
			}
			if(isLineStart && text.length > 0) {
				offsets.push(text.length);
			}
			return this.lineOffsets = offsets;
		}
		return this.lineOffsets;
	}
	,__class__: haxeLanguageServer_TextDocument
};
var haxeLanguageServer_TextDocuments = function(protocol) {
	this.documents = new haxe_ds_StringMap();
	var handler = $bind(this,this.onDidChangeTextDocument);
	protocol.notificationHandlers.set("textDocument/didChange",handler);
	var handler1 = $bind(this,this.onDidCloseTextDocument);
	protocol.notificationHandlers.set("textDocument/didClose",handler1);
};
haxeLanguageServer_TextDocuments.__name__ = ["haxeLanguageServer","TextDocuments"];
haxeLanguageServer_TextDocuments.prototype = {
	onDidOpenTextDocument: function(event) {
		var td = event.textDocument;
		var this1 = this.documents;
		var k = td.uri;
		var v = new haxeLanguageServer_TextDocument(td.uri,td.languageId,td.version,td.text);
		var _this = this1;
		if(__map_reserved[k] != null) {
			_this.setReserved(k,v);
		} else {
			_this.h[k] = v;
		}
	}
	,onDidChangeTextDocument: function(event) {
		var td = event.textDocument;
		var changes = event.contentChanges;
		if(changes.length == 0) {
			return;
		}
		var key = td.uri;
		var _this = this.documents;
		var document = __map_reserved[key] != null ? _this.getReserved(key) : _this.h[key];
		if(document != null) {
			document.update(changes,td.version);
		}
	}
	,onDidCloseTextDocument: function(event) {
		this.documents.remove(event.textDocument.uri);
	}
	,__class__: haxeLanguageServer_TextDocuments
};
var haxeLanguageServer_Uri = function() { };
haxeLanguageServer_Uri.__name__ = ["haxeLanguageServer","Uri"];
haxeLanguageServer_Uri.fsPathToUri = function(path) {
	path = StringTools.replace(path,"\\","/");
	if(path.charCodeAt(0) != 47) {
		path = "/" + path;
	}
	var parts = ["file://"];
	if(haxeLanguageServer_Uri.upperCaseDriveRe.match(path)) {
		path = haxeLanguageServer_Uri.upperCaseDriveRe.matched(1) + haxeLanguageServer_Uri.upperCaseDriveRe.matched(2).toLowerCase() + haxeLanguageServer_Uri.upperCaseDriveRe.matchedRight();
	}
	var lastIdx = 0;
	while(true) {
		var idx = path.indexOf("/",lastIdx);
		if(idx == -1) {
			parts.push(haxeLanguageServer_Uri.urlEncode2(path.substring(lastIdx)));
			break;
		}
		parts.push(haxeLanguageServer_Uri.urlEncode2(path.substring(lastIdx,idx)));
		parts.push("/");
		lastIdx = idx + 1;
	}
	return parts.join("");
};
haxeLanguageServer_Uri.urlEncode2 = function(s) {
	return new EReg("[!'()*]","g").map(encodeURIComponent(s),function(re) {
		return "%" + StringTools.hex(re.matched(0).charCodeAt(0));
	});
};
haxeLanguageServer_Uri.uriToFsPath = function(uri) {
	if(!haxeLanguageServer_Uri.uriRe.match(uri) || haxeLanguageServer_Uri.uriRe.matched(2) != "file") {
		throw new js__$Boot_HaxeError("Invalid uri: " + uri);
	}
	var s = haxeLanguageServer_Uri.uriRe.matched(5);
	var path = decodeURIComponent(s.split("+").join(" "));
	if(haxeLanguageServer_Uri.driveLetterPathRe.match(path)) {
		return path.charAt(1).toLowerCase() + HxOverrides.substr(path,2,null);
	} else {
		return path;
	}
};
var haxeLanguageServer_features_CodeActionFeature = function(context) {
	this.contributors = [];
	this.context = context;
	var handler = $bind(this,this.onCodeAction);
	context.protocol.requestHandlers.set("textDocument/codeAction",handler);
};
haxeLanguageServer_features_CodeActionFeature.__name__ = ["haxeLanguageServer","features","CodeActionFeature"];
haxeLanguageServer_features_CodeActionFeature.prototype = {
	registerContributor: function(contributor) {
		this.contributors.push(contributor);
	}
	,onCodeAction: function(params,token,resolve,reject) {
		var codeActions = [];
		var _g = 0;
		var _g1 = this.contributors;
		while(_g < _g1.length) {
			var contributor = _g1[_g];
			++_g;
			codeActions = codeActions.concat(contributor(params));
		}
		resolve(codeActions);
	}
	,__class__: haxeLanguageServer_features_CodeActionFeature
};
var haxeLanguageServer_features_CodeGenerationFeature = function(context) {
	this.context = context;
	context.codeActions.registerContributor($bind(this,this.generateAnonymousFunction));
	context.codeActions.registerContributor($bind(this,this.extractVariable));
};
haxeLanguageServer_features_CodeGenerationFeature.__name__ = ["haxeLanguageServer","features","CodeGenerationFeature"];
haxeLanguageServer_features_CodeGenerationFeature.prototype = {
	generateAnonymousFunction: function(params) {
		var currentSignature = this.context.signatureHelp.currentSignature;
		if(currentSignature == null || currentSignature.params.textDocument.uri != params.textDocument.uri) {
			return [];
		}
		var help = currentSignature.help;
		var activeParam = help.signatures[help.activeSignature].parameters[help.activeParameter];
		if(activeParam == null) {
			return [];
		}
		var position = currentSignature.params.position;
		var currentType = haxeLanguageServer_helper_TypeHelper.parseFunctionArgumentType(activeParam.label);
		if(currentType[1] == 1) {
			var ret = currentType[3];
			var args = currentType[2];
			var generatedCode = haxeLanguageServer_helper_TypeHelper.printFunctionDeclaration(args,ret,this.context.config.codeGeneration.functions.anonymous) + " ";
			return [{ title : "Generate anonymous function", command : "haxe.applyFixes", 'arguments' : [params.textDocument.uri,0,[{ range : { start : position, end : position}, newText : generatedCode}]]}];
		} else {
			return [];
		}
	}
	,extractVariable: function(params) {
		if(haxeLanguageServer_helper_RangeHelper.isEmpty(params.range)) {
			return [];
		}
		var doc = this.context.documents.documents.get(params.textDocument.uri);
		var range = params.range;
		var startLine = range.start.line;
		var indent = doc.indentAt(startLine);
		var extraction = StringTools.replace(doc.getText(range),"$","\\$");
		var variable = "" + indent + "var $" + " = " + extraction + ";\n";
		var pos = { line : startLine, character : 0};
		var insertRange = { start : pos, end : pos};
		return [{ title : "Extract variable", 'arguments' : [params.textDocument.uri,0,[{ range : insertRange, newText : variable},{ range : params.range, newText : "$"}]], command : "haxe.applyFixes"}];
	}
	,__class__: haxeLanguageServer_features_CodeGenerationFeature
};
var haxeLanguageServer_features_CodeLensFeature = function(context) {
	this.context = context;
	var handler = $bind(this,this.onCodeLens);
	context.protocol.requestHandlers.set("textDocument/codeLens",handler);
};
haxeLanguageServer_features_CodeLensFeature.__name__ = ["haxeLanguageServer","features","CodeLensFeature"];
haxeLanguageServer_features_CodeLensFeature.prototype = {
	getCodeLensFromStatistics: function(uri,statistics) {
		var actions = [];
		var addRelation = function(kind,plural,range,relations) {
			if(relations == null) {
				relations = [];
			}
			var title = relations.length + " " + kind + (relations.length == 1 ? "" : plural);
			var action;
			if(relations.length == 0) {
				action = { command : { title : title, command : "", 'arguments' : []}, range : range};
			} else {
				var range1 = range.start;
				var args = relations.map(function(c) {
					var cRange = c.range;
					if(c.range.start.line != c.range.end.line) {
						var nextLineStart = { character : 0, line : c.range.start.line + 1};
						cRange = { start : c.range.start, end : nextLineStart};
					}
					return { range : cRange, uri : haxeLanguageServer_Uri.fsPathToUri(c.file)};
				});
				var args1 = [uri,range1,args];
				action = { command : { title : title, command : "haxe.showReferences", 'arguments' : args1}, range : range};
			}
			actions.push(action);
		};
		var _g = 0;
		while(_g < statistics.length) {
			var statistic = statistics[_g];
			++_g;
			if(statistic.kind == null) {
				continue;
			}
			var range2 = statistic.range;
			var _g1 = statistic.kind;
			switch(_g1) {
			case "class field":
				if(statistic.overrides != null) {
					addRelation("override","s",range2,statistic.overrides);
				}
				addRelation("reference","s",range2,statistic.references);
				if(statistic.implementers != null) {
					addRelation("implementation","s",range2,statistic.implementers);
				}
				break;
			case "class type":
				addRelation("subclass","es",range2,statistic.subclasses);
				break;
			case "enum field":
				addRelation("reference","s",range2,statistic.references);
				break;
			case "enum type":
				addRelation("reference","s",range2,statistic.references);
				break;
			case "interface type":
				addRelation("implementer","s",range2,statistic.implementers);
				addRelation("subinterface","s",range2,statistic.subclasses);
				break;
			}
		}
		return actions;
	}
	,onCodeLens: function(params,token,resolve,reject) {
		var _gthis = this;
		if(!this.context.config.enableCodeLens) {
			resolve([]);
			return;
		}
		var doc = this.context.documents.documents.get(params.textDocument.uri);
		var processError = function(error) {
			var params1 = { type : 4, message : error};
			var message = { jsonrpc : "2.0", method : "window/logMessage"};
			if(params1 != null) {
				message.params = params1;
			}
			_gthis.context.protocol.writeMessage(message);
		};
		var processStatisticsReply = function(s) {
			var data;
			try {
				data = JSON.parse(s);
			} catch( e ) {
				haxe_CallStack.lastException = e;
				if (e instanceof js__$Boot_HaxeError) e = e.val;
				var this1 = { code : -32603, message : "Error parsing stats response: " + Std.string(e)};
				reject(this1);
				return;
			}
			var _g = 0;
			while(_g < data.length) {
				var statistics = data[_g];
				++_g;
				var uri = haxeLanguageServer_Uri.fsPathToUri(statistics.file);
				if(uri == params.textDocument.uri) {
					var processStatisticsReply1 = _gthis.getCodeLensFromStatistics(uri,statistics.statistics);
					resolve(processStatisticsReply1);
				}
			}
		};
		this.context.callDisplay(["--display",doc.fsPath + "@0@statistics"],doc.content,null,processStatisticsReply,processError);
	}
	,__class__: haxeLanguageServer_features_CodeLensFeature
};
var haxeLanguageServer_features_CompletionFeature = function(context) {
	this.context = context;
	var handler = $bind(this,this.onCompletion);
	context.protocol.requestHandlers.set("textDocument/completion",handler);
};
haxeLanguageServer_features_CompletionFeature.__name__ = ["haxeLanguageServer","features","CompletionFeature"];
haxeLanguageServer_features_CompletionFeature.calculateCompletionPosition = function(text,index) {
	if(haxeLanguageServer_features_CompletionFeature.reFieldPart.match(text)) {
		return { pos : index - haxeLanguageServer_features_CompletionFeature.reFieldPart.matched(3).length, toplevel : false};
	} else if(haxeLanguageServer_features_CompletionFeature.reStructPart.match(text)) {
		return { pos : index - haxeLanguageServer_features_CompletionFeature.reStructPart.matched(1).length, toplevel : false};
	} else {
		return { pos : index, toplevel : true};
	}
};
haxeLanguageServer_features_CompletionFeature.parseToplevelCompletion = function(x) {
	var result = [];
	var timers = [];
	var el = x.elements();
	while(el.hasNext()) {
		var el1 = el.next();
		var kind = el1.get("k");
		var type = el1.get("t");
		if(el1.nodeType != Xml.Document && el1.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + el1.nodeType);
		}
		var _this = el1.children[0];
		if(_this.nodeType == Xml.Document || _this.nodeType == Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, unexpected " + _this.nodeType);
		}
		var name = _this.nodeValue;
		var item = { label : name};
		var displayKind = haxeLanguageServer_features_CompletionFeature.toplevelKindToCompletionItemKind(kind);
		if(displayKind != null) {
			item.kind = displayKind;
		}
		if(StringTools.startsWith(name,"@TIME") || StringTools.startsWith(name,"@TOTAL")) {
			var info = name.split(":");
			timers.push(haxeLanguageServer_features_CompletionFeature.getTimerCompletionItem(info[0],info[1]));
			continue;
		}
		var fullName = name;
		if(kind == "global") {
			fullName = el1.get("p") + "." + name;
		} else if(kind == "type") {
			fullName = el1.get("p");
		}
		if(type != null || fullName != name) {
			var parts = [];
			if(fullName != name) {
				parts.push("(" + fullName + ")");
			}
			if(type != null) {
				parts.push(type);
			}
			item.detail = parts.join(" ");
		}
		var doc = el1.get("d");
		if(doc != null) {
			item.documentation = haxeLanguageServer_helper_DocHelper.extractText(doc);
		}
		result.push(item);
	}
	haxeLanguageServer_features_CompletionFeature.sortTimers(timers);
	return result.concat(timers);
};
haxeLanguageServer_features_CompletionFeature.toplevelKindToCompletionItemKind = function(kind) {
	switch(kind) {
	case "enum":case "enumabstract":
		return 13;
	case "global":
		return 6;
	case "literal":
		return 14;
	case "local":
		return 6;
	case "member":
		return 5;
	case "package":
		return 9;
	case "static":
		return 7;
	case "timer":
		return 12;
	case "type":
		return 7;
	default:
		haxe_Log.trace("unknown toplevel item kind: " + kind,{ fileName : "CompletionFeature.hx", lineNumber : 113, className : "haxeLanguageServer.features.CompletionFeature", methodName : "toplevelKindToCompletionItemKind"});
		return null;
	}
};
haxeLanguageServer_features_CompletionFeature.parseFieldCompletion = function(x,textBefore) {
	var result = [];
	var timers = [];
	var el = x.elements();
	while(el.hasNext()) {
		var el1 = el.next();
		var rawKind = el1.get("k");
		var kind = haxeLanguageServer_features_CompletionFeature.fieldKindToCompletionItemKind(rawKind);
		var type = null;
		var doc = null;
		var child = el1.elements();
		while(child.hasNext()) {
			var child1 = child.next();
			if(child1.nodeType != Xml.Element) {
				throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + child1.nodeType);
			}
			var _g = child1.nodeName;
			switch(_g) {
			case "d":
				if(child1.nodeType != Xml.Document && child1.nodeType != Xml.Element) {
					throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + child1.nodeType);
				}
				var _this = child1.children[0];
				if(_this.nodeType == Xml.Document || _this.nodeType == Xml.Element) {
					throw new js__$Boot_HaxeError("Bad node type, unexpected " + _this.nodeType);
				}
				var s = _this.nodeValue;
				if(s == "") {
					doc = null;
				} else {
					doc = s;
				}
				break;
			case "t":
				if(child1.nodeType != Xml.Document && child1.nodeType != Xml.Element) {
					throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + child1.nodeType);
				}
				var _this1 = child1.children[0];
				if(_this1.nodeType == Xml.Document || _this1.nodeType == Xml.Element) {
					throw new js__$Boot_HaxeError("Bad node type, unexpected " + _this1.nodeType);
				}
				var s1 = _this1.nodeValue;
				if(s1 == "") {
					type = null;
				} else {
					type = s1;
				}
				break;
			}
		}
		var name = el1.get("n");
		var insertText = null;
		if(rawKind == "metadata") {
			name = HxOverrides.substr(name,1,null);
			haxeLanguageServer_features_CompletionFeature.reFieldPart.match(textBefore);
			if(haxeLanguageServer_features_CompletionFeature.reFieldPart.matched(2) == ":") {
				insertText = HxOverrides.substr(name,1,null);
			}
		} else if(StringTools.startsWith(name,"@TIME") || StringTools.startsWith(name,"@TOTAL")) {
			timers.push(haxeLanguageServer_features_CompletionFeature.getTimerCompletionItem(name,type));
			continue;
		}
		var item = { label : name};
		if(doc != null) {
			item.documentation = haxeLanguageServer_helper_DocHelper.extractText(doc);
		}
		if(kind != null) {
			item.kind = kind;
		}
		if(type != null) {
			item.detail = haxeLanguageServer_features_CompletionFeature.formatType(type,name,kind);
		}
		if(insertText != null) {
			item.insertText = insertText;
		}
		result.push(item);
	}
	haxeLanguageServer_features_CompletionFeature.sortTimers(timers);
	return result.concat(timers);
};
haxeLanguageServer_features_CompletionFeature.sortTimers = function(items) {
	items.sort(function(a,b) {
		var time1 = a.data;
		var time2 = b.data;
		if(time1 < time2) {
			return 1;
		}
		if(time1 > time2) {
			return -1;
		}
		return 0;
	});
	var _g1 = 0;
	var _g = items.length;
	while(_g1 < _g) {
		var i = _g1++;
		var tmp = String.fromCharCode(65 + i);
		items[i].sortText = "_" + tmp;
	}
};
haxeLanguageServer_features_CompletionFeature.getTimerCompletionItem = function(name,time) {
	var timeRegex = new EReg("([0-9.]*)s(?: \\(([0-9]*)%\\))?","");
	var seconds = 0.0;
	var percentage = "--";
	try {
		timeRegex.match(time);
		seconds = parseFloat(timeRegex.matched(1));
		percentage = timeRegex.matched(2);
	} catch( e ) {
		haxe_CallStack.lastException = e;
	}
	var doc = null;
	if(StringTools.startsWith(name,"@TIME @TOTAL")) {
		name = "@Total time: " + time;
	} else {
		name = StringTools.replace(name,"@TIME ","" + percentage + "% ");
		doc = seconds + "s";
	}
	return { label : name, kind : 12, documentation : doc, insertText : " ", data : seconds};
};
haxeLanguageServer_features_CompletionFeature.formatType = function(type,name,kind) {
	if(kind == 2) {
		return name + haxeLanguageServer_helper_TypeHelper.prepareSignature(type);
	} else {
		return type;
	}
};
haxeLanguageServer_features_CompletionFeature.fieldKindToCompletionItemKind = function(kind) {
	switch(kind) {
	case "metadata":
		return 3;
	case "method":
		return 2;
	case "package":
		return 9;
	case "timer":
		return 12;
	case "type":
		return 7;
	case "var":
		return 5;
	default:
		haxe_Log.trace("unknown field item kind: " + kind,{ fileName : "CompletionFeature.hx", lineNumber : 214, className : "haxeLanguageServer.features.CompletionFeature", methodName : "fieldKindToCompletionItemKind"});
		return null;
	}
};
haxeLanguageServer_features_CompletionFeature.prototype = {
	onCompletion: function(params,token,resolve,reject) {
		var doc = this.context.documents.documents.get(params.textDocument.uri);
		var offset = doc.offsetAt(params.position);
		var textBefore = doc.content.substring(0,offset);
		var r = haxeLanguageServer_features_CompletionFeature.calculateCompletionPosition(textBefore,offset);
		var bytePos = doc.offsetToByteOffset(r.pos);
		var args = ["--display","" + doc.fsPath + "@" + bytePos + (r.toplevel ? "@toplevel" : "")];
		this.context.callDisplay(args,doc.content,token,function(data) {
			if(token.canceled) {
				return;
			}
			var xml;
			try {
				xml = Xml.parse(data).firstElement();
			} catch( _ ) {
				haxe_CallStack.lastException = _;
				xml = null;
			}
			if(xml == null) {
				var this1 = { code : -32603, message : "Invalid xml data: " + data};
				reject(this1);
				return;
			}
			var items = r.toplevel ? haxeLanguageServer_features_CompletionFeature.parseToplevelCompletion(xml) : haxeLanguageServer_features_CompletionFeature.parseFieldCompletion(xml,textBefore);
			resolve(items);
		},function(error) {
			var this2 = { code : -32603, message : error};
			reject(this2);
		});
	}
	,__class__: haxeLanguageServer_features_CompletionFeature
};
var haxeLanguageServer_features_DeterminePackageFeature = function(context) {
	this.context = context;
	var handler = $bind(this,this.onDeterminePackage);
	context.protocol.requestHandlers.set("vshaxe/determinePackage",handler);
};
haxeLanguageServer_features_DeterminePackageFeature.__name__ = ["haxeLanguageServer","features","DeterminePackageFeature"];
haxeLanguageServer_features_DeterminePackageFeature.prototype = {
	onDeterminePackage: function(params,token,resolve,reject) {
		var args = ["--display","" + params.fsPath + "@0@package"];
		this.context.callDisplay(args,null,token,function(data) {
			if(token.canceled) {
				return;
			}
			resolve({ pack : data});
		},function(error) {
			var this1 = { code : -32603, message : error};
			reject(this1);
		});
	}
	,__class__: haxeLanguageServer_features_DeterminePackageFeature
};
var haxeLanguageServer_features_DiagnosticsManager = function(context) {
	var _gthis = this;
	this.context = context;
	this.diagnosticsArguments = new haxe_ds_StringMap();
	var handler = $bind(this,this.onRunGlobalDiagnostics);
	context.protocol.notificationHandlers.set("vshaxe/runGlobalDiagnostics",handler);
	js_node_ChildProcess.exec("haxelib config",function(error,stdout,stderr) {
		_gthis.haxelibPath = StringTools.trim(stdout);
	});
};
haxeLanguageServer_features_DiagnosticsManager.__name__ = ["haxeLanguageServer","features","DiagnosticsManager"];
haxeLanguageServer_features_DiagnosticsManager.prototype = {
	onRunGlobalDiagnostics: function(_) {
		var f = $bind(this,this.processDiagnosticsReply);
		var tmp = function(s) {
			f(null,s);
		};
		this.context.callDisplay(["--display","diagnostics"],null,null,tmp,$bind(this,this.processErrorReply));
	}
	,processErrorReply: function(error) {
		var params = { type : 4, message : error};
		var message = { jsonrpc : "2.0", method : "window/logMessage"};
		if(params != null) {
			message.params = params;
		}
		this.context.protocol.writeMessage(message);
	}
	,processDiagnosticsReply: function(uri,s) {
		var _gthis = this;
		var data;
		try {
			data = JSON.parse(s);
		} catch( e ) {
			haxe_CallStack.lastException = e;
			if (e instanceof js__$Boot_HaxeError) e = e.val;
			haxe_Log.trace("Error parsing diagnostics response: " + Std.string(e),{ fileName : "DiagnosticsManager.hx", lineNumber : 32, className : "haxeLanguageServer.features.DiagnosticsManager", methodName : "processDiagnosticsReply"});
			return;
		}
		var pathFilter = haxeLanguageServer_helper_PathHelper.preparePathFilter(this.context.config.diagnosticsPathFilter,this.haxelibPath,this.context.workspacePath);
		var sent = new haxe_ds_StringMap();
		var _g = 0;
		while(_g < data.length) {
			var data1 = data[_g];
			++_g;
			if(haxeLanguageServer_helper_PathHelper.matches(data1.file,pathFilter)) {
				var uri1 = haxeLanguageServer_Uri.fsPathToUri(data1.file);
				var v = new haxeLanguageServer_features__$DiagnosticsManager_DiagnosticsMap();
				var _this = this.diagnosticsArguments;
				if(__map_reserved[uri1] != null) {
					_this.setReserved(uri1,v);
				} else {
					_this.h[uri1] = v;
				}
				var diagnostics = [];
				var _g1 = 0;
				var _g2 = data1.diagnostics;
				while(_g1 < _g2.length) {
					var hxDiag = _g2[_g1];
					++_g1;
					if(hxDiag.range == null) {
						continue;
					}
					var diag = { range : hxDiag.range, source : "haxe", code : hxDiag.kind, severity : hxDiag.severity, message : haxeLanguageServer_features__$DiagnosticsManager_DiagnosticsKind_$Impl_$.getMessage(hxDiag.kind,hxDiag.args)};
					v.set({ code : diag.code, range : diag.range},hxDiag.args);
					diagnostics.push(diag);
				}
				var params = { uri : uri1, diagnostics : diagnostics};
				var message = { jsonrpc : "2.0", method : "textDocument/publishDiagnostics"};
				if(params != null) {
					message.params = params;
				}
				this.context.protocol.writeMessage(message);
				if(__map_reserved[uri1] != null) {
					sent.setReserved(uri1,true);
				} else {
					sent.h[uri1] = true;
				}
			}
		}
		if(uri == null) {
			var uri2 = this.diagnosticsArguments.keys();
			while(uri2.hasNext()) {
				var uri3 = uri2.next();
				if(!(__map_reserved[uri3] != null ? sent.existsReserved(uri3) : sent.h.hasOwnProperty(uri3))) {
					if(_gthis.diagnosticsArguments.remove(uri3)) {
						var params1 = { uri : uri3, diagnostics : []};
						var message1 = { jsonrpc : "2.0", method : "textDocument/publishDiagnostics"};
						if(params1 != null) {
							message1.params = params1;
						}
						_gthis.context.protocol.writeMessage(message1);
					}
				}
			}
		} else if(!(__map_reserved[uri] != null ? sent.existsReserved(uri) : sent.h.hasOwnProperty(uri))) {
			if(_gthis.diagnosticsArguments.remove(uri)) {
				var params2 = { uri : uri, diagnostics : []};
				var message2 = { jsonrpc : "2.0", method : "textDocument/publishDiagnostics"};
				if(params2 != null) {
					message2.params = params2;
				}
				_gthis.context.protocol.writeMessage(message2);
			}
		}
	}
	,publishDiagnostics: function(uri) {
		var doc = this.context.documents.documents.get(uri);
		var f = $bind(this,this.processDiagnosticsReply);
		var a1 = uri;
		var tmp = function(s) {
			f(a1,s);
		};
		this.context.callDisplay(["--display",doc.fsPath + "@0@diagnostics"],null,null,tmp,$bind(this,this.processErrorReply));
	}
	,__class__: haxeLanguageServer_features_DiagnosticsManager
};
var haxeLanguageServer_features__$DiagnosticsManager_DiagnosticsKind_$Impl_$ = {};
haxeLanguageServer_features__$DiagnosticsManager_DiagnosticsKind_$Impl_$.__name__ = ["haxeLanguageServer","features","_DiagnosticsManager","DiagnosticsKind_Impl_"];
haxeLanguageServer_features__$DiagnosticsManager_DiagnosticsKind_$Impl_$.getMessage = function(this1,args) {
	var _g = this1;
	switch(_g) {
	case 0:
		return "Unused import";
	case 1:
		return "Unresolved identifier";
	case 2:
		return args;
	case 3:
		return args.description;
	}
};
var haxeLanguageServer_features__$DiagnosticsManager_DiagnosticsMap = function() {
	haxe_ds_BalancedTree.call(this);
};
haxeLanguageServer_features__$DiagnosticsManager_DiagnosticsMap.__name__ = ["haxeLanguageServer","features","_DiagnosticsManager","DiagnosticsMap"];
haxeLanguageServer_features__$DiagnosticsManager_DiagnosticsMap.__super__ = haxe_ds_BalancedTree;
haxeLanguageServer_features__$DiagnosticsManager_DiagnosticsMap.prototype = $extend(haxe_ds_BalancedTree.prototype,{
	compare: function(k1,k2) {
		var start1 = k1.range.start;
		var start2 = k2.range.start;
		var end1 = k1.range.end;
		var end2 = k2.range.end;
		var i1 = k1.code;
		var i2 = k2.code;
		var i11 = start1.line;
		var i21 = start2.line;
		var i12 = start1.character;
		var i22 = start2.character;
		var i13 = end1.line;
		var i23 = end2.line;
		var i14 = end1.character;
		var i24 = end2.character;
		if(i1 < i2) {
			return -1;
		} else if(i1 > i2) {
			return 1;
		} else {
			return i11 < i21 ? -1 : i11 > i21 ? 1 : i12 < i22 ? -1 : i12 > i22 ? 1 : i13 < i23 ? -1 : i13 > i23 ? 1 : i14 < i24 ? -1 : i14 > i24 ? 1 : 0;
		}
	}
	,__class__: haxeLanguageServer_features__$DiagnosticsManager_DiagnosticsMap
});
var haxeLanguageServer_features_DocumentSymbolsFeature = function(context) {
	this.context = context;
	var handler = $bind(this,this.onDocumentSymbols);
	context.protocol.requestHandlers.set("textDocument/documentSymbol",handler);
	var handler1 = $bind(this,this.onWorkspaceSymbols);
	context.protocol.requestHandlers.set("workspace/symbol",handler1);
};
haxeLanguageServer_features_DocumentSymbolsFeature.__name__ = ["haxeLanguageServer","features","DocumentSymbolsFeature"];
haxeLanguageServer_features_DocumentSymbolsFeature.prototype = {
	processSymbolsReply: function(data,reject) {
		var data1;
		try {
			data1 = JSON.parse(data);
		} catch( e ) {
			haxe_CallStack.lastException = e;
			if (e instanceof js__$Boot_HaxeError) e = e.val;
			var this1 = { code : -32603, message : "Error parsing document symbol response: " + Std.string(e)};
			reject(this1);
			return [];
		}
		var result = [];
		var _g = 0;
		while(_g < data1.length) {
			var file = data1[_g];
			++_g;
			var uri = haxeLanguageServer_Uri.fsPathToUri(haxeLanguageServer_HaxePosition.getProperFileNameCase(file.file));
			var _g1 = 0;
			var _g2 = file.symbols;
			while(_g1 < _g2.length) {
				var symbol = _g2[_g1];
				++_g1;
				if(symbol.range == null) {
					var _this = this.context;
					var params = { type : 1, message : "Unknown location for " + JSON.stringify(symbol)};
					var message = { jsonrpc : "2.0", method : "window/showMessage"};
					if(params != null) {
						message.params = params;
					}
					_this.protocol.writeMessage(message);
					continue;
				}
				result.push(this.moduleSymbolEntryToSymbolInformation(symbol,uri));
			}
		}
		return result;
	}
	,makeRequest: function(args,doc,token,resolve,reject) {
		var _gthis = this;
		this.context.callDisplay(args,doc == null ? null : doc.content,token,function(data) {
			if(token.canceled) {
				return;
			}
			var result = _gthis.processSymbolsReply(data,reject);
			resolve(result);
		},function(error) {
			var this1 = { code : -32603, message : error};
			reject(this1);
		});
	}
	,onDocumentSymbols: function(params,token,resolve,reject) {
		var doc = this.context.documents.documents.get(params.textDocument.uri);
		var args = ["--display","" + doc.fsPath + "@0@module-symbols"];
		this.makeRequest(args,doc,token,resolve,reject);
	}
	,onWorkspaceSymbols: function(params,token,resolve,reject) {
		var args = ["--display ?@0@workspace-symbols@" + params.query];
		this.makeRequest(args,null,token,resolve,reject);
	}
	,moduleSymbolEntryToSymbolInformation: function(entry,uri) {
		var _g = entry.kind;
		var result;
		switch(_g) {
		case 1:case 5:
			result = 5;
			break;
		case 3:
			result = 10;
			break;
		case 2:case 4:
			result = 11;
			break;
		case 6:
			result = 8;
			break;
		case 7:
			result = 7;
			break;
		case 8:
			result = 6;
			break;
		case 9:
			result = 9;
			break;
		case 10:
			result = 12;
			break;
		case 11:
			result = 13;
			break;
		}
		var result1 = { name : entry.name, kind : result, location : { uri : uri, range : entry.range}};
		if(entry.containerName != null) {
			result1.containerName = entry.containerName;
		}
		return result1;
	}
	,__class__: haxeLanguageServer_features_DocumentSymbolsFeature
};
var haxeLanguageServer_features_FindReferencesFeature = function(context) {
	this.context = context;
	var handler = $bind(this,this.onFindReferences);
	context.protocol.requestHandlers.set("textDocument/references",handler);
};
haxeLanguageServer_features_FindReferencesFeature.__name__ = ["haxeLanguageServer","features","FindReferencesFeature"];
haxeLanguageServer_features_FindReferencesFeature.prototype = {
	onFindReferences: function(params,token,resolve,reject) {
		var doc = this.context.documents.documents.get(params.textDocument.uri);
		var bytePos = doc.offsetAt(params.position);
		var bytePos1 = doc.offsetToByteOffset(bytePos);
		var args = ["--display","" + doc.fsPath + "@" + bytePos1 + "@usage"];
		this.context.callDisplay(args,doc.content,token,function(data) {
			if(token.canceled) {
				return;
			}
			var xml;
			try {
				xml = Xml.parse(data).firstElement();
			} catch( _ ) {
				haxe_CallStack.lastException = _;
				xml = null;
			}
			if(xml == null) {
				var this1 = { code : -32603, message : "Invalid xml data: " + data};
				reject(this1);
				return;
			}
			var _g = [];
			var el = xml.elements();
			while(el.hasNext()) {
				var el1 = el.next();
				if(el1.nodeType != Xml.Document && el1.nodeType != Xml.Element) {
					throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + el1.nodeType);
				}
				var _this = el1.children[0];
				if(_this.nodeType == Xml.Document || _this.nodeType == Xml.Element) {
					throw new js__$Boot_HaxeError("Bad node type, unexpected " + _this.nodeType);
				}
				_g.push(_this.nodeValue);
			}
			if(_g.length == 0) {
				resolve([]);
				return;
			}
			var results = [];
			var haxePosCache = new haxe_ds_StringMap();
			var _g1 = 0;
			while(_g1 < _g.length) {
				var pos = _g[_g1];
				++_g1;
				var location = haxeLanguageServer_HaxePosition.parse(pos,doc,haxePosCache);
				if(location == null) {
					haxe_Log.trace("Got invalid position: " + pos,{ fileName : "FindReferencesFeature.hx", lineNumber : 36, className : "haxeLanguageServer.features.FindReferencesFeature", methodName : "onFindReferences"});
					continue;
				}
				results.push(location);
			}
			resolve(results);
			return;
		},function(error) {
			var this2 = { code : -32603, message : error};
			reject(this2);
		});
	}
	,__class__: haxeLanguageServer_features_FindReferencesFeature
};
var haxeLanguageServer_features_GotoDefinitionFeature = function(context) {
	this.context = context;
	var handler = $bind(this,this.onGotoDefinition);
	context.protocol.requestHandlers.set("textDocument/definition",handler);
};
haxeLanguageServer_features_GotoDefinitionFeature.__name__ = ["haxeLanguageServer","features","GotoDefinitionFeature"];
haxeLanguageServer_features_GotoDefinitionFeature.prototype = {
	onGotoDefinition: function(params,token,resolve,reject) {
		var doc = this.context.documents.documents.get(params.textDocument.uri);
		var bytePos = doc.offsetAt(params.position);
		var bytePos1 = doc.offsetToByteOffset(bytePos);
		var args = ["--display","" + doc.fsPath + "@" + bytePos1 + "@position"];
		this.context.callDisplay(args,doc.content,token,function(data) {
			if(token.canceled) {
				return;
			}
			var xml;
			try {
				xml = Xml.parse(data).firstElement();
			} catch( _ ) {
				haxe_CallStack.lastException = _;
				xml = null;
			}
			if(xml == null) {
				var this1 = { code : -32603, message : "Invalid xml data: " + data};
				reject(this1);
				return;
			}
			var _g = [];
			var el = xml.elements();
			while(el.hasNext()) {
				var el1 = el.next();
				if(el1.nodeType != Xml.Document && el1.nodeType != Xml.Element) {
					throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + el1.nodeType);
				}
				var _this = el1.children[0];
				if(_this.nodeType == Xml.Document || _this.nodeType == Xml.Element) {
					throw new js__$Boot_HaxeError("Bad node type, unexpected " + _this.nodeType);
				}
				_g.push(_this.nodeValue);
			}
			if(_g.length == 0) {
				resolve([]);
				return;
			}
			var results = [];
			var _g1 = 0;
			while(_g1 < _g.length) {
				var pos = _g[_g1];
				++_g1;
				var location = haxeLanguageServer_HaxePosition.parse(pos,doc,null);
				if(location == null) {
					haxe_Log.trace("Got invalid position: " + pos,{ fileName : "GotoDefinitionFeature.hx", lineNumber : 36, className : "haxeLanguageServer.features.GotoDefinitionFeature", methodName : "onGotoDefinition"});
					continue;
				}
				results.push(location);
			}
			resolve(results);
			return;
		},function(error) {
			var this2 = { code : -32603, message : error};
			reject(this2);
		});
	}
	,__class__: haxeLanguageServer_features_GotoDefinitionFeature
};
var haxeLanguageServer_features_HoverFeature = function(context) {
	this.context = context;
	var handler = $bind(this,this.onHover);
	context.protocol.requestHandlers.set("textDocument/hover",handler);
};
haxeLanguageServer_features_HoverFeature.__name__ = ["haxeLanguageServer","features","HoverFeature"];
haxeLanguageServer_features_HoverFeature.prototype = {
	onHover: function(params,token,resolve,reject) {
		var doc = this.context.documents.documents.get(params.textDocument.uri);
		var bytePos = doc.offsetAt(params.position);
		var bytePos1 = doc.offsetToByteOffset(bytePos);
		var args = ["--display","" + doc.fsPath + "@" + bytePos1 + "@type"];
		this.context.callDisplay(args,doc.content,token,function(data) {
			if(token.canceled) {
				return;
			}
			var xml;
			try {
				xml = Xml.parse(data).firstElement();
			} catch( _ ) {
				haxe_CallStack.lastException = _;
				xml = null;
			}
			if(xml == null) {
				var this1 = { code : -32603, message : "Invalid xml data: " + data};
				reject(this1);
				return;
			}
			if(xml.nodeType != Xml.Document && xml.nodeType != Xml.Element) {
				throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + xml.nodeType);
			}
			var _this = xml.children[0];
			if(_this.nodeType == Xml.Document || _this.nodeType == Xml.Element) {
				throw new js__$Boot_HaxeError("Bad node type, unexpected " + _this.nodeType);
			}
			var s = StringTools.trim(_this.nodeValue);
			if(xml.nodeType != Xml.Element) {
				throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + xml.nodeType);
			}
			var _g = xml.nodeName;
			if(_g == "metadata") {
				if(s.length == 0) {
					var this2 = { code : 0, message : "No metadata information"};
					reject(this2);
					return;
				}
				resolve({ contents : s});
			} else {
				if(s.length == 0) {
					var this3 = { code : 0, message : "No type information"};
					reject(this3);
					return;
				}
				var type;
				var _g1 = haxeLanguageServer_helper_TypeHelper.parseDisplayType(s);
				switch(_g1[1]) {
				case 0:
					var type1 = _g1[2];
					if(type1 == null) {
						type = "unknown";
					} else {
						type = type1;
					}
					break;
				case 1:
					var ret = _g1[3];
					var args1 = _g1[2];
					type = haxeLanguageServer_helper_TypeHelper.printFunctionDeclaration(args1,ret,{ argumentTypeHints : true, returnTypeHint : "always"});
					break;
				}
				var d = xml.get("d");
				if(d == null) {
					d = "";
				} else {
					d = haxeLanguageServer_helper_DocHelper.markdownFormat(d);
				}
				var result = { contents : "```haxe\n" + type + "\n```\n" + d};
				var p = haxeLanguageServer_HaxePosition.parse(xml.get("p"),doc,null);
				if(p != null) {
					result.range = p.range;
				}
				resolve(result);
			}
		},function(error) {
			var this4 = { code : -32603, message : error};
			reject(this4);
		});
	}
	,__class__: haxeLanguageServer_features_HoverFeature
};
var haxeLanguageServer_features_SignatureHelpFeature = function(context) {
	this.context = context;
	var handler = $bind(this,this.onSignatureHelp);
	context.protocol.requestHandlers.set("textDocument/signatureHelp",handler);
};
haxeLanguageServer_features_SignatureHelpFeature.__name__ = ["haxeLanguageServer","features","SignatureHelpFeature"];
haxeLanguageServer_features_SignatureHelpFeature.prototype = {
	onSignatureHelp: function(params,token,resolve,reject) {
		var _gthis = this;
		var doc = this.context.documents.documents.get(params.textDocument.uri);
		var bytePos = doc.offsetToByteOffset(doc.offsetAt(params.position));
		var args = ["--display","" + doc.fsPath + "@" + bytePos + "@signature"];
		this.context.callDisplay(args,doc.content,token,function(data) {
			if(token.canceled) {
				return;
			}
			var help = JSON.parse(data);
			resolve(help);
			_gthis.currentSignature = { help : help, params : params};
		},function(error) {
			var this1 = { code : -32603, message : error};
			reject(this1);
		});
	}
	,__class__: haxeLanguageServer_features_SignatureHelpFeature
};
var haxeLanguageServer_helper_DocHelper = function() { };
haxeLanguageServer_helper_DocHelper.__name__ = ["haxeLanguageServer","helper","DocHelper"];
haxeLanguageServer_helper_DocHelper.trim = function(doc) {
	if(doc == null) {
		return "";
	}
	while(doc.charAt(0) == "*") doc = HxOverrides.substr(doc,1,null);
	while(doc.charAt(doc.length - 1) == "*") doc = HxOverrides.substr(doc,0,doc.length - 1);
	doc = StringTools.trim(doc);
	var ereg = new EReg("^([ \t]+(\\* )?)[^\\s\\*]","m");
	var matched = ereg.match(doc);
	if(matched) {
		var string = ereg.matched(1);
		string = string.split("* ").join("\\* ?");
		var indent_r = new RegExp("^" + string,"gm".split("u").join(""));
		doc = doc.replace(indent_r,"");
	}
	if(doc.charAt(0) == "*") {
		doc = StringTools.ltrim(HxOverrides.substr(doc,1,null));
	}
	return doc;
};
haxeLanguageServer_helper_DocHelper.markdownFormat = function(doc) {
	var tableLine = function(a,b) {
		return "| " + a + " | " + b + " |\n";
	};
	var tableHeader = function(a1,b1) {
		return "\n" + tableLine(a1,b1) + tableLine("------","------");
	};
	var replaceNewlines = function(s,by) {
		return StringTools.replace(StringTools.replace(s,"\n",by),"\r",by);
	};
	var mapDocTags = function(tags) {
		return tags.map(function(p) {
			var desc = replaceNewlines(p.doc," ");
			return tableLine("`" + p.value + "`",desc);
		}).join("");
	};
	doc = haxeLanguageServer_helper_DocHelper.trim(doc);
	var docInfos = haxeLanguageServer_helper_JavadocHelper.parse(doc);
	var result = docInfos.doc;
	var hasParams = docInfos.params.length > 0;
	var hasReturn = docInfos.returns != null;
	if(docInfos.deprecated != null) {
		result += "\n**Deprecated:** " + docInfos.deprecated.doc + "\n";
	}
	if(hasParams || hasReturn) {
		result += tableHeader("Argument","Description");
	}
	if(hasParams) {
		result += mapDocTags(docInfos.params);
	}
	if(hasReturn) {
		var result1 = replaceNewlines(docInfos.returns.doc," ");
		result += tableLine("`return`",result1);
	}
	if(docInfos["throws"].length > 0) {
		result += tableHeader("Exception","Description") + mapDocTags(docInfos["throws"]);
	}
	if(docInfos.sees.length > 0) {
		result += "\nSee also:\n" + docInfos.sees.map(function(p1) {
			return "* " + p1.doc;
		}).join("\n") + "\n";
	}
	if(docInfos.since != null) {
		result += "\n_Available since " + docInfos.since.doc + "_";
	}
	return result;
};
haxeLanguageServer_helper_DocHelper.extractText = function(doc) {
	if(doc == null) {
		return null;
	}
	return StringTools.trim(doc).split("\n").map(function(line) {
		line = StringTools.trim(line);
		if(StringTools.startsWith(line,"*")) {
			line = HxOverrides.substr(line,1,null);
		}
		return line;
	}).join("\n");
};
var haxeLanguageServer_helper_JavadocHelper = function() { };
haxeLanguageServer_helper_JavadocHelper.__name__ = ["haxeLanguageServer","helper","JavadocHelper"];
haxeLanguageServer_helper_JavadocHelper.parse = function(doc) {
	var tags = [];
	var ereg = new EReg("^@(param|default|exception|throws|deprecated|return|returns|since|see)\\s+([^@]+)","gm");
	doc = ereg.map(doc,function(e) {
		var name = e.matched(1);
		var doc1 = e.matched(2);
		var value = null;
		switch(name) {
		case "exception":case "param":case "throws":
			var ereg1 = new EReg("([^\\s]+)\\s+([\\s\\S]*)","g");
			if(ereg1.match(doc1)) {
				value = ereg1.matched(1);
				doc1 = ereg1.matched(2);
			}
			break;
		default:
		}
		doc1 = haxeLanguageServer_helper_JavadocHelper.trimDoc(doc1);
		tags.push({ name : name, doc : doc1, value : value});
		return "";
	});
	var infos = { doc : doc, 'throws' : [], params : [], sees : [], tags : tags};
	var _g = 0;
	while(_g < tags.length) {
		var tag = tags[_g];
		++_g;
		var _g1 = tag.name;
		switch(_g1) {
		case "default":
			infos.defaultValue = tag;
			break;
		case "deprecated":
			infos.deprecated = tag;
			break;
		case "param":
			infos.params.push(tag);
			break;
		case "return":case "returns":
			infos.returns = tag;
			break;
		case "see":
			infos.sees.push(tag);
			break;
		case "since":
			infos.since = tag;
			break;
		case "exception":case "throws":
			infos["throws"].push(tag);
			break;
		default:
		}
	}
	return infos;
};
haxeLanguageServer_helper_JavadocHelper.trimDoc = function(doc) {
	var ereg = new EReg("^\\s+","m");
	if(ereg.match(doc)) {
		var space_r = new RegExp("^" + ereg.matched(0),"mg".split("u").join(""));
		doc = doc.replace(space_r,"");
	}
	return doc;
};
var haxeLanguageServer_helper_PathHelper = function() { };
haxeLanguageServer_helper_PathHelper.__name__ = ["haxeLanguageServer","helper","PathHelper"];
haxeLanguageServer_helper_PathHelper.matches = function(path,pathFilter) {
	return new EReg(pathFilter,"").match(haxeLanguageServer_helper_PathHelper.normalize(path));
};
haxeLanguageServer_helper_PathHelper.preparePathFilter = function(diagnosticsPathFilter,haxelibPath,workspaceRoot) {
	var path = diagnosticsPathFilter;
	path = StringTools.replace(diagnosticsPathFilter,"${workspaceRoot}",workspaceRoot);
	if(haxelibPath != null) {
		path = StringTools.replace(path,"${haxelibPath}",haxelibPath);
	} else {
		haxe_Log.trace("Could not retrieve haxelib repo path for diagnostics filtering",{ fileName : "PathHelper.hx", lineNumber : 17, className : "haxeLanguageServer.helper.PathHelper", methodName : "preparePathFilter"});
	}
	return haxeLanguageServer_helper_PathHelper.normalize(path);
};
haxeLanguageServer_helper_PathHelper.normalize = function(path) {
	path = haxe_io_Path.normalize(path);
	if(haxeLanguageServer_helper_PathHelper.reUpperCaseDriveLetter.match(path)) {
		var letter = HxOverrides.substr(path,0,1).toLowerCase();
		path = letter + path.substring(1);
	}
	return path;
};
var haxeLanguageServer_helper_PositionHelper = function() { };
haxeLanguageServer_helper_PositionHelper.__name__ = ["haxeLanguageServer","helper","PositionHelper"];
haxeLanguageServer_helper_PositionHelper.isEqual = function(pos,other) {
	if(pos.line == other.line) {
		return pos.character == other.character;
	} else {
		return false;
	}
};
var haxeLanguageServer_helper_RangeHelper = function() { };
haxeLanguageServer_helper_RangeHelper.__name__ = ["haxeLanguageServer","helper","RangeHelper"];
haxeLanguageServer_helper_RangeHelper.isEmpty = function(range) {
	return haxeLanguageServer_helper_PositionHelper.isEqual(range.end,range.start);
};
var haxeLanguageServer_helper_TypeHelper = function() { };
haxeLanguageServer_helper_TypeHelper.__name__ = ["haxeLanguageServer","helper","TypeHelper"];
haxeLanguageServer_helper_TypeHelper.getCloseChar = function(c) {
	switch(c) {
	case "(":
		return ")";
	case "<":
		return ">";
	case "{":
		return "}";
	default:
		throw new js__$Boot_HaxeError("unknown opening char " + c);
	}
};
haxeLanguageServer_helper_TypeHelper.prepareSignature = function(type) {
	var _g = haxeLanguageServer_helper_TypeHelper.parseDisplayType(type);
	switch(_g[1]) {
	case 0:
		var type1 = _g[2];
		if(type1 == null) {
			return "";
		} else {
			return type1;
		}
		break;
	case 1:
		var ret = _g[3];
		var args = _g[2];
		return haxeLanguageServer_helper_TypeHelper.printFunctionSignature(args,ret,{ argumentTypeHints : true, returnTypeHint : "always"});
	}
};
haxeLanguageServer_helper_TypeHelper.printFunctionDeclaration = function(args,ret,formatting) {
	return "function" + haxeLanguageServer_helper_TypeHelper.printFunctionSignature(args,ret,formatting);
};
haxeLanguageServer_helper_TypeHelper.printFunctionSignature = function(args,ret,formatting) {
	var result_b = "";
	result_b = "(";
	var first = true;
	var _g = 0;
	while(_g < args.length) {
		var arg = args[_g];
		++_g;
		if(first) {
			first = false;
		} else {
			result_b += ", ";
		}
		result_b += Std.string(haxeLanguageServer_helper_TypeHelper.printSignatureArgument(arg,formatting.argumentTypeHints));
	}
	result_b += ")";
	if(haxeLanguageServer_helper_TypeHelper.shouldPrintReturnType(ret,formatting.returnTypeHint)) {
		result_b += ":";
		result_b += ret == null ? "null" : "" + ret;
	}
	return result_b;
};
haxeLanguageServer_helper_TypeHelper.shouldPrintReturnType = function(ret,option) {
	if(ret == null) {
		return false;
	}
	switch(option) {
	case "always":
		return true;
	case "never":
		return false;
	case "non-void":
		return ret != "Void";
	}
};
haxeLanguageServer_helper_TypeHelper.printSignatureArgument = function(arg,typeHints) {
	var result = arg.name;
	if(arg.opt) {
		result = "?" + result;
	}
	if(arg.type != null && typeHints) {
		result += ":";
		result += arg.type;
	}
	return result;
};
haxeLanguageServer_helper_TypeHelper.parseFunctionArgumentType = function(argument) {
	if(StringTools.startsWith(argument,"?")) {
		argument = HxOverrides.substr(argument,1,null);
	}
	var colonIndex = argument.indexOf(":");
	var argumentType = HxOverrides.substr(argument,colonIndex + 1,null);
	while(StringTools.startsWith(argumentType,"Null<") && StringTools.endsWith(argumentType,">")) argumentType = argumentType.substring("Null<".length,argumentType.length - 1);
	return haxeLanguageServer_helper_TypeHelper.parseDisplayType(argumentType);
};
haxeLanguageServer_helper_TypeHelper.parseDisplayType = function(type) {
	type = StringTools.replace(type," -> ","%");
	var toplevel_b = "";
	var groups = new haxe_ds_IntMap();
	var closeStack = new haxe_ds_GenericStack();
	var depth = 0;
	var groupId = 0;
	var _g1 = 0;
	var _g = type.length;
	while(_g1 < _g) {
		var i = _g1++;
		var $char = type.charAt(i);
		if($char == "(" || $char == "<" || $char == "{") {
			++depth;
			closeStack.head = new haxe_ds_GenericCell(haxeLanguageServer_helper_TypeHelper.getCloseChar($char),closeStack.head);
			if(depth == 1) {
				++groupId;
				var v = new StringBuf();
				groups.h[groupId] = v;
				toplevel_b += $char == null ? "null" : "" + $char;
				toplevel_b += Std.string("$" + groupId);
				continue;
			}
		} else if($char == (closeStack.head == null ? null : closeStack.head.elt)) {
			var k = closeStack.head;
			if(k != null) {
				closeStack.head = k.next;
			}
			--depth;
		}
		if(depth == 0) {
			toplevel_b += $char == null ? "null" : "" + $char;
		} else {
			groups.h[groupId].b += $char == null ? "null" : "" + $char;
		}
	}
	var processType = function(type1) {
		type1 = haxeLanguageServer_helper_TypeHelper.groupRegex.map(type1,function(r) {
			var groupId1 = Std.parseInt(r.matched(1));
			return StringTools.replace(groups.h[groupId1].b,"%","->");
		});
		if(haxeLanguageServer_helper_TypeHelper.parenRegex.match(type1)) {
			type1 = haxeLanguageServer_helper_TypeHelper.parenRegex.matched(1);
		}
		return type1;
	};
	var parts = toplevel_b.split("%");
	var returnType = processType(parts.pop());
	if(haxeLanguageServer_helper_TypeHelper.monomorphRegex.match(returnType)) {
		returnType = null;
	}
	if(parts.length > 0) {
		var args = [];
		var _g11 = 0;
		var _g2 = parts.length;
		while(_g11 < _g2) {
			var i1 = _g11++;
			var part = parts[i1];
			var name;
			var type2;
			var opt = false;
			if(haxeLanguageServer_helper_TypeHelper.argNameRegex.match(part)) {
				name = haxeLanguageServer_helper_TypeHelper.argNameRegex.matched(1);
				if(HxOverrides.cca(name,0) == 63) {
					name = name.substring(1);
					opt = true;
				}
				type2 = haxeLanguageServer_helper_TypeHelper.argNameRegex.matchedRight();
			} else {
				name = String.fromCharCode(97 + i1);
				type2 = part;
				if(HxOverrides.cca(part,0) == 63) {
					type2 = part.substring(1);
					opt = true;
				}
			}
			if(opt && haxeLanguageServer_helper_TypeHelper.nullRegex.match(type2)) {
				type2 = haxeLanguageServer_helper_TypeHelper.nullRegex.matched(1);
			}
			type2 = processType(type2);
			if(type2 == "Void") {
				continue;
			}
			var arg = { name : name};
			if(!haxeLanguageServer_helper_TypeHelper.monomorphRegex.match(type2)) {
				arg.type = type2;
			}
			if(opt) {
				arg.opt = true;
			}
			args.push(arg);
		}
		return haxeLanguageServer_helper_DisplayType.DTFunction(args,returnType);
	} else {
		return haxeLanguageServer_helper_DisplayType.DTValue(returnType);
	}
};
var haxeLanguageServer_helper_DisplayType = { __ename__ : true, __constructs__ : ["DTValue","DTFunction"] };
haxeLanguageServer_helper_DisplayType.DTValue = function(type) { var $x = ["DTValue",0,type]; $x.__enum__ = haxeLanguageServer_helper_DisplayType; $x.toString = $estr; return $x; };
haxeLanguageServer_helper_DisplayType.DTFunction = function(args,ret) { var $x = ["DTFunction",1,args,ret]; $x.__enum__ = haxeLanguageServer_helper_DisplayType; $x.toString = $estr; return $x; };
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = ["js","_Boot","HaxeError"];
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
	__class__: js__$Boot_HaxeError
});
var js_Boot = function() { };
js_Boot.__name__ = ["js","Boot"];
js_Boot.__unhtml = function(s) {
	return s.split("&").join("&amp;").split("<").join("&lt;").split(">").join("&gt;");
};
js_Boot.__trace = function(v,i) {
	var msg = i != null ? i.fileName + ":" + i.lineNumber + ": " : "";
	msg += js_Boot.__string_rec(v,"");
	if(i != null && i.customParams != null) {
		var _g = 0;
		var _g1 = i.customParams;
		while(_g < _g1.length) {
			var v1 = _g1[_g];
			++_g;
			msg += "," + js_Boot.__string_rec(v1,"");
		}
	}
	var d;
	var tmp;
	if(typeof(document) != "undefined") {
		d = document.getElementById("haxe:trace");
		tmp = d != null;
	} else {
		tmp = false;
	}
	if(tmp) {
		d.innerHTML += js_Boot.__unhtml(msg) + "<br/>";
	} else if(typeof console != "undefined" && console.log != null) {
		console.log(msg);
	}
};
js_Boot.getClass = function(o) {
	if((o instanceof Array) && o.__enum__ == null) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			haxe_CallStack.lastException = e;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g1 = 0;
		var _g = intf.length;
		while(_g1 < _g) {
			var i = _g1++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		if((o instanceof Array)) {
			return o.__enum__ == null;
		} else {
			return false;
		}
		break;
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return true;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return (o|0) === o;
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(o instanceof cl) {
					return true;
				}
				if(js_Boot.__interfLoop(js_Boot.getClass(o),cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(o instanceof cl) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ == cl;
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var js_node_ChildProcess = require("child_process");
var js_node_Fs = require("fs");
var js_node_Net = require("net");
var js_node_Path = require("path");
var jsonrpc__$CancellationToken_CancellationTokenImpl = function() {
	this.canceled = false;
};
jsonrpc__$CancellationToken_CancellationTokenImpl.__name__ = ["jsonrpc","_CancellationToken","CancellationTokenImpl"];
jsonrpc__$CancellationToken_CancellationTokenImpl.prototype = {
	__class__: jsonrpc__$CancellationToken_CancellationTokenImpl
};
var jsonrpc_ErrorUtils = function() { };
jsonrpc_ErrorUtils.__name__ = ["jsonrpc","ErrorUtils"];
jsonrpc_ErrorUtils.errorToString = function(error,intro) {
	var result = intro + Std.string(error);
	var stack = haxe_CallStack.exceptionStack();
	if(stack != null && stack.length > 0) {
		result += "\n" + haxe_CallStack.toString(stack);
	}
	return result;
};
var jsonrpc_Protocol = function(writeMessage) {
	this.writeMessage = writeMessage;
	this.requestHandlers = new haxe_ds_StringMap();
	this.notificationHandlers = new haxe_ds_StringMap();
	this.requestTokens = new haxe_ds_StringMap();
	this.nextRequestId = 0;
};
jsonrpc_Protocol.__name__ = ["jsonrpc","Protocol"];
jsonrpc_Protocol.prototype = {
	handleMessage: function(message) {
		if((Object.prototype.hasOwnProperty.call(message,"result") || Object.prototype.hasOwnProperty.call(message,"error")) && Object.prototype.hasOwnProperty.call(message,"id")) {
			this.handleResponse(message);
		} else if(Object.prototype.hasOwnProperty.call(message,"method")) {
			if(Object.prototype.hasOwnProperty.call(message,"id")) {
				this.handleRequest(message);
			} else {
				this.handleNotification(message);
			}
		}
	}
	,handleRequest: function(request) {
		var _gthis = this;
		var tokenKey = Std.string(request.id);
		var resolve = function(result) {
			_gthis.requestTokens.remove(tokenKey);
			var response = { jsonrpc : "2.0", id : request.id, result : result};
			_gthis.writeMessage(response);
		};
		var reject = function(error) {
			_gthis.requestTokens.remove(tokenKey);
			var response1 = { jsonrpc : "2.0", id : request.id, error : error};
			_gthis.writeMessage(response1);
		};
		var key = request.method;
		var _this = this.requestHandlers;
		var handler = __map_reserved[key] != null ? _this.getReserved(key) : _this.h[key];
		if($bind(this,this.handleMessage) == null) {
			var this1 = { code : -32601, message : "Unhandled method " + request.method};
			reject(this1);
			return;
		}
		var this2 = new jsonrpc__$CancellationToken_CancellationTokenImpl();
		var tokenSource = this2;
		var _this1 = this.requestTokens;
		if(__map_reserved[tokenKey] != null) {
			_this1.setReserved(tokenKey,tokenSource);
		} else {
			_this1.h[tokenKey] = tokenSource;
		}
		try {
			handler(request.params,tokenSource,resolve,reject);
		} catch( e ) {
			haxe_CallStack.lastException = e;
			if (e instanceof js__$Boot_HaxeError) e = e.val;
			this.requestTokens.remove(tokenKey);
			var message = jsonrpc_ErrorUtils.errorToString(e,"Exception while handling request " + request.method + ": ");
			var this3 = { code : -32603, message : message};
			reject(this3);
			this.logError(message);
		}
	}
	,handleNotification: function(notification) {
		if(notification.method == "$/cancelRequest") {
			var tokenKey = Std.string(notification.params.id);
			var _this = this.requestTokens;
			var tokenSource = __map_reserved[tokenKey] != null ? _this.getReserved(tokenKey) : _this.h[tokenKey];
			if(tokenSource != null) {
				this.requestTokens.remove(tokenKey);
				if(!tokenSource.canceled) {
					tokenSource.canceled = true;
					if(tokenSource.callback != null) {
						tokenSource.callback();
					}
				}
			}
		} else {
			var key = notification.method;
			var _this1 = this.notificationHandlers;
			var handler = __map_reserved[key] != null ? _this1.getReserved(key) : _this1.h[key];
			if(handler == null) {
				return;
			}
			try {
				handler(notification.params);
			} catch( e ) {
				haxe_CallStack.lastException = e;
				if (e instanceof js__$Boot_HaxeError) e = e.val;
				$bind(this,this.logError)(jsonrpc_ErrorUtils.errorToString(e,"Exception while processing notification " + notification.method + ": "));
			}
		}
	}
	,handleResponse: function(response) {
		var v = response.id;
		if(!(typeof(v) == "number" && ((v | 0) === v))) {
			$bind(this,this.logError)("Got response with non-integer id:\n" + JSON.stringify(response,null,"    "));
			return;
		}
		var handler = this.responseCallbacks.h[response.id];
		if(handler != null) {
			this.responseCallbacks.remove(response.id);
			try {
				if(Object.prototype.hasOwnProperty.call(response,"error")) {
					handler.reject(response.error);
				} else {
					handler.resolve(response.result);
				}
			} catch( e ) {
				haxe_CallStack.lastException = e;
				if (e instanceof js__$Boot_HaxeError) e = e.val;
				$bind(this,this.logError)(jsonrpc_ErrorUtils.errorToString(e,"Exception while handing response " + handler.method + ": "));
			}
		}
	}
	,logError: function(message) {
	}
	,__class__: jsonrpc_Protocol
};
var jsonrpc__$Protocol_ResponseCallbackEntry = function() { };
jsonrpc__$Protocol_ResponseCallbackEntry.__name__ = ["jsonrpc","_Protocol","ResponseCallbackEntry"];
jsonrpc__$Protocol_ResponseCallbackEntry.prototype = {
	__class__: jsonrpc__$Protocol_ResponseCallbackEntry
};
var jsonrpc_NoData = { __ename__ : true, __constructs__ : [] };
var jsonrpc_node_MessageReader = function(readable,encoding) {
	if(encoding == null) {
		encoding = "utf-8";
	}
	this.readable = readable;
	this.buffer = new jsonrpc_node__$MessageReader_MessageBuffer(encoding);
};
jsonrpc_node_MessageReader.__name__ = ["jsonrpc","node","MessageReader"];
jsonrpc_node_MessageReader.prototype = {
	listen: function(cb) {
		this.nextMessageLength = -1;
		this.callback = cb;
		this.readable.on("data",$bind(this,this.onData));
	}
	,onData: function(data) {
		this.buffer.append(data);
		while(true) {
			if(this.nextMessageLength == -1) {
				var headers = this.buffer.tryReadHeaders();
				if(headers == null) {
					return;
				}
				var contentLength = __map_reserved["Content-Length"] != null ? headers.getReserved("Content-Length") : headers.h["Content-Length"];
				if(contentLength == null) {
					throw new js__$Boot_HaxeError("Header must provide a Content-Length property.");
				}
				var length = Std.parseInt(contentLength);
				if(length == null) {
					throw new js__$Boot_HaxeError("Content-Length value must be a number.");
				}
				this.nextMessageLength = length;
			}
			var msg = this.buffer.tryReadContent(this.nextMessageLength);
			if(msg == null) {
				return;
			}
			this.nextMessageLength = -1;
			var json = JSON.parse(msg);
			this.callback(json);
		}
	}
	,__class__: jsonrpc_node_MessageReader
};
var jsonrpc_node__$MessageReader_MessageBuffer = function(encoding) {
	if(encoding == null) {
		encoding = "utf-8";
	}
	this.encoding = encoding;
	this.index = 0;
	this.buffer = new js_node_buffer_Buffer(8192);
};
jsonrpc_node__$MessageReader_MessageBuffer.__name__ = ["jsonrpc","node","_MessageReader","MessageBuffer"];
jsonrpc_node__$MessageReader_MessageBuffer.prototype = {
	append: function(chunk) {
		var toAppend;
		if(typeof(chunk) == "string") {
			var str = chunk;
			toAppend = new js_node_buffer_Buffer(str.length);
			toAppend.write(str,0,str.length,this.encoding);
		} else {
			toAppend = chunk;
		}
		if(this.buffer.length - this.index >= toAppend.length) {
			toAppend.copy(this.buffer,this.index,0,toAppend.length);
		} else {
			var newSize = (Math.ceil((this.index + toAppend.length) / 8192) + 1) * 8192;
			if(this.index == 0) {
				this.buffer = new js_node_buffer_Buffer(newSize);
				toAppend.copy(this.buffer,0,0,toAppend.length);
			} else {
				this.buffer = js_node_buffer_Buffer.concat([this.buffer.slice(0,this.index),toAppend],newSize);
			}
		}
		this.index += toAppend.length;
	}
	,tryReadHeaders: function() {
		var current = 0;
		while(current + 3 < this.index && (this.buffer[current] != jsonrpc_node__$MessageReader_MessageBuffer.CR || this.buffer[current + 1] != jsonrpc_node__$MessageReader_MessageBuffer.LF || this.buffer[current + 2] != jsonrpc_node__$MessageReader_MessageBuffer.CR || this.buffer[current + 3] != jsonrpc_node__$MessageReader_MessageBuffer.LF)) ++current;
		if(current + 3 >= this.index) {
			return null;
		}
		var result = new haxe_ds_StringMap();
		var headers = this.buffer.toString("ascii",0,current).split("\r\n");
		var _g = 0;
		while(_g < headers.length) {
			var header = headers[_g];
			++_g;
			var index = header.indexOf(":");
			if(index == -1) {
				throw new js__$Boot_HaxeError("Message header must separate key and value using :");
			}
			var key = HxOverrides.substr(header,0,index);
			var value = StringTools.trim(HxOverrides.substr(header,index + 1,null));
			if(__map_reserved[key] != null) {
				result.setReserved(key,value);
			} else {
				result.h[key] = value;
			}
		}
		var nextStart = current + 4;
		this.buffer = this.buffer.slice(nextStart);
		this.index -= nextStart;
		return result;
	}
	,tryReadContent: function(length) {
		if(this.index < length) {
			return null;
		}
		var result = this.buffer.toString(this.encoding,0,length);
		this.buffer.copy(this.buffer,0,length);
		this.index -= length;
		return result;
	}
	,__class__: jsonrpc_node__$MessageReader_MessageBuffer
};
var jsonrpc_node_MessageWriter = function(writable,encoding) {
	if(encoding == null) {
		encoding = "utf8";
	}
	this.writable = writable;
	this.encoding = encoding;
};
jsonrpc_node_MessageWriter.__name__ = ["jsonrpc","node","MessageWriter"];
jsonrpc_node_MessageWriter.prototype = {
	write: function(msg) {
		var json = JSON.stringify(msg);
		var contentLength = js_node_buffer_Buffer.byteLength(json,this.encoding);
		this.writable.write("Content-Length: ","ascii");
		this.writable.write("" + contentLength,"ascii");
		this.writable.write("\r\n");
		this.writable.write("\r\n");
		this.writable.write(json,this.encoding);
	}
	,__class__: jsonrpc_node_MessageWriter
};
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
String.prototype.__class__ = String;
String.__name__ = ["String"];
Array.__name__ = ["Array"];
var Int = { __name__ : ["Int"]};
var Dynamic = { __name__ : ["Dynamic"]};
var Float = Number;
Float.__name__ = ["Float"];
var Bool = Boolean;
Bool.__ename__ = ["Bool"];
var Class = { __name__ : ["Class"]};
var Enum = { };
var __map_reserved = {}
Xml.Element = 0;
Xml.PCData = 1;
Xml.CData = 2;
Xml.Comment = 3;
Xml.DocType = 4;
Xml.ProcessingInstruction = 5;
Xml.Document = 6;
haxe_xml_Parser.escapes = (function($this) {
	var $r;
	var h = new haxe_ds_StringMap();
	if(__map_reserved["lt"] != null) {
		h.setReserved("lt","<");
	} else {
		h.h["lt"] = "<";
	}
	if(__map_reserved["gt"] != null) {
		h.setReserved("gt",">");
	} else {
		h.h["gt"] = ">";
	}
	if(__map_reserved["amp"] != null) {
		h.setReserved("amp","&");
	} else {
		h.h["amp"] = "&";
	}
	if(__map_reserved["quot"] != null) {
		h.setReserved("quot","\"");
	} else {
		h.h["quot"] = "\"";
	}
	if(__map_reserved["apos"] != null) {
		h.setReserved("apos","'");
	} else {
		h.h["apos"] = "'";
	}
	$r = h;
	return $r;
}(this));
haxeLanguageServer_Context.systemKey = (function($this) {
	var $r;
	var _g = Sys.systemName();
	$r = (function($this) {
		var $r;
		switch(_g) {
		case "Mac":
			$r = "osx";
			break;
		case "Windows":
			$r = "windows";
			break;
		default:
			$r = "linux";
		}
		return $r;
	}($this));
	return $r;
}(this));
haxeLanguageServer_HaxePosition.positionRe = new EReg("^(.+):(\\d+): (?:lines (\\d+)-(\\d+)|character(?:s (\\d+)-| )(\\d+))$","");
haxeLanguageServer_HaxePosition.isWindows = Sys.systemName() == "Windows";
haxeLanguageServer__$HaxeServer_DisplayRequest.stdinSepBuf = new js_node_buffer_Buffer([1]);
haxeLanguageServer_HaxeServer.reVersion = new EReg("^(\\d+)\\.(\\d+)\\.(\\d+)(?:\\s.*)?$","");
haxeLanguageServer_HaxeServer.reTrailingNewline = new EReg("\r?\n$","");
haxeLanguageServer_Uri.driveLetterPathRe = new EReg("^/[a-zA-Z]:","");
haxeLanguageServer_Uri.upperCaseDriveRe = new EReg("^(/)?([A-Z]:)","");
haxeLanguageServer_Uri.uriRe = new EReg("^(([^:/?#]+?):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?","");
haxeLanguageServer_features_CompletionFeature.reFieldPart = new EReg("(\\.|@(:?))(\\w*)$","");
haxeLanguageServer_features_CompletionFeature.reStructPart = new EReg("[(,]\\s*{(\\s*(\\s*\\w+\\s*:\\s*[\"'\\w()\\.]+\\s*,\\s*)*\\w*)$","");
haxeLanguageServer_helper_PathHelper.reUpperCaseDriveLetter = new EReg("^([A-Z]:)","");
haxeLanguageServer_helper_TypeHelper.groupRegex = new EReg("\\$(\\d+)","g");
haxeLanguageServer_helper_TypeHelper.parenRegex = new EReg("^\\((.*)\\)$","");
haxeLanguageServer_helper_TypeHelper.argNameRegex = new EReg("^(\\??\\w+) : ","");
haxeLanguageServer_helper_TypeHelper.monomorphRegex = new EReg("^Unknown<\\d+>$","");
haxeLanguageServer_helper_TypeHelper.nullRegex = new EReg("^Null<(\\$\\d+)>$","");
js_Boot.__toStr = ({ }).toString;
jsonrpc_node__$MessageReader_MessageBuffer.CR = new js_node_buffer_Buffer("\r","ascii")[0];
jsonrpc_node__$MessageReader_MessageBuffer.LF = new js_node_buffer_Buffer("\n","ascii")[0];
haxeLanguageServer_Main.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);

//# sourceMappingURL=server.js.map