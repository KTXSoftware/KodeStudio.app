// Generated by Haxe 3.3.0
(function ($hx_exports) { "use strict";
var HxOverrides = function() { };
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
var LanguageClient = require("vscode-languageclient").LanguageClient;
var Main = function(ctx) {
	this.context = ctx;
	this.context.subscriptions.push(Vscode.commands.registerCommand("haxe.restartLanguageServer",$bind(this,this.restartLanguageServer)));
	this.context.subscriptions.push(Vscode.commands.registerCommand("haxe.initProject",$bind(this,this.initProject)));
	this.context.subscriptions.push(Vscode.commands.registerCommand("haxe.applyFixes",$bind(this,this.applyFixes)));
	this.startLanguageServer();
};
Main.findKha = function() {
	var config = Vscode.workspace.getConfiguration("kha");
	var khapath = config.khaPath;
	if(khapath.length > 0) {
		return khapath;
	}
	return js_node_Path.join(Vscode.extensions.getExtension("ktx.kha").extensionPath,"Kha");
};
Main.main = $hx_exports["activate"] = function(context) {
	new Main(context);
};
Main.prototype = {
	applyFixes: function(uri,version,edits) {
		var editor = Vscode.window.activeTextEditor;
		if(editor == null || editor.document.uri.toString() != uri) {
			return;
		}
		editor.edit(function(mutator) {
			var _g = 0;
			while(_g < edits.length) {
				var edit = edits[_g];
				++_g;
				mutator.replace(new Range(edit.range.start.line,edit.range.start.character,edit.range.end.line,edit.range.end.character),edit.newText);
			}
		});
	}
	,startLanguageServer: function() {
		var serverModule = this.context.asAbsolutePath("./server_wrapper.js");
		var client = new LanguageClient("Haxe",{ run : { module : serverModule}, debug : { module : serverModule, options : { execArgv : ["--nolazy","--debug=6004"]}}},{ documentSelector : "haxe", synchronize : { configurationSection : "haxe"}, initializationOptions : { kha : Main.findKha()}});
		client.onReady().then(function(_) {
			Vscode.window.setStatusBarMessage("Haxe language server started",2000);
		});
		this.serverDisposable = client.start();
		this.context.subscriptions.push(this.serverDisposable);
	}
	,restartLanguageServer: function() {
		if(this.serverDisposable != null) {
			HxOverrides.remove(this.context.subscriptions,this.serverDisposable);
			this.serverDisposable.dispose();
		}
		this.startLanguageServer();
	}
	,initProject: function() {
		var workspaceRoot = Vscode.workspace.rootPath;
		if(workspaceRoot == null) {
			Vscode.window.showErrorMessage("Please open a folder to set up a Haxe project into");
			return;
		}
		if(js_node_Fs.readdirSync(workspaceRoot).length == 0) {
			this.scaffoldEmpty(workspaceRoot);
			return;
		}
		var vscodeDir = workspaceRoot + "/.vscode";
		if(sys_FileSystem.exists(vscodeDir)) {
			this.showConfigureHint();
			return;
		}
		var hxmls = this.findHxmls(workspaceRoot);
		if(hxmls.length > 0) {
			this.createWorkspaceConfiguration(vscodeDir,hxmls);
			return;
		}
		Vscode.window.showErrorMessage("Workspace must be empty to set up a Haxe project");
	}
	,scaffoldEmpty: function(root) {
		this.copyRec(this.context.asAbsolutePath("./scaffold"),root);
		Vscode.window.setStatusBarMessage("Haxe project scaffolded",2000);
	}
	,createWorkspaceConfiguration: function(vscodeDir,hxmls) {
		var _gthis = this;
		Vscode.window.showQuickPick(hxmls,{ placeHolder : "Choose HXML file to use"}).then(function(s) {
			if(s == null) {
				return;
			}
			var path = s.description;
			var file = s.label;
			var hxmlPath = path.length == 0?file:path + "/" + file;
			_gthis.copyRec(_gthis.context.asAbsolutePath("./scaffold/.vscode"),vscodeDir);
			var path1 = vscodeDir + "/" + "tasks.json";
			js_node_Fs.writeFileSync(path1,StringTools.replace(js_node_Fs.readFileSync(path1,{ encoding : "utf8"}),"\"build.hxml\"","\"" + hxmlPath + "\""));
			var path2 = vscodeDir + "/" + "settings.json";
			js_node_Fs.writeFileSync(path2,StringTools.replace(js_node_Fs.readFileSync(path2,{ encoding : "utf8"}),"\"build.hxml\"","\"" + hxmlPath + "\""));
			Vscode.workspace.openTextDocument(vscodeDir + "/settings.json").then(function(doc) {
				Vscode.window.showTextDocument(doc);
				Vscode.window.showInformationMessage("Please check if " + hxmlPath + " is suitable for completion and modify haxe.displayArguments if needed.");
			});
		});
	}
	,findHxmls: function(root) {
		var hxmls = [];
		var loop = null;
		loop = function(path) {
			var fullPath = root + "/" + path;
			if(js_node_Fs.statSync(fullPath).isDirectory()) {
				var _g = 0;
				var _g1 = js_node_Fs.readdirSync(fullPath);
				while(_g < _g1.length) {
					var file = _g1[_g];
					++_g;
					if(StringTools.endsWith(file,".hxml")) {
						hxmls.push({ label : file, description : path});
					} else {
						loop(path.length == 0?file:path + "/" + file);
					}
				}
			}
		};
		loop("");
		return hxmls;
	}
	,showConfigureHint: function() {
		var channel = Vscode.window.createOutputChannel("Haxe scaffold");
		var content = js_node_Fs.readFileSync(this.context.asAbsolutePath("./configureHint.txt"),{ encoding : "utf8"});
		content = StringTools.replace(content,"{{tasks}}",js_node_Fs.readFileSync(this.context.asAbsolutePath("./scaffold/.vscode/tasks.json"),{ encoding : "utf8"}));
		channel.clear();
		channel.append(content);
		channel.show();
	}
	,copyRec: function(from,to) {
		var loop = null;
		loop = function(src,dst) {
			var fromPath = from + src;
			var toPath = to + dst;
			if(js_node_Fs.statSync(fromPath).isDirectory()) {
				sys_FileSystem.createDirectory(toPath);
				var _g = 0;
				var _g1 = js_node_Fs.readdirSync(fromPath);
				while(_g < _g1.length) {
					var file = _g1[_g];
					++_g;
					loop(src + "/" + file,dst + "/" + file);
				}
			} else {
				sys_io_File.copy(fromPath,toPath);
			}
		};
		loop("","");
	}
};
var StringTools = function() { };
StringTools.endsWith = function(s,end) {
	var elen = end.length;
	var slen = s.length;
	if(slen >= elen) {
		return HxOverrides.substr(s,slen - elen,elen) == end;
	} else {
		return false;
	}
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var Vscode = require("vscode");
var Range = require("vscode").Range;
var haxe_io_Bytes = function() { };
var js_node_Fs = require("fs");
var js_node_Path = require("path");
var js_node_buffer_Buffer = require("buffer").Buffer;
var sys_FileSystem = function() { };
sys_FileSystem.exists = function(path) {
	try {
		js_node_Fs.accessSync(path);
		return true;
	} catch( _ ) {
		return false;
	}
};
sys_FileSystem.createDirectory = function(path) {
	try {
		js_node_Fs.mkdirSync(path);
	} catch( e ) {
		if(e.code == "ENOENT") {
			sys_FileSystem.createDirectory(js_node_Path.dirname(path));
			js_node_Fs.mkdirSync(path);
		} else {
			var stat;
			try {
				stat = js_node_Fs.statSync(path);
			} catch( _ ) {
				throw e;
			}
			if(!stat.isDirectory()) {
				throw e;
			}
		}
	}
};
var sys_io_File = function() { };
sys_io_File.copy = function(srcPath,dstPath) {
	var src = js_node_Fs.openSync(srcPath,"r");
	var dst = js_node_Fs.openSync(dstPath,"w",js_node_Fs.fstatSync(src).mode);
	var bytesRead;
	var pos = 0;
	while(true) {
		bytesRead = js_node_Fs.readSync(src,sys_io_File.copyBuf,0,65536,pos);
		if(!(bytesRead > 0)) {
			break;
		}
		js_node_Fs.writeSync(dst,sys_io_File.copyBuf,0,bytesRead);
		pos += bytesRead;
	}
	js_node_Fs.closeSync(src);
	js_node_Fs.closeSync(dst);
};
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
sys_io_File.copyBuf = new js_node_buffer_Buffer(65536);
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this);

//# sourceMappingURL=client.js.map