// Generated by Haxe 4.0.0-preview.4+eec79c1e5
(function ($hx_exports) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = true;
EReg.prototype = {
	split: function(s) {
		return s.replace(this.r,"#__delim__#").split("#__delim__#");
	}
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.strDate = function(s) {
	switch(s.length) {
	case 8:
		var k = s.split(":");
		var d = new Date();
		d["setTime"](0);
		d["setUTCHours"](k[0]);
		d["setUTCMinutes"](k[1]);
		d["setUTCSeconds"](k[2]);
		return d;
	case 10:
		var k1 = s.split("-");
		return new Date(k1[0],k1[1] - 1,k1[2],0,0,0);
	case 19:
		var k2 = s.split(" ");
		var y = k2[0].split("-");
		var t = k2[1].split(":");
		return new Date(y[0],y[1] - 1,y[2],t[0],t[1],t[2]);
	default:
		throw new js__$Boot_HaxeError("Invalid date format : " + s);
	}
};
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var Lambda = function() { };
Lambda.__name__ = true;
Lambda.exists = function(it,f) {
	var x = $getIterator(it);
	while(x.hasNext()) if(f(x.next())) {
		return true;
	}
	return false;
};
Lambda.find = function(it,f) {
	var v = $getIterator(it);
	while(v.hasNext()) {
		var v1 = v.next();
		if(f(v1)) {
			return v1;
		}
	}
	return null;
};
Math.__name__ = true;
var Reflect = function() { };
Reflect.__name__ = true;
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( e ) {
		return null;
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.compare = function(a,b) {
	if(a == b) {
		return 0;
	} else if(a > b) {
		return 1;
	} else {
		return -1;
	}
};
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return HxOverrides.substr(s,0,start.length) == start;
	} else {
		return false;
	}
};
StringTools.endsWith = function(s,end) {
	var elen = end.length;
	var slen = s.length;
	if(slen >= elen) {
		return HxOverrides.substr(s,slen - elen,elen) == end;
	} else {
		return false;
	}
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var Sys = function() { };
Sys.__name__ = true;
Sys.systemName = function() {
	var _g = process.platform;
	switch(_g) {
	case "darwin":
		return "Mac";
	case "freebsd":
		return "BSD";
	case "linux":
		return "Linux";
	case "win32":
		return "Windows";
	default:
		return _g;
	}
};
var Vscode = require("vscode");
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
var haxe_Timer = function(time_ms) {
	var me = this;
	this.id = setInterval(function() {
		me.run();
	},time_ms);
};
haxe_Timer.__name__ = true;
haxe_Timer.delay = function(f,time_ms) {
	var t = new haxe_Timer(time_ms);
	t.run = function() {
		t.stop();
		f();
	};
	return t;
};
haxe_Timer.prototype = {
	stop: function() {
		if(this.id == null) {
			return;
		}
		clearInterval(this.id);
		this.id = null;
	}
	,run: function() {
	}
};
var haxe_ds_ArraySort = function() { };
haxe_ds_ArraySort.__name__ = true;
haxe_ds_ArraySort.sort = function(a,cmp) {
	haxe_ds_ArraySort.rec(a,cmp,0,a.length);
};
haxe_ds_ArraySort.rec = function(a,cmp,from,to) {
	var middle = from + to >> 1;
	if(to - from < 12) {
		if(to <= from) {
			return;
		}
		var _g = from + 1;
		while(_g < to) {
			var j = _g++;
			while(j > from) {
				if(cmp(a[j],a[j - 1]) < 0) {
					haxe_ds_ArraySort.swap(a,j - 1,j);
				} else {
					break;
				}
				--j;
			}
		}
		return;
	}
	haxe_ds_ArraySort.rec(a,cmp,from,middle);
	haxe_ds_ArraySort.rec(a,cmp,middle,to);
	haxe_ds_ArraySort.doMerge(a,cmp,from,middle,to,middle - from,to - middle);
};
haxe_ds_ArraySort.doMerge = function(a,cmp,from,pivot,to,len1,len2) {
	var first_cut;
	var second_cut;
	var len11;
	var len22;
	if(len1 == 0 || len2 == 0) {
		return;
	}
	if(len1 + len2 == 2) {
		if(cmp(a[pivot],a[from]) < 0) {
			haxe_ds_ArraySort.swap(a,pivot,from);
		}
		return;
	}
	if(len1 > len2) {
		len11 = len1 >> 1;
		first_cut = from + len11;
		second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut);
		len22 = second_cut - pivot;
	} else {
		len22 = len2 >> 1;
		second_cut = pivot + len22;
		first_cut = haxe_ds_ArraySort.upper(a,cmp,from,pivot,second_cut);
		len11 = first_cut - from;
	}
	haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut);
	var new_mid = first_cut + len22;
	haxe_ds_ArraySort.doMerge(a,cmp,from,first_cut,new_mid,len11,len22);
	haxe_ds_ArraySort.doMerge(a,cmp,new_mid,second_cut,to,len1 - len11,len2 - len22);
};
haxe_ds_ArraySort.rotate = function(a,cmp,from,mid,to) {
	if(from == mid || mid == to) {
		return;
	}
	var n = haxe_ds_ArraySort.gcd(to - from,mid - from);
	while(n-- != 0) {
		var val = a[from + n];
		var shift = mid - from;
		var p1 = from + n;
		var p2 = from + n + shift;
		while(p2 != from + n) {
			a[p1] = a[p2];
			p1 = p2;
			if(to - p2 > shift) {
				p2 += shift;
			} else {
				p2 = from + (shift - (to - p2));
			}
		}
		a[p1] = val;
	}
};
haxe_ds_ArraySort.gcd = function(m,n) {
	while(n != 0) {
		var t = m % n;
		m = n;
		n = t;
	}
	return m;
};
haxe_ds_ArraySort.upper = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[val],a[mid]) < 0) {
			len = half;
		} else {
			from = mid + 1;
			len = len - half - 1;
		}
	}
	return from;
};
haxe_ds_ArraySort.lower = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[mid],a[val]) < 0) {
			from = mid + 1;
			len = len - half - 1;
		} else {
			len = half;
		}
	}
	return from;
};
haxe_ds_ArraySort.swap = function(a,i,j) {
	var tmp = a[i];
	a[i] = a[j];
	a[j] = tmp;
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = true;
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	remove: function(key) {
		if(!this.h.hasOwnProperty(key)) {
			return false;
		}
		delete(this.h[key]);
		return true;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) {
			a.push(key | 0);
		}
		return HxOverrides.iter(a);
	}
	,iterator: function() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			var i = this.it.next();
			return this.ref[i];
		}};
	}
};
var haxe_ds_StringMap = function() {
	this.h = { };
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	,existsReserved: function(key) {
		if(this.rh == null) {
			return false;
		}
		return this.rh.hasOwnProperty("$" + key);
	}
	,remove: function(key) {
		if(__map_reserved[key] != null) {
			key = "$" + key;
			if(this.rh == null || !this.rh.hasOwnProperty(key)) {
				return false;
			}
			delete(this.rh[key]);
			return true;
		} else {
			if(!this.h.hasOwnProperty(key)) {
				return false;
			}
			delete(this.h[key]);
			return true;
		}
	}
	,keys: function() {
		return HxOverrides.iter(this.arrayKeys());
	}
	,arrayKeys: function() {
		var out = [];
		for( var key in this.h ) {
		if(this.h.hasOwnProperty(key)) {
			out.push(key);
		}
		}
		if(this.rh != null) {
			for( var key in this.rh ) {
			if(key.charCodeAt(0) == 36) {
				out.push(key.substr(1));
			}
			}
		}
		return out;
	}
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.alloc = function(length) {
	return new haxe_io_Bytes(new ArrayBuffer(length));
};
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i1 = 0;
	while(i1 < s.length) {
		var c1 = s.charCodeAt(i1++);
		if(55296 <= c1 && c1 <= 56319) {
			c1 = c1 - 55232 << 10 | s.charCodeAt(i1++) & 1023;
		}
		if(c1 <= 127) {
			a.push(c1);
		} else if(c1 <= 2047) {
			a.push(192 | c1 >> 6);
			a.push(128 | c1 & 63);
		} else if(c1 <= 65535) {
			a.push(224 | c1 >> 12);
			a.push(128 | c1 >> 6 & 63);
			a.push(128 | c1 & 63);
		} else {
			a.push(240 | c1 >> 18);
			a.push(128 | c1 >> 12 & 63);
			a.push(128 | c1 >> 6 & 63);
			a.push(128 | c1 & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.ofData = function(b) {
	var hb = b.hxBytes;
	if(hb != null) {
		return hb;
	}
	return new haxe_io_Bytes(b);
};
haxe_io_Bytes.ofHex = function(s) {
	if((s.length & 1) != 0) {
		throw new js__$Boot_HaxeError("Not a hex string (odd number of digits)");
	}
	var a = [];
	var i = 0;
	var len = s.length >> 1;
	while(i < len) {
		var high = s.charCodeAt(i * 2);
		var low = s.charCodeAt(i * 2 + 1);
		high = (high & 15) + ((high & 64) >> 6) * 9;
		low = (low & 15) + ((low & 64) >> 6) * 9;
		a.push((high << 4 | low) & 255);
		++i;
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.fastGet = function(b,pos) {
	return b.bytes[pos];
};
var haxe_io_Encoding = { __ename__ : true, __constructs__ : ["UTF8","RawNative"] };
haxe_io_Encoding.UTF8 = ["UTF8",0];
haxe_io_Encoding.UTF8.toString = $estr;
haxe_io_Encoding.UTF8.__enum__ = haxe_io_Encoding;
haxe_io_Encoding.RawNative = ["RawNative",1];
haxe_io_Encoding.RawNative.toString = $estr;
haxe_io_Encoding.RawNative.__enum__ = haxe_io_Encoding;
var haxe_io_Path = function(path) {
	switch(path) {
	case ".":case "..":
		this.dir = path;
		this.file = "";
		return;
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		this.dir = HxOverrides.substr(path,0,c2);
		path = HxOverrides.substr(path,c2 + 1,null);
		this.backslash = true;
	} else if(c2 < c1) {
		this.dir = HxOverrides.substr(path,0,c1);
		path = HxOverrides.substr(path,c1 + 1,null);
	} else {
		this.dir = null;
	}
	var cp = path.lastIndexOf(".");
	if(cp != -1) {
		this.ext = HxOverrides.substr(path,cp + 1,null);
		this.file = HxOverrides.substr(path,0,cp);
	} else {
		this.ext = null;
		this.file = path;
	}
};
haxe_io_Path.__name__ = true;
haxe_io_Path.directory = function(path) {
	var s = new haxe_io_Path(path);
	if(s.dir == null) {
		return "";
	}
	return s.dir;
};
haxe_io_Path.extension = function(path) {
	var s = new haxe_io_Path(path);
	if(s.ext == null) {
		return "";
	}
	return s.ext;
};
haxe_io_Path.join = function(paths) {
	var paths1 = paths.filter(function(s) {
		if(s != null) {
			return s != "";
		} else {
			return false;
		}
	});
	if(paths1.length == 0) {
		return "";
	}
	var path = paths1[0];
	var _g = 1;
	var _g1 = paths1.length;
	while(_g < _g1) {
		path = haxe_io_Path.addTrailingSlash(path);
		path += paths1[_g++];
	}
	return haxe_io_Path.normalize(path);
};
haxe_io_Path.normalize = function(path) {
	path = path.split("\\").join("/");
	if(path == "/") {
		return "/";
	}
	var target = [];
	var _g = 0;
	var _g1 = path.split("/");
	while(_g < _g1.length) {
		var token = _g1[_g];
		++_g;
		if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
			target.pop();
		} else if(token != ".") {
			target.push(token);
		}
	}
	var tmp = target.join("/");
	var acc_b = "";
	var colon = false;
	var slashes = false;
	var _g2 = 0;
	var _g3 = tmp.length;
	while(_g2 < _g3) {
		var _g21 = tmp.charCodeAt(_g2++);
		switch(_g21) {
		case 47:
			if(!colon) {
				slashes = true;
			} else {
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(_g21);
			}
			break;
		case 58:
			acc_b += ":";
			colon = true;
			break;
		default:
			colon = false;
			if(slashes) {
				acc_b += "/";
				slashes = false;
			}
			acc_b += String.fromCodePoint(_g21);
		}
	}
	return acc_b;
};
haxe_io_Path.addTrailingSlash = function(path) {
	if(path.length == 0) {
		return "/";
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		if(c2 != path.length - 1) {
			return path + "\\";
		} else {
			return path;
		}
	} else if(c1 != path.length - 1) {
		return path + "/";
	} else {
		return path;
	}
};
haxe_io_Path.isAbsolute = function(path) {
	if(StringTools.startsWith(path,"/")) {
		return true;
	}
	if(path.charAt(1) == ":") {
		return true;
	}
	if(StringTools.startsWith(path,"\\\\")) {
		return true;
	}
	return false;
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if((o instanceof Array)) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g = 2;
				var _g1 = o.length;
				while(_g < _g1) {
					var i = _g++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g2 = 0;
			var _g11 = l;
			while(_g2 < _g11) {
				var i2 = _g2++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			var e1 = (e instanceof js__$Boot_HaxeError) ? e.val : e;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var js_node_ChildProcess = require("child_process");
var js_node_Fs = require("fs");
var js_node_Path = require("path");
var js_node_buffer_Buffer = require("buffer").Buffer;
var jsonrpc__$CancellationToken_CancellationTokenImpl = function() { };
jsonrpc__$CancellationToken_CancellationTokenImpl.__name__ = true;
var sys_FileSystem = function() { };
sys_FileSystem.__name__ = true;
sys_FileSystem.exists = function(path) {
	try {
		js_node_Fs.accessSync(path);
		return true;
	} catch( _ ) {
		return false;
	}
};
sys_FileSystem.isDirectory = function(path) {
	try {
		return js_node_Fs.statSync(path).isDirectory();
	} catch( e ) {
		return false;
	}
};
sys_FileSystem.createDirectory = function(path) {
	try {
		js_node_Fs.mkdirSync(path);
	} catch( e ) {
		var e1 = (e instanceof js__$Boot_HaxeError) ? e.val : e;
		if(e1.code == "ENOENT") {
			sys_FileSystem.createDirectory(js_node_Path.dirname(path));
			js_node_Fs.mkdirSync(path);
		} else {
			var stat;
			try {
				stat = js_node_Fs.statSync(path);
			} catch( _ ) {
				throw e1;
			}
			if(!stat.isDirectory()) {
				throw e1;
			}
		}
	}
};
var sys_io_File = function() { };
sys_io_File.__name__ = true;
sys_io_File.copy = function(srcPath,dstPath) {
	var src = js_node_Fs.openSync(srcPath,"r");
	var dst = js_node_Fs.openSync(dstPath,"w",js_node_Fs.fstatSync(src).mode);
	var bytesRead;
	var pos = 0;
	while(true) {
		bytesRead = js_node_Fs.readSync(src,sys_io_File.copyBuf,0,65536,pos);
		if(!(bytesRead > 0)) {
			break;
		}
		js_node_Fs.writeSync(dst,sys_io_File.copyBuf,0,bytesRead);
		pos += bytesRead;
	}
	js_node_Fs.closeSync(src);
	js_node_Fs.closeSync(dst);
};
var vscode__$DiagnosticTag_DiagnosticTag_$Impl_$ = require("vscode").DiagnosticTag;
var vscode_Disposable = require("vscode").Disposable;
var vscode_EventEmitter = require("vscode").EventEmitter;
var vscode_Location = require("vscode").Location;
var vscode_Position = require("vscode").Position;
var vscode_ProcessExecution = require("vscode").ProcessExecution;
var vscode__$ProgressLocation_ProgressLocation_$Impl_$ = require("vscode").ProgressLocation;
var vscode_Range = require("vscode").Range;
var vscode_RelativePattern = require("vscode").RelativePattern;
var vscode__$StatusBarAlignment_StatusBarAlignment_$Impl_$ = require("vscode").StatusBarAlignment;
var vscode_Task = require("vscode").Task;
var vscode_TaskGroup = require("vscode").TaskGroup;
var vscode__$TaskPanelKind_TaskPanelKind_$Impl_$ = require("vscode").TaskPanelKind;
var vscode__$TaskRevealKind_TaskRevealKind_$Impl_$ = require("vscode").TaskRevealKind;
var vscode_ThemeColor = require("vscode").ThemeColor;
var vscode_TreeItem = require("vscode").TreeItem;
var vscode__$TreeItemCollapsibleState_TreeItemCollapsibleState_$Impl_$ = require("vscode").TreeItemCollapsibleState;
var vscode_Uri = require("vscode").Uri;
var vscode__$ViewColumn_ViewColumn_$Impl_$ = require("vscode").ViewColumn;
var vshaxe__$HaxeMemento_HaxeMementoKey_$Impl_$ = {};
vshaxe__$HaxeMemento_HaxeMementoKey_$Impl_$.__name__ = true;
vshaxe__$HaxeMemento_HaxeMementoKey_$Impl_$._new = function(key) {
	return "haxe." + key;
};
var vshaxe_HxmlDiscovery = function(folder,mementos) {
	var _gthis = this;
	this.folder = folder;
	this.mementos = mementos;
	this.didChangeFilesEmitter = new vscode_EventEmitter();
	this.files = mementos.get(folder,"haxe.hxmlDiscoveryFiles",[]);
	var pattern = new vscode_RelativePattern(folder,"*.hxml");
	Vscode.workspace.findFiles(pattern).then(function(files) {
		var foundFiles = files != null ? files.map(function(uri) {
			return vshaxe_helper_PathHelper.relativize(uri.fsPath,_gthis.folder.uri.fsPath);
		}) : [];
		if(!vshaxe_helper_ArrayHelper.equals(_gthis.files,foundFiles)) {
			_gthis.files = foundFiles;
			_gthis.mementos.set(_gthis.folder,"haxe.hxmlDiscoveryFiles",_gthis.files);
			_gthis.didChangeFilesEmitter.fire();
		}
		return;
	});
	this.fileWatcher = Vscode.workspace.createFileSystemWatcher(pattern,false,true,false);
	this.fileWatcher.onDidCreate(function(uri1) {
		_gthis.files.push(vshaxe_helper_PathHelper.relativize(uri1.fsPath,_gthis.folder.uri.fsPath));
		_gthis.mementos.set(_gthis.folder,"haxe.hxmlDiscoveryFiles",_gthis.files);
		_gthis.didChangeFilesEmitter.fire();
		return;
	});
	this.fileWatcher.onDidDelete(function(uri2) {
		HxOverrides.remove(_gthis.files,vshaxe_helper_PathHelper.relativize(uri2.fsPath,_gthis.folder.uri.fsPath));
		_gthis.mementos.set(_gthis.folder,"haxe.hxmlDiscoveryFiles",_gthis.files);
		_gthis.didChangeFilesEmitter.fire();
		return;
	});
};
vshaxe_HxmlDiscovery.__name__ = true;
vshaxe_HxmlDiscovery.prototype = {
	dispose: function() {
		this.fileWatcher.dispose();
		this.didChangeFilesEmitter.dispose();
	}
};
var vshaxe_Main = function(context) {
	new vshaxe_commands_InitProject(context);
	var wsFolder = Vscode.workspace.workspaceFolders == null ? null : Vscode.workspace.workspaceFolders[0];
	if(wsFolder == null) {
		return;
	}
	Vscode.commands.executeCommand("setContext","vshaxeActivated",true);
	var wsMementos = new vshaxe_WorkspaceMementos(context.workspaceState);
	var hxmlDiscovery = new vshaxe_HxmlDiscovery(wsFolder,wsMementos);
	context.subscriptions.push(hxmlDiscovery);
	var displayArguments = new vshaxe_display_DisplayArguments(wsFolder,wsMementos);
	context.subscriptions.push(displayArguments);
	var haxeExecutable = new vshaxe_helper_HaxeExecutable(wsFolder);
	context.subscriptions.push(haxeExecutable);
	var problemMatchers = ["$haxe-absolute","$haxe","$haxe-error","$haxe-trace"];
	this.api = { haxeExecutable : haxeExecutable, enableCompilationServer : true, problemMatchers : problemMatchers.slice(), taskPresentation : { }, registerDisplayArgumentsProvider : $bind(displayArguments,displayArguments.registerProvider), parseHxmlToArguments : vshaxe_helper_HxmlParser.parseToArgs};
	var server = new vshaxe_server_LanguageServer(wsFolder,context,haxeExecutable,displayArguments,this.api);
	context.subscriptions.push(server);
	new vshaxe_helper_HaxeCodeLensProvider();
	new vshaxe_view_dependencies_DependencyTreeView(context,displayArguments,haxeExecutable);
	new vshaxe_view_methods_MethodTreeView(context,server);
	new vshaxe_display_DisplayArgumentsSelector(context,displayArguments);
	var haxeDisplayArgumentsProvider = new vshaxe_display_HaxeDisplayArgumentsProvider(context,displayArguments,hxmlDiscovery);
	new vshaxe_commands_Commands(context,server,haxeDisplayArgumentsProvider);
	var taskConfiguration = new vshaxe_tasks_TaskConfiguration(haxeExecutable,problemMatchers,server,this.api);
	new vshaxe_tasks_HxmlTaskProvider(taskConfiguration,hxmlDiscovery);
	new vshaxe_tasks_HaxeTaskProvider(taskConfiguration,displayArguments,haxeDisplayArgumentsProvider);
	if(displayArguments["arguments"] == null) {
		var serverStarted = false;
		var disposable = displayArguments._onDidChangeArguments.event(function($arguments) {
			disposable.dispose();
			server.start();
			serverStarted = true;
			return serverStarted;
		});
		haxe_Timer.delay(function() {
			if(!serverStarted) {
				disposable.dispose();
				server.start();
			}
			return;
		},5000);
	} else {
		server.start();
	}
};
vshaxe_Main.__name__ = true;
vshaxe_Main.main = $hx_exports["activate"] = function(context) {
	return new vshaxe_Main(context).api;
};
var vshaxe_WorkspaceMementos = function(storage) {
	this.storage = storage;
	this.maybeMigrate();
};
vshaxe_WorkspaceMementos.__name__ = true;
vshaxe_WorkspaceMementos.prototype = {
	get: function(folder,key,defaultValue) {
		var collection = this.storage.get(key);
		if(collection == null) {
			return defaultValue;
		}
		var value = collection[folder.uri.toString()];
		if(value != null) {
			return value;
		} else {
			return defaultValue;
		}
	}
	,set: function(folder,key,value) {
		var collection = this.storage.get(key);
		if(collection == null) {
			collection = { };
		}
		collection[folder.uri.toString()] = value;
		return this.storage.update(key,collection);
	}
	,maybeMigrate: function() {
		var _gthis = this;
		if(this.storage.get("haxe.mementoVersion") == null) {
			_gthis.storage.update("haxe.displayArgumentsProviderName",undefined);
			_gthis.storage.update(vshaxe_display_HaxeDisplayArgumentsProvider.ConfigurationIndexKey,undefined);
			_gthis.storage.update("haxe.hxmlDiscoveryFiles",undefined);
			this.storage.update("haxe.mementoVersion",1);
		}
	}
};
var vshaxe_commands_Commands = function(context,server,haxeDisplayArgumentsProvider) {
	this.context = context;
	this.server = server;
	this.haxeDisplayArgumentsProvider = haxeDisplayArgumentsProvider;
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "restartLanguageServer",$bind(server,server.restart));
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "showReferences",$bind(this,this.showReferences));
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "runGlobalDiagnostics",$bind(server,server.runGlobalDiagnostics));
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "toggleCodeLens",$bind(this,this.toggleCodeLens));
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "debugSelectedConfiguration",$bind(this,this.debugSelectedConfiguration));
};
vshaxe_commands_Commands.__name__ = true;
vshaxe_commands_Commands.prototype = {
	showReferences: function(uri,position,locations) {
		var locations1 = locations.map(function(location) {
			var locations2 = vscode_Uri.parse(location.uri);
			var position1 = location.range.start;
			var locations3 = new vscode_Position(position1.line,position1.character);
			var position2 = location.range.end;
			return new vscode_Location(locations2,new vscode_Range(locations3,new vscode_Position(position2.line,position2.character)));
		});
		Vscode.commands.executeCommand("editor.action.showReferences",vscode_Uri.parse(uri),new vscode_Position(position.line,position.character),locations1).then(function(s) {
			console.log("src/vshaxe/commands/Commands.hx:34:",s);
		},function(s1) {
			console.log("src/vshaxe/commands/Commands.hx:34:","err: " + s1);
		});
	}
	,toggleCodeLens: function() {
		var config = Vscode.workspace.getConfiguration("haxe");
		var info = config.inspect("enableCodeLens");
		config.update("enableCodeLens",!this.getCurrentConfigValue(info,config),info.workspaceValue == null);
	}
	,debugSelectedConfiguration: function() {
		if(this.haxeDisplayArgumentsProvider.provideArguments == null) {
			Vscode.window.showErrorMessage("The built-in completion provider is not active, so there is no configuration to be debugged.");
			return;
		}
		var label = this.haxeDisplayArgumentsProvider.getCurrentLabel();
		if(label == null) {
			Vscode.window.showErrorMessage("There is no configuration selected.");
			return;
		}
		var error = function() {
			Vscode.window.showErrorMessage("There is no launch configuration named '" + label + "'.");
		};
		var folder = Vscode.workspace.workspaceFolders[0];
		var launchConfigs = Vscode.workspace.getConfiguration("launch",folder.uri);
		var configurations = launchConfigs.get("configurations");
		var compounds = launchConfigs.get("compounds");
		var allConfigs = [];
		if(configurations != null) {
			allConfigs = allConfigs.concat(configurations);
		}
		if(compounds != null) {
			allConfigs = allConfigs.concat(compounds);
		}
		if(Lambda.exists(allConfigs,function(config) {
			return config.name == label;
		})) {
			Vscode.debug.startDebugging(folder,label);
		} else {
			error();
		}
	}
	,getCurrentConfigValue: function(info,config) {
		var value = info.workspaceValue;
		if(value == null) {
			value = info.globalValue;
		}
		if(value == null) {
			value = info.defaultValue;
		}
		return value;
	}
};
var vshaxe_commands_InitProject = function(context) {
	this.context = context;
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "initProject",$bind(this,this.initProject));
};
vshaxe_commands_InitProject.__name__ = true;
vshaxe_commands_InitProject.prototype = {
	initProject: function() {
		var _gthis = this;
		var _g = Vscode.workspace.workspaceFolders;
		if(_g == null) {
			Vscode.window.showOpenDialog({ canSelectFolders : true, canSelectFiles : false}).then(function(folders) {
				if(folders != null && folders.length > 0) {
					_gthis.setupFolder(folders[0].fsPath);
					Vscode.commands.executeCommand("vscode.openFolder",folders[0]);
				}
				return;
			});
		} else {
			switch(_g.length) {
			case 0:
				Vscode.window.showOpenDialog({ canSelectFolders : true, canSelectFiles : false}).then(function(folders1) {
					if(folders1 != null && folders1.length > 0) {
						_gthis.setupFolder(folders1[0].fsPath);
						Vscode.commands.executeCommand("vscode.openFolder",folders1[0]);
					}
					return;
				});
				break;
			case 1:
				this.setupFolder(_g[0].uri.fsPath);
				break;
			default:
				Vscode.window.showWorkspaceFolderPick({ placeHolder : "Select a folder to set up a Haxe project into..."}).then(function(folder) {
					if(folder == null) {
						return;
					}
					_gthis.setupFolder(folder.uri.fsPath);
				});
			}
		}
	}
	,setupFolder: function(fsPath) {
		if(Lambda.exists(js_node_Fs.readdirSync(fsPath),function(f) {
			return !StringTools.startsWith(f,".");
		})) {
			Vscode.window.showErrorMessage("To set up sample Haxe project, the folder must be empty");
			return;
		}
		this.copyRec(this.context.asAbsolutePath("./scaffold/project"),fsPath);
		Vscode.window.setStatusBarMessage("Haxe project scaffolded",2000);
	}
	,copyRec: function(from,to) {
		var loop = null;
		loop = function(src,dst) {
			var fromPath = from + src;
			var toPath = to + dst;
			if(sys_FileSystem.isDirectory(fromPath)) {
				sys_FileSystem.createDirectory(toPath);
				var _g = 0;
				var _g1 = js_node_Fs.readdirSync(fromPath);
				while(_g < _g1.length) {
					var file = _g1[_g];
					++_g;
					loop(src + "/" + file,dst + "/" + file);
				}
			} else {
				sys_io_File.copy(fromPath,toPath);
			}
		};
		loop("","");
	}
};
var vshaxe_display_DisplayArguments = function(folder,mementos) {
	this._onDidChangeCurrentProvider = new vscode_EventEmitter();
	this._onDidChangeArguments = new vscode_EventEmitter();
	this.providers = new haxe_ds_StringMap();
	this.folder = folder;
	this.mementos = mementos;
};
vshaxe_display_DisplayArguments.__name__ = true;
vshaxe_display_DisplayArguments.prototype = {
	dispose: function() {
		this._onDidChangeArguments.dispose();
		this._onDidChangeCurrentProvider.dispose();
	}
	,registerProvider: function(name,provider) {
		var _gthis = this;
		var _this = this.providers;
		if(__map_reserved[name] != null ? _this.existsReserved(name) : _this.h.hasOwnProperty(name)) {
			throw new Error("Display arguments provider `" + name + "` is already registered.");
		}
		var _this1 = this.providers;
		if(__map_reserved[name] != null) {
			_this1.setReserved(name,provider);
		} else {
			_this1.h[name] = provider;
		}
		var savedProvider = this.mementos.get(this.folder,"haxe.displayArgumentsProviderName");
		if(this.currentProvider == null || savedProvider == null || savedProvider == name) {
			this.setCurrentProvider(name,false);
		}
		return new vscode_Disposable(function() {
			_gthis.providers.remove(name);
			if(name == _gthis.currentProvider) {
				_gthis.setCurrentProvider(null,false);
			}
		});
	}
	,setCurrentProvider: function(name,persist) {
		if(this.currentProvider != null) {
			var key = this.currentProvider;
			var _this = this.providers;
			var provider = __map_reserved[key] != null ? _this.getReserved(key) : _this.h[key];
			if(provider != null) {
				provider.deactivate();
			}
		}
		this.currentProvider = name;
		Vscode.commands.executeCommand("setContext","haxeCompletionProvider",name);
		if(name != null) {
			var _this1 = this.providers;
			var provider1 = __map_reserved[name] != null ? _this1.getReserved(name) : _this1.h[name];
			if(provider1 != null) {
				provider1.activate($bind(this,this.provideArguments));
			}
		}
		if(persist) {
			this.mementos.set(this.folder,"haxe.displayArgumentsProviderName",name);
		}
		this._onDidChangeCurrentProvider.fire(this.currentProvider);
	}
	,provideArguments: function(newArguments) {
		if(!vshaxe_helper_ArrayHelper.equals(newArguments,this["arguments"])) {
			this["arguments"] = newArguments;
			this._onDidChangeArguments.fire(newArguments);
		}
	}
};
var vshaxe_display_DisplayArgumentsSelector = function(context,displayArguments) {
	var _gthis = this;
	this.displayArguments = displayArguments;
	this.statusBarItem = Vscode.window.createStatusBarItem(vscode__$StatusBarAlignment_StatusBarAlignment_$Impl_$.Left,11);
	this.statusBarItem.tooltip = "Select Haxe Completion Provider";
	this.statusBarItem.command = "haxe." + "selectDisplayArgumentsProvider";
	context.subscriptions.push(this.statusBarItem);
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "selectDisplayArgumentsProvider",$bind(this,this.selectProvider));
	displayArguments._onDidChangeCurrentProvider.event(function(_) {
		_gthis.updateStatusBarItem();
		return;
	});
	this.updateStatusBarItem();
};
vshaxe_display_DisplayArgumentsSelector.__name__ = true;
vshaxe_display_DisplayArgumentsSelector.prototype = {
	selectProvider: function() {
		var _gthis = this;
		var _g = [];
		var name = this.displayArguments.providers.keys();
		while(name.hasNext()) {
			var name1 = name.next();
			var _this = this.displayArguments.providers;
			_g.push({ label : name1, description : (__map_reserved[name1] != null ? _this.getReserved(name1) : _this.h[name1]).description});
		}
		if(_g.length == 0) {
			Vscode.window.showErrorMessage("No Haxe completion providers registered.");
			return;
		}
		vshaxe_helper_ArrayHelper.moveToStart(_g,function(item) {
			return item.label == _gthis.displayArguments.currentProvider;
		});
		Vscode.window.showQuickPick(_g,{ placeHolder : "Select Haxe Completion Provider"}).then(function(item1) {
			if(item1 != null) {
				_gthis.displayArguments.setCurrentProvider(item1.label,true);
			}
			return;
		});
	}
	,updateStatusBarItem: function() {
		if(this.displayArguments.currentProvider == null) {
			this.statusBarItem.hide();
			return;
		}
		var label = this.displayArguments.currentProvider;
		var color = null;
		var name = this.displayArguments.currentProvider;
		var _this = this.displayArguments.providers;
		if(!(__map_reserved[name] != null ? _this.existsReserved(name) : _this.h.hasOwnProperty(name))) {
			label += " (not available)";
			color = vshaxe_display_DisplayArgumentsSelector.statusBarWarningThemeColor;
		}
		this.statusBarItem.color = color;
		this.statusBarItem.text = "$(gear) " + label;
		this.statusBarItem.show();
	}
};
var vshaxe_display_HaxeDisplayArgumentsProvider = function(context,displayArguments,hxmlDiscovery) {
	this.description = "Project using haxe.displayConfigurations or HXML files (built-in)";
	var _gthis = this;
	this.context = context;
	this.displayArguments = displayArguments;
	this.hxmlDiscovery = hxmlDiscovery;
	this.statusBarItem = Vscode.window.createStatusBarItem(vscode__$StatusBarAlignment_StatusBarAlignment_$Impl_$.Left,10);
	this.statusBarItem.tooltip = "Select Haxe Configuration";
	this.statusBarItem.command = "haxe." + "selectDisplayConfiguration";
	context.subscriptions.push(this.statusBarItem);
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "selectDisplayConfiguration",$bind(this,this.selectConfiguration));
	context.subscriptions.push(Vscode.workspace.onDidChangeConfiguration(function(_) {
		_gthis.refresh();
		return;
	}));
	hxmlDiscovery.didChangeFilesEmitter.event(function(_1) {
		_gthis.refresh();
		return;
	});
	this.refresh();
};
vshaxe_display_HaxeDisplayArgumentsProvider.__name__ = true;
vshaxe_display_HaxeDisplayArgumentsProvider.prototype = {
	updateConfigurations: function() {
		var configs = Vscode.workspace.getConfiguration("haxe").get("displayConfigurations");
		if(configs == null) {
			configs = [];
		}
		this.configurations = [];
		var _g = 0;
		var _g1 = configs.length;
		while(_g < _g1) {
			var i = _g++;
			var config = configs[i];
			var args = null;
			var label = null;
			if((config instanceof Array) && config.__enum__ == null) {
				args = config;
			} else {
				var config1 = config;
				args = config1.args;
				label = config1.label;
			}
			this.configurations.push({ kind : vshaxe_display__$HaxeDisplayArgumentsProvider_ConfigurationKind.Configured(i,label), args : args});
		}
		var _g2 = 0;
		var _g3 = this.hxmlDiscovery.files;
		while(_g2 < _g3.length) {
			var hxmlFile = _g3[_g2];
			++_g2;
			var hxmlConfig = [[hxmlFile]];
			if(!Lambda.exists(configs,(function(hxmlConfig1) {
				return function(config2) {
					return vshaxe_helper_ArrayHelper.equals(config2,hxmlConfig1[0]);
				};
			})(hxmlConfig))) {
				this.configurations.push({ kind : vshaxe_display__$HaxeDisplayArgumentsProvider_ConfigurationKind.Discovered(hxmlFile), args : hxmlConfig[0]});
			}
		}
	}
	,activate: function(provideArguments) {
		this.provideArguments = provideArguments;
		var config = this.getCurrent();
		this.updateStatusBarItem(config);
		if(this.provideArguments != null) {
			this.provideArguments(config == null ? [] : config.args);
		}
	}
	,deactivate: function() {
		this.provideArguments = null;
		this.updateStatusBarItem(null);
	}
	,selectConfiguration: function() {
		var _gthis = this;
		if(this.configurations.length == 0) {
			Vscode.window.showErrorMessage("No Haxe configurations are available. Please provide the haxe.displayConfigurations setting.",{ title : "Edit settings"}).then(function(button) {
				if(button == null) {
					return;
				}
				Vscode.workspace.getConfiguration("haxe").update("displayConfigurations",[],false).then(function(_) {
					Vscode.workspace.openTextDocument(Vscode.workspace.workspaceFolders[0].uri.fsPath + "/.vscode/settings.json").then(function(document) {
						return Vscode.window.showTextDocument(document);
					});
					return;
				});
			});
			return;
		}
		var items = [];
		var _g = 0;
		var _g1 = this.configurations;
		while(_g < _g1.length) {
			var configuration = _g1[_g];
			++_g;
			var description = configuration.kind[1] == 1;
			items.push({ label : this.getConfigurationLabel(configuration), description : description ? "auto-discovered" : "from settings.json", config : configuration});
		}
		var current = this.getCurrent();
		if(current != null) {
			vshaxe_helper_ArrayHelper.moveToStart(items,function(item) {
				return item.config == current;
			});
		}
		Vscode.window.showQuickPick(items,{ matchOnDescription : true, placeHolder : "Select Haxe Configuration"}).then(function(choice) {
			if(choice == null || choice.config == current) {
				return;
			}
			_gthis.setCurrent(choice.config);
		});
	}
	,getCurrentLabel: function() {
		var current = this.getCurrent();
		if(current == null) {
			return null;
		}
		return this.getConfigurationLabel(current);
	}
	,getConfigurationLabel: function(configuration) {
		var _g = configuration.kind;
		switch(_g[1]) {
		case 0:
			var label = _g[3];
			if(label != null) {
				return label;
			} else {
				return configuration.args.join(" ");
			}
			break;
		case 1:
			return _g[2];
		}
	}
	,getCurrent: function() {
		var selection = this.context.workspaceState.get(vshaxe_display_HaxeDisplayArgumentsProvider.ConfigurationIndexKey,0);
		var _g = 0;
		var _g1 = this.configurations;
		while(_g < _g1.length) {
			var conf = _g1[_g];
			++_g;
			var _g2 = conf.kind;
			switch(_g2[1]) {
			case 0:
				if(_g2[2] == selection) {
					return conf;
				}
				break;
			case 1:
				if(_g2[2] == selection) {
					return conf;
				}
				break;
			default:
			}
		}
		return null;
	}
	,setCurrent: function(config) {
		var this1 = this.context.workspaceState;
		var value;
		var _g = config.kind;
		switch(_g[1]) {
		case 0:
			value = _g[2];
			break;
		case 1:
			value = _g[2];
			break;
		}
		this1.update(vshaxe_display_HaxeDisplayArgumentsProvider.ConfigurationIndexKey,value);
		this.updateStatusBarItem(config);
		if(this.provideArguments != null) {
			this.provideArguments(config == null ? [] : config.args);
		}
	}
	,refresh: function() {
		this.updateConfigurations();
		this.updateDisplayArgumentsProviderRegistration();
		var config = this.getCurrent();
		if(config == null && this.configurations.length > 0) {
			config = this.configurations[0];
			this.setCurrent(config);
		} else {
			this.updateStatusBarItem(config);
			if(this.provideArguments != null) {
				this.provideArguments(config == null ? [] : config.args);
			}
		}
	}
	,updateDisplayArgumentsProviderRegistration: function() {
		var isActive = this.configurations.length > 0;
		if(isActive && this.providerDisposable == null) {
			this.providerDisposable = this.displayArguments.registerProvider("Haxe",this);
		} else if(!isActive && this.providerDisposable != null) {
			this.providerDisposable.dispose();
			this.providerDisposable = null;
		}
	}
	,updateStatusBarItem: function(config) {
		if(this.provideArguments != null && config != null) {
			var _g = config.kind;
			var label = _g[1] == 0 ? _g[3] : null;
			if(label == null) {
				label = config.args.join(" ");
				if(label.length > 50) {
					label = StringTools.rtrim(HxOverrides.substr(label,0,47)) + "...";
				}
			}
			this.statusBarItem.text = label;
			this.statusBarItem.show();
			return;
		}
		this.statusBarItem.hide();
	}
};
var vshaxe_display__$HaxeDisplayArgumentsProvider_ConfigurationKind = { __ename__ : true, __constructs__ : ["Configured","Discovered"] };
vshaxe_display__$HaxeDisplayArgumentsProvider_ConfigurationKind.Configured = function(index,label) { var $x = ["Configured",0,index,label]; $x.__enum__ = vshaxe_display__$HaxeDisplayArgumentsProvider_ConfigurationKind; $x.toString = $estr; return $x; }
vshaxe_display__$HaxeDisplayArgumentsProvider_ConfigurationKind.Discovered = function(id) { var $x = ["Discovered",1,id]; $x.__enum__ = vshaxe_display__$HaxeDisplayArgumentsProvider_ConfigurationKind; $x.toString = $estr; return $x; }
var vshaxe_helper_ArrayHelper = function() { };
vshaxe_helper_ArrayHelper.__name__ = true;
vshaxe_helper_ArrayHelper.equals = function(a1,a2) {
	if(a1 == null && a2 == null) {
		return true;
	}
	if(a1 == null && a2 != null) {
		return false;
	}
	if(a1 != null && a2 == null) {
		return false;
	}
	if(a1.length != a2.length) {
		return false;
	}
	var _g = 0;
	var _g1 = a1.length;
	while(_g < _g1) {
		var i = _g++;
		if(a1[i] != a2[i]) {
			return false;
		}
	}
	return true;
};
vshaxe_helper_ArrayHelper.moveToStart = function(array,f) {
	var element = Lambda.find(array,f);
	if(element != null) {
		HxOverrides.remove(array,element);
		array.unshift(element);
	}
};
var vshaxe_helper_ContextHelper = function() { };
vshaxe_helper_ContextHelper.__name__ = true;
vshaxe_helper_ContextHelper.registerHaxeCommand = function(context,command,callback) {
	context.subscriptions.push(Vscode.commands.registerCommand(command,callback));
};
var vshaxe_helper_CopyPaste = require("copy-paste");
var vshaxe_helper_HaxeCodeLensProvider = function() {
	this._onDidChangeCodeLenses = new vscode_EventEmitter();
	this.onDidChangeCodeLenses = this._onDidChangeCodeLenses.event;
	this.enableCodeLens = this.getEnableCodeLens();
	Vscode.languages.registerCodeLensProvider("haxe",this);
	Vscode.workspace.onDidChangeConfiguration($bind(this,this.onDidChangeConfiguration));
};
vshaxe_helper_HaxeCodeLensProvider.__name__ = true;
vshaxe_helper_HaxeCodeLensProvider.prototype = {
	getEnableCodeLens: function() {
		return Vscode.workspace.getConfiguration("haxe").get("enableCodeLens");
	}
	,onDidChangeConfiguration: function(_) {
		var enableCodeLens = this.getEnableCodeLens();
		if(enableCodeLens != this.enableCodeLens) {
			this._onDidChangeCodeLenses.fire();
			this.enableCodeLens = enableCodeLens;
		}
	}
	,provideCodeLenses: function(document,token) {
		return [];
	}
	,resolveCodeLens: function(codeLens,token) {
		return codeLens;
	}
};
var vshaxe_helper_HaxeExecutable = function(folder) {
	this.folder = folder;
	this._onDidChangeConfiguration = new vscode_EventEmitter();
	this.updateConfig();
	this.changeConfigurationListener = Vscode.workspace.onDidChangeConfiguration($bind(this,this.onWorkspaceConfigurationChanged));
};
vshaxe_helper_HaxeExecutable.__name__ = true;
vshaxe_helper_HaxeExecutable.isSame = function(oldConfig,newConfig) {
	if(typeof(oldConfig) == "string" || typeof(newConfig) == "string") {
		if(oldConfig != newConfig) {
			return false;
		}
	}
	if(oldConfig.path != newConfig.path) {
		return false;
	}
	var oldKeys = Reflect.fields(oldConfig.env);
	var newKeys = Reflect.fields(newConfig.env);
	if(oldKeys.length != newKeys.length) {
		return false;
	}
	var _g = 0;
	while(_g < newKeys.length) {
		var key = newKeys[_g];
		++_g;
		if(oldConfig.env[key] != newConfig.env[key]) {
			return false;
		}
		HxOverrides.remove(oldKeys,key);
	}
	if(oldKeys.length > 0) {
		return false;
	}
	return true;
};
vshaxe_helper_HaxeExecutable.prototype = {
	get_onDidChangeConfiguration: function() {
		return this._onDidChangeConfiguration.event;
	}
	,dispose: function() {
		this.changeConfigurationListener.dispose();
	}
	,isConfigured: function() {
		var executableSetting = Vscode.workspace.getConfiguration("haxe",this.folder.uri).inspect("executable");
		if(!(executableSetting.globalValue != null || executableSetting.workspaceValue != null)) {
			return executableSetting.workspaceFolderValue != null;
		} else {
			return true;
		}
	}
	,onWorkspaceConfigurationChanged: function(change) {
		if(change.affectsConfiguration("haxe.executable",this.folder.uri)) {
			var oldConfig = this.rawConfig;
			this.updateConfig();
			if(!vshaxe_helper_HaxeExecutable.isSame(oldConfig,this.rawConfig)) {
				this._onDidChangeConfiguration.fire(this.configuration);
			}
		}
	}
	,updateConfig: function() {
		var input = Vscode.workspace.getConfiguration("haxe",this.folder.uri).get("executable");
		var executable = "haxe";
		var env = { };
		var merge = function(conf) {
			if(typeof(conf) == "string") {
				executable = conf;
			} else {
				var conf1 = conf;
				if(conf1.path != null) {
					executable = conf1.path;
				}
				if(conf1.env != null) {
					env = conf1.env;
				}
			}
		};
		if(input != null) {
			merge(input);
			var systemConfig = Reflect.field(input,vshaxe_helper_HaxeExecutable.SYSTEM_KEY);
			if(systemConfig != null) {
				merge(systemConfig);
			}
		}
		var isCommand = false;
		if(!haxe_io_Path.isAbsolute(executable)) {
			var absolutePath = vshaxe_helper_PathHelper.absolutize(executable,this.folder.uri.fsPath);
			if(sys_FileSystem.exists(absolutePath) && !sys_FileSystem.isDirectory(absolutePath)) {
				executable = absolutePath;
			} else {
				isCommand = true;
			}
		}
		this.rawConfig = input;
		this.configuration = { executable : executable, isCommand : isCommand, env : env};
	}
};
var vshaxe_helper_HxmlLine = { __ename__ : true, __constructs__ : ["Comment","Simple","Param"] };
vshaxe_helper_HxmlLine.Comment = function(comment) { var $x = ["Comment",0,comment]; $x.__enum__ = vshaxe_helper_HxmlLine; $x.toString = $estr; return $x; }
vshaxe_helper_HxmlLine.Simple = function(name) { var $x = ["Simple",1,name]; $x.__enum__ = vshaxe_helper_HxmlLine; $x.toString = $estr; return $x; }
vshaxe_helper_HxmlLine.Param = function(name,value) { var $x = ["Param",2,name,value]; $x.__enum__ = vshaxe_helper_HxmlLine; $x.toString = $estr; return $x; }
var vshaxe_helper_HxmlParser = function() { };
vshaxe_helper_HxmlParser.__name__ = true;
vshaxe_helper_HxmlParser.unquote = function(s) {
	var len = s.length;
	if(len > 0 && s.charCodeAt(0) == 34 && s.charCodeAt(len - 1) == 34) {
		return s.substring(1,len - 1);
	} else {
		return s;
	}
};
vshaxe_helper_HxmlParser.parseFile = function(src) {
	var result = [];
	var srcLines = new EReg("[\n\r]+","g").split(src);
	var _g = 0;
	while(_g < srcLines.length) {
		var line = srcLines[_g];
		++_g;
		line = vshaxe_helper_HxmlParser.unquote(StringTools.trim(line));
		if(line.length == 0) {
			continue;
		}
		if(StringTools.startsWith(line,"#")) {
			result.push(vshaxe_helper_HxmlLine.Comment(StringTools.ltrim(HxOverrides.substr(line,1,null))));
		} else if(StringTools.startsWith(line,"-")) {
			var idx = line.indexOf(" ");
			if(idx == -1) {
				result.push(vshaxe_helper_HxmlLine.Simple(line));
			} else {
				result.push(vshaxe_helper_HxmlLine.Param(HxOverrides.substr(line,0,idx),vshaxe_helper_HxmlParser.unquote(StringTools.ltrim(HxOverrides.substr(line,idx,null)))));
			}
		} else {
			result.push(vshaxe_helper_HxmlLine.Simple(line));
		}
	}
	return result;
};
vshaxe_helper_HxmlParser.parseToArgs = function(src) {
	var result = [];
	var _g = 0;
	var _g1 = vshaxe_helper_HxmlParser.parseFile(src);
	while(_g < _g1.length) {
		var line = _g1[_g];
		++_g;
		switch(line[1]) {
		case 0:
			break;
		case 1:
			result.push(line[2]);
			break;
		case 2:
			result.push(line[2]);
			result.push(line[3]);
			break;
		}
	}
	return result;
};
vshaxe_helper_HxmlParser.parseArray = function(args) {
	var result = [];
	var flag = null;
	var _g = 0;
	while(_g < args.length) {
		var arg = args[_g];
		++_g;
		if(StringTools.startsWith(arg,"-")) {
			if(flag != null) {
				result.push(vshaxe_helper_HxmlLine.Simple(flag));
				flag = null;
			}
			flag = arg;
		} else if(flag != null) {
			result.push(vshaxe_helper_HxmlLine.Param(flag,arg));
			flag = null;
		} else {
			result.push(vshaxe_helper_HxmlLine.Simple(arg));
		}
	}
	if(flag != null) {
		result.push(vshaxe_helper_HxmlLine.Simple(flag));
	}
	return result;
};
var vshaxe_helper_PathHelper = function() { };
vshaxe_helper_PathHelper.__name__ = true;
vshaxe_helper_PathHelper.absolutize = function(path,cwd) {
	return haxe_io_Path.normalize(haxe_io_Path.isAbsolute(path) ? path : haxe_io_Path.join([cwd,path]));
};
vshaxe_helper_PathHelper.relativize = function(path,cwd) {
	path = haxe_io_Path.normalize(path);
	cwd = haxe_io_Path.normalize(cwd) + "/";
	var segments = path.split(cwd);
	segments.shift();
	return segments.join(cwd);
};
vshaxe_helper_PathHelper.containsFile = function(directory,file) {
	directory = haxe_io_Path.normalize(directory) + "/";
	var fileDirectory = haxe_io_Path.normalize(haxe_io_Path.directory(file)) + "/";
	if(Sys.systemName() == "Windows") {
		directory = directory.toLowerCase();
		fileDirectory = fileDirectory.toLowerCase();
	}
	return StringTools.startsWith(fileDirectory,directory);
};
vshaxe_helper_PathHelper.areEqual = function(path1,path2) {
	if(Sys.systemName() == "Windows") {
		path1 = path1.toLowerCase();
		path2 = path2.toLowerCase();
	}
	return haxe_io_Path.normalize(path1) == haxe_io_Path.normalize(path2);
};
vshaxe_helper_PathHelper.capitalizeDriveLetter = function(path) {
	if(Sys.systemName() == "Windows" && haxe_io_Path.isAbsolute(path)) {
		path = path.charAt(0).toUpperCase() + HxOverrides.substr(path,1,null);
	}
	return path;
};
var vshaxe_server_LanguageClient = require("vscode-languageclient").LanguageClient;
var vshaxe_server_LanguageServer = function(folder,context,haxeExecutable,displayArguments,api) {
	this._onDidChangeRequestQueue = new vscode_EventEmitter();
	this._onDidRunHaxeMethod = new vscode_EventEmitter();
	this.progresses = new haxe_ds_IntMap();
	var _gthis = this;
	this.folder = folder;
	this.displayArguments = displayArguments;
	this.haxeExecutable = haxeExecutable;
	this.api = api;
	this.serverModulePath = context.asAbsolutePath("./server_wrapper.js");
	this.hxFileWatcher = Vscode.workspace.createFileSystemWatcher(new vscode_RelativePattern(folder,"**/*.hx"),false,true,false);
	this.prepareDisplayServerConfig();
	this.disposables = [this.hxFileWatcher,Vscode.workspace.onDidChangeConfiguration(function(_) {
		_gthis.refreshDisplayServerConfig();
		return;
	}),(haxeExecutable.get_onDidChangeConfiguration())(function(_1) {
		_gthis.refreshDisplayServerConfig();
		return;
	}),Vscode.window.onDidChangeActiveTextEditor($bind(this,this.onDidChangeActiveTextEditor))];
	this.restartDisposables = [];
};
vshaxe_server_LanguageServer.__name__ = true;
vshaxe_server_LanguageServer.prototype = {
	dispose: function() {
		var _g = 0;
		var _g1 = this.restartDisposables;
		while(_g < _g1.length) _g1[_g++].dispose();
		var _g2 = 0;
		var _g3 = this.disposables;
		while(_g2 < _g3.length) _g3[_g2++].dispose();
	}
	,refreshDisplayServerConfig: function() {
		if(this.prepareDisplayServerConfig() && this.client != null) {
			this.client.sendNotification("haxe/didChangeDisplayServerConfig",this.displayServerConfig);
		}
	}
	,onDidChangeActiveTextEditor: function(editor) {
		if(editor != null && editor.document.languageId == "haxe") {
			this.client.sendNotification("haxe/didChangeActiveTextEditor",{ uri : editor.document.uri.toString()});
		}
	}
	,start: function() {
		var _gthis = this;
		var clientOptions = { documentSelector : "haxe", synchronize : { configurationSection : "haxe", fileEvents : this.hxFileWatcher}, initializationOptions : { displayArguments : this.displayArguments["arguments"], displayServerConfig : this.displayServerConfig, sendMethodResults : true}, revealOutputChannelOn : 4, workspaceFolder : this.folder, middleware : { handleDiagnostics : function(uri,diagnostics,next) {
			var _g = 0;
			while(_g < diagnostics.length) {
				var diagnostic = diagnostics[_g];
				++_g;
				if(diagnostic.message.indexOf("has no effect") != -1 || diagnostic.message == "Unused import/using" || diagnostic.message == "Unused variable") {
					diagnostic.tags = [vscode__$DiagnosticTag_DiagnosticTag_$Impl_$.Unnecessary];
				}
			}
			next(uri,diagnostics);
			return;
		}}};
		this.client = new vshaxe_server_LanguageClient("haxe","Haxe",{ run : { module : this.serverModulePath, options : { env : process.env}}, debug : { module : this.serverModulePath, options : { env : process.env, execArgv : ["--nolazy","--inspect=6004"]}}},clientOptions);
		var argumentsChanged = false;
		var argumentChangeListenerDisposable = this.displayArguments._onDidChangeArguments.event(function(_) {
			argumentsChanged = true;
			return argumentsChanged;
		});
		this.restartDisposables.push(argumentChangeListenerDisposable);
		this.client.onReady().then(function(_1) {
			_gthis.client.outputChannel.appendLine("Haxe language server started");
			HxOverrides.remove(_gthis.restartDisposables,argumentChangeListenerDisposable);
			argumentChangeListenerDisposable.dispose();
			if(argumentsChanged) {
				_gthis.client.sendNotification("haxe/didChangeDisplayArguments",{ 'arguments' : _gthis.displayArguments["arguments"]});
			}
			_gthis.restartDisposables.push(_gthis.displayArguments._onDidChangeArguments.event(function($arguments) {
				_gthis.client.sendNotification("haxe/didChangeDisplayArguments",{ 'arguments' : $arguments});
				return;
			}));
			_gthis.restartDisposables.push(new vshaxe_server_PackageInserter(_gthis.hxFileWatcher,_gthis.client));
			_gthis.client.onNotification("haxe/progressStart",$bind(_gthis,_gthis.onStartProgress));
			_gthis.client.onNotification("haxe/progressStop",$bind(_gthis,_gthis.onStopProgress));
			_gthis.client.onNotification("haxe/didChangeDisplayPort",$bind(_gthis,_gthis.onDidChangeDisplayPort));
			_gthis.client.onNotification("haxe/didRunGlobalDiagnostics",$bind(_gthis,_gthis.onDidRunGlobalDiangostics));
			_gthis.client.onNotification("haxe/didRunHaxeMethod",$bind(_gthis,_gthis.onDidRunHaxeMethodCallback));
			_gthis.client.onNotification("haxe/didChangeRequestQueue",$bind(_gthis,_gthis.onDidChangeRequestQueueCallback));
			_gthis.client.onNotification("haxe/cacheBuildFailed",$bind(_gthis,_gthis.onCacheBuildFailed));
			_gthis.client.onDidChangeState($bind(_gthis,_gthis.onDidChangeState));
		});
		this.restartDisposables.push(this.client.start());
	}
	,prepareDisplayServerConfig: function() {
		var path = this.haxeExecutable.configuration.executable;
		var env = this.haxeExecutable.configuration.env;
		var haxeConfig = Vscode.workspace.getConfiguration("haxe");
		var $arguments = haxeConfig.get("displayServer.arguments",[]);
		var print = haxeConfig.get("displayServer.print",{ completion : false, reusing : false});
		if(!this.haxeExecutable.isConfigured()) {
			var displayServerConfig = haxeConfig.get("displayServer");
			var merge = function(conf) {
				if(conf.haxePath != null) {
					path = conf.haxePath;
				}
				if(conf.env != null) {
					env = conf.env;
				}
			};
			if(displayServerConfig != null) {
				merge(displayServerConfig);
				var systemConfig = Reflect.field(displayServerConfig,vshaxe_helper_HaxeExecutable.SYSTEM_KEY);
				if(systemConfig != null) {
					merge(systemConfig);
				}
			}
		}
		this.displayServerConfig = { path : path, env : env, 'arguments' : $arguments, print : print};
		var oldSerialized = this.displayServerConfigSerialized;
		this.displayServerConfigSerialized = JSON.stringify(this.displayServerConfig);
		return this.displayServerConfigSerialized != oldSerialized;
	}
	,onStartProgress: function(data) {
		var _gthis = this;
		Vscode.window.withProgress({ location : vscode__$ProgressLocation_ProgressLocation_$Impl_$.Window, title : data.title},function(_,_1) {
			return new Promise(function(resolve,_2) {
				var v = function() {
					resolve(null);
				};
				_gthis.progresses.h[data.id] = v;
			});
		});
	}
	,onStopProgress: function(data) {
		var stop = this.progresses.h[data.id];
		if(stop != null) {
			this.progresses.remove(data.id);
			stop();
		}
	}
	,onDidChangeDisplayPort: function(data) {
		this.displayPort = data.port;
		this.api.displayPort = data.port;
	}
	,restart: function() {
		if(this.client != null && this.client.outputChannel != null) {
			this.client.outputChannel.dispose();
		}
		var _g = 0;
		var _g1 = this.restartDisposables;
		while(_g < _g1.length) _g1[_g++].dispose();
		this.restartDisposables = [];
		this.stopAllProgresses();
		this.start();
	}
	,stopAllProgresses: function() {
		var stop = this.progresses.iterator();
		while(stop.hasNext()) (stop.next())();
		this.progresses = new haxe_ds_IntMap();
	}
	,runGlobalDiagnostics: function() {
		this.client.sendNotification("haxe/runGlobalDiagnostics");
	}
	,onDidRunGlobalDiangostics: function(_) {
		Vscode.commands.executeCommand("workbench.action.problems.focus");
	}
	,onDidRunHaxeMethodCallback: function(data) {
		this._onDidRunHaxeMethod.fire(data);
	}
	,onDidChangeRequestQueueCallback: function(data) {
		this._onDidChangeRequestQueue.fire(data.queue);
	}
	,onCacheBuildFailed: function(_) {
		var _gthis = this;
		Vscode.window.showWarningMessage("Unable to build cache - completion features may be slower than expected. Try fixing the error(s) and restarting the language server.","Show Error").then(function(selection) {
			if(selection == "Show Error") {
				_gthis.client.outputChannel.show();
			}
			return;
		});
	}
	,onDidChangeState: function(event) {
		if(event.newState == 1) {
			this.stopAllProgresses();
		}
	}
};
var vshaxe_server_PackageInserter = function(watcher,client) {
	var _gthis = this;
	this.client = client;
	this.createEvent = watcher.onDidCreate(function(uri) {
		var editor = Vscode.window.activeTextEditor;
		if(editor == null || editor.document.uri.fsPath != uri.fsPath) {
			_gthis.lastCreatedFile = uri;
		} else {
			_gthis.insertPackageStatement(editor);
		}
	});
	this.openEvent = Vscode.window.onDidChangeActiveTextEditor(function(editor1) {
		if(editor1 != null && _gthis.lastCreatedFile != null && editor1.document.uri.fsPath == _gthis.lastCreatedFile.fsPath) {
			_gthis.insertPackageStatement(editor1);
		}
	});
};
vshaxe_server_PackageInserter.__name__ = true;
vshaxe_server_PackageInserter.prototype = {
	insertPackageStatement: function(editor) {
		this.lastCreatedFile = null;
		if(editor.document.getText(new vscode_Range(0,0,0,1)).length > 0) {
			return;
		}
		this.client.sendRequest("haxe/determinePackage",{ fsPath : editor.document.uri.fsPath}).then(function(result) {
			if(result.pack == "") {
				return;
			}
			editor.edit(function(edit) {
				edit.insert(new vscode_Position(0,0),"package " + result.pack + ";\n\n");
			});
		});
	}
	,dispose: function() {
		this.createEvent.dispose();
		this.openEvent.dispose();
	}
};
var vshaxe_tasks_HaxeTaskProvider = function(taskConfiguration,displayArguments,haxeDisplayArgumentsProvider) {
	this.taskConfiguration = taskConfiguration;
	this.displayArguments = displayArguments;
	this.haxeDisplayArgumentsProvider = haxeDisplayArgumentsProvider;
	Vscode.tasks.registerTaskProvider("haxe",this);
};
vshaxe_tasks_HaxeTaskProvider.__name__ = true;
vshaxe_tasks_HaxeTaskProvider.prototype = {
	provideTasks: function(token) {
		if(this.haxeDisplayArgumentsProvider.configurations.length == 0) {
			return [];
		}
		return [this.taskConfiguration.createTask({ type : "haxe", args : "active configuration"},"active configuration",this.displayArguments["arguments"])];
	}
	,resolveTask: function(task,token) {
		return task;
	}
};
var vshaxe_tasks_HxmlTaskProvider = function(taskConfiguration,hxmlDiscovery) {
	this.taskConfiguration = taskConfiguration;
	this.hxmlDiscovery = hxmlDiscovery;
	Vscode.tasks.registerTaskProvider("hxml",this);
};
vshaxe_tasks_HxmlTaskProvider.__name__ = true;
vshaxe_tasks_HxmlTaskProvider.prototype = {
	provideTasks: function(token) {
		var _g = [];
		var _g1 = 0;
		var _g2 = this.hxmlDiscovery.files;
		while(_g1 < _g2.length) {
			var file = _g2[_g1];
			++_g1;
			_g.push(this.taskConfiguration.createTask({ type : "hxml", file : file},file,[file]));
		}
		return _g;
	}
	,resolveTask: function(task,token) {
		return task;
	}
};
var vshaxe_tasks_TaskConfiguration = function(haxeExecutable,problemMatchers,server,api) {
	var _gthis = this;
	this.haxeExecutable = haxeExecutable;
	this.problemMatchers = problemMatchers;
	this.server = server;
	this.api = api;
	Vscode.workspace.onDidChangeConfiguration(function(_) {
		_gthis.update();
		return;
	});
	this.update();
};
vshaxe_tasks_TaskConfiguration.__name__ = true;
vshaxe_tasks_TaskConfiguration.prototype = {
	update: function() {
		this.enableCompilationServer = Vscode.workspace.getConfiguration("haxe").get("enableCompilationServer");
		var presentation = Vscode.workspace.getConfiguration("haxe").get("taskPresentation");
		var tmp;
		switch(presentation.reveal) {
		case "always":
			tmp = vscode__$TaskRevealKind_TaskRevealKind_$Impl_$.Always;
			break;
		case "never":
			tmp = vscode__$TaskRevealKind_TaskRevealKind_$Impl_$.Never;
			break;
		case "silent":
			tmp = vscode__$TaskRevealKind_TaskRevealKind_$Impl_$.Silent;
			break;
		default:
			tmp = vscode__$TaskRevealKind_TaskRevealKind_$Impl_$.Always;
		}
		var tmp1;
		switch(presentation.panel) {
		case "dedicated":
			tmp1 = vscode__$TaskPanelKind_TaskPanelKind_$Impl_$.Dedicated;
			break;
		case "new":
			tmp1 = vscode__$TaskPanelKind_TaskPanelKind_$Impl_$.New;
			break;
		case "shared":
			tmp1 = vscode__$TaskPanelKind_TaskPanelKind_$Impl_$.Shared;
			break;
		default:
			tmp1 = vscode__$TaskPanelKind_TaskPanelKind_$Impl_$.Shared;
		}
		this.taskPresentation = { echo : presentation.echo, reveal : tmp, focus : presentation.focus, panel : tmp1, showReuseMessage : presentation.showReuseMessage};
		var writeableApi = this.api;
		writeableApi.enableCompilationServer = this.enableCompilationServer;
		writeableApi.taskPresentation = this.taskPresentation;
	}
	,createTask: function(definition,name,args) {
		var exectuable = this.haxeExecutable.configuration.executable;
		if(this.server.displayPort != null && this.enableCompilationServer) {
			args = ["--connect",Std.string(this.server.displayPort)].concat(args);
		}
		var task = new vscode_Task(definition,name,"haxe",new vscode_ProcessExecution(exectuable,args,{ env : this.haxeExecutable.configuration.env}),this.problemMatchers);
		task.group = vscode_TaskGroup.Build;
		task.presentationOptions = this.taskPresentation;
		return task;
	}
};
var vshaxe_view_TreeItemHelper = function() { };
vshaxe_view_TreeItemHelper.__name__ = true;
vshaxe_view_TreeItemHelper.collapse = function(item) {
	if(item.collapsibleState != vscode__$TreeItemCollapsibleState_TreeItemCollapsibleState_$Impl_$.None) {
		item.collapsibleState = vscode__$TreeItemCollapsibleState_TreeItemCollapsibleState_$Impl_$.Collapsed;
		vshaxe_view_TreeItemHelper.refreshHack(item);
	}
};
vshaxe_view_TreeItemHelper.refreshHack = function(item) {
	var addOrRemoveSpace = function(s) {
		if(StringTools.endsWith(s," ")) {
			return StringTools.rtrim(s);
		} else {
			return s + " ";
		}
	};
	if(item.id != null) {
		item.id = addOrRemoveSpace(item.id);
	} else {
		item.label = addOrRemoveSpace(item.label);
	}
};
var vshaxe_view_dependencies_DependencyExtractor = function() { };
vshaxe_view_dependencies_DependencyExtractor.__name__ = true;
vshaxe_view_dependencies_DependencyExtractor.extractDependencies = function(args,cwd) {
	var result = { libs : [], classPaths : [], hxmls : []};
	if(args == null) {
		return result;
	}
	var processHxml = function(hxmlFile,cwd1) {
		hxmlFile = vshaxe_helper_PathHelper.absolutize(hxmlFile,cwd1);
		result.hxmls.push(hxmlFile);
		if(hxmlFile == null || !sys_FileSystem.exists(hxmlFile)) {
			return [];
		}
		return vshaxe_helper_HxmlParser.parseFile(js_node_Fs.readFileSync(hxmlFile,{ encoding : "utf8"}));
	};
	var processLines = null;
	processLines = function(lines) {
		var _g = 0;
		while(_g < lines.length) {
			var line = lines[_g];
			++_g;
			switch(line[1]) {
			case 1:
				var name = line[2];
				if(StringTools.endsWith(name,".hxml")) {
					var processLines1 = processHxml(name,cwd);
					processLines(processLines1);
				}
				break;
			case 2:
				switch(line[2]) {
				case "--library":case "-L":case "-lib":
					result.libs.push(line[3]);
					break;
				case "--cwd":case "-C":
					var newCwd = line[3];
					if(haxe_io_Path.isAbsolute(newCwd)) {
						cwd = newCwd;
					} else {
						cwd = haxe_io_Path.join([cwd,newCwd]);
					}
					break;
				case "--class-path":case "-cp":case "-p":
					result.classPaths.push(line[3]);
					break;
				default:
				}
				break;
			default:
			}
		}
	};
	var tmp = vshaxe_helper_HxmlParser.parseArray(args);
	processLines(tmp);
	return result;
};
var vshaxe_view_dependencies_DependencyResolver = function() { };
vshaxe_view_dependencies_DependencyResolver.__name__ = true;
vshaxe_view_dependencies_DependencyResolver.resolveDependencies = function(dependencies,haxeExecutable) {
	var paths = [];
	var _g = 0;
	var _g1 = dependencies.libs;
	while(_g < _g1.length) paths = paths.concat(vshaxe_view_dependencies_DependencyResolver.resolveHaxelib(_g1[_g++]));
	paths = paths.concat(dependencies.classPaths);
	paths = vshaxe_view_dependencies_DependencyResolver.pruneSubdirectories(paths);
	var infos = [];
	if(vshaxe_view_dependencies_DependencyResolver.get_haxelibRepo() != null) {
		infos = paths.map(vshaxe_view_dependencies_DependencyResolver.getDependencyInfo).filter(function(info) {
			return info != null;
		});
	}
	var stdLibPath = vshaxe_view_dependencies_DependencyResolver.getStandardLibraryPath(haxeExecutable.configuration);
	if(stdLibPath != null && sys_FileSystem.exists(stdLibPath)) {
		infos.push(vshaxe_view_dependencies_DependencyResolver.getStandardLibraryInfo(stdLibPath,haxeExecutable.configuration.executable));
	}
	return infos;
};
vshaxe_view_dependencies_DependencyResolver.get_haxelibRepo = function() {
	if(vshaxe_view_dependencies_DependencyResolver._haxelibRepo == null) {
		var output = vshaxe_view_dependencies_DependencyResolver.getProcessOutput("haxelib config")[0];
		if(output == null) {
			console.log("src/vshaxe/view/dependencies/DependencyResolver.hx:47:","`haxelib config` call failed, Haxe Dependencies won't be populated.");
		} else {
			vshaxe_view_dependencies_DependencyResolver._haxelibRepo = haxe_io_Path.normalize(output);
		}
	}
	return vshaxe_view_dependencies_DependencyResolver._haxelibRepo;
};
vshaxe_view_dependencies_DependencyResolver.resolveHaxelib = function(lib) {
	var paths = [];
	var _g = 0;
	var _g1 = vshaxe_view_dependencies_DependencyResolver.getProcessOutput("haxelib path " + lib);
	while(_g < _g1.length) {
		var potentialPath = haxe_io_Path.normalize(_g1[_g++]);
		if(sys_FileSystem.exists(potentialPath)) {
			paths.push(potentialPath);
		}
	}
	return paths;
};
vshaxe_view_dependencies_DependencyResolver.getProcessOutput = function(command) {
	try {
		var oldCwd = process.cwd();
		if(Vscode.workspace.workspaceFolders != null) {
			process.chdir(Vscode.workspace.workspaceFolders[0].uri.fsPath);
		}
		var result = js_node_ChildProcess.execSync(command);
		process.chdir(oldCwd);
		var lines = result.toString().split("\n");
		var _g = [];
		var _g1 = 0;
		while(_g1 < lines.length) _g.push(StringTools.trim(lines[_g1++]));
		return _g;
	} catch( e ) {
		return [];
	}
};
vshaxe_view_dependencies_DependencyResolver.pruneSubdirectories = function(paths) {
	paths = paths.map(haxe_io_Path.addTrailingSlash);
	return paths.filter(function(path) {
		return !Lambda.exists(paths,function(p) {
			if(p != path) {
				return StringTools.startsWith(path,p);
			} else {
				return false;
			}
		});
	});
};
vshaxe_view_dependencies_DependencyResolver.getDependencyInfo = function(path) {
	var rootPath = Vscode.workspace.workspaceFolders[0].uri.fsPath;
	var absPath = vshaxe_helper_PathHelper.absolutize(path,rootPath);
	if(!sys_FileSystem.exists(absPath)) {
		return null;
	}
	if(absPath.indexOf(vshaxe_view_dependencies_DependencyResolver.get_haxelibRepo()) == -1) {
		if(absPath.indexOf(haxe_io_Path.normalize(rootPath)) == -1) {
			var haxelibInfo = vshaxe_view_dependencies_DependencyResolver.searchHaxelibJson(absPath);
			if(haxelibInfo == null) {
				return { name : path, version : null, path : absPath};
			}
			return haxelibInfo;
		}
		return null;
	}
	path = StringTools.replace(absPath,vshaxe_view_dependencies_DependencyResolver.get_haxelibRepo() + "/","");
	var segments = path.split("/");
	var name = segments[0];
	var version = segments[1];
	path = "" + vshaxe_view_dependencies_DependencyResolver.get_haxelibRepo() + "/" + name;
	if(name != null) {
		name = StringTools.replace(name,",",".");
	}
	if(version != null) {
		path += "/" + version;
		version = StringTools.replace(version,",",".");
	} else {
		version = path;
	}
	if(!sys_FileSystem.exists(path)) {
		return null;
	}
	return { name : name, version : version, path : path};
};
vshaxe_view_dependencies_DependencyResolver.searchHaxelibJson = function(path,levels) {
	if(levels == null) {
		levels = 3;
	}
	if(levels <= 0) {
		return null;
	}
	var haxelibFile = haxe_io_Path.join([path,"haxelib.json"]);
	if(sys_FileSystem.exists(haxelibFile)) {
		var content = JSON.parse(js_node_Fs.readFileSync(haxelibFile,{ encoding : "utf8"}));
		if(content.name == null) {
			return null;
		}
		path = haxe_io_Path.normalize(path);
		return { name : content.name, version : "dev", path : path};
	}
	return vshaxe_view_dependencies_DependencyResolver.searchHaxelibJson(haxe_io_Path.join([path,".."]),levels - 1);
};
vshaxe_view_dependencies_DependencyResolver.getStandardLibraryPath = function(haxeExecutable) {
	var path = process.env["HAXE_STD_PATH"];
	if(path != null) {
		return path;
	}
	if(Sys.systemName() == "Windows") {
		var path1;
		if(haxeExecutable.isCommand) {
			var exectuable = vshaxe_view_dependencies_DependencyResolver.getProcessOutput("where " + haxeExecutable.executable)[0];
			if(exectuable == null) {
				return null;
			}
			path1 = exectuable;
		} else {
			path1 = haxeExecutable.executable;
		}
		return haxe_io_Path.join([haxe_io_Path.directory(path1),"std"]);
	} else {
		if(sys_FileSystem.exists("/usr/local/share/haxe/std/")) {
			return "/usr/local/share/haxe/std/";
		}
		if(sys_FileSystem.exists("/usr/local/lib/haxe/std/")) {
			return "/usr/local/lib/haxe/std/";
		}
		if(sys_FileSystem.exists("/usr/share/haxe/std/")) {
			return "/usr/share/haxe/std/";
		}
		if(sys_FileSystem.exists("/usr/lib/haxe/std/")) {
			return "/usr/lib/haxe/std/";
		}
	}
	return null;
};
vshaxe_view_dependencies_DependencyResolver.getStandardLibraryInfo = function(path,haxeExecutable) {
	var version = "?";
	var result = js_node_ChildProcess.spawnSync(haxeExecutable,["-version"]);
	if(result != null && result.stderr != null) {
		var output = StringTools.trim(result.stderr.toString());
		if(output == "") {
			output = StringTools.trim(result.stdout.toString());
		}
		if(output != null) {
			version = StringTools.trim(output.split(" ")[0]);
		}
	}
	return { name : "haxe", path : path, version : version};
};
var vshaxe_view_dependencies_DependencyTreeView = function(context,displayArguments,haxeExecutable) {
	this.getParent = function(node) {
		return node.parent;
	};
	this._onDidChangeTreeData = new vscode_EventEmitter();
	this.autoRevealEnabled = false;
	this.refreshNeeded = true;
	this.dependencyNodes = [];
	this.relevantHxmls = [];
	var _gthis = this;
	this.context = context;
	this.displayArguments = displayArguments["arguments"];
	this.haxeExecutable = haxeExecutable;
	this.onDidChangeTreeData = this._onDidChangeTreeData.event;
	Vscode.window.registerTreeDataProvider("haxe.dependencies",this);
	this.view = Vscode.window.createTreeView("haxe.dependencies",{ treeDataProvider : this});
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "refreshDependencies",$bind(this,this.refresh));
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "collapseDependencies",$bind(this,this.collapseAll));
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "dependencies.openTextDocument",$bind(this,this.openTextDocument));
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "dependencies.refresh",$bind(this,this.refresh));
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "dependencies.collapseAll",$bind(this,this.collapseAll));
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "dependencies.openPreview",$bind(this,this.openPreview));
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "dependencies.openToTheSide",$bind(this,this.openToTheSide));
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "dependencies.revealInExplorer",$bind(this,this.revealInExplorer));
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "dependencies.openInCommandPrompt",$bind(this,this.openInCommandPrompt));
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "dependencies.copyPath",$bind(this,this.copyPath));
	var hxmlFileWatcher = Vscode.workspace.createFileSystemWatcher("**/*.hxml");
	context.subscriptions.push(hxmlFileWatcher.onDidCreate($bind(this,this.onDidChangeHxml)));
	context.subscriptions.push(hxmlFileWatcher.onDidChange($bind(this,this.onDidChangeHxml)));
	context.subscriptions.push(hxmlFileWatcher.onDidDelete($bind(this,this.onDidChangeHxml)));
	context.subscriptions.push(hxmlFileWatcher);
	context.subscriptions.push((haxeExecutable.get_onDidChangeConfiguration())(function(_) {
		_gthis.refresh();
		return;
	}));
	context.subscriptions.push(Vscode.workspace.onDidChangeConfiguration(function(_1) {
		_gthis.updateAutoReveal();
		return;
	}));
	context.subscriptions.push(displayArguments._onDidChangeArguments.event($bind(this,this.onDidChangeDisplayArguments)));
	context.subscriptions.push(Vscode.window.onDidChangeActiveTextEditor(function(_2) {
		_gthis.autoReveal();
		return;
	}));
	context.subscriptions.push(this.view.onDidChangeVisibility(function(_3) {
		_gthis.autoReveal();
		return;
	}));
	this.updateAutoReveal();
};
vshaxe_view_dependencies_DependencyTreeView.__name__ = true;
vshaxe_view_dependencies_DependencyTreeView.prototype = {
	onDidChangeHxml: function(uri) {
		var _g = 0;
		var _g1 = this.relevantHxmls;
		while(_g < _g1.length) if(vshaxe_helper_PathHelper.areEqual(uri.fsPath,_g1[_g++])) {
			this.refresh(false);
		}
	}
	,refreshDependencies: function() {
		var newDependencies = vshaxe_view_dependencies_DependencyExtractor.extractDependencies(this.displayArguments,Vscode.workspace.workspaceFolders[0].uri.fsPath);
		this.relevantHxmls = newDependencies.hxmls;
		if(this.dependencies != null && vshaxe_helper_ArrayHelper.equals(this.dependencies.libs,newDependencies.libs) && vshaxe_helper_ArrayHelper.equals(this.dependencies.classPaths,newDependencies.classPaths)) {
			return this.dependencyNodes;
		}
		this.dependencies = newDependencies;
		return this.updateNodes(vshaxe_view_dependencies_DependencyResolver.resolveDependencies(newDependencies,this.haxeExecutable));
	}
	,updateNodes: function(dependencyInfos) {
		var newNodes = [];
		var _g = 0;
		while(_g < dependencyInfos.length) {
			var info = [dependencyInfos[_g]];
			++_g;
			if(Lambda.find(newNodes,(function(info1) {
				return function(d) {
					return vshaxe_helper_PathHelper.areEqual(d.path,info1[0].path);
				};
			})(info)) != null) {
				continue;
			}
			if(this.dependencies != null) {
				var oldNode = Lambda.find(this.dependencyNodes,(function(info2) {
					return function(d1) {
						return d1.path == info2[0].path;
					};
				})(info));
				if(oldNode != null) {
					newNodes.push(oldNode);
					continue;
				}
			}
			var node = this.createNode(info[0]);
			if(node != null) {
				newNodes.push(node);
			}
		}
		vshaxe_view_dependencies_Node.sort(newNodes);
		haxe_ds_ArraySort.sort(newNodes,function(node1,node2) {
			if(node1.type == vshaxe_view_dependencies_NodeType.StandardLibrary) {
				return 1;
			} else if(node2.type == vshaxe_view_dependencies_NodeType.StandardLibrary) {
				return -1;
			}
			return 0;
		});
		return newNodes;
	}
	,createNode: function(info) {
		if(info == null) {
			return null;
		}
		var label = info.name;
		if(info.version != null) {
			label += " (" + info.version + ")";
		}
		return new vshaxe_view_dependencies_Node(null,label,info.path,info.name == "haxe" ? vshaxe_view_dependencies_NodeType.StandardLibrary : vshaxe_view_dependencies_NodeType.Haxelib);
	}
	,onDidChangeDisplayArguments: function(displayArguments) {
		this.displayArguments = displayArguments;
		this.refresh();
	}
	,updateAutoReveal: function() {
		this.autoRevealEnabled = Vscode.workspace.getConfiguration("explorer").get("autoReveal");
	}
	,autoReveal: function() {
		var _gthis = this;
		var editor = Vscode.window.activeTextEditor;
		if(editor == null || !this.view.visible || !this.autoRevealEnabled) {
			return;
		}
		var loop = null;
		loop = function(nodes) {
			var _g = 0;
			while(_g < nodes.length) {
				var node = nodes[_g];
				++_g;
				if(node.type != vshaxe_view_dependencies_NodeType.File && vshaxe_helper_PathHelper.containsFile(node.path,editor.document.fileName)) {
					var loop1 = node.get_children();
					loop(loop1);
				} else if(vshaxe_helper_PathHelper.areEqual(node.path,editor.document.fileName)) {
					_gthis.view.reveal(node,{ select : true});
					break;
				}
			}
		};
		loop(this.dependencyNodes);
	}
	,refresh: function(hard) {
		if(hard == null) {
			hard = true;
		}
		if(hard) {
			this.dependencies = null;
			var _g = 0;
			var _g1 = this.dependencyNodes;
			while(_g < _g1.length) _g1[_g++].refresh();
		}
		this.refreshNeeded = true;
		this._onDidChangeTreeData.fire();
	}
	,getTreeItem: function(element) {
		return element;
	}
	,getChildren: function(node) {
		if(this.refreshNeeded) {
			this.dependencyNodes = this.refreshDependencies();
			this.refreshNeeded = false;
		}
		if(node == null) {
			return this.dependencyNodes;
		} else {
			return node.get_children();
		}
	}
	,openTextDocument: function(node) {
		var currentTime = new Date().getTime();
		var preview = this.previousSelection == null || this.previousSelection.node != node || currentTime - this.previousSelection.time >= 500;
		Vscode.workspace.openTextDocument(node.path).then(function(document) {
			return Vscode.window.showTextDocument(document,{ preview : preview});
		});
		this.previousSelection = { node : node, time : currentTime};
	}
	,collapseAll: function(node) {
		var _g = 0;
		var _g1 = this.dependencyNodes;
		while(_g < _g1.length) vshaxe_view_TreeItemHelper.collapse(_g1[_g++]);
		this._onDidChangeTreeData.fire();
	}
	,openPreview: function(node) {
		Vscode.commands.executeCommand("markdown.showPreview",node.resourceUri);
	}
	,openToTheSide: function(node) {
		Vscode.window.showTextDocument(node.resourceUri,{ viewColumn : vscode__$ViewColumn_ViewColumn_$Impl_$.Three});
	}
	,revealInExplorer: function(node) {
		var explorer;
		switch(Sys.systemName()) {
		case "Linux":
			explorer = "xdg-open";
			break;
		case "Mac":
			explorer = "open";
			break;
		case "Windows":
			explorer = "explorer";
			break;
		default:
			throw new js__$Boot_HaxeError("unsupported OS");
		}
		var arg = node.resourceUri.fsPath;
		if(Sys.systemName() == "Windows") {
			arg = "/select,\"" + arg + "\"";
		}
		js_node_ChildProcess.spawnSync("" + explorer + " " + arg,{ shell : true, stdio : "inherit"});
	}
	,openInCommandPrompt: function(node) {
		var cwd = node.path;
		if(node.type == vshaxe_view_dependencies_NodeType.File) {
			cwd = haxe_io_Path.directory(node.path);
		}
		Vscode.window.createTerminal({ cwd : cwd}).show();
	}
	,copyPath: function(node) {
		vshaxe_helper_CopyPaste.copy(vshaxe_helper_PathHelper.capitalizeDriveLetter(node.resourceUri.fsPath));
	}
};
var vshaxe_view_dependencies_NodeType = { __ename__ : true, __constructs__ : ["File","Folder","Haxelib","StandardLibrary"] };
vshaxe_view_dependencies_NodeType.File = ["File",0];
vshaxe_view_dependencies_NodeType.File.toString = $estr;
vshaxe_view_dependencies_NodeType.File.__enum__ = vshaxe_view_dependencies_NodeType;
vshaxe_view_dependencies_NodeType.Folder = ["Folder",1];
vshaxe_view_dependencies_NodeType.Folder.toString = $estr;
vshaxe_view_dependencies_NodeType.Folder.__enum__ = vshaxe_view_dependencies_NodeType;
vshaxe_view_dependencies_NodeType.Haxelib = ["Haxelib",2];
vshaxe_view_dependencies_NodeType.Haxelib.toString = $estr;
vshaxe_view_dependencies_NodeType.Haxelib.__enum__ = vshaxe_view_dependencies_NodeType;
vshaxe_view_dependencies_NodeType.StandardLibrary = ["StandardLibrary",3];
vshaxe_view_dependencies_NodeType.StandardLibrary.toString = $estr;
vshaxe_view_dependencies_NodeType.StandardLibrary.__enum__ = vshaxe_view_dependencies_NodeType;
var vshaxe_view_dependencies_Node = function(parent,label,path,type) {
	vscode_TreeItem.call(this,label);
	this.resourceUri = vscode_Uri.file(path);
	this.parent = parent;
	this.path = path;
	this.type = type;
	if(this.type == null) {
		this.type = sys_FileSystem.isDirectory(path) ? vshaxe_view_dependencies_NodeType.Folder : vshaxe_view_dependencies_NodeType.File;
	}
	if(this.type != vshaxe_view_dependencies_NodeType.File) {
		this.collapsibleState = vscode__$TreeItemCollapsibleState_TreeItemCollapsibleState_$Impl_$.Collapsed;
		this.contextValue = "folder";
	} else {
		this.contextValue = "file." + haxe_io_Path.extension(path);
		this.command = { command : "haxe." + "dependencies.openTextDocument", 'arguments' : [this], title : "Open File"};
	}
};
vshaxe_view_dependencies_Node.__name__ = true;
vshaxe_view_dependencies_Node.sort = function(nodes) {
	haxe_ds_ArraySort.sort(nodes,function(c1,c2) {
		var compare = function(a,b) {
			a = a.toLowerCase();
			b = b.toLowerCase();
			if(a < b) {
				return -1;
			}
			if(a > b) {
				return 1;
			}
			return 0;
		};
		if(c1.type != vshaxe_view_dependencies_NodeType.File && c2.type != vshaxe_view_dependencies_NodeType.File) {
			return compare(c1.label,c2.label);
		} else if(c1.type != vshaxe_view_dependencies_NodeType.File) {
			return -1;
		} else if(c2.type != vshaxe_view_dependencies_NodeType.File) {
			return 1;
		} else {
			return compare(c1.label,c2.label);
		}
	});
};
vshaxe_view_dependencies_Node.__super__ = vscode_TreeItem;
vshaxe_view_dependencies_Node.prototype = $extend(vscode_TreeItem.prototype,{
	refresh: function() {
		var _gthis = this;
		if(this.type == vshaxe_view_dependencies_NodeType.File || this.get_children() == null) {
			return;
		}
		var newChildren = [];
		this.forEachChild(function(file,path) {
			var existingNode = null;
			if(_gthis.get_children() != null) {
				existingNode = Lambda.find(_gthis.get_children(),function(node) {
					return node.label == file;
				});
			}
			if(existingNode != null) {
				existingNode.refresh();
				return newChildren.push(existingNode);
			} else {
				return newChildren.push(new vshaxe_view_dependencies_Node(_gthis,file,path));
			}
		});
		vshaxe_view_dependencies_Node.sort(newChildren);
		this.children = newChildren;
	}
	,get_children: function() {
		if(this.children == null) {
			this.children = this.createChildren();
		}
		return this.children;
	}
	,createChildren: function() {
		var _gthis = this;
		if(this.type == vshaxe_view_dependencies_NodeType.File) {
			return [];
		}
		var children = [];
		this.forEachChild(function(file,path) {
			return children.push(new vshaxe_view_dependencies_Node(_gthis,file,path));
		});
		vshaxe_view_dependencies_Node.sort(children);
		return children;
	}
	,forEachChild: function(f) {
		var _g = 0;
		var _g1 = js_node_Fs.readdirSync(this.path);
		while(_g < _g1.length) {
			var file = _g1[_g];
			++_g;
			if(!this.isExcluded(file)) {
				f(file,"" + this.path + "/" + file);
			}
		}
	}
	,isExcluded: function(file) {
		if(!(file == ".git" || file == ".svn" || file == ".hg" || file == "CVS")) {
			return file == ".DS_Store";
		} else {
			return true;
		}
	}
});
var vshaxe_view_methods_MethodTreeItem = function(context,parent,timer,method,debugInfo,parentId) {
	if(parentId == null) {
		parentId = "";
	}
	vscode_TreeItem.call(this,"");
	this.context = context;
	this.parent = parent;
	this.timer = timer;
	this.method = method;
	this.debugInfo = debugInfo;
	this.name = this.formatName();
	this.label = this.formatLabel();
	this.tooltip = this.formatTooltip();
	this.id = parentId + ">" + this.name;
	if(timer == null || timer.children == null) {
		this.children = null;
		this.collapsibleState = vscode__$TreeItemCollapsibleState_TreeItemCollapsibleState_$Impl_$.None;
	} else {
		var f = function(context1,parent1,timer1,method1,debugInfo1,parentId1) {
			return new vshaxe_view_methods_MethodTreeItem(context1,parent1,timer1,method1,debugInfo1,parentId1);
		};
		var context2 = context;
		var parent2 = this;
		var method2 = method;
		var parentId2 = this.id;
		var tmp = function(timer2) {
			return f(context2,parent2,timer2,method2,null,parentId2);
		};
		this.children = timer.children.map(tmp);
		this.collapsibleState = vscode__$TreeItemCollapsibleState_TreeItemCollapsibleState_$Impl_$.Expanded;
	}
	if(this.parent == null) {
		this.iconPath = { light : context.asAbsolutePath("resources/light/method.svg"), dark : context.asAbsolutePath("resources/dark/method.svg")};
	}
};
vshaxe_view_methods_MethodTreeItem.__name__ = true;
vshaxe_view_methods_MethodTreeItem.__super__ = vscode_TreeItem;
vshaxe_view_methods_MethodTreeItem.prototype = $extend(vscode_TreeItem.prototype,{
	formatName: function() {
		var name = this.parent == null ? this.method : this.timer.name;
		if(this.timer != null && this.timer.info != "" && this.timer.info != null) {
			name = "" + this.timer.info + "." + name;
		}
		return name;
	}
	,formatLabel: function() {
		if(this.timer == null) {
			return this.name;
		}
		var percent = this.timer.percentTotal != null ? this.truncate(this.timer.percentTotal,4) : null;
		var label = "" + this.name + " - " + this.truncate(this.timer.time,5) + "s";
		if(this.parent != null && percent != null) {
			label += " (" + percent + "%)";
		}
		if(this.debugInfo != null) {
			label += " [" + this.debugInfo + "]";
		}
		return label;
	}
	,formatTooltip: function() {
		if(this.timer == null) {
			return null;
		}
		var now = new Date();
		return "" + ("[" + now.getHours() + ":" + now.getMinutes() + ":" + now.getSeconds() + "]") + " " + (this.timer.calls != null ? "" + this.timer.calls + " calls " : "") + "- " + this.truncate(this.timer.time,7) + "s";
	}
	,truncate: function(f,precision) {
		return HxOverrides.substr(f == null ? "null" : "" + f,0,precision);
	}
	,toString: function(indent) {
		if(indent == null) {
			indent = "";
		}
		var result = indent + this.label;
		if(this.children != null) {
			result += "\n" + this.children.map(function(child) {
				return child.toString(indent + "  ");
			}).join("\n");
		}
		return result;
	}
});
var vshaxe_view_methods_MethodTreeView = function(context,server) {
	this.getParent = function(element) {
		return element.parent;
	};
	this._onDidChangeTreeData = new vscode_EventEmitter();
	this.queue = [];
	this.methods = [];
	var _gthis = this;
	this.context = context;
	this.server = server;
	server._onDidRunHaxeMethod.event($bind(this,this.onDidRunHaxeMethod));
	server._onDidChangeRequestQueue.event($bind(this,this.onDidChangeRequestQueue));
	Vscode.workspace.onDidChangeConfiguration(function(_) {
		_gthis.update();
		return;
	});
	this.onDidChangeTreeData = this._onDidChangeTreeData.event;
	this.setMethodsViewType("timers");
	this.update();
	Vscode.window.registerTreeDataProvider("haxe.methods",this);
	this.treeView = Vscode.window.createTreeView("haxe.methods",{ treeDataProvider : this});
	var f = $bind(this,this.switchTo);
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "methods.switchToQueue",function() {
		f("queue");
	});
	var f1 = $bind(this,this.switchTo);
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "methods.switchToTimers",function() {
		f1("timers");
	});
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "methods.collapseAll",$bind(this,this.collapseAll));
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "methods.copy",$bind(this,this.copy));
	vshaxe_helper_ContextHelper.registerHaxeCommand(context,"haxe." + "methods.track",$bind(this,this.track));
};
vshaxe_view_methods_MethodTreeView.__name__ = true;
vshaxe_view_methods_MethodTreeView.prototype = {
	setMethodsViewType: function(viewType) {
		this.viewType = viewType;
		Vscode.commands.executeCommand("setContext","haxeMethodsViewType",Std.string(viewType));
	}
	,switchTo: function(viewType) {
		this.setMethodsViewType(viewType);
		this._onDidChangeTreeData.fire();
	}
	,onDidRunHaxeMethod: function(data) {
		if(!this.enabled) {
			return;
		}
		var rootTimer = data.response.timers;
		if(rootTimer == null) {
			rootTimer = this.makeTimer("",0,[]);
		}
		if(data.additionalTimes != null) {
			rootTimer.children.push(this.createAdditionalTimers(data));
		}
		var method = data.method;
		this.methods = this.methods.filter(function(item) {
			return item.method != method;
		});
		var item1 = new vshaxe_view_methods_MethodTreeItem(this.context,null,rootTimer,data.method,data.debugInfo);
		this.methods.push(item1);
		this.methods.sort(function(item11,item2) {
			return Reflect.compare(item11.method,item2.method);
		});
		if(this.viewType == "timers") {
			this._onDidChangeTreeData.fire();
			if(this.treeView.visible) {
				this.treeView.reveal(item1,{ select : true});
			}
		}
	}
	,createAdditionalTimers: function(data) {
		var additionalTimes = data.additionalTimes;
		var transmissionTime = additionalTimes.arrival - data.response.timestamp * 1000.0;
		var parsingTime = additionalTimes.beforeProcessing - additionalTimes.arrival;
		var processingTime = additionalTimes.afterProcessing - additionalTimes.beforeProcessing;
		return this.makeTimer("vshaxe",transmissionTime + parsingTime + processingTime,[this.makeTimer("display call",additionalTimes.arrival - additionalTimes.beforeCall),this.makeTimer("transmission",transmissionTime),this.makeTimer("parsing",parsingTime),this.makeTimer("processing",processingTime)]);
	}
	,makeTimer: function(name,time,children) {
		var date = new Date(time);
		return { name : name, time : date.getSeconds() + date.getMilliseconds() / 1000.0, children : children};
	}
	,onDidChangeRequestQueue: function(queue) {
		var _gthis = this;
		this.queue = queue.map(function(label) {
			return new vshaxe_view_methods_MethodTreeItem(_gthis.context,null,null,label);
		});
		if(this.viewType == "queue") {
			this._onDidChangeTreeData.fire();
		}
	}
	,update: function() {
		this.enabled = Vscode.workspace.getConfiguration("haxe").get("enableMethodsView");
		Vscode.commands.executeCommand("setContext","enableHaxeMethodsView",this.enabled);
	}
	,getTreeItem: function(element) {
		return element;
	}
	,getChildren: function(element) {
		if(this.viewType == "queue") {
			return this.queue;
		}
		if(element == null) {
			return this.methods;
		} else {
			return element.children;
		}
	}
	,collapseAll: function() {
		var _g = 0;
		var _g1 = this.methods;
		while(_g < _g1.length) vshaxe_view_TreeItemHelper.collapse(_g1[_g++]);
		this._onDidChangeTreeData.fire();
	}
	,copy: function(element) {
		vshaxe_helper_CopyPaste.copy(element == null ? this.methods.map(function(method) {
			return method.toString();
		}).join("\n\n") : element.toString());
	}
	,track: function(element) {
		if(element != null) {
			Vscode.commands.executeCommand("vshaxeDebugTools.methodResultsView.track",element.method);
		}
	}
};
function $getIterator(o) { if( o instanceof Array ) return HxOverrides.iter(o); else return o.iterator(); }
var $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.__name__ = true;
Array.__name__ = true;
Date.__name__ = "Date";
var __map_reserved = {};
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
sys_io_File.copyBuf = new js_node_buffer_Buffer(65536);
vshaxe_display_DisplayArgumentsSelector.statusBarWarningThemeColor = new vscode_ThemeColor("errorForeground");
vshaxe_display_HaxeDisplayArgumentsProvider.ConfigurationIndexKey = vshaxe__$HaxeMemento_HaxeMementoKey_$Impl_$._new("displayConfigurationIndex");
vshaxe_helper_HaxeExecutable.SYSTEM_KEY = (function($this) {
	var $r;
	switch(Sys.systemName()) {
	case "Mac":
		$r = "osx";
		break;
	case "Windows":
		$r = "windows";
		break;
	default:
		$r = "linux";
	}
	return $r;
}(this));
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this);
