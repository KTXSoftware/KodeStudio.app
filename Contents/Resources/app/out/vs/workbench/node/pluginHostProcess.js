/*!--------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
define("vs/base/common/arrays", ["require", "exports"], function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Returns the last element of an array.
     * @param array The array.
     * @param n Which element from the end (default ist zero).
     */
    function tail(array, n) {
        if (n === void 0) { n = 0; }
        return array[array.length - (1 + n)];
    }
    exports.tail = tail;
    /**
     * Iterates the provided array and allows to remove
     * elements while iterating.
     */
    function forEach(array, callback) {
        for (var i = 0, len = array.length; i < len; i++) {
            callback(array[i], function () {
                array.splice(i, 1);
                i--;
                len--;
            });
        }
    }
    exports.forEach = forEach;
    function equals(one, other, itemEquals) {
        if (one.length !== other.length) {
            return false;
        }
        for (var i = 0, len = one.length; i < len; i++) {
            if (!itemEquals(one[i], other[i])) {
                return false;
            }
        }
        return true;
    }
    exports.equals = equals;
    function binarySearch(array, key, comparator) {
        var low = 0, high = array.length - 1;
        while (low <= high) {
            var mid = ((low + high) / 2) | 0;
            var comp = comparator(array[mid], key);
            if (comp < 0) {
                low = mid + 1;
            }
            else if (comp > 0) {
                high = mid - 1;
            }
            else {
                return mid;
            }
        }
        return -(low + 1);
    }
    exports.binarySearch = binarySearch;
    /**
     * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false
     * are located before all elements where p(x) is true.
     * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.
     */
    function findFirst(array, p) {
        var low = 0, high = array.length;
        if (high === 0) {
            return 0; // no children
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (p(array[mid])) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        return low;
    }
    exports.findFirst = findFirst;
    function merge(arrays, hashFn) {
        var result = new Array();
        if (!hashFn) {
            for (var i = 0, len = arrays.length; i < len; i++) {
                result.push.apply(result, arrays[i]);
            }
        }
        else {
            var map = {};
            for (var i = 0; i < arrays.length; i++) {
                for (var j = 0; j < arrays[i].length; j++) {
                    var element = arrays[i][j], hash = hashFn(element);
                    if (!map.hasOwnProperty(hash)) {
                        map[hash] = true;
                        result.push(element);
                    }
                }
            }
        }
        return result;
    }
    exports.merge = merge;
    /**
     * @returns a new array with all undefined or null values removed. The original array is not modified at all.
     */
    function coalesce(array) {
        if (!array) {
            return array;
        }
        return array.filter(function (e) { return !!e; });
    }
    exports.coalesce = coalesce;
    /**
     * @returns true if the given item is contained in the array.
     */
    function contains(array, item) {
        return array.indexOf(item) >= 0;
    }
    exports.contains = contains;
    /**
     * Swaps the elements in the array for the provided positions.
     */
    function swap(array, pos1, pos2) {
        var element1 = array[pos1];
        var element2 = array[pos2];
        array[pos1] = element2;
        array[pos2] = element1;
    }
    exports.swap = swap;
    /**
     * Moves the element in the array for the provided positions.
     */
    function move(array, from, to) {
        array.splice(to, 0, array.splice(from, 1)[0]);
    }
    exports.move = move;
    /**
     * @returns {{false}} if the provided object is an array
     * 	and not empty.
     */
    function isFalsyOrEmpty(obj) {
        return !Array.isArray(obj) || obj.length === 0;
    }
    exports.isFalsyOrEmpty = isFalsyOrEmpty;
    /**
     * Removes duplicates from the given array. The optional keyFn allows to specify
     * how elements are checked for equalness by returning a unique string for each.
     */
    function distinct(array, keyFn) {
        if (!keyFn) {
            return array.filter(function (element, position) {
                return array.indexOf(element) === position;
            });
        }
        var seen = {};
        return array.filter(function (elem) {
            var key = keyFn(elem);
            if (seen[key]) {
                return false;
            }
            seen[key] = true;
            return true;
        });
    }
    exports.distinct = distinct;
    function first(array, fn, notFoundValue) {
        if (notFoundValue === void 0) { notFoundValue = null; }
        for (var i = 0; i < array.length; i++) {
            var element = array[i];
            if (fn(element)) {
                return element;
            }
        }
        return notFoundValue;
    }
    exports.first = first;
    function commonPrefixLength(one, other, equals) {
        if (equals === void 0) { equals = function (a, b) { return a === b; }; }
        var result = 0;
        for (var i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {
            result++;
        }
        return result;
    }
    exports.commonPrefixLength = commonPrefixLength;
    function flatten(arr) {
        return arr.reduce(function (r, v) { return r.concat(v); }, []);
    }
    exports.flatten = flatten;
});

define("vs/base/common/assert", ["require", "exports"], function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Throws an error with the provided message if the provided value does not evaluate to a true Javascript value.
     */
    function ok(value, message) {
        if (!value || value === null) {
            throw new Error(message ? 'Assertion failed (' + message + ')' : 'Assertion Failed');
        }
    }
    exports.ok = ok;
});

define("vs/base/common/collections", ["require", "exports"], function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function createStringDictionary() {
        return Object.create(null);
    }
    exports.createStringDictionary = createStringDictionary;
    function createNumberDictionary() {
        return Object.create(null);
    }
    exports.createNumberDictionary = createNumberDictionary;
    function lookup(from, what, alternate) {
        if (alternate === void 0) { alternate = null; }
        var key = String(what);
        if (contains(from, key)) {
            return from[key];
        }
        return alternate;
    }
    exports.lookup = lookup;
    function lookupOrInsert(from, stringOrNumber, alternate) {
        var key = String(stringOrNumber);
        if (contains(from, key)) {
            return from[key];
        }
        else {
            if (typeof alternate === 'function') {
                alternate = alternate();
            }
            from[key] = alternate;
            return alternate;
        }
    }
    exports.lookupOrInsert = lookupOrInsert;
    function insert(into, data, hashFn) {
        into[hashFn(data)] = data;
    }
    exports.insert = insert;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function contains(from, what) {
        return hasOwnProperty.call(from, what);
    }
    exports.contains = contains;
    function values(from) {
        var result = [];
        for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
                result.push(from[key]);
            }
        }
        return result;
    }
    exports.values = values;
    function forEach(from, callback) {
        for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
                var result = callback({ key: key, value: from[key] }, function () {
                    delete from[key];
                });
                if (result === false) {
                    return;
                }
            }
        }
    }
    exports.forEach = forEach;
    function remove(from, key) {
        if (!hasOwnProperty.call(from, key)) {
            return false;
        }
        delete from[key];
        return true;
    }
    exports.remove = remove;
    /**
     * Groups the collection into a dictionary based on the provided
     * group function.
     */
    function groupBy(data, groupFn) {
        var result = createStringDictionary();
        data.forEach(function (element) { return lookupOrInsert(result, groupFn(element), []).push(element); });
        return result;
    }
    exports.groupBy = groupBy;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("vs/base/common/events", ["require", "exports"], function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Event = (function () {
        function Event(originalEvent) {
            this.time = (new Date()).getTime();
            this.originalEvent = originalEvent;
            this.source = null;
        }
        return Event;
    }());
    exports.Event = Event;
    var PropertyChangeEvent = (function (_super) {
        __extends(PropertyChangeEvent, _super);
        function PropertyChangeEvent(key, oldValue, newValue, originalEvent) {
            _super.call(this, originalEvent);
            this.key = key;
            this.oldValue = oldValue;
            this.newValue = newValue;
        }
        return PropertyChangeEvent;
    }(Event));
    exports.PropertyChangeEvent = PropertyChangeEvent;
    var ViewerEvent = (function (_super) {
        __extends(ViewerEvent, _super);
        function ViewerEvent(element, originalEvent) {
            _super.call(this, originalEvent);
            this.element = element;
        }
        return ViewerEvent;
    }(Event));
    exports.ViewerEvent = ViewerEvent;
    exports.EventType = {
        PROPERTY_CHANGED: 'propertyChanged',
        SELECTION: 'selection',
        FOCUS: 'focus',
        BLUR: 'blur',
        HIGHLIGHT: 'highlight',
        EXPAND: 'expand',
        COLLAPSE: 'collapse',
        TOGGLE: 'toggle',
        CONTENTS_CHANGED: 'contentsChanged',
        BEFORE_RUN: 'beforeRun',
        RUN: 'run',
        EDIT: 'edit',
        SAVE: 'save',
        CANCEL: 'cancel',
        CHANGE: 'change',
        DISPOSE: 'dispose',
    };
});

define("vs/base/common/lifecycle", ["require", "exports"], function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.empty = Object.freeze({
        dispose: function () { }
    });
    function dispose(disposable) {
        if (disposable) {
            disposable.dispose();
        }
        return null;
    }
    exports.dispose = dispose;
    function disposeAll(arr) {
        if (arr) {
            for (var i = 0, len = arr.length; i < len; i++) {
                if (arr[i]) {
                    arr[i].dispose();
                }
            }
        }
        return [];
    }
    exports.disposeAll = disposeAll;
    function combinedDispose() {
        var disposables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            disposables[_i - 0] = arguments[_i];
        }
        return {
            dispose: function () { return disposeAll(disposables); }
        };
    }
    exports.combinedDispose = combinedDispose;
    function combinedDispose2(disposables) {
        return {
            dispose: function () { return disposeAll(disposables); }
        };
    }
    exports.combinedDispose2 = combinedDispose2;
    function fnToDisposable(fn) {
        return {
            dispose: function () { return fn(); }
        };
    }
    exports.fnToDisposable = fnToDisposable;
    function toDisposable() {
        var fns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            fns[_i - 0] = arguments[_i];
        }
        return combinedDispose2(fns.map(fnToDisposable));
    }
    exports.toDisposable = toDisposable;
    function callAll(arg) {
        if (!arg) {
            return null;
        }
        else if (typeof arg === 'function') {
            arg();
            return null;
        }
        else if (Array.isArray(arg)) {
            while (arg.length > 0) {
                arg.pop()();
            }
            return arg;
        }
        else {
            return null;
        }
    }
    /**
     * Calls all functions that are being passed to it.
     */
    exports.cAll = callAll;
    var Disposable = (function () {
        function Disposable() {
            this._toDispose = [];
        }
        Disposable.prototype.dispose = function () {
            this._toDispose = disposeAll(this._toDispose);
        };
        Disposable.prototype._register = function (t) {
            this._toDispose.push(t);
            return t;
        };
        return Disposable;
    }());
    exports.Disposable = Disposable;
});

define("vs/base/common/platform", ["require", "exports"], function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // --- THIS FILE IS TEMPORARY UNTIL ENV.TS IS CLEANED UP. IT CAN SAFELY BE USED IN ALL TARGET EXECUTION ENVIRONMENTS (node & dom) ---
    var _isWindows = false;
    var _isMacintosh = false;
    var _isLinux = false;
    var _isNative = false;
    var _isWeb = false;
    var _isQunit = false;
    var _locale = undefined;
    var _language = undefined;
    // OS detection
    if (typeof process === 'object') {
        _isWindows = (process.platform === 'win32');
        _isMacintosh = (process.platform === 'darwin');
        _isLinux = (process.platform === 'linux');
        var vscode_nls_config = process.env['VSCODE_NLS_CONFIG'];
        if (vscode_nls_config) {
            try {
                var nlsConfig = JSON.parse(vscode_nls_config);
                var resolved = nlsConfig.availableLanguages['*'];
                _locale = nlsConfig.locale;
                // VSCode's default language is 'en'
                _language = resolved ? resolved : 'en';
            }
            catch (e) {
            }
        }
        _isNative = true;
    }
    else if (typeof navigator === 'object') {
        var userAgent = navigator.userAgent;
        _isWindows = userAgent.indexOf('Windows') >= 0;
        _isMacintosh = userAgent.indexOf('Macintosh') >= 0;
        _isLinux = userAgent.indexOf('Linux') >= 0;
        _isWeb = true;
        _locale = navigator.language;
        _language = _locale;
        _isQunit = !!self.QUnit;
    }
    (function (Platform) {
        Platform[Platform["Web"] = 0] = "Web";
        Platform[Platform["Mac"] = 1] = "Mac";
        Platform[Platform["Linux"] = 2] = "Linux";
        Platform[Platform["Windows"] = 3] = "Windows";
    })(exports.Platform || (exports.Platform = {}));
    var Platform = exports.Platform;
    exports._platform = Platform.Web;
    if (_isNative) {
        if (_isMacintosh) {
            exports._platform = Platform.Mac;
        }
        else if (_isWindows) {
            exports._platform = Platform.Windows;
        }
        else if (_isLinux) {
            exports._platform = Platform.Linux;
        }
    }
    exports.isWindows = _isWindows;
    exports.isMacintosh = _isMacintosh;
    exports.isLinux = _isLinux;
    exports.isNative = _isNative;
    exports.isWeb = _isWeb;
    exports.isQunit = _isQunit;
    exports.platform = exports._platform;
    /**
     * The language used for the user interface. The format of
     * the string is all lower case (e.g. zh-tw for Traditional
     * Chinese)
     */
    exports.language = _language;
    /**
     * The OS locale or the locale specified by --locale. The format of
     * the string is all lower case (e.g. zh-tw for Traditional
     * Chinese)
     */
    exports.locale = _locale;
    var _globals = (typeof self === 'object' ? self : global);
    exports.globals = _globals;
    function hasWebWorkerSupport() {
        return typeof _globals.Worker !== 'undefined';
    }
    exports.hasWebWorkerSupport = hasWebWorkerSupport;
    exports.setTimeout = _globals.setTimeout.bind(_globals);
    exports.clearTimeout = _globals.clearTimeout.bind(_globals);
    exports.setInterval = _globals.setInterval.bind(_globals);
    exports.clearInterval = _globals.clearInterval.bind(_globals);
});

define("vs/base/common/stopwatch", ["require", "exports", 'vs/base/common/platform'], function (require, exports, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var hasPerformanceNow = (platform_1.globals.performance && typeof platform_1.globals.performance.now === 'function');
    var StopWatch = (function () {
        function StopWatch(highResolution) {
            this._highResolution = hasPerformanceNow && highResolution;
            this._startTime = this._now();
            this._stopTime = -1;
        }
        StopWatch.create = function (highResolution) {
            if (highResolution === void 0) { highResolution = true; }
            return new StopWatch(highResolution);
        };
        StopWatch.prototype.stop = function () {
            this._stopTime = this._now();
        };
        StopWatch.prototype.elapsed = function () {
            if (this._stopTime !== -1) {
                return this._stopTime - this._startTime;
            }
            return this._now() - this._startTime;
        };
        StopWatch.prototype._now = function () {
            return this._highResolution ? platform_1.globals.performance.now() : new Date().getTime();
        };
        return StopWatch;
    }());
    exports.StopWatch = StopWatch;
});

define("vs/base/common/strings", ["require", "exports"], function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * The empty string.
     */
    exports.empty = '';
    /**
     * @returns the provided number with the given number of preceding zeros.
     */
    function pad(n, l, char) {
        if (char === void 0) { char = '0'; }
        var str = '' + n;
        var r = [str];
        for (var i = str.length; i < l; i++) {
            r.push(char);
        }
        return r.reverse().join('');
    }
    exports.pad = pad;
    var _formatRegexp = /{(\d+)}/g;
    /**
     * Helper to produce a string with a variable number of arguments. Insert variable segments
     * into the string using the {n} notation where N is the index of the argument following the string.
     * @param value string to which formatting is applied
     * @param args replacements for {n}-entries
     */
    function format(value) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (args.length === 0) {
            return value;
        }
        return value.replace(_formatRegexp, function (match, group) {
            var idx = parseInt(group, 10);
            return isNaN(idx) || idx < 0 || idx >= args.length ?
                match :
                args[idx];
        });
    }
    exports.format = format;
    /**
     * Converts HTML characters inside the string to use entities instead. Makes the string safe from
     * being used e.g. in HTMLElement.innerHTML.
     */
    function escape(html) {
        return html.replace(/[<|>|&]/g, function (match) {
            switch (match) {
                case '<': return '&lt;';
                case '>': return '&gt;';
                case '&': return '&amp;';
                default: return match;
            }
        });
    }
    exports.escape = escape;
    /**
     * Escapes regular expression characters in a given string
     */
    function escapeRegExpCharacters(value) {
        return value.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&');
    }
    exports.escapeRegExpCharacters = escapeRegExpCharacters;
    /**
     * Removes all occurrences of needle from the beginning and end of haystack.
     * @param haystack string to trim
     * @param needle the thing to trim (default is a blank)
     */
    function trim(haystack, needle) {
        if (needle === void 0) { needle = ' '; }
        var trimmed = ltrim(haystack, needle);
        return rtrim(trimmed, needle);
    }
    exports.trim = trim;
    /**
     * Removes all occurrences of needle from the beginning of haystack.
     * @param haystack string to trim
     * @param needle the thing to trim
     */
    function ltrim(haystack, needle) {
        if (!haystack || !needle) {
            return haystack;
        }
        var needleLen = needle.length;
        if (needleLen === 0 || haystack.length === 0) {
            return haystack;
        }
        var offset = 0, idx = -1;
        while ((idx = haystack.indexOf(needle, offset)) === offset) {
            offset = offset + needleLen;
        }
        return haystack.substring(offset);
    }
    exports.ltrim = ltrim;
    /**
     * Removes all occurrences of needle from the end of haystack.
     * @param haystack string to trim
     * @param needle the thing to trim
     */
    function rtrim(haystack, needle) {
        if (!haystack || !needle) {
            return haystack;
        }
        var needleLen = needle.length, haystackLen = haystack.length;
        if (needleLen === 0 || haystackLen === 0) {
            return haystack;
        }
        var offset = haystackLen, idx = -1;
        while (true) {
            idx = haystack.lastIndexOf(needle, offset - 1);
            if (idx === -1 || idx + needleLen !== offset) {
                break;
            }
            if (idx === 0) {
                return '';
            }
            offset = idx;
        }
        return haystack.substring(0, offset);
    }
    exports.rtrim = rtrim;
    function convertSimple2RegExpPattern(pattern) {
        return pattern.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&').replace(/[\*]/g, '.*');
    }
    exports.convertSimple2RegExpPattern = convertSimple2RegExpPattern;
    function stripWildcards(pattern) {
        return pattern.replace(/\*/g, '');
    }
    exports.stripWildcards = stripWildcards;
    /**
     * Determines if haystack starts with needle.
     */
    function startsWith(haystack, needle) {
        if (haystack.length < needle.length) {
            return false;
        }
        for (var i = 0; i < needle.length; i++) {
            if (haystack[i] !== needle[i]) {
                return false;
            }
        }
        return true;
    }
    exports.startsWith = startsWith;
    /**
     * Determines if haystack ends with needle.
     */
    function endsWith(haystack, needle) {
        var diff = haystack.length - needle.length;
        if (diff > 0) {
            return haystack.lastIndexOf(needle) === haystack.length - needle.length;
        }
        else if (diff === 0) {
            return haystack === needle;
        }
        else {
            return false;
        }
    }
    exports.endsWith = endsWith;
    function createRegExp(searchString, isRegex, matchCase, wholeWord, global) {
        if (searchString === '') {
            throw new Error('Cannot create regex from empty string');
        }
        if (!isRegex) {
            searchString = searchString.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&');
        }
        if (wholeWord) {
            if (!/\B/.test(searchString.charAt(0))) {
                searchString = '\\b' + searchString;
            }
            if (!/\B/.test(searchString.charAt(searchString.length - 1))) {
                searchString = searchString + '\\b';
            }
        }
        var modifiers = '';
        if (global) {
            modifiers += 'g';
        }
        if (!matchCase) {
            modifiers += 'i';
        }
        return new RegExp(searchString, modifiers);
    }
    exports.createRegExp = createRegExp;
    /**
     * Create a regular expression only if it is valid and it doesn't lead to endless loop.
     */
    function createSafeRegExp(searchString, isRegex, matchCase, wholeWord) {
        if (searchString === '') {
            return null;
        }
        // Try to create a RegExp out of the params
        var regex = null;
        try {
            regex = createRegExp(searchString, isRegex, matchCase, wholeWord, true);
        }
        catch (err) {
            return null;
        }
        // Guard against endless loop RegExps & wrap around try-catch as very long regexes produce an exception when executed the first time
        try {
            if (regExpLeadsToEndlessLoop(regex)) {
                return null;
            }
        }
        catch (err) {
            return null;
        }
        return regex;
    }
    exports.createSafeRegExp = createSafeRegExp;
    function regExpLeadsToEndlessLoop(regexp) {
        // Exit early if it's one of these special cases which are meant to match
        // against an empty string
        if (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$') {
            return false;
        }
        // We check against an empty string. If the regular expression doesn't advance
        // (e.g. ends in an endless loop) it will match an empty string.
        var match = regexp.exec('');
        return (match && regexp.lastIndex === 0);
    }
    exports.regExpLeadsToEndlessLoop = regExpLeadsToEndlessLoop;
    /**
     * The normalize() method returns the Unicode Normalization Form of a given string. The form will be
     * the Normalization Form Canonical Composition.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize}
     */
    exports.canNormalize = typeof (''.normalize) === 'function';
    var nonAsciiCharactersPattern = /[^\u0000-\u0080]/;
    var normalizedCache = Object.create(null);
    var cacheCounter = 0;
    function normalizeNFC(str) {
        if (!exports.canNormalize || !str) {
            return str;
        }
        var cached = normalizedCache[str];
        if (cached) {
            return cached;
        }
        var res;
        if (nonAsciiCharactersPattern.test(str)) {
            res = str.normalize('NFC');
        }
        else {
            res = str;
        }
        // Use the cache for fast lookup but do not let it grow unbounded
        if (cacheCounter < 10000) {
            normalizedCache[str] = res;
            cacheCounter++;
        }
        return res;
    }
    exports.normalizeNFC = normalizeNFC;
    /**
     * Returns first index of the string that is not whitespace.
     * If string is empty or contains only whitespaces, returns -1
     */
    function firstNonWhitespaceIndex(str) {
        for (var i = 0, len = str.length; i < len; i++) {
            if (str.charAt(i) !== ' ' && str.charAt(i) !== '\t') {
                return i;
            }
        }
        return -1;
    }
    exports.firstNonWhitespaceIndex = firstNonWhitespaceIndex;
    /**
     * Returns the leading whitespace of the string.
     * If the string contains only whitespaces, returns entire string
     */
    function getLeadingWhitespace(str) {
        for (var i = 0, len = str.length; i < len; i++) {
            if (str.charAt(i) !== ' ' && str.charAt(i) !== '\t') {
                return str.substring(0, i);
            }
        }
        return str;
    }
    exports.getLeadingWhitespace = getLeadingWhitespace;
    /**
     * Returns last index of the string that is not whitespace.
     * If string is empty or contains only whitespaces, returns -1
     */
    function lastNonWhitespaceIndex(str) {
        for (var i = str.length - 1; i >= 0; i--) {
            if (str.charAt(i) !== ' ' && str.charAt(i) !== '\t') {
                return i;
            }
        }
        return -1;
    }
    exports.lastNonWhitespaceIndex = lastNonWhitespaceIndex;
    function localeCompare(strA, strB) {
        return strA.localeCompare(strB);
    }
    exports.localeCompare = localeCompare;
    function isAsciiChar(code) {
        return (code >= 97 && code <= 122) || (code >= 65 && code <= 90);
    }
    function equalsIgnoreCase(a, b) {
        var len1 = a.length, len2 = b.length;
        if (len1 !== len2) {
            return false;
        }
        for (var i = 0; i < len1; i++) {
            var codeA = a.charCodeAt(i), codeB = b.charCodeAt(i);
            if (codeA === codeB) {
                continue;
            }
            else if (isAsciiChar(codeA) && isAsciiChar(codeB)) {
                var diff = Math.abs(codeA - codeB);
                if (diff !== 0 && diff !== 32) {
                    return false;
                }
            }
            else {
                if (String.fromCharCode(codeA).toLocaleLowerCase() !== String.fromCharCode(codeB).toLocaleLowerCase()) {
                    return false;
                }
            }
        }
        return true;
    }
    exports.equalsIgnoreCase = equalsIgnoreCase;
    /**
     * @returns the length of the common prefix of the two strings.
     */
    function commonPrefixLength(a, b) {
        var i, len = Math.min(a.length, b.length);
        for (i = 0; i < len; i++) {
            if (a.charCodeAt(i) !== b.charCodeAt(i)) {
                return i;
            }
        }
        return len;
    }
    exports.commonPrefixLength = commonPrefixLength;
    /**
     * @returns the length of the common suffix of the two strings.
     */
    function commonSuffixLength(a, b) {
        var i, len = Math.min(a.length, b.length);
        var aLastIndex = a.length - 1;
        var bLastIndex = b.length - 1;
        for (i = 0; i < len; i++) {
            if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {
                return i;
            }
        }
        return len;
    }
    exports.commonSuffixLength = commonSuffixLength;
    // --- unicode
    // http://en.wikipedia.org/wiki/Surrogate_pair
    // Returns the code point starting at a specified index in a string
    // Code points U+0000 to U+D7FF and U+E000 to U+FFFF are represented on a single character
    // Code points U+10000 to U+10FFFF are represented on two consecutive characters
    //export function getUnicodePoint(str:string, index:number, len:number):number {
    //	let chrCode = str.charCodeAt(index);
    //	if (0xD800 <= chrCode && chrCode <= 0xDBFF && index + 1 < len) {
    //		let nextChrCode = str.charCodeAt(index + 1);
    //		if (0xDC00 <= nextChrCode && nextChrCode <= 0xDFFF) {
    //			return (chrCode - 0xD800) << 10 + (nextChrCode - 0xDC00) + 0x10000;
    //		}
    //	}
    //	return chrCode;
    //}
    //export function isLeadSurrogate(chr:string) {
    //	let chrCode = chr.charCodeAt(0);
    //	return ;
    //}
    //
    //export function isTrailSurrogate(chr:string) {
    //	let chrCode = chr.charCodeAt(0);
    //	return 0xDC00 <= chrCode && chrCode <= 0xDFFF;
    //}
    function isFullWidthCharacter(charCode) {
        // Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns
        // http://jrgraphix.net/research/unicode_blocks.php
        //          2E80 — 2EFF   CJK Radicals Supplement
        //          2F00 — 2FDF   Kangxi Radicals
        //          2FF0 — 2FFF   Ideographic Description Characters
        //          3000 — 303F   CJK Symbols and Punctuation
        //          3040 — 309F   Hiragana
        //          30A0 — 30FF   Katakana
        //          3100 — 312F   Bopomofo
        //          3130 — 318F   Hangul Compatibility Jamo
        //          3190 — 319F   Kanbun
        //          31A0 — 31BF   Bopomofo Extended
        //          31F0 — 31FF   Katakana Phonetic Extensions
        //          3200 — 32FF   Enclosed CJK Letters and Months
        //          3300 — 33FF   CJK Compatibility
        //          3400 — 4DBF   CJK Unified Ideographs Extension A
        //          4DC0 — 4DFF   Yijing Hexagram Symbols
        //          4E00 — 9FFF   CJK Unified Ideographs
        //          A000 — A48F   Yi Syllables
        //          A490 — A4CF   Yi Radicals
        //          AC00 — D7AF   Hangul Syllables
        // [IGNORE] D800 — DB7F   High Surrogates
        // [IGNORE] DB80 — DBFF   High Private Use Surrogates
        // [IGNORE] DC00 — DFFF   Low Surrogates
        // [IGNORE] E000 — F8FF   Private Use Area
        //          F900 — FAFF   CJK Compatibility Ideographs
        // [IGNORE] FB00 — FB4F   Alphabetic Presentation Forms
        // [IGNORE] FB50 — FDFF   Arabic Presentation Forms-A
        // [IGNORE] FE00 — FE0F   Variation Selectors
        // [IGNORE] FE20 — FE2F   Combining Half Marks
        // [IGNORE] FE30 — FE4F   CJK Compatibility Forms
        // [IGNORE] FE50 — FE6F   Small Form Variants
        // [IGNORE] FE70 — FEFF   Arabic Presentation Forms-B
        //          FF00 — FFEF   Halfwidth and Fullwidth Forms
        //               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]
        //               of which FF01 - FF5E fullwidth ASCII of 21 to 7E
        // [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul
        // [IGNORE] FFF0 — FFFF   Specials
        return ((charCode >= 0x2E80 && charCode <= 0xD7AF)
            || (charCode >= 0xF900 && charCode <= 0xFAFF)
            || (charCode >= 0xFF01 && charCode <= 0xFF5E));
    }
    exports.isFullWidthCharacter = isFullWidthCharacter;
    /**
     * Computes the difference score for two strings. More similar strings have a higher score.
     * We use largest common subsequence dynamic programming approach but penalize in the end for length differences.
     * Strings that have a large length difference will get a bad default score 0.
     * Complexity - both time and space O(first.length * second.length)
     * Dynamic programming LCS computation http://en.wikipedia.org/wiki/Longest_common_subsequence_problem
     *
     * @param first a string
     * @param second a string
     */
    function difference(first, second, maxLenDelta) {
        if (maxLenDelta === void 0) { maxLenDelta = 4; }
        var lengthDifference = Math.abs(first.length - second.length);
        // We only compute score if length of the currentWord and length of entry.name are similar.
        if (lengthDifference > maxLenDelta) {
            return 0;
        }
        // Initialize LCS (largest common subsequence) matrix.
        var LCS = [];
        var zeroArray = [];
        var i, j;
        for (i = 0; i < second.length + 1; ++i) {
            zeroArray.push(0);
        }
        for (i = 0; i < first.length + 1; ++i) {
            LCS.push(zeroArray);
        }
        for (i = 1; i < first.length + 1; ++i) {
            for (j = 1; j < second.length + 1; ++j) {
                if (first[i - 1] === second[j - 1]) {
                    LCS[i][j] = LCS[i - 1][j - 1] + 1;
                }
                else {
                    LCS[i][j] = Math.max(LCS[i - 1][j], LCS[i][j - 1]);
                }
            }
        }
        return LCS[first.length][second.length] - Math.sqrt(lengthDifference);
    }
    exports.difference = difference;
    /**
     * Returns an array in which every entry is the offset of a
     * line. There is always one entry which is zero.
     */
    function computeLineStarts(text) {
        var regexp = /\r\n|\r|\n/g, ret = [0], match;
        while ((match = regexp.exec(text))) {
            ret.push(regexp.lastIndex);
        }
        return ret;
    }
    exports.computeLineStarts = computeLineStarts;
    /**
     * Given a string and a max length returns a shorted version. Shorting
     * happens at favorable positions - such as whitespace or punctuation characters.
     */
    function lcut(text, n) {
        if (text.length < n) {
            return text;
        }
        var segments = text.split(/\b/), count = 0;
        for (var i = segments.length - 1; i >= 0; i--) {
            count += segments[i].length;
            if (count > n) {
                segments.splice(0, i);
                break;
            }
        }
        return segments.join(exports.empty).replace(/^\s/, exports.empty);
    }
    exports.lcut = lcut;
    // Escape codes
    // http://en.wikipedia.org/wiki/ANSI_escape_code
    var EL = /\x1B\x5B[12]?K/g; // Erase in line
    var LF = /\xA/g; // line feed
    var COLOR_START = /\x1b\[\d+m/g; // Color
    var COLOR_END = /\x1b\[0?m/g; // Color
    function removeAnsiEscapeCodes(str) {
        if (str) {
            str = str.replace(EL, '');
            str = str.replace(LF, '\n');
            str = str.replace(COLOR_START, '');
            str = str.replace(COLOR_END, '');
        }
        return str;
    }
    exports.removeAnsiEscapeCodes = removeAnsiEscapeCodes;
    // -- UTF-8 BOM
    var __utf8_bom = 65279;
    exports.UTF8_BOM_CHARACTER = String.fromCharCode(__utf8_bom);
    function startsWithUTF8BOM(str) {
        return (str && str.length > 0 && str.charCodeAt(0) === __utf8_bom);
    }
    exports.startsWithUTF8BOM = startsWithUTF8BOM;
});

define("vs/base/common/filters", ["require", "exports", 'vs/base/common/strings'], function (require, exports, strings) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // Combined filters
    /**
     * @returns A filter which combines the provided set
     * of filters with an or. The *first* filters that
     * matches defined the return value of the returned
     * filter.
     */
    function or() {
        var filter = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            filter[_i - 0] = arguments[_i];
        }
        return function (word, wordToMatchAgainst) {
            for (var i = 0, len = filter.length; i < len; i++) {
                var match = filter[i](word, wordToMatchAgainst);
                if (match) {
                    return match;
                }
            }
            return null;
        };
    }
    exports.or = or;
    /**
     * @returns A filter which combines the provided set
     * of filters with an and. The combines matches are
     * returned if *all* filters match.
     */
    function and() {
        var filter = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            filter[_i - 0] = arguments[_i];
        }
        return function (word, wordToMatchAgainst) {
            var result = [];
            for (var i = 0, len = filter.length; i < len; i++) {
                var match = filter[i](word, wordToMatchAgainst);
                if (!match) {
                    return null;
                }
                result = result.concat(match);
            }
            return result;
        };
    }
    exports.and = and;
    // Prefix
    exports.matchesStrictPrefix = function (word, wordToMatchAgainst) { return _matchesPrefix(false, word, wordToMatchAgainst); };
    exports.matchesPrefix = function (word, wordToMatchAgainst) { return _matchesPrefix(true, word, wordToMatchAgainst); };
    function _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {
        if (wordToMatchAgainst.length === 0 || wordToMatchAgainst.length < word.length) {
            return null;
        }
        if (ignoreCase) {
            word = word.toLowerCase();
            wordToMatchAgainst = wordToMatchAgainst.toLowerCase();
        }
        for (var i = 0; i < word.length; i++) {
            if (word[i] !== wordToMatchAgainst[i]) {
                return null;
            }
        }
        return word.length > 0 ? [{ start: 0, end: word.length }] : [];
    }
    // Contiguous Substring
    function matchesContiguousSubString(word, wordToMatchAgainst) {
        var index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());
        if (index === -1) {
            return null;
        }
        return [{ start: index, end: index + word.length }];
    }
    exports.matchesContiguousSubString = matchesContiguousSubString;
    // Substring
    function matchesSubString(word, wordToMatchAgainst) {
        return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);
    }
    exports.matchesSubString = matchesSubString;
    function _matchesSubString(word, wordToMatchAgainst, i, j) {
        if (i === word.length) {
            return [];
        }
        else if (j === wordToMatchAgainst.length) {
            return null;
        }
        else {
            if (word[i] === wordToMatchAgainst[j]) {
                var result = null;
                if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {
                    return join({ start: j, end: j + 1 }, result);
                }
            }
            return _matchesSubString(word, wordToMatchAgainst, i, j + 1);
        }
    }
    // CamelCase
    function isLower(code) {
        return 97 <= code && code <= 122;
    }
    function isUpper(code) {
        return 65 <= code && code <= 90;
    }
    function isNumber(code) {
        return 48 <= code && code <= 57;
    }
    function isWhitespace(code) {
        return [32, 9, 10, 13].indexOf(code) > -1;
    }
    function isAlphanumeric(code) {
        return isLower(code) || isUpper(code) || isNumber(code);
    }
    function join(head, tail) {
        if (tail.length === 0) {
            tail = [head];
        }
        else if (head.end === tail[0].start) {
            tail[0].start = head.start;
        }
        else {
            tail.unshift(head);
        }
        return tail;
    }
    function nextAnchor(camelCaseWord, start) {
        for (var i = start; i < camelCaseWord.length; i++) {
            var c = camelCaseWord.charCodeAt(i);
            if (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {
                return i;
            }
        }
        return camelCaseWord.length;
    }
    function _matchesCamelCase(word, camelCaseWord, i, j) {
        if (i === word.length) {
            return [];
        }
        else if (j === camelCaseWord.length) {
            return null;
        }
        else if (word[i] !== camelCaseWord[j].toLowerCase()) {
            return null;
        }
        else {
            var result = null;
            var nextUpperIndex = j + 1;
            result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);
            while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {
                result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);
                nextUpperIndex++;
            }
            return result === null ? null : join({ start: j, end: j + 1 }, result);
        }
    }
    // Heuristic to avoid computing camel case matcher for words that don't
    // look like camelCaseWords.
    function isCamelCaseWord(word) {
        if (word.length > 60) {
            return false;
        }
        var upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;
        for (var i = 0; i < word.length; i++) {
            code = word.charCodeAt(i);
            if (isUpper(code)) {
                upper++;
            }
            if (isLower(code)) {
                lower++;
            }
            if (isAlphanumeric(code)) {
                alpha++;
            }
            if (isNumber(code)) {
                numeric++;
            }
        }
        var upperPercent = upper / word.length;
        var lowerPercent = lower / word.length;
        var alphaPercent = alpha / word.length;
        var numericPercent = numeric / word.length;
        return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;
    }
    // Heuristic to avoid computing camel case matcher for words that don't
    // look like camel case patterns.
    function isCamelCasePattern(word) {
        var upper = 0, lower = 0, code = 0, whitespace = 0;
        for (var i = 0; i < word.length; i++) {
            code = word.charCodeAt(i);
            if (isUpper(code)) {
                upper++;
            }
            if (isLower(code)) {
                lower++;
            }
            if (isWhitespace(code)) {
                whitespace++;
            }
        }
        if ((upper === 0 || lower === 0) && whitespace === 0) {
            return word.length <= 30;
        }
        else {
            return upper <= 5;
        }
    }
    function matchesCamelCase(word, camelCaseWord) {
        if (camelCaseWord.length === 0) {
            return null;
        }
        if (!isCamelCasePattern(word)) {
            return null;
        }
        if (!isCamelCaseWord(camelCaseWord)) {
            return null;
        }
        var result = null;
        var i = 0;
        while (i < camelCaseWord.length && (result = _matchesCamelCase(word.toLowerCase(), camelCaseWord, 0, i)) === null) {
            i = nextAnchor(camelCaseWord, i + 1);
        }
        return result;
    }
    exports.matchesCamelCase = matchesCamelCase;
    // Fuzzy
    (function (SubstringMatching) {
        SubstringMatching[SubstringMatching["Contiguous"] = 0] = "Contiguous";
        SubstringMatching[SubstringMatching["Separate"] = 1] = "Separate";
    })(exports.SubstringMatching || (exports.SubstringMatching = {}));
    var SubstringMatching = exports.SubstringMatching;
    var fuzzyContiguousFilter = or(exports.matchesPrefix, matchesCamelCase, matchesContiguousSubString);
    var fuzzySeparateFilter = or(exports.matchesPrefix, matchesCamelCase, matchesSubString);
    var fuzzyRegExpCache = {};
    function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching) {
        if (enableSeparateSubstringMatching === void 0) { enableSeparateSubstringMatching = false; }
        // Form RegExp for wildcard matches
        var regexp = fuzzyRegExpCache[word];
        if (!regexp) {
            regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');
            fuzzyRegExpCache[word] = regexp;
        }
        // RegExp Filter
        var match = regexp.exec(wordToMatchAgainst);
        if (match) {
            return [{ start: match.index, end: match.index + match[0].length }];
        }
        // Default Filter
        return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);
    }
    exports.matchesFuzzy = matchesFuzzy;
});

define("vs/base/common/paths", ["require", "exports", 'vs/base/common/platform', 'vs/base/common/strings'], function (require, exports, platform_1, strings_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * The forward slash path separator.
     */
    exports.sep = '/';
    /**
     * The native path separator depending on the OS.
     */
    exports.nativeSep = platform_1.isWindows ? '\\' : '/';
    function relative(from, to) {
        from = normalize(from);
        to = normalize(to);
        var fromParts = from.split(exports.sep), toParts = to.split(exports.sep);
        while (fromParts.length > 0 && toParts.length > 0) {
            if (fromParts[0] === toParts[0]) {
                fromParts.shift();
                toParts.shift();
            }
            else {
                break;
            }
        }
        for (var i = 0, len = fromParts.length; i < len; i++) {
            toParts.unshift('..');
        }
        return toParts.join(exports.sep);
    }
    exports.relative = relative;
    var _dotSegment = /[\\\/]\.\.?[\\\/]?|[\\\/]?\.\.?[\\\/]/;
    function normalize(path, toOSPath) {
        if (!path) {
            return path;
        }
        // a path is already normal if it contains no .. or . parts
        // and already uses the proper path separator
        if (!_dotSegment.test(path)) {
            // badSep is the path separator we don't want. Usually
            // the backslash, unless isWindows && toOSPath
            var badSep = toOSPath && platform_1.isWindows ? '/' : '\\';
            if (path.indexOf(badSep) === -1) {
                return path;
            }
        }
        var parts = path.split(/[\\\/]/);
        for (var i = 0, len = parts.length; i < len; i++) {
            if (parts[i] === '.' && !!parts[i + 1]) {
                parts.splice(i, 1);
                i -= 1;
            }
            else if (parts[i] === '..' && !!parts[i - 1]) {
                parts.splice(i - 1, 2);
                i -= 2;
            }
        }
        return parts.join(toOSPath ? exports.nativeSep : exports.sep);
    }
    exports.normalize = normalize;
    function dirnames(path) {
        var value = path, done = false;
        function next() {
            if (value === '.' || value === '/' || value === '\\') {
                value = undefined;
                done = true;
            }
            else {
                value = dirname(value);
            }
            return {
                value: value,
                done: done
            };
        }
        return {
            next: next
        };
    }
    exports.dirnames = dirnames;
    /**
     * @returns the directory name of a path.
     */
    function dirname(path) {
        var idx = ~path.lastIndexOf('/') || ~path.lastIndexOf('\\');
        if (idx === 0) {
            return '.';
        }
        else if (~idx === 0) {
            return path[0];
        }
        else {
            return path.substring(0, ~idx);
        }
    }
    exports.dirname = dirname;
    /**
     * @returns the base name of a path.
     */
    function basename(path) {
        var idx = ~path.lastIndexOf('/') || ~path.lastIndexOf('\\');
        if (idx === 0) {
            return path;
        }
        else if (~idx === path.length - 1) {
            return basename(path.substring(0, path.length - 1));
        }
        else {
            return path.substr(~idx + 1);
        }
    }
    exports.basename = basename;
    /**
     * @returns {{.far}} from boo.far or the empty string.
     */
    function extname(path) {
        path = basename(path);
        var idx = ~path.lastIndexOf('.');
        return idx ? path.substring(~idx) : '';
    }
    exports.extname = extname;
    function getRootLength(path) {
        if (!path) {
            return 0;
        }
        path = path.replace(/\/|\\/g, '/');
        if (path[0] === '/') {
            if (path[1] !== '/') {
                // /far/boo
                return 1;
            }
            else {
                // //server/far/boo
                return 2;
            }
        }
        if (path[1] === ':') {
            if (path[2] === '/') {
                // c:/boo/far.txt
                return 3;
            }
            else {
                // c:
                return 2;
            }
        }
        if (path.indexOf('file:///') === 0) {
            return 8; // 8 -> 'file:///'.length
        }
        var idx = path.indexOf('://');
        if (idx !== -1) {
            return idx + 3; // 3 -> "://".length
        }
        return 0;
    }
    function join() {
        var parts = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            parts[_i - 0] = arguments[_i];
        }
        var rootLen = getRootLength(parts[0]), root;
        // simply preserve things like c:/, //localhost/, file:///, http://, etc
        root = parts[0].substr(0, rootLen);
        parts[0] = parts[0].substr(rootLen);
        var allParts = [], endsWithSep = /[\\\/]$/.test(parts[parts.length - 1]);
        for (var i = 0; i < parts.length; i++) {
            allParts.push.apply(allParts, parts[i].split(/\/|\\/));
        }
        for (var i = 0; i < allParts.length; i++) {
            var part = allParts[i];
            if (part === '.' || part.length === 0) {
                allParts.splice(i, 1);
                i -= 1;
            }
            else if (part === '..' && !!allParts[i - 1] && allParts[i - 1] !== '..') {
                allParts.splice(i - 1, 2);
                i -= 2;
            }
        }
        if (endsWithSep) {
            allParts.push('');
        }
        var ret = allParts.join('/');
        if (root) {
            ret = root.replace(/\/|\\/g, '/') + ret;
        }
        return ret;
    }
    exports.join = join;
    function isUNC(path) {
        if (!platform_1.isWindows || !path) {
            return false; // UNC is a windows concept
        }
        path = this.normalize(path, true);
        return path[0] === exports.nativeSep && path[1] === exports.nativeSep;
    }
    exports.isUNC = isUNC;
    function isPosixAbsolute(path) {
        return path && path[0] === '/';
    }
    function makeAbsolute(path, isPathNormalized) {
        return isPosixAbsolute(!isPathNormalized ? normalize(path) : path) ? path : exports.sep + path;
    }
    exports.makeAbsolute = makeAbsolute;
    function isRelative(path) {
        return path && path.length > 1 && path[0] === '.';
    }
    exports.isRelative = isRelative;
    var _slash = '/'.charCodeAt(0);
    function isEqualOrParent(path, candidate) {
        if (path === candidate) {
            return true;
        }
        path = normalize(path);
        candidate = normalize(candidate);
        var candidateLen = candidate.length;
        var lastCandidateChar = candidate.charCodeAt(candidateLen - 1);
        if (lastCandidateChar === _slash) {
            candidate = candidate.substring(0, candidateLen - 1);
            candidateLen -= 1;
        }
        if (path === candidate) {
            return true;
        }
        if (!platform_1.isLinux) {
            // case insensitive
            path = path.toLowerCase();
            candidate = candidate.toLowerCase();
        }
        if (path === candidate) {
            return true;
        }
        if (path.indexOf(candidate) !== 0) {
            return false;
        }
        var char = path.charCodeAt(candidateLen);
        return char === _slash;
    }
    exports.isEqualOrParent = isEqualOrParent;
    // Reference: https://en.wikipedia.org/wiki/Filename
    var INVALID_FILE_CHARS = platform_1.isWindows ? /[\\/:\*\?"<>\|]/g : /[\\/]/g;
    var WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\$|nul|lpt[0-9]|com[0-9])$/i;
    function isValidBasename(name) {
        if (!name || name.length === 0 || /^\s+$/.test(name)) {
            return false; // require a name that is not just whitespace
        }
        INVALID_FILE_CHARS.lastIndex = 0; // the holy grail of software development
        if (INVALID_FILE_CHARS.test(name)) {
            return false; // check for certain invalid file characters
        }
        if (platform_1.isWindows && WINDOWS_FORBIDDEN_NAMES.test(name)) {
            return false; // check for certain invalid file names
        }
        if (name === '.' || name === '..') {
            return false; // check for reserved values
        }
        if (platform_1.isWindows && strings_1.endsWith(name, '.')) {
            return false; // Windows: file cannot end with a "."
        }
        if (platform_1.isWindows && name.length !== name.trim().length) {
            return false; // Windows: file cannot end with a whitespace
        }
        return true;
    }
    exports.isValidBasename = isValidBasename;
    exports.isAbsoluteRegex = /^((\/|[a-zA-Z]:\\)[^\(\)<>\\'\"\[\]]+)/;
    /**
     * If you have access to node, it is recommended to use node's path.isAbsolute().
     * This is a simple regex based approach.
     */
    function isAbsolute(path) {
        return exports.isAbsoluteRegex.test(path);
    }
    exports.isAbsolute = isAbsolute;
});

define("vs/base/common/glob", ["require", "exports", 'vs/base/common/strings', 'vs/base/common/paths'], function (require, exports, strings, paths) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CACHE = Object.create(null);
    var PATH_REGEX = '[/\\\\]'; // any slash or backslash
    var NO_PATH_REGEX = '[^/\\\\]'; // any non-slash and non-backslash
    function starsToRegExp(starCount) {
        switch (starCount) {
            case 0:
                return '';
            case 1:
                return NO_PATH_REGEX + '*?'; // 1 star matches any number of characters except path separator (/ and \) - non greedy (?)
            default:
                // Matches:  (Path Sep    OR     Path Val followed by Path Sep     OR    Path Sep followed by Path Val) 0-many times
                // Group is non capturing because we don't need to capture at all (?:...)
                // Overall we use non-greedy matching because it could be that we match too much
                return '(?:' + PATH_REGEX + '|' + NO_PATH_REGEX + '+' + PATH_REGEX + '|' + PATH_REGEX + NO_PATH_REGEX + '+)*?';
        }
    }
    function splitGlobAware(pattern, splitChar) {
        if (!pattern) {
            return [];
        }
        var segments = [];
        var inBraces = false;
        var inBrackets = false;
        var char;
        var curVal = '';
        for (var i = 0; i < pattern.length; i++) {
            char = pattern[i];
            switch (char) {
                case splitChar:
                    if (!inBraces && !inBrackets) {
                        segments.push(curVal);
                        curVal = '';
                        continue;
                    }
                    break;
                case '{':
                    inBraces = true;
                    break;
                case '}':
                    inBraces = false;
                    break;
                case '[':
                    inBrackets = true;
                    break;
                case ']':
                    inBrackets = false;
                    break;
            }
            curVal += char;
        }
        // Tail
        if (curVal) {
            segments.push(curVal);
        }
        return segments;
    }
    exports.splitGlobAware = splitGlobAware;
    function parseRegExp(pattern) {
        if (!pattern) {
            return '';
        }
        var regEx = '';
        // Split up into segments for each slash found
        var segments = splitGlobAware(pattern, '/');
        // Special case where we only have globstars
        if (segments.every(function (s) { return s === '**'; })) {
            regEx = '.*';
        }
        else {
            var previousSegmentWasGlobStar_1 = false;
            segments.forEach(function (segment, index) {
                // Globstar is special
                if (segment === '**') {
                    // if we have more than one globstar after another, just ignore it
                    if (!previousSegmentWasGlobStar_1) {
                        regEx += starsToRegExp(2);
                        previousSegmentWasGlobStar_1 = true;
                    }
                    return;
                }
                // States
                var inBraces = false;
                var braceVal = '';
                var inBrackets = false;
                var bracketVal = '';
                var char;
                for (var i = 0; i < segment.length; i++) {
                    char = segment[i];
                    // Support brace expansion
                    if (char !== '}' && inBraces) {
                        braceVal += char;
                        continue;
                    }
                    // Support brackets
                    if (char !== ']' && inBrackets) {
                        var res = void 0;
                        switch (char) {
                            case '-':
                                res = char;
                                break;
                            case '^':
                                res = char;
                                break;
                            default:
                                res = strings.escapeRegExpCharacters(char);
                        }
                        bracketVal += res;
                        continue;
                    }
                    switch (char) {
                        case '{':
                            inBraces = true;
                            continue;
                        case '[':
                            inBrackets = true;
                            continue;
                        case '}':
                            var choices = splitGlobAware(braceVal, ',');
                            // Converts {foo,bar} => [foo|bar]
                            var braceRegExp = '(?:' + choices.reduce(function (prevValue, curValue, i, array) {
                                return prevValue + '|' + parseRegExp(curValue);
                            }, parseRegExp(choices[0]) /* parse the first segment as regex and give as initial value */) + ')';
                            regEx += braceRegExp;
                            inBraces = false;
                            braceVal = '';
                            break;
                        case ']':
                            regEx += ('[' + bracketVal + ']');
                            inBrackets = false;
                            bracketVal = '';
                            break;
                        case '?':
                            regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \)
                            continue;
                        case '*':
                            regEx += starsToRegExp(1);
                            continue;
                        default:
                            regEx += strings.escapeRegExpCharacters(char);
                    }
                }
                // Tail: Add the slash we had split on if there is more to come and the next one is not a globstar
                if (index < segments.length - 1 && segments[index + 1] !== '**') {
                    regEx += PATH_REGEX;
                }
                // reset state
                previousSegmentWasGlobStar_1 = false;
            });
        }
        return regEx;
    }
    function globToRegExp(pattern) {
        if (!pattern) {
            return null;
        }
        // Whitespace trimming
        pattern = pattern.trim();
        // Check cache
        if (CACHE[pattern]) {
            var cached = CACHE[pattern];
            cached.lastIndex = 0; // reset RegExp to its initial state to reuse it!
            return cached;
        }
        var regEx = parseRegExp(pattern);
        // Wrap it
        regEx = '^' + regEx + '$';
        // Convert to regexp and be ready for errors
        var result = toRegExp(regEx);
        // Make sure to cache
        CACHE[pattern] = result;
        return result;
    }
    function toRegExp(regEx) {
        try {
            return new RegExp(regEx);
        }
        catch (error) {
            return /.^/; // create a regex that matches nothing if we cannot parse the pattern
        }
    }
    function match(arg1, path, siblings) {
        if (!arg1 || !path) {
            return false;
        }
        // Glob with String
        if (typeof arg1 === 'string') {
            var regExp = globToRegExp(arg1);
            return regExp && regExp.test(path);
        }
        // Glob with Expression
        return matchExpression(arg1, path, siblings);
    }
    exports.match = match;
    function matchExpression(expression, path, siblings) {
        var patterns = Object.getOwnPropertyNames(expression);
        var basename;
        var _loop_1 = function(i) {
            var pattern = patterns[i];
            var value = expression[pattern];
            if (value === false) {
                return "continue"; // pattern is disabled
            }
            // Pattern matches path
            if (match(pattern, path)) {
                // Expression Pattern is <boolean>
                if (typeof value === 'boolean') {
                    return { value: pattern };
                }
                // Expression Pattern is <SiblingClause>
                if (value && typeof value.when === 'string') {
                    if (!siblings || !siblings.length) {
                        return "continue"; // pattern is malformed or we don't have siblings
                    }
                    if (!basename) {
                        basename = strings.rtrim(paths.basename(path), paths.extname(path));
                    }
                    var clause = value;
                    var clausePattern_1 = clause.when.replace('$(basename)', basename);
                    if (siblings.some(function (sibling) { return sibling === clausePattern_1; })) {
                        return { value: pattern };
                    }
                    else {
                        return "continue"; // pattern does not match in the end because the when clause is not satisfied
                    }
                }
                // Expression is Anything
                return { value: pattern };
            }
        };
        for (var i = 0; i < patterns.length; i++) {
            var state_1 = _loop_1(i);
            if (typeof state_1 === "object") return state_1.value;
            if (state_1 === "continue") continue;
        }
        return null;
    }
});

define("vs/base/common/types", ["require", "exports"], function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * @returns whether the provided parameter is a JavaScript Array or not.
     */
    function isArray(array) {
        if (Array.isArray) {
            return Array.isArray(array);
        }
        if (array && typeof (array.length) === 'number' && array.constructor === Array) {
            return true;
        }
        return false;
    }
    exports.isArray = isArray;
    /**
     * @returns whether the provided parameter is a JavaScript String or not.
     */
    function isString(str) {
        if (typeof (str) === 'string' || str instanceof String) {
            return true;
        }
        return false;
    }
    exports.isString = isString;
    /**
     * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.
     */
    function isStringArray(value) {
        return isArray(value) && value.every(function (elem) { return isString(elem); });
    }
    exports.isStringArray = isStringArray;
    /**
     * @returns whether the provided parameter is a JavaScript Object or not.
     */
    function isObject(obj) {
        // Needed for IE8
        if (typeof obj === 'undefined' || obj === null) {
            return false;
        }
        return Object.prototype.toString.call(obj) === '[object Object]';
    }
    exports.isObject = isObject;
    /**
     * @returns whether the provided parameter is a JavaScript Number or not.
     */
    function isNumber(obj) {
        if ((typeof (obj) === 'number' || obj instanceof Number) && !isNaN(obj)) {
            return true;
        }
        return false;
    }
    exports.isNumber = isNumber;
    /**
     * @returns whether the provided parameter is a JavaScript Boolean or not.
     */
    function isBoolean(obj) {
        return obj === true || obj === false;
    }
    exports.isBoolean = isBoolean;
    /**
     * @returns whether the provided parameter is undefined.
     */
    function isUndefined(obj) {
        return typeof (obj) === 'undefined';
    }
    exports.isUndefined = isUndefined;
    /**
     * @returns whether the provided parameter is undefined or null.
     */
    function isUndefinedOrNull(obj) {
        return isUndefined(obj) || obj === null;
    }
    exports.isUndefinedOrNull = isUndefinedOrNull;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    /**
     * @returns whether the provided parameter is an empty JavaScript Object or not.
     */
    function isEmptyObject(obj) {
        if (!isObject(obj)) {
            return false;
        }
        for (var key in obj) {
            if (hasOwnProperty.call(obj, key)) {
                return false;
            }
        }
        return true;
    }
    exports.isEmptyObject = isEmptyObject;
    /**
     * @returns whether the provided parameter is a JavaScript Function or not.
     */
    function isFunction(obj) {
        return Object.prototype.toString.call(obj) === '[object Function]';
    }
    exports.isFunction = isFunction;
    /**
     * @returns whether the provided parameters is are JavaScript Function or not.
     */
    function areFunctions() {
        var objects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            objects[_i - 0] = arguments[_i];
        }
        return objects && objects.length > 0 && objects.every(function (object) { return isFunction(object); });
    }
    exports.areFunctions = areFunctions;
    function validateConstraints(args, constraints) {
        var len = Math.min(args.length, constraints.length);
        for (var i = 0; i < len; i++) {
            validateConstraint(args[i], constraints[i]);
        }
    }
    exports.validateConstraints = validateConstraints;
    function validateConstraint(arg, constraint) {
        if (typeof constraint === 'string') {
            if (typeof arg !== constraint) {
                throw new Error("argument does not match constraint: typeof " + constraint);
            }
        }
        else if (typeof constraint === 'function') {
            if (arg instanceof constraint) {
                return;
            }
            if (arg && arg.constructor === constraint) {
                return;
            }
            if (constraint.length === 1 && constraint.call(undefined, arg) === true) {
                return;
            }
            throw new Error("argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true");
        }
    }
    exports.validateConstraint = validateConstraint;
    /**
     * Creates a new object of the provided class and will call the constructor with
     * any additional argument supplied.
     */
    function create(ctor) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var obj = Object.create(ctor.prototype);
        ctor.apply(obj, args);
        return obj;
    }
    exports.create = create;
});

define("vs/base/common/graph", ["require", "exports", 'vs/base/common/types', 'vs/base/common/collections'], function (require, exports, objects, collections) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function newNode(data) {
        return {
            data: data,
            incoming: {},
            outgoing: {}
        };
    }
    exports.newNode = newNode;
    var Graph = (function () {
        function Graph(_hashFn) {
            this._hashFn = _hashFn;
            this._nodes = Object.create(null);
            // empty
        }
        Graph.prototype.roots = function () {
            var ret = [];
            collections.forEach(this._nodes, function (entry) {
                if (objects.isEmptyObject(entry.value.outgoing)) {
                    ret.push(entry.value);
                }
            });
            return ret;
        };
        Graph.prototype.traverse = function (start, inwards, callback) {
            var startNode = this.lookup(start);
            if (!startNode) {
                return;
            }
            this._traverse(startNode, inwards, {}, callback);
        };
        Graph.prototype._traverse = function (node, inwards, seen, callback) {
            var _this = this;
            var key = this._hashFn(node.data);
            if (collections.contains(seen, key)) {
                return;
            }
            seen[key] = true;
            callback(node.data);
            var nodes = inwards ? node.outgoing : node.incoming;
            collections.forEach(nodes, function (entry) { return _this._traverse(entry.value, inwards, seen, callback); });
        };
        Graph.prototype.insertEdge = function (from, to) {
            var fromNode = this.lookupOrInsertNode(from), toNode = this.lookupOrInsertNode(to);
            fromNode.outgoing[this._hashFn(to)] = toNode;
            toNode.incoming[this._hashFn(from)] = fromNode;
        };
        Graph.prototype.removeNode = function (data) {
            var key = this._hashFn(data);
            delete this._nodes[key];
            collections.forEach(this._nodes, function (entry) {
                delete entry.value.outgoing[key];
                delete entry.value.incoming[key];
            });
        };
        Graph.prototype.lookupOrInsertNode = function (data) {
            var key = this._hashFn(data), node = collections.lookup(this._nodes, key);
            if (!node) {
                node = newNode(data);
                this._nodes[key] = node;
            }
            return node;
        };
        Graph.prototype.lookup = function (data) {
            return collections.lookup(this._nodes, this._hashFn(data));
        };
        Object.defineProperty(Graph.prototype, "length", {
            get: function () {
                return Object.keys(this._nodes).length;
            },
            enumerable: true,
            configurable: true
        });
        return Graph;
    }());
    exports.Graph = Graph;
});

define("vs/base/common/labels", ["require", "exports", 'vs/base/common/platform', 'vs/base/common/types', 'vs/base/common/strings', 'vs/base/common/paths'], function (require, exports, platform, types, strings, paths) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var PathLabelProvider = (function () {
        function PathLabelProvider(arg1) {
            this.root = arg1 && getPath(arg1);
        }
        PathLabelProvider.prototype.getLabel = function (arg1) {
            return getPathLabel(getPath(arg1), this.root);
        };
        return PathLabelProvider;
    }());
    exports.PathLabelProvider = PathLabelProvider;
    function getPathLabel(arg1, arg2) {
        var basepath = arg2 && getPath(arg2);
        var absolutePath = getPath(arg1);
        if (basepath && paths.isEqualOrParent(absolutePath, basepath)) {
            return paths.normalize(strings.ltrim(absolutePath.substr(basepath.length), paths.nativeSep), true);
        }
        if (platform.isWindows && absolutePath[1] === ':') {
            return paths.normalize(absolutePath.charAt(0).toUpperCase() + absolutePath.slice(1), true);
        }
        return paths.normalize(absolutePath, true);
    }
    exports.getPathLabel = getPathLabel;
    function getPath(arg1) {
        if (!arg1) {
            return null;
        }
        if (typeof arg1 === 'string') {
            return arg1;
        }
        if (types.isFunction(arg1.getWorkspace)) {
            var ws = arg1.getWorkspace();
            return ws ? ws.resource.fsPath : void 0;
        }
        return arg1.fsPath;
    }
});

define("vs/base/common/mime", ["require", "exports", 'vs/base/common/paths', 'vs/base/common/types', 'vs/base/common/strings', 'vs/base/common/glob'], function (require, exports, paths, types, strings, glob_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.MIME_TEXT = 'text/plain';
    exports.MIME_BINARY = 'application/octet-stream';
    exports.MIME_UNKNOWN = 'application/unknown';
    var registeredAssociations = [];
    /**
     * Associate a text mime to the registry.
     */
    function registerTextMime(association) {
        // Register
        registeredAssociations.push(association);
        // Check for conflicts unless this is a user configured association
        if (!association.userConfigured) {
            registeredAssociations.forEach(function (a) {
                if (a.mime === association.mime || a.userConfigured) {
                    return; // same mime or userConfigured is ok
                }
                if (association.extension && a.extension === association.extension) {
                    console.warn("Overwriting extension <<" + association.extension + ">> to now point to mime <<" + association.mime + ">>");
                }
                if (association.filename && a.filename === association.filename) {
                    console.warn("Overwriting filename <<" + association.filename + ">> to now point to mime <<" + association.mime + ">>");
                }
                if (association.filepattern && a.filepattern === association.filepattern) {
                    console.warn("Overwriting filepattern <<" + association.filepattern + ">> to now point to mime <<" + association.mime + ">>");
                }
                if (association.firstline && a.firstline === association.firstline) {
                    console.warn("Overwriting firstline <<" + association.firstline + ">> to now point to mime <<" + association.mime + ">>");
                }
            });
        }
    }
    exports.registerTextMime = registerTextMime;
    /**
     * Clear text mimes from the registry.
     */
    function clearTextMimes(onlyUserConfigured) {
        if (!onlyUserConfigured) {
            registeredAssociations = [];
        }
        else {
            registeredAssociations = registeredAssociations.filter(function (a) { return !a.userConfigured; });
        }
    }
    exports.clearTextMimes = clearTextMimes;
    /**
     * Given a file, return the best matching mime type for it
     */
    function guessMimeTypes(path, firstLine) {
        if (!path) {
            return [exports.MIME_UNKNOWN];
        }
        path = path.toLowerCase();
        // 1.) User configured mappings have highest priority
        var configuredMime = guessMimeTypeByPath(path, registeredAssociations.filter(function (a) { return a.userConfigured; }));
        if (configuredMime) {
            return [configuredMime, exports.MIME_TEXT];
        }
        // 2.) Registered mappings have middle priority
        var registeredMime = guessMimeTypeByPath(path, registeredAssociations.filter(function (a) { return !a.userConfigured; }));
        if (registeredMime) {
            return [registeredMime, exports.MIME_TEXT];
        }
        // 3.) Firstline has lowest priority
        if (firstLine) {
            var firstlineMime = guessMimeTypeByFirstline(firstLine);
            if (firstlineMime) {
                return [firstlineMime, exports.MIME_TEXT];
            }
        }
        return [exports.MIME_UNKNOWN];
    }
    exports.guessMimeTypes = guessMimeTypes;
    function guessMimeTypeByPath(path, associations) {
        var filename = paths.basename(path);
        var filenameMatch;
        var patternMatch;
        var extensionMatch;
        for (var i = 0; i < associations.length; i++) {
            var association = associations[i];
            // First exact name match
            if (association.filename && filename === association.filename.toLowerCase()) {
                filenameMatch = association;
                break; // take it!
            }
            // Longest pattern match
            if (association.filepattern) {
                var target = association.filepattern.indexOf(paths.sep) >= 0 ? path : filename; // match on full path if pattern contains path separator
                if (glob_1.match(association.filepattern.toLowerCase(), target)) {
                    if (!patternMatch || association.filepattern.length > patternMatch.filepattern.length) {
                        patternMatch = association;
                    }
                }
            }
            // Longest extension match
            if (association.extension) {
                if (strings.endsWith(filename, association.extension.toLowerCase())) {
                    if (!extensionMatch || association.extension.length > extensionMatch.extension.length) {
                        extensionMatch = association;
                    }
                }
            }
        }
        // 1.) Exact name match has second highest prio
        if (filenameMatch) {
            return filenameMatch.mime;
        }
        // 2.) Match on pattern
        if (patternMatch) {
            return patternMatch.mime;
        }
        // 3.) Match on extension comes next
        if (extensionMatch) {
            return extensionMatch.mime;
        }
        return null;
    }
    function guessMimeTypeByFirstline(firstLine) {
        if (strings.startsWithUTF8BOM(firstLine)) {
            firstLine = firstLine.substr(1);
        }
        if (firstLine.length > 0) {
            for (var i = 0; i < registeredAssociations.length; ++i) {
                var association = registeredAssociations[i];
                if (!association.firstline) {
                    continue;
                }
                // Make sure the entire line matches, not just a subpart.
                var matches = firstLine.match(association.firstline);
                if (matches && matches.length > 0 && matches[0].length === firstLine.length) {
                    return association.mime;
                }
            }
        }
        return null;
    }
    function isBinaryMime(mimes) {
        if (!mimes) {
            return false;
        }
        var mimeVals;
        if (types.isArray(mimes)) {
            mimeVals = mimes;
        }
        else {
            mimeVals = mimes.split(',').map(function (mime) { return mime.trim(); });
        }
        return mimeVals.indexOf(exports.MIME_BINARY) >= 0;
    }
    exports.isBinaryMime = isBinaryMime;
    function isUnspecific(mime) {
        if (!mime) {
            return true;
        }
        if (typeof mime === 'string') {
            return mime === exports.MIME_BINARY || mime === exports.MIME_TEXT || mime === exports.MIME_UNKNOWN;
        }
        return mime.length === 1 && isUnspecific(mime[0]);
    }
    exports.isUnspecific = isUnspecific;
    function suggestFilename(theMime, prefix) {
        for (var i = 0; i < registeredAssociations.length; i++) {
            var association = registeredAssociations[i];
            if (association.userConfigured) {
                continue; // only support registered ones
            }
            if (association.mime === theMime && association.extension) {
                return prefix + association.extension;
            }
        }
        return null;
    }
    exports.suggestFilename = suggestFilename;
});

define("vs/base/common/objects", ["require", "exports", 'vs/base/common/types'], function (require, exports, Types) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function clone(obj) {
        if (!obj || typeof obj !== 'object') {
            return obj;
        }
        if (obj instanceof RegExp) {
            return obj;
        }
        var result = (Array.isArray(obj)) ? [] : {};
        Object.keys(obj).forEach(function (key) {
            if (obj[key] && typeof obj[key] === 'object') {
                result[key] = clone(obj[key]);
            }
            else {
                result[key] = obj[key];
            }
        });
        return result;
    }
    exports.clone = clone;
    function deepClone(obj) {
        if (!obj || typeof obj !== 'object') {
            return obj;
        }
        var result = (Array.isArray(obj)) ? [] : {};
        Object.getOwnPropertyNames(obj).forEach(function (key) {
            if (obj[key] && typeof obj[key] === 'object') {
                result[key] = deepClone(obj[key]);
            }
            else {
                result[key] = obj[key];
            }
        });
        return result;
    }
    exports.deepClone = deepClone;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function cloneAndChange(obj, changer) {
        return _cloneAndChange(obj, changer, []);
    }
    exports.cloneAndChange = cloneAndChange;
    function _cloneAndChange(obj, changer, encounteredObjects) {
        if (Types.isUndefinedOrNull(obj)) {
            return obj;
        }
        var changed = changer(obj);
        if (typeof changed !== 'undefined') {
            return changed;
        }
        if (Types.isArray(obj)) {
            var r1 = [];
            for (var i1 = 0; i1 < obj.length; i1++) {
                r1.push(_cloneAndChange(obj[i1], changer, encounteredObjects));
            }
            return r1;
        }
        if (Types.isObject(obj)) {
            if (encounteredObjects.indexOf(obj) >= 0) {
                throw new Error('Cannot clone recursive data-structure');
            }
            encounteredObjects.push(obj);
            var r2 = {};
            for (var i2 in obj) {
                if (hasOwnProperty.call(obj, i2)) {
                    r2[i2] = _cloneAndChange(obj[i2], changer, encounteredObjects);
                }
            }
            encounteredObjects.pop();
            return r2;
        }
        return obj;
    }
    // DON'T USE THESE FUNCTION UNLESS YOU KNOW HOW CHROME
    // WORKS... WE HAVE SEEN VERY WEIRD BEHAVIOUR WITH CHROME >= 37
    ///**
    // * Recursively call Object.freeze on object and any properties that are objects.
    // */
    //export function deepFreeze(obj:any):void {
    //	Object.freeze(obj);
    //	Object.keys(obj).forEach((key) => {
    //		if(!(typeof obj[key] === 'object') || Object.isFrozen(obj[key])) {
    //			return;
    //		}
    //
    //		deepFreeze(obj[key]);
    //	});
    //	if(!Object.isFrozen(obj)) {
    //		console.log('too warm');
    //	}
    //}
    //
    //export function deepSeal(obj:any):void {
    //	Object.seal(obj);
    //	Object.keys(obj).forEach((key) => {
    //		if(!(typeof obj[key] === 'object') || Object.isSealed(obj[key])) {
    //			return;
    //		}
    //
    //		deepSeal(obj[key]);
    //	});
    //	if(!Object.isSealed(obj)) {
    //		console.log('NOT sealed');
    //	}
    //}
    /**
     * Copies all properties of source into destination. The optional parameter "overwrite" allows to control
     * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).
     */
    function mixin(destination, source, overwrite) {
        if (overwrite === void 0) { overwrite = true; }
        if (!Types.isObject(destination)) {
            return source;
        }
        if (Types.isObject(source)) {
            Object.keys(source).forEach(function (key) {
                if (key in destination) {
                    if (overwrite) {
                        if (Types.isObject(destination[key]) && Types.isObject(source[key])) {
                            mixin(destination[key], source[key], overwrite);
                        }
                        else {
                            destination[key] = source[key];
                        }
                    }
                }
                else {
                    destination[key] = source[key];
                }
            });
        }
        return destination;
    }
    exports.mixin = mixin;
    function assign(destination) {
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        sources.forEach(function (source) { return Object.keys(source).forEach(function (key) { return destination[key] = source[key]; }); });
        return destination;
    }
    exports.assign = assign;
    function toObject(arr, keyMap, valueMap) {
        if (valueMap === void 0) { valueMap = function (x) { return x; }; }
        return arr.reduce(function (o, d) { return assign(o, (_a = {}, _a[keyMap(d)] = valueMap(d), _a)); var _a; }, Object.create(null));
    }
    exports.toObject = toObject;
    /**
     * Returns a new object that has all values of {{obj}}
     * plus those from {{defaults}}.
     */
    function withDefaults(obj, defaults) {
        return mixin(clone(defaults), obj || {});
    }
    exports.withDefaults = withDefaults;
    function equals(one, other) {
        if (one === other) {
            return true;
        }
        if (one === null || one === undefined || other === null || other === undefined) {
            return false;
        }
        if (typeof one !== typeof other) {
            return false;
        }
        if (typeof one !== 'object') {
            return false;
        }
        if ((Array.isArray(one)) !== (Array.isArray(other))) {
            return false;
        }
        var i, key;
        if (Array.isArray(one)) {
            if (one.length !== other.length) {
                return false;
            }
            for (i = 0; i < one.length; i++) {
                if (!equals(one[i], other[i])) {
                    return false;
                }
            }
        }
        else {
            var oneKeys = [];
            for (key in one) {
                oneKeys.push(key);
            }
            oneKeys.sort();
            var otherKeys = [];
            for (key in other) {
                otherKeys.push(key);
            }
            otherKeys.sort();
            if (!equals(oneKeys, otherKeys)) {
                return false;
            }
            for (i = 0; i < oneKeys.length; i++) {
                if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {
                    return false;
                }
            }
        }
        return true;
    }
    exports.equals = equals;
    function ensureProperty(obj, property, defaultValue) {
        if (typeof obj[property] === 'undefined') {
            obj[property] = defaultValue;
        }
    }
    exports.ensureProperty = ensureProperty;
    function arrayToHash(array) {
        var result = {};
        for (var i = 0; i < array.length; ++i) {
            result[array[i]] = true;
        }
        return result;
    }
    exports.arrayToHash = arrayToHash;
    /**
     * Given an array of strings, returns a function which, given a string
     * returns true or false whether the string is in that array.
     */
    function createKeywordMatcher(arr, caseInsensitive) {
        if (caseInsensitive === void 0) { caseInsensitive = false; }
        if (caseInsensitive) {
            arr = arr.map(function (x) { return x.toLowerCase(); });
        }
        var hash = arrayToHash(arr);
        if (caseInsensitive) {
            return function (word) {
                return hash[word.toLowerCase()] !== undefined && hash.hasOwnProperty(word.toLowerCase());
            };
        }
        else {
            return function (word) {
                return hash[word] !== undefined && hash.hasOwnProperty(word);
            };
        }
    }
    exports.createKeywordMatcher = createKeywordMatcher;
    /**
     * Started from TypeScript's __extends function to make a type a subclass of a specific class.
     * Modified to work with properties already defined on the derivedClass, since we can't get TS
     * to call this method before the constructor definition.
     */
    function derive(baseClass, derivedClass) {
        for (var prop in baseClass) {
            if (baseClass.hasOwnProperty(prop)) {
                derivedClass[prop] = baseClass[prop];
            }
        }
        derivedClass = derivedClass || function () { };
        var basePrototype = baseClass.prototype;
        var derivedPrototype = derivedClass.prototype;
        derivedClass.prototype = Object.create(basePrototype);
        for (var prop in derivedPrototype) {
            if (derivedPrototype.hasOwnProperty(prop)) {
                // handle getters and setters properly
                Object.defineProperty(derivedClass.prototype, prop, Object.getOwnPropertyDescriptor(derivedPrototype, prop));
            }
        }
        // Cast to any due to Bug 16188:PropertyDescriptor set and get function should be optional.
        Object.defineProperty(derivedClass.prototype, 'constructor', { value: derivedClass, writable: true, configurable: true, enumerable: true });
    }
    exports.derive = derive;
    /**
     * Calls JSON.Stringify with a replacer to break apart any circular references.
     * This prevents JSON.stringify from throwing the exception
     *  "Uncaught TypeError: Converting circular structure to JSON"
     */
    function safeStringify(obj) {
        var seen = [];
        return JSON.stringify(obj, function (key, value) {
            if (Types.isObject(value) || Array.isArray(value)) {
                if (seen.indexOf(value) !== -1) {
                    return '[Circular]';
                }
                else {
                    seen.push(value);
                }
            }
            return value;
        });
    }
    exports.safeStringify = safeStringify;
});

define("vs/base/common/uri", ["require", "exports", 'vs/base/common/platform'], function (require, exports, platform) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent
    function fixedEncodeURIComponent(str) {
        return encodeURIComponent(str).replace(/[!'()*]/g, function (c) { return '%' + c.charCodeAt(0).toString(16).toUpperCase(); });
    }
    /**
     * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.
     * This class is a simple parser which creates the basic component paths
     * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
     * and encoding.
     *
     *       foo://example.com:8042/over/there?name=ferret#nose
     *       \_/   \______________/\_________/ \_________/ \__/
     *        |           |            |            |        |
     *     scheme     authority       path        query   fragment
     *        |   _____________________|__
     *       / \ /                        \
     *       urn:example:animal:ferret:nose
     *
     *
     */
    var URI = (function () {
        function URI() {
            this._scheme = URI._empty;
            this._authority = URI._empty;
            this._path = URI._empty;
            this._query = URI._empty;
            this._fragment = URI._empty;
        }
        Object.defineProperty(URI.prototype, "scheme", {
            /**
             * scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.
             * The part before the first colon.
             */
            get: function () {
                return this._scheme;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URI.prototype, "authority", {
            /**
             * authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.
             * The part between the first double slashes and the next slash.
             */
            get: function () {
                return this._authority;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URI.prototype, "path", {
            /**
             * path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.
             */
            get: function () {
                return this._path;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URI.prototype, "query", {
            /**
             * query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.
             */
            get: function () {
                return this._query;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URI.prototype, "fragment", {
            /**
             * fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.
             */
            get: function () {
                return this._fragment;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URI.prototype, "fsPath", {
            /**
             * Returns a string representing the corresponding file system path of this URI.
             * Will handle UNC paths and normalize windows drive letters to lower-case. Also
             * uses the platform specific path separator. Will *not* validate the path for
             * invalid characters and semantics. Will *not* look at the scheme of this URI.
             */
            get: function () {
                if (!this._fsPath) {
                    var value;
                    if (this._authority && this.scheme === 'file') {
                        // unc path: file://shares/c$/far/boo
                        value = "//" + this._authority + this._path;
                    }
                    else if (URI._driveLetterPath.test(this._path)) {
                        // windows drive letter: file:///c:/far/boo
                        value = this._path[1].toLowerCase() + this._path.substr(2);
                    }
                    else {
                        // other path
                        value = this._path;
                    }
                    if (platform.isWindows) {
                        value = value.replace(/\//g, '\\');
                    }
                    this._fsPath = value;
                }
                return this._fsPath;
            },
            enumerable: true,
            configurable: true
        });
        // ---- modify to new -------------------------
        URI.prototype.with = function (scheme, authority, path, query, fragment) {
            var ret = new URI();
            ret._scheme = scheme || this.scheme;
            ret._authority = authority || this.authority;
            ret._path = path || this.path;
            ret._query = query || this.query;
            ret._fragment = fragment || this.fragment;
            URI._validate(ret);
            return ret;
        };
        URI.prototype.withScheme = function (value) {
            return this.with(value, undefined, undefined, undefined, undefined);
        };
        URI.prototype.withAuthority = function (value) {
            return this.with(undefined, value, undefined, undefined, undefined);
        };
        URI.prototype.withPath = function (value) {
            return this.with(undefined, undefined, value, undefined, undefined);
        };
        URI.prototype.withQuery = function (value) {
            return this.with(undefined, undefined, undefined, value, undefined);
        };
        URI.prototype.withFragment = function (value) {
            return this.with(undefined, undefined, undefined, undefined, value);
        };
        // ---- parse & validate ------------------------
        URI.parse = function (value) {
            var ret = new URI();
            var data = URI._parseComponents(value);
            ret._scheme = data.scheme;
            ret._authority = decodeURIComponent(data.authority);
            ret._path = decodeURIComponent(data.path);
            ret._query = decodeURIComponent(data.query);
            ret._fragment = decodeURIComponent(data.fragment);
            URI._validate(ret);
            return ret;
        };
        URI.file = function (path) {
            path = path.replace(/\\/g, '/');
            path = path.replace(/%/g, '%25');
            path = path.replace(/#/g, '%23');
            path = path.replace(/\?/g, '%3F');
            // makes sure something like 'C:/Users' isn't
            // parsed as scheme='C', path='Users'
            path = URI._driveLetter.test(path)
                ? '/' + path
                : path;
            var data = URI._parseComponents(path);
            if (data.scheme || data.fragment || data.query) {
                throw new Error('Path contains a scheme, fragment or a query. Can not convert it to a file uri.');
            }
            var ret = new URI();
            ret._scheme = 'file';
            ret._authority = data.authority;
            ret._path = decodeURIComponent(data.path[0] === '/' ? data.path : '/' + data.path); // path starts with slash
            ret._query = data.query;
            ret._fragment = data.fragment;
            URI._validate(ret);
            return ret;
        };
        URI._parseComponents = function (value) {
            var ret = {
                scheme: URI._empty,
                authority: URI._empty,
                path: URI._empty,
                query: URI._empty,
                fragment: URI._empty,
            };
            var match = URI._regexp.exec(value);
            if (match) {
                ret.scheme = match[2] || ret.scheme;
                ret.authority = match[4] || ret.authority;
                ret.path = match[5] || ret.path;
                ret.query = match[7] || ret.query;
                ret.fragment = match[9] || ret.fragment;
            }
            return ret;
        };
        URI.create = function (scheme, authority, path, query, fragment) {
            return new URI().with(scheme, authority, path, query, fragment);
        };
        URI._validate = function (ret) {
            // validation
            // path, http://tools.ietf.org/html/rfc3986#section-3.3
            // If a URI contains an authority component, then the path component
            // must either be empty or begin with a slash ("/") character.  If a URI
            // does not contain an authority component, then the path cannot begin
            // with two slash characters ("//").
            if (ret.authority && ret.path && ret.path[0] !== '/') {
                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
            }
            if (!ret.authority && ret.path.indexOf('//') === 0) {
                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
            }
        };
        URI.prototype.toString = function () {
            if (!this._formatted) {
                var parts = [];
                if (this._scheme) {
                    parts.push(this._scheme);
                    parts.push(':');
                }
                if (this._authority || this._scheme === 'file') {
                    parts.push('//');
                }
                if (this._authority) {
                    var authority = this._authority, idx;
                    authority = authority.toLowerCase();
                    idx = authority.indexOf(':');
                    if (idx === -1) {
                        parts.push(fixedEncodeURIComponent(authority));
                    }
                    else {
                        parts.push(fixedEncodeURIComponent(authority.substr(0, idx)));
                        parts.push(authority.substr(idx));
                    }
                }
                if (this._path) {
                    // encode every segment of the path
                    var path = this._path, segments;
                    // lower-case win drive letters in /C:/fff
                    if (URI._driveLetterPath.test(path)) {
                        path = '/' + path[1].toLowerCase() + path.substr(2);
                    }
                    else if (URI._driveLetter.test(path)) {
                        path = path[0].toLowerCase() + path.substr(1);
                    }
                    segments = path.split('/');
                    for (var i = 0, len = segments.length; i < len; i++) {
                        segments[i] = fixedEncodeURIComponent(segments[i]);
                    }
                    parts.push(segments.join('/'));
                }
                if (this._query) {
                    // in http(s) querys often use 'key=value'-pairs and
                    // ampersand characters for multiple pairs
                    var encoder = /https?/i.test(this.scheme)
                        ? encodeURI
                        : fixedEncodeURIComponent;
                    parts.push('?');
                    parts.push(encoder(this._query));
                }
                if (this._fragment) {
                    parts.push('#');
                    parts.push(fixedEncodeURIComponent(this._fragment));
                }
                this._formatted = parts.join('');
            }
            return this._formatted;
        };
        URI.prototype.toJSON = function () {
            return {
                scheme: this.scheme,
                authority: this.authority,
                path: this.path,
                fsPath: this.fsPath,
                query: this.query,
                fragment: this.fragment.replace(/URL_MARSHAL_REMOVE.*$/, ''),
                external: this.toString().replace(/#?URL_MARSHAL_REMOVE.*$/, ''),
                $mid: 1
            };
        };
        URI.revive = function (data) {
            var result = new URI();
            result._scheme = data.scheme;
            result._authority = data.authority;
            result._path = data.path;
            result._query = data.query;
            result._fragment = data.fragment;
            result._fsPath = data.fsPath;
            result._formatted = data.external;
            URI._validate(result);
            return result;
        };
        URI._empty = '';
        URI._regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
        URI._driveLetterPath = /^\/[a-zA-z]:/;
        URI._driveLetter = /^[a-zA-z]:/;
        return URI;
    }());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = URI;
});

define("vs/base/common/marshalling", ["require", "exports", 'vs/base/common/uri'], function (require, exports, uri_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function stringify(obj) {
        return JSON.stringify(obj, replacer);
    }
    exports.stringify = stringify;
    function parse(text) {
        return JSON.parse(text, reviver);
    }
    exports.parse = parse;
    function replacer(key, value) {
        // URI is done via toJSON-member
        if (value instanceof RegExp) {
            return {
                $mid: 2,
                source: value.source,
                flags: (value.global ? 'g' : '') + (value.ignoreCase ? 'i' : '') + (value.multiline ? 'm' : ''),
            };
        }
        return value;
    }
    function reviver(key, value) {
        var marshallingConst;
        if (value !== void 0 && value !== null) {
            marshallingConst = value.$mid;
        }
        if (marshallingConst === 1) {
            return uri_1.default.revive(value);
        }
        else if (marshallingConst === 2) {
            return new RegExp(value.source, value.flags);
        }
        else {
            return value;
        }
    }
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("vs/base/common/uuid", ["require", "exports"], function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ValueUUID = (function () {
        function ValueUUID(_value) {
            this._value = _value;
            // empty
        }
        ValueUUID.prototype.asHex = function () {
            return this._value;
        };
        ValueUUID.prototype.equals = function (other) {
            return this.asHex() === other.asHex();
        };
        return ValueUUID;
    }());
    var V4UUID = (function (_super) {
        __extends(V4UUID, _super);
        function V4UUID() {
            _super.call(this, [
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                '4',
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                V4UUID._oneOf(V4UUID._timeHighBits),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
            ].join(''));
        }
        V4UUID._oneOf = function (array) {
            var idx = Math.floor(array.length * Math.random());
            return array[idx];
        };
        V4UUID._randomHex = function () {
            return V4UUID._oneOf(V4UUID._chars);
        };
        V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
        V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
        return V4UUID;
    }(ValueUUID));
    /**
     * An empty UUID that contains only zeros.
     */
    exports.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');
    function v4() {
        return new V4UUID();
    }
    exports.v4 = v4;
    var _UUIDPattern = /^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}$/;
    /**
     * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
     * @param value A uuid string.
     */
    function parse(value) {
        if (!_UUIDPattern.test(value)) {
            throw new Error('invalid uuid');
        }
        return new ValueUUID(value);
    }
    exports.parse = parse;
    function generateUuid() {
        return v4().asHex();
    }
    exports.generateUuid = generateUuid;
});

/// <loc filename="Metadata\base_loc_oam.xml" format="messagebundle" />
/*! @minifier_do_not_preserve
  © Microsoft. All rights reserved.

  This library is supported for use in Windows Store apps only.

  Build: 1.0.9200.20602.win8_ldr.130108-1504

  Version: Microsoft.WinJS.1.0
*/

/*
	Note: Copied out of base.js.
	Changes:
		- we have only kept the first 2554 lines.
		- we have patched WinJS.xhr to add the hedader X-Requested-With:XMLHttpRequest
		- we have wrapped the entire code in an if statement to make WinJS re-entrant (if already defined)
		- we have to define setImmediate if not running in IE 10 since its a IE 10 only function
		- we have removed some getter syntax
*/

// MONACO CHANGE: Make WinJS re-entrant (if already defined)
if (typeof WinJS === 'undefined') {

// MONACO CHANGE: define setImmediate
(function (global) {
    if (!global.setImmediate) {
        if (typeof process !== 'undefined' && typeof process.nextTick === 'function') {
            // running in node
            global.setImmediate = function(callback) {
                return process.nextTick(callback);
            };
        } else {
            // running in browser
            global.setImmediate = function(callback) {
                return setTimeout(callback, 0);
            };
        }
	}

})(this);

/// <reference path="ms-appx://Microsoft.WinJS.1.0/js/base.js" />
(function baseInit(global, undefined) {
    "use strict";

    function initializeProperties(target, members) {
        var keys = Object.keys(members);
        var properties;
        var i, len;
        for (i = 0, len = keys.length; i < len; i++) {
            var key = keys[i];
            var enumerable = key.charCodeAt(0) !== /*_*/95;
            var member = members[key];
            if (member && typeof member === 'object') {
                if (member.value !== undefined || typeof member.get === 'function' || typeof member.set === 'function') {
                    if (member.enumerable === undefined) {
                        member.enumerable = enumerable;
                    }
                    properties = properties || {};
                    properties[key] = member;
                    continue;
                }
            }
            if (!enumerable) {
                properties = properties || {};
                properties[key] = { value: member, enumerable: enumerable, configurable: true, writable: true }
                continue;
            }
            target[key] = member;
        }
        if (properties) {
            Object.defineProperties(target, properties);
        }
    }

    (function (rootNamespace) {

        // Create the rootNamespace in the global namespace
        if (!global[rootNamespace]) {
            global[rootNamespace] = Object.create(Object.prototype);
        }

        // Cache the rootNamespace we just created in a local variable
        var _rootNamespace = global[rootNamespace];
        if (!_rootNamespace.Namespace) {
            _rootNamespace.Namespace = Object.create(Object.prototype);
        }

        function defineWithParent(parentNamespace, name, members) {
            /// <signature helpKeyword="WinJS.Namespace.defineWithParent">
            /// <summary locid="WinJS.Namespace.defineWithParent">
            /// Defines a new namespace with the specified name under the specified parent namespace.
            /// </summary>
            /// <param name="parentNamespace" type="Object" locid="WinJS.Namespace.defineWithParent_p:parentNamespace">
            /// The parent namespace.
            /// </param>
            /// <param name="name" type="String" locid="WinJS.Namespace.defineWithParent_p:name">
            /// The name of the new namespace.
            /// </param>
            /// <param name="members" type="Object" locid="WinJS.Namespace.defineWithParent_p:members">
            /// The members of the new namespace.
            /// </param>
            /// <returns type="Object" locid="WinJS.Namespace.defineWithParent_returnValue">
            /// The newly-defined namespace.
            /// </returns>
            /// </signature>
            var currentNamespace = parentNamespace,
                namespaceFragments = name.split(".");

            for (var i = 0, len = namespaceFragments.length; i < len; i++) {
                var namespaceName = namespaceFragments[i];
                if (!currentNamespace[namespaceName]) {
                    Object.defineProperty(currentNamespace, namespaceName,
                        { value: {}, writable: false, enumerable: true, configurable: true }
                    );
                }
                currentNamespace = currentNamespace[namespaceName];
            }

            if (members) {
                initializeProperties(currentNamespace, members);
            }

            return currentNamespace;
        }

        function define(name, members) {
            /// <signature helpKeyword="WinJS.Namespace.define">
            /// <summary locid="WinJS.Namespace.define">
            /// Defines a new namespace with the specified name.
            /// </summary>
            /// <param name="name" type="String" locid="WinJS.Namespace.define_p:name">
            /// The name of the namespace. This could be a dot-separated name for nested namespaces.
            /// </param>
            /// <param name="members" type="Object" locid="WinJS.Namespace.define_p:members">
            /// The members of the new namespace.
            /// </param>
            /// <returns type="Object" locid="WinJS.Namespace.define_returnValue">
            /// The newly-defined namespace.
            /// </returns>
            /// </signature>
            return defineWithParent(global, name, members);
        }

        // Establish members of the "WinJS.Namespace" namespace
        Object.defineProperties(_rootNamespace.Namespace, {

            defineWithParent: { value: defineWithParent, writable: true, enumerable: true, configurable: true },

            define: { value: define, writable: true, enumerable: true, configurable: true }

        });

    })("WinJS");

    (function (WinJS) {

        function define(constructor, instanceMembers, staticMembers) {
            /// <signature helpKeyword="WinJS.Class.define">
            /// <summary locid="WinJS.Class.define">
            /// Defines a class using the given constructor and the specified instance members.
            /// </summary>
            /// <param name="constructor" type="Function" locid="WinJS.Class.define_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <param name="instanceMembers" type="Object" locid="WinJS.Class.define_p:instanceMembers">
            /// The set of instance fields, properties, and methods made available on the class.
            /// </param>
            /// <param name="staticMembers" type="Object" locid="WinJS.Class.define_p:staticMembers">
            /// The set of static fields, properties, and methods made available on the class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.define_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            constructor = constructor || function () { };
            WinJS.Utilities.markSupportedForProcessing(constructor);
            if (instanceMembers) {
                initializeProperties(constructor.prototype, instanceMembers);
            }
            if (staticMembers) {
                initializeProperties(constructor, staticMembers);
            }
            return constructor;
        }

        function derive(baseClass, constructor, instanceMembers, staticMembers) {
            /// <signature helpKeyword="WinJS.Class.derive">
            /// <summary locid="WinJS.Class.derive">
            /// Creates a sub-class based on the supplied baseClass parameter, using prototypal inheritance.
            /// </summary>
            /// <param name="baseClass" type="Function" locid="WinJS.Class.derive_p:baseClass">
            /// The class to inherit from.
            /// </param>
            /// <param name="constructor" type="Function" locid="WinJS.Class.derive_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <param name="instanceMembers" type="Object" locid="WinJS.Class.derive_p:instanceMembers">
            /// The set of instance fields, properties, and methods to be made available on the class.
            /// </param>
            /// <param name="staticMembers" type="Object" locid="WinJS.Class.derive_p:staticMembers">
            /// The set of static fields, properties, and methods to be made available on the class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.derive_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            if (baseClass) {
                constructor = constructor || function () { };
                var basePrototype = baseClass.prototype;
                constructor.prototype = Object.create(basePrototype);
                WinJS.Utilities.markSupportedForProcessing(constructor);
                Object.defineProperty(constructor.prototype, "constructor", { value: constructor, writable: true, configurable: true, enumerable: true });
                if (instanceMembers) {
                    initializeProperties(constructor.prototype, instanceMembers);
                }
                if (staticMembers) {
                    initializeProperties(constructor, staticMembers);
                }
                return constructor;
            } else {
                return define(constructor, instanceMembers, staticMembers);
            }
        }

        function mix(constructor) {
            /// <signature helpKeyword="WinJS.Class.mix">
            /// <summary locid="WinJS.Class.mix">
            /// Defines a class using the given constructor and the union of the set of instance members
            /// specified by all the mixin objects. The mixin parameter list is of variable length.
            /// </summary>
            /// <param name="constructor" locid="WinJS.Class.mix_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.mix_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            constructor = constructor || function () { };
            var i, len;
            for (i = 1, len = arguments.length; i < len; i++) {
                initializeProperties(constructor.prototype, arguments[i]);
            }
            return constructor;
        }

        // Establish members of "WinJS.Class" namespace
        WinJS.Namespace.define("WinJS.Class", {
            define: define,
            derive: derive,
            mix: mix
        });

    })(global.WinJS);

})(this);


(function baseUtilsInit(global, WinJS) {
    "use strict";

    var hasWinRT = !!global.Windows;

    var strings = {
		// MONACOCHANGE
        //get notSupportedForProcessing() { return WinJS.Resources._getWinJSString("base/notSupportedForProcessing").value; }
		notSupportedForProcessing: "Value is not supported within a declarative processing context, if you want it to be supported mark it using WinJS.Utilities.markSupportedForProcessing. The value was: '{0}'"
    };

    function nop(v) {
        return v;
    }

    function getMemberFiltered(name, root, filter) {
        return name.split(".").reduce(function (currentNamespace, name) {
            if (currentNamespace) {
                return filter(currentNamespace[name]);
            }
            return null;
        }, root);
    }

    // Establish members of "WinJS.Utilities" namespace
    WinJS.Namespace.define("WinJS.Utilities", {
        // Used for mocking in tests
        _setHasWinRT: {
            value: function (value) {
                hasWinRT = value;
            },
            configurable: false,
            writable: false,
            enumerable: false
        },

        /// <field type="Boolean" locid="WinJS.Utilities.hasWinRT" helpKeyword="WinJS.Utilities.hasWinRT">Determine if WinRT is accessible in this script context.</field>
        hasWinRT: {
            get: function () { return hasWinRT; },
            configurable: false,
            enumerable: true
        },

        _getMemberFiltered: getMemberFiltered,

        getMember: function (name, root) {
            /// <signature helpKeyword="WinJS.Utilities.getMember">
            /// <summary locid="WinJS.Utilities.getMember">
            /// Gets the leaf-level type or namespace specified by the name parameter.
            /// </summary>
            /// <param name="name" locid="WinJS.Utilities.getMember_p:name">
            /// The name of the member.
            /// </param>
            /// <param name="root" locid="WinJS.Utilities.getMember_p:root">
            /// The root to start in. Defaults to the global object.
            /// </param>
            /// <returns type="Object" locid="WinJS.Utilities.getMember_returnValue">
            /// The leaf-level type or namespace in the specified parent namespace.
            /// </returns>
            /// </signature>
            if (!name) {
                return null;
            }
            return getMemberFiltered(name, root || global, nop);
        },

        ready: function (callback, async) {
            /// <signature helpKeyword="WinJS.Utilities.ready">
            /// <summary locid="WinJS.Utilities.ready">
            /// Ensures that the specified function executes only after the DOMContentLoaded event has fired
            /// for the current page.
            /// </summary>
            /// <returns type="WinJS.Promise" locid="WinJS.Utilities.ready_returnValue">A promise that completes after DOMContentLoaded has occurred.</returns>
            /// <param name="callback" optional="true" locid="WinJS.Utilities.ready_p:callback">
            /// A function that executes after DOMContentLoaded has occurred.
            /// </param>
            /// <param name="async" optional="true" locid="WinJS.Utilities.ready_p:async">
            /// If true, the callback should be executed asynchronously.
            /// </param>
            /// </signature>
            return new WinJS.Promise(function (c, e) {
                function complete() {
                    if (callback) {
                        try {
                            callback();
                            c();
                        }
                        catch (err) {
                            e(err);
                        }
                    }
                    else {
                        c();
                    }
                }

                var readyState = WinJS.Utilities.testReadyState;
                if (!readyState) {
                    if (global.document) {
                        readyState = document.readyState;
                    }
                    else {
                        readyState = "complete";
                    }
                }
                if (readyState === "complete" || (global.document && document.body !== null)) {
                    if (async) {
                        global.setImmediate(complete);
                    }
                    else {
                        complete();
                    }
                }
                else {
                    global.addEventListener("DOMContentLoaded", complete, false);
                }
            });
        },

        /// <field type="Boolean" locid="WinJS.Utilities.strictProcessing" helpKeyword="WinJS.Utilities.strictProcessing">Determines if strict declarative processing is enabled in this script context.</field>
        strictProcessing: {
            get: function () { return true; },
            configurable: false,
            enumerable: true,
        },

        markSupportedForProcessing: {
            value: function (func) {
                /// <signature helpKeyword="WinJS.Utilities.markSupportedForProcessing">
                /// <summary locid="WinJS.Utilities.markSupportedForProcessing">
                /// Marks a function as being compatible with declarative processing, such as WinJS.UI.processAll
                /// or WinJS.Binding.processAll.
                /// </summary>
                /// <param name="func" type="Function" locid="WinJS.Utilities.markSupportedForProcessing_p:func">
                /// The function to be marked as compatible with declarative processing.
                /// </param>
                /// <returns type="Function" locid="WinJS.Utilities.markSupportedForProcessing_returnValue">
                /// The input function.
                /// </returns>
                /// </signature>
                func.supportedForProcessing = true;
                return func;
            },
            configurable: false,
            writable: false,
            enumerable: true
        },

        requireSupportedForProcessing: {
            value: function (value) {
                /// <signature helpKeyword="WinJS.Utilities.requireSupportedForProcessing">
                /// <summary locid="WinJS.Utilities.requireSupportedForProcessing">
                /// Asserts that the value is compatible with declarative processing, such as WinJS.UI.processAll
                /// or WinJS.Binding.processAll. If it is not compatible an exception will be thrown.
                /// </summary>
                /// <param name="value" type="Object" locid="WinJS.Utilities.requireSupportedForProcessing_p:value">
                /// The value to be tested for compatibility with declarative processing. If the
                /// value is a function it must be marked with a property 'supportedForProcessing'
                /// with a value of true.
                /// </param>
                /// <returns type="Object" locid="WinJS.Utilities.requireSupportedForProcessing_returnValue">
                /// The input value.
                /// </returns>
                /// </signature>
                var supportedForProcessing = true;

                supportedForProcessing = supportedForProcessing && !(value === global);
                supportedForProcessing = supportedForProcessing && !(value === global.location);
                supportedForProcessing = supportedForProcessing && !(value instanceof HTMLIFrameElement);
                supportedForProcessing = supportedForProcessing && !(typeof value === "function" && !value.supportedForProcessing);

                switch (global.frames.length) {
                    case 0:
                        break;

                    case 1:
                        supportedForProcessing = supportedForProcessing && !(value === global.frames[0]);
                        break;

                    default:
                        for (var i = 0, len = global.frames.length; supportedForProcessing && i < len; i++) {
                            supportedForProcessing = supportedForProcessing && !(value === global.frames[i]);
                        }
                        break;
                }

                if (supportedForProcessing) {
                    return value;
                }

                throw new WinJS.ErrorFromName("WinJS.Utilities.requireSupportedForProcessing", WinJS.Resources._formatString(strings.notSupportedForProcessing, value));
            },
            configurable: false,
            writable: false,
            enumerable: true
        },

    });

    WinJS.Namespace.define("WinJS", {
        validation: false,

        strictProcessing: {
            value: function () {
                /// <signature helpKeyword="WinJS.strictProcessing">
                /// <summary locid="WinJS.strictProcessing">
                /// Strict processing is always enforced, this method has no effect.
                /// </summary>
                /// </signature>
            },
            configurable: false,
            writable: false,
            enumerable: false
        },
    });
})(this, this.WinJS);


(function logInit(WinJS) {
    "use strict";

    var spaceR = /\s+/g;
    var typeR = /^(error|warn|info|log)$/;

    function format(message, tag, type) {
        /// <signature helpKeyword="WinJS.Utilities.formatLog">
        /// <summary locid="WinJS.Utilities.formatLog">
        /// Adds tags and type to a logging message.
        /// </summary>
        /// <param name="message" type="String" locid="WinJS.Utilities.startLog_p:message">The message to be formatted.</param>
        /// <param name="tag" type="String" locid="WinJS.Utilities.startLog_p:tag">The tag(s) to be applied to the message. Multiple tags should be separated by spaces.</param>
        /// <param name="type" type="String" locid="WinJS.Utilities.startLog_p:type">The type of the message.</param>
        /// <returns type="String" locid="WinJS.Utilities.startLog_returnValue">The formatted message.</returns>
        /// </signature>
        var m = message;
        if (typeof (m) === "function") { m = m(); }

        return ((type && typeR.test(type)) ? ("") : (type ? (type + ": ") : "")) +
            (tag ? tag.replace(spaceR, ":") + ": " : "") +
            m;
    }
    function defAction(message, tag, type) {
        var m = WinJS.Utilities.formatLog(message, tag, type);
        console[(type && typeR.test(type)) ? type : "log"](m);
    }
    function escape(s) {
        // \s (whitespace) is used as separator, so don't escape it
        return s.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
    }
    WinJS.Namespace.define("WinJS.Utilities", {
        startLog: function (options) {
            /// <signature helpKeyword="WinJS.Utilities.startLog">
            /// <summary locid="WinJS.Utilities.startLog">
            /// Configures a logger that writes messages containing the specified tags from WinJS.log to console.log.
            /// </summary>
            /// <param name="options" type="String" locid="WinJS.Utilities.startLog_p:options">The tags for messages to log. Multiple tags should be separated by spaces.</param>
            /// </signature>
            /// <signature>
            /// <summary locid="WinJS.Utilities.startLog2">
            /// Configure a logger to write WinJS.log output.
            /// </summary>
            /// <param name="options" type="Object" locid="WinJS.Utilities.startLog_p:options2">
            /// May contain .type, .tags, .excludeTags and .action properties.
            /// - .type is a required tag.
            /// - .excludeTags is a space-separated list of tags, any of which will result in a message not being logged.
            /// - .tags is a space-separated list of tags, any of which will result in a message being logged.
            /// - .action is a function that, if present, will be called with the log message, tags and type. The default is to log to the console.
            /// </param>
            /// </signature>
            options = options || {};
            if (typeof options === "string") {
                options = { tags: options };
            }
            var el = options.type && new RegExp("^(" + escape(options.type).replace(spaceR, " ").split(" ").join("|") + ")$");
            var not = options.excludeTags && new RegExp("(^|\\s)(" + escape(options.excludeTags).replace(spaceR, " ").split(" ").join("|") + ")(\\s|$)", "i");
            var has = options.tags && new RegExp("(^|\\s)(" + escape(options.tags).replace(spaceR, " ").split(" ").join("|") + ")(\\s|$)", "i");
            var action = options.action || defAction;

            if (!el && !not && !has && !WinJS.log) {
                WinJS.log = action;
                return;
            }

            var result = function (message, tag, type) {
                if (!((el && !el.test(type))          // if the expected log level is not satisfied
                    || (not && not.test(tag))         // if any of the excluded categories exist
                    || (has && !has.test(tag)))) {    // if at least one of the included categories doesn't exist
                        action(message, tag, type);
                    }

                result.next && result.next(message, tag, type);
            };
            result.next = WinJS.log;
            WinJS.log = result;
        },
        stopLog: function () {
            /// <signature helpKeyword="WinJS.Utilities.stopLog">
            /// <summary locid="WinJS.Utilities.stopLog">
            /// Removes the previously set up logger.
            /// </summary>
            /// </signature>
            delete WinJS.log;
        },
        formatLog: format
    });
})(this.WinJS);

(function eventsInit(WinJS, undefined) {
    "use strict";


    function createEventProperty(name) {
        var eventPropStateName = "_on" + name + "state";

        return {
            get: function () {
                var state = this[eventPropStateName];
                return state && state.userHandler;
            },
            set: function (handler) {
                var state = this[eventPropStateName];
                if (handler) {
                    if (!state) {
                        state = { wrapper: function (evt) { return state.userHandler(evt); }, userHandler: handler };
                        Object.defineProperty(this, eventPropStateName, { value: state, enumerable: false, writable:true, configurable: true });
                        this.addEventListener(name, state.wrapper, false);
                    }
                    state.userHandler = handler;
                } else if (state) {
                    this.removeEventListener(name, state.wrapper, false);
                    this[eventPropStateName] = null;
                }
            },
            enumerable: true
        }
    }

    function createEventProperties(events) {
        /// <signature helpKeyword="WinJS.Utilities.createEventProperties">
        /// <summary locid="WinJS.Utilities.createEventProperties">
        /// Creates an object that has one property for each name passed to the function.
        /// </summary>
        /// <param name="events" locid="WinJS.Utilities.createEventProperties_p:events">
        /// A variable list of property names.
        /// </param>
        /// <returns type="Object" locid="WinJS.Utilities.createEventProperties_returnValue">
        /// The object with the specified properties. The names of the properties are prefixed with 'on'.
        /// </returns>
        /// </signature>
        var props = {};
        for (var i = 0, len = arguments.length; i < len; i++) {
            var name = arguments[i];
            props["on" + name] = createEventProperty(name);
        }
        return props;
    }

    var EventMixinEvent = WinJS.Class.define(
        function EventMixinEvent_ctor(type, detail, target) {
            this.detail = detail;
            this.target = target;
            this.timeStamp = Date.now();
            this.type = type;
        },
        {
            bubbles: { value: false, writable: false },
            cancelable: { value: false, writable: false },
            currentTarget: {
                get: function () { return this.target; }
            },
            defaultPrevented: {
                get: function () { return this._preventDefaultCalled; }
            },
            trusted: { value: false, writable: false },
            eventPhase: { value: 0, writable: false },
            target: null,
            timeStamp: null,
            type: null,

            preventDefault: function () {
                this._preventDefaultCalled = true;
            },
            stopImmediatePropagation: function () {
                this._stopImmediatePropagationCalled = true;
            },
            stopPropagation: function () {
            }
        }, {
            supportedForProcessing: false,
        }
    );

    var eventMixin = {
        _listeners: null,

        addEventListener: function (type, listener, useCapture) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.addEventListener">
            /// <summary locid="WinJS.Utilities.eventMixin.addEventListener">
            /// Adds an event listener to the control.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.addEventListener_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="listener" locid="WinJS.Utilities.eventMixin.addEventListener_p:listener">
            /// The listener to invoke when the event gets raised.
            /// </param>
            /// <param name="useCapture" locid="WinJS.Utilities.eventMixin.addEventListener_p:useCapture">
            /// if true initiates capture, otherwise false.
            /// </param>
            /// </signature>
            useCapture = useCapture || false;
            this._listeners = this._listeners || {};
            var eventListeners = (this._listeners[type] = this._listeners[type] || []);
            for (var i = 0, len = eventListeners.length; i < len; i++) {
                var l = eventListeners[i];
                if (l.useCapture === useCapture && l.listener === listener) {
                    return;
                }
            }
            eventListeners.push({ listener: listener, useCapture: useCapture });
        },
        dispatchEvent: function (type, details) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.dispatchEvent">
            /// <summary locid="WinJS.Utilities.eventMixin.dispatchEvent">
            /// Raises an event of the specified type and with the specified additional properties.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.dispatchEvent_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="details" locid="WinJS.Utilities.eventMixin.dispatchEvent_p:details">
            /// The set of additional properties to be attached to the event object when the event is raised.
            /// </param>
            /// <returns type="Boolean" locid="WinJS.Utilities.eventMixin.dispatchEvent_returnValue">
            /// true if preventDefault was called on the event.
            /// </returns>
            /// </signature>
            var listeners = this._listeners && this._listeners[type];
            if (listeners) {
                var eventValue = new EventMixinEvent(type, details, this);
                // Need to copy the array to protect against people unregistering while we are dispatching
                listeners = listeners.slice(0, listeners.length);
                for (var i = 0, len = listeners.length; i < len && !eventValue._stopImmediatePropagationCalled; i++) {
                    listeners[i].listener(eventValue);
                }
                return eventValue.defaultPrevented || false;
            }
            return false;
        },
        removeEventListener: function (type, listener, useCapture) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.removeEventListener">
            /// <summary locid="WinJS.Utilities.eventMixin.removeEventListener">
            /// Removes an event listener from the control.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.removeEventListener_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="listener" locid="WinJS.Utilities.eventMixin.removeEventListener_p:listener">
            /// The listener to remove.
            /// </param>
            /// <param name="useCapture" locid="WinJS.Utilities.eventMixin.removeEventListener_p:useCapture">
            /// Specifies whether to initiate capture.
            /// </param>
            /// </signature>
            useCapture = useCapture || false;
            var listeners = this._listeners && this._listeners[type];
            if (listeners) {
                for (var i = 0, len = listeners.length; i < len; i++) {
                    var l = listeners[i];
                    if (l.listener === listener && l.useCapture === useCapture) {
                        listeners.splice(i, 1);
                        if (listeners.length === 0) {
                            delete this._listeners[type];
                        }
                        // Only want to remove one element for each call to removeEventListener
                        break;
                    }
                }
            }
        }
    };

    WinJS.Namespace.define("WinJS.Utilities", {
        _createEventProperty: createEventProperty,
        createEventProperties: createEventProperties,
        eventMixin: eventMixin
    });

})(this.WinJS);


(function resourcesInit(global, WinJS, undefined) {
    "use strict";

    var resourceMap;
    var mrtEventHook = false;
    var contextChangedET = "contextchanged";

    var ListenerType = WinJS.Class.mix(WinJS.Class.define(null, { /* empty */ }, { supportedForProcessing: false }), WinJS.Utilities.eventMixin);
    var listeners = new ListenerType();

    var strings = {
		// MONACO CHANGE
        //get malformedFormatStringInput() { return WinJS.Resources._getWinJSString("base/malformedFormatStringInput").value; },
		malformedFormatStringInput: "Malformed, did you mean to escape your '{0}'?"
    };

    WinJS.Namespace.define("WinJS.Resources", {
        addEventListener: function (type, listener, useCapture) {
            /// <signature helpKeyword="WinJS.Resources.addEventListener">
            /// <summary locid="WinJS.Resources.addEventListener">
            /// Registers an event handler for the specified event.
            /// </summary>
            /// <param name="type" type="String" locid="WinJS.Resources.addEventListener_p:type">
            /// The name of the event to handle.
            /// </param>
            /// <param name="listener" type="Function" locid="WinJS.Resources.addEventListener_p:listener">
            /// The listener to invoke when the event gets raised.
            /// </param>
            /// <param name="useCapture" type="Boolean" locid="WinJS.Resources.addEventListener_p:useCapture">
            /// Set to true to register the event handler for the capturing phase; set to false to register for the bubbling phase.
            /// </param>
            /// </signature>
            if (WinJS.Utilities.hasWinRT && !mrtEventHook) {
                if (type === contextChangedET) {
                    try {
                        Windows.ApplicationModel.Resources.Core.ResourceManager.current.defaultContext.qualifierValues.addEventListener("mapchanged", function (e) {
                            WinJS.Resources.dispatchEvent(contextChangedET, { qualifier: e.key, changed: e.target[e.key] });
                        }, false);

                        mrtEventHook = true;
                    } catch (e) {
                    }
                }
            }
            listeners.addEventListener(type, listener, useCapture);
        },
        removeEventListener: listeners.removeEventListener.bind(listeners),
        dispatchEvent: listeners.dispatchEvent.bind(listeners),

        _formatString: function (string) {
            var args = arguments;
            if (args.length > 1) {
                string = string.replace(/({{)|(}})|{(\d+)}|({)|(})/g, function (unused, left, right, index, illegalLeft, illegalRight) {
                    if (illegalLeft || illegalRight) { throw WinJS.Resources._formatString(strings.malformedFormatStringInput, illegalLeft || illegalRight); }
                    return (left && "{") || (right && "}") || args[(index|0) + 1];
                });
            }
            return string;
        },

        _getStringWinRT: function (resourceId) {
            if (!resourceMap) {
                var mainResourceMap = Windows.ApplicationModel.Resources.Core.ResourceManager.current.mainResourceMap;
                try {
                    resourceMap = mainResourceMap.getSubtree('Resources');
                }
                catch (e) {
                }
                if (!resourceMap) {
                    resourceMap = mainResourceMap;
                }
            }

            var stringValue;
            var langValue;
            var resCandidate;
            try {
                resCandidate = resourceMap.getValue(resourceId);
                if (resCandidate) {
                    stringValue = resCandidate.valueAsString;
                    if (stringValue === undefined) {
                        stringValue = resCandidate.toString();
                    }
                }
            }
            catch (e) {}

            if (!stringValue) {
                return { value: resourceId, empty: true };
            }

            try {
                langValue = resCandidate.getQualifierValue("Language");
            }
            catch (e) {
                return { value: stringValue };
            }

            return { value: stringValue, lang: langValue };
        },

        _getStringJS: function (resourceId) {
            var str = global.strings && global.strings[resourceId];
            if (typeof str === "string") {
                str = { value: str };
            }
            return str || { value: resourceId, empty: true };
        }
    });

    Object.defineProperties(WinJS.Resources, WinJS.Utilities.createEventProperties(contextChangedET));

    var getStringImpl;

    WinJS.Resources.getString = function (resourceId) {
        /// <signature helpKeyword="WinJS.Resources.getString">
        /// <summary locid="WinJS.Resources.getString">
        /// Retrieves the resource string that has the specified resource id.
        /// </summary>
        /// <param name="resourceId" type="Number" locid="WinJS.Resources.getString._p:resourceId">
        /// The resource id of the string to retrieve.
        /// </param>
        /// <returns type="Object" locid="WinJS.Resources.getString_returnValue">
        /// An object that can contain these properties:
        ///
        /// value:
        /// The value of the requested string. This property is always present.
        ///
        /// empty:
        /// A value that specifies whether the requested string wasn't found.
        /// If its true, the string wasn't found. If its false or undefined,
        /// the requested string was found.
        ///
        /// lang:
        /// The language of the string, if specified. This property is only present
        /// for multi-language resources.
        ///
        /// </returns>
        /// </signature>
        getStringImpl =
            getStringImpl ||
                (WinJS.Utilities.hasWinRT
                    ? WinJS.Resources._getStringWinRT
                    : WinJS.Resources._getStringJS);

        return getStringImpl(resourceId);
    };


})(this, this.WinJS);


(function promiseInit(global, WinJS, undefined) {
    "use strict";

    global.Debug && (global.Debug.setNonUserCodeExceptions = true);

    var ListenerType = WinJS.Class.mix(WinJS.Class.define(null, { /*empty*/ }, { supportedForProcessing: false }), WinJS.Utilities.eventMixin);
    var promiseEventListeners = new ListenerType();
    // make sure there is a listeners collection so that we can do a more trivial check below
    promiseEventListeners._listeners = {};
    var errorET = "error";
    var canceledName = "Canceled";
    var tagWithStack = false;
    var tag = {
        promise:            0x01,
        thenPromise:        0x02,
        errorPromise:       0x04,
        exceptionPromise:   0x08,
        completePromise:    0x10,
    };
    tag.all = tag.promise | tag.thenPromise | tag.errorPromise | tag.exceptionPromise | tag.completePromise;

    //
    // Global error counter, for each error which enters the system we increment this once and then
    // the error number travels with the error as it traverses the tree of potential handlers.
    //
    // When someone has registered to be told about errors (WinJS.Promise.callonerror) promises
    // which are in error will get tagged with a ._errorId field. This tagged field is the
    // contract by which nested promises with errors will be identified as chaining for the
    // purposes of the callonerror semantics. If a nested promise in error is encountered without
    // a ._errorId it will be assumed to be foreign and treated as an interop boundary and
    // a new error id will be minted.
    //
    var error_number = 1;

    //
    // The state machine has a interesting hiccup in it with regards to notification, in order
    // to flatten out notification and avoid recursion for synchronous completion we have an
    // explicit set of *_notify states which are responsible for notifying their entire tree
    // of children. They can do this because they know that immediate children are always
    // ThenPromise instances and we can therefore reach into their state to access the
    // _listeners collection.
    //
    // So, what happens is that a Promise will be fulfilled through the _completed or _error
    // messages at which point it will enter a *_notify state and be responsible for to move
    // its children into an (as appropriate) success or error state and also notify that child's
    // listeners of the state transition, until leaf notes are reached.
    //

    var state_created,              // -> working
        state_working,              // -> error | error_notify | success | success_notify | canceled | waiting
        state_waiting,              // -> error | error_notify | success | success_notify | waiting_canceled
        state_waiting_canceled,     // -> error | error_notify | success | success_notify | canceling
        state_canceled,             // -> error | error_notify | success | success_notify | canceling
        state_canceling,            // -> error_notify
        state_success_notify,       // -> success
        state_success,              // -> .
        state_error_notify,         // -> error
        state_error;                // -> .

    // Noop function, used in the various states to indicate that they don't support a given
    // message. Named with the somewhat cute name '_' because it reads really well in the states.

    function _() { }

    // Initial state
    //
    state_created = {
        name: "created",
        enter: function (promise) {
            promise._setState(state_working);
        },
        cancel: _,
        done: _,
        then: _,
        _completed: _,
        _error: _,
        _notify: _,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Ready state, waiting for a message (completed/error/progress), able to be canceled
    //
    state_working = {
        name: "working",
        enter: _,
        cancel: function (promise) {
            promise._setState(state_canceled);
        },
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Waiting state, if a promise is completed with a value which is itself a promise
    // (has a then() method) it signs up to be informed when that child promise is
    // fulfilled at which point it will be fulfilled with that value.
    //
    state_waiting = {
        name: "waiting",
        enter: function (promise) {
            var waitedUpon = promise._value;
            var error = function (value) {
                if (waitedUpon._errorId) {
                    promise._chainedError(value, waitedUpon);
                } else {
                    // Because this is an interop boundary we want to indicate that this
                    //  error has been handled by the promise infrastructure before we
                    //  begin a new handling chain.
                    //
                    callonerror(promise, value, detailsForHandledError, waitedUpon, error);
                    promise._error(value);
                }
            };
            error.handlesOnError = true;
            waitedUpon.then(
                promise._completed.bind(promise),
                error,
                promise._progress.bind(promise)
            );
        },
        cancel: function (promise) {
            promise._setState(state_waiting_canceled);
        },
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Waiting canceled state, when a promise has been in a waiting state and receives a
    // request to cancel its pending work it will forward that request to the child promise
    // and then waits to be informed of the result. This promise moves itself into the
    // canceling state but understands that the child promise may instead push it to a
    // different state.
    //
    state_waiting_canceled = {
        name: "waiting_canceled",
        enter: function (promise) {
            // Initiate a transition to canceling. Triggering a cancel on the promise
            // that we are waiting upon may result in a different state transition
            // before the state machine pump runs again.
            promise._setState(state_canceling);
            var waitedUpon = promise._value;
            if (waitedUpon.cancel) {
                waitedUpon.cancel();
            }
        },
        cancel: _,
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Canceled state, moves to the canceling state and then tells the promise to do
    // whatever it might need to do on cancelation.
    //
    state_canceled = {
        name: "canceled",
        enter: function (promise) {
            // Initiate a transition to canceling. The _cancelAction may change the state
            // before the state machine pump runs again.
            promise._setState(state_canceling);
            promise._cancelAction();
        },
        cancel: _,
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Canceling state, commits to the promise moving to an error state with an error
    // object whose 'name' and 'message' properties contain the string "Canceled"
    //
    state_canceling = {
        name: "canceling",
        enter: function (promise) {
            var error = new Error(canceledName);
            error.name = error.message;
            promise._value = error;
            promise._setState(state_error_notify);
        },
        cancel: _,
        done: _,
        then: _,
        _completed: _,
        _error: _,
        _notify: _,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Success notify state, moves a promise to the success state and notifies all children
    //
    state_success_notify = {
        name: "complete_notify",
        enter: function (promise) {
            promise.done = CompletePromise.prototype.done;
            promise.then = CompletePromise.prototype.then;
            if (promise._listeners) {
                var queue = [promise];
                var p;
                while (queue.length) {
                    p = queue.pop();
                    p._state._notify(p, queue);
                }
            }
            promise._setState(state_success);
        },
        cancel: _,
        done: null, /*error to get here */
        then: null, /*error to get here */
        _completed: _,
        _error: _,
        _notify: notifySuccess,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Success state, moves a promise to the success state and does NOT notify any children.
    // Some upstream promise is owning the notification pass.
    //
    state_success = {
        name: "success",
        enter: function (promise) {
            promise.done = CompletePromise.prototype.done;
            promise.then = CompletePromise.prototype.then;
            promise._cleanupAction();
        },
        cancel: _,
        done: null, /*error to get here */
        then: null, /*error to get here */
        _completed: _,
        _error: _,
        _notify: notifySuccess,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Error notify state, moves a promise to the error state and notifies all children
    //
    state_error_notify = {
        name: "error_notify",
        enter: function (promise) {
            promise.done = ErrorPromise.prototype.done;
            promise.then = ErrorPromise.prototype.then;
            if (promise._listeners) {
                var queue = [promise];
                var p;
                while (queue.length) {
                    p = queue.pop();
                    p._state._notify(p, queue);
                }
            }
            promise._setState(state_error);
        },
        cancel: _,
        done: null, /*error to get here*/
        then: null, /*error to get here*/
        _completed: _,
        _error: _,
        _notify: notifyError,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Error state, moves a promise to the error state and does NOT notify any children.
    // Some upstream promise is owning the notification pass.
    //
    state_error = {
        name: "error",
        enter: function (promise) {
            promise.done = ErrorPromise.prototype.done;
            promise.then = ErrorPromise.prototype.then;
            promise._cleanupAction();
        },
        cancel: _,
        done: null, /*error to get here*/
        then: null, /*error to get here*/
        _completed: _,
        _error: _,
        _notify: notifyError,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    //
    // The statemachine implementation follows a very particular pattern, the states are specified
    // as static stateless bags of functions which are then indirected through the state machine
    // instance (a Promise). As such all of the functions on each state have the promise instance
    // passed to them explicitly as a parameter and the Promise instance members do a little
    // dance where they indirect through the state and insert themselves in the argument list.
    //
    // We could instead call directly through the promise states however then every caller
    // would have to remember to do things like pumping the state machine to catch state transitions.
    //

    var PromiseStateMachine = WinJS.Class.define(null, {
        _listeners: null,
        _nextState: null,
        _state: null,
        _value: null,

        cancel: function () {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
            /// <summary locid="WinJS.PromiseStateMachine.cancel">
            /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
            /// already been fulfilled and cancellation is supported, the promise enters
            /// the error state with a value of Error("Canceled").
            /// </summary>
            /// </signature>
            this._state.cancel(this);
            this._run();
        },
        done: function Promise_done(onComplete, onError, onProgress) {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
            /// <summary locid="WinJS.PromiseStateMachine.done">
            /// Allows you to specify the work to be done on the fulfillment of the promised value,
            /// the error handling to be performed if the promise fails to fulfill
            /// a value, and the handling of progress notifications along the way.
            ///
            /// After the handlers have finished executing, this function throws any error that would have been returned
            /// from then() as a promise in the error state.
            /// </summary>
            /// <param name="onComplete" type="Function" locid="WinJS.PromiseStateMachine.done_p:onComplete">
            /// The function to be called if the promise is fulfilled successfully with a value.
            /// The fulfilled value is passed as the single argument. If the value is null,
            /// the fulfilled value is returned. The value returned
            /// from the function becomes the fulfilled value of the promise returned by
            /// then(). If an exception is thrown while executing the function, the promise returned
            /// by then() moves into the error state.
            /// </param>
            /// <param name="onError" type="Function" optional="true" locid="WinJS.PromiseStateMachine.done_p:onError">
            /// The function to be called if the promise is fulfilled with an error. The error
            /// is passed as the single argument. If it is null, the error is forwarded.
            /// The value returned from the function is the fulfilled value of the promise returned by then().
            /// </param>
            /// <param name="onProgress" type="Function" optional="true" locid="WinJS.PromiseStateMachine.done_p:onProgress">
            /// the function to be called if the promise reports progress. Data about the progress
            /// is passed as the single argument. Promises are not required to support
            /// progress.
            /// </param>
            /// </signature>
            this._state.done(this, onComplete, onError, onProgress);
        },
        then: function Promise_then(onComplete, onError, onProgress) {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
            /// <summary locid="WinJS.PromiseStateMachine.then">
            /// Allows you to specify the work to be done on the fulfillment of the promised value,
            /// the error handling to be performed if the promise fails to fulfill
            /// a value, and the handling of progress notifications along the way.
            /// </summary>
            /// <param name="onComplete" type="Function" locid="WinJS.PromiseStateMachine.then_p:onComplete">
            /// The function to be called if the promise is fulfilled successfully with a value.
            /// The value is passed as the single argument. If the value is null, the value is returned.
            /// The value returned from the function becomes the fulfilled value of the promise returned by
            /// then(). If an exception is thrown while this function is being executed, the promise returned
            /// by then() moves into the error state.
            /// </param>
            /// <param name="onError" type="Function" optional="true" locid="WinJS.PromiseStateMachine.then_p:onError">
            /// The function to be called if the promise is fulfilled with an error. The error
            /// is passed as the single argument. If it is null, the error is forwarded.
            /// The value returned from the function becomes the fulfilled value of the promise returned by then().
            /// </param>
            /// <param name="onProgress" type="Function" optional="true" locid="WinJS.PromiseStateMachine.then_p:onProgress">
            /// The function to be called if the promise reports progress. Data about the progress
            /// is passed as the single argument. Promises are not required to support
            /// progress.
            /// </param>
            /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
            /// The promise whose value is the result of executing the complete or
            /// error function.
            /// </returns>
            /// </signature>
            return this._state.then(this, onComplete, onError, onProgress);
        },

        _chainedError: function (value, context) {
            var result = this._state._error(this, value, detailsForChainedError, context);
            this._run();
            return result;
        },
        _completed: function (value) {
            var result = this._state._completed(this, value);
            this._run();
            return result;
        },
        _error: function (value) {
            var result = this._state._error(this, value, detailsForError);
            this._run();
            return result;
        },
        _progress: function (value) {
            this._state._progress(this, value);
        },
        _setState: function (state) {
            this._nextState = state;
        },
        _setCompleteValue: function (value) {
            this._state._setCompleteValue(this, value);
            this._run();
        },
        _setChainedErrorValue: function (value, context) {
            var result = this._state._setErrorValue(this, value, detailsForChainedError, context);
            this._run();
            return result;
        },
        _setExceptionValue: function (value) {
            var result = this._state._setErrorValue(this, value, detailsForException);
            this._run();
            return result;
        },
        _run: function () {
            while (this._nextState) {
                this._state = this._nextState;
                this._nextState = null;
                this._state.enter(this);
            }
        }
    }, {
        supportedForProcessing: false
    });

    //
    // Implementations of shared state machine code.
    //

    function completed(promise, value) {
        var targetState;
        if (value && typeof value === "object" && typeof value.then === "function") {
            targetState = state_waiting;
        } else {
            targetState = state_success_notify;
        }
        promise._value = value;
        promise._setState(targetState);
    }
    function createErrorDetails(exception, error, promise, id, parent, handler) {
        return {
            exception: exception,
            error: error,
            promise: promise,
            handler: handler,
            id: id,
            parent: parent
        };
    }
    function detailsForHandledError(promise, errorValue, context, handler) {
        var exception = context._isException;
        var errorId = context._errorId;
        return createErrorDetails(
            exception ? errorValue : null,
            exception ? null : errorValue,
            promise,
            errorId,
            context,
            handler
        );
    }
    function detailsForChainedError(promise, errorValue, context) {
        var exception = context._isException;
        var errorId = context._errorId;
        setErrorInfo(promise, errorId, exception);
        return createErrorDetails(
            exception ? errorValue : null,
            exception ? null : errorValue,
            promise,
            errorId,
            context
        );
    }
    function detailsForError(promise, errorValue) {
        var errorId = ++error_number;
        setErrorInfo(promise, errorId);
        return createErrorDetails(
            null,
            errorValue,
            promise,
            errorId
        );
    }
    function detailsForException(promise, exceptionValue) {
        var errorId = ++error_number;
        setErrorInfo(promise, errorId, true);
        return createErrorDetails(
            exceptionValue,
            null,
            promise,
            errorId
        );
    }
    function done(promise, onComplete, onError, onProgress) {
        pushListener(promise, { c: onComplete, e: onError, p: onProgress });
    }
    function error(promise, value, onerrorDetails, context) {
        promise._value = value;
        callonerror(promise, value, onerrorDetails, context);
        promise._setState(state_error_notify);
    }
    function notifySuccess(promise, queue) {
        var value = promise._value;
        var listeners = promise._listeners;
        if (!listeners) {
            return;
        }
        promise._listeners = null;
        var i, len;
        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
            var listener = len === 1 ? listeners : listeners[i];
            var onComplete = listener.c;
            var target = listener.promise;
            if (target) {
                try {
                    target._setCompleteValue(onComplete ? onComplete(value) : value);
                } catch (ex) {
                    target._setExceptionValue(ex);
                }
                if (target._state !== state_waiting && target._listeners) {
                    queue.push(target);
                }
            } else {
                CompletePromise.prototype.done.call(promise, onComplete);
            }
        }
    }
    function notifyError(promise, queue) {
        var value = promise._value;
        var listeners = promise._listeners;
        if (!listeners) {
            return;
        }
        promise._listeners = null;
        var i, len;
        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
            var listener = len === 1 ? listeners : listeners[i];
            var onError = listener.e;
            var target = listener.promise;
            if (target) {
                try {
                    if (onError) {
                        if (!onError.handlesOnError) {
                            callonerror(target, value, detailsForHandledError, promise, onError);
                        }
                        target._setCompleteValue(onError(value))
                    } else {
                        target._setChainedErrorValue(value, promise);
                    }
                } catch (ex) {
                    target._setExceptionValue(ex);
                }
                if (target._state !== state_waiting && target._listeners) {
                    queue.push(target);
                }
            } else {
                ErrorPromise.prototype.done.call(promise, null, onError);
            }
        }
    }
    function callonerror(promise, value, onerrorDetailsGenerator, context, handler) {
        if (promiseEventListeners._listeners[errorET]) {
            if (value instanceof Error && value.message === canceledName) {
                return;
            }
            promiseEventListeners.dispatchEvent(errorET, onerrorDetailsGenerator(promise, value, context, handler));
        }
    }
    function progress(promise, value) {
        var listeners = promise._listeners;
        if (listeners) {
            var i, len;
            for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
                var listener = len === 1 ? listeners : listeners[i];
                var onProgress = listener.p;
                if (onProgress) {
                    try { onProgress(value); } catch (ex) { }
                }
                if (!(listener.c || listener.e) && listener.promise) {
                    listener.promise._progress(value);
                }
            }
        }
    }
    function pushListener(promise, listener) {
        var listeners = promise._listeners;
        if (listeners) {
            // We may have either a single listener (which will never be wrapped in an array)
            // or 2+ listeners (which will be wrapped). Since we are now adding one more listener
            // we may have to wrap the single listener before adding the second.
            listeners = Array.isArray(listeners) ? listeners : [listeners];
            listeners.push(listener);
        } else {
            listeners = listener;
        }
        promise._listeners = listeners;
    }
    // The difference beween setCompleteValue()/setErrorValue() and complete()/error() is that setXXXValue() moves
    // a promise directly to the success/error state without starting another notification pass (because one
    // is already ongoing).
    function setErrorInfo(promise, errorId, isException) {
        promise._isException = isException || false;
        promise._errorId = errorId;
    }
    function setErrorValue(promise, value, onerrorDetails, context) {
        promise._value = value;
        callonerror(promise, value, onerrorDetails, context);
        promise._setState(state_error);
    }
    function setCompleteValue(promise, value) {
        var targetState;
        if (value && typeof value === "object" && typeof value.then === "function") {
            targetState = state_waiting;
        } else {
            targetState = state_success;
        }
        promise._value = value;
        promise._setState(targetState);
    }
    function then(promise, onComplete, onError, onProgress) {
        var result = new ThenPromise(promise);
        pushListener(promise, { promise: result, c: onComplete, e: onError, p: onProgress });
        return result;
    }

    //
    // Internal implementation detail promise, ThenPromise is created when a promise needs
    // to be returned from a then() method.
    //
    var ThenPromise = WinJS.Class.derive(PromiseStateMachine,
        function (creator) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.thenPromise))) {
                this._stack = WinJS.Promise._getStack();
            }

            this._creator = creator;
            this._setState(state_created);
            this._run();
        }, {
            _creator: null,

            _cancelAction: function () { if (this._creator) { this._creator.cancel(); } },
            _cleanupAction: function () { this._creator = null; }
        }, {
            supportedForProcessing: false
        }
    );

    //
    // Slim promise implementations for already completed promises, these are created
    // under the hood on synchronous completion paths as well as by WinJS.Promise.wrap
    // and WinJS.Promise.wrapError.
    //

    var ErrorPromise = WinJS.Class.define(
        function ErrorPromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.errorPromise))) {
                this._stack = WinJS.Promise._getStack();
            }

            this._value = value;
            callonerror(this, value, detailsForError);
        }, {
            cancel: function () {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
                /// <summary locid="WinJS.PromiseStateMachine.cancel">
                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
                /// already been fulfilled and cancellation is supported, the promise enters
                /// the error state with a value of Error("Canceled").
                /// </summary>
                /// </signature>
            },
            done: function ErrorPromise_done(unused, onError) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
                /// <summary locid="WinJS.PromiseStateMachine.done">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                ///
                /// After the handlers have finished executing, this function throws any error that would have been returned
                /// from then() as a promise in the error state.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The fulfilled value is passed as the single argument. If the value is null,
                /// the fulfilled value is returned. The value returned
                /// from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while executing the function, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function is the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
                /// the function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// </signature>
                var value = this._value;
                if (onError) {
                    try {
                        if (!onError.handlesOnError) {
                            callonerror(null, value, detailsForHandledError, this, onError);
                        }
                        var result = onError(value);
                        if (result && typeof result === "object" && typeof result.done === "function") {
                            // If a promise is returned we need to wait on it.
                            result.done();
                        }
                        return;
                    } catch (ex) {
                        value = ex;
                    }
                }
                if (value instanceof Error && value.message === canceledName) {
                    // suppress cancel
                    return;
                }
                // force the exception to be thrown asyncronously to avoid any try/catch blocks
                //
                setImmediate(function () {
                    throw value;
                });
            },
            then: function ErrorPromise_then(unused, onError) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
                /// <summary locid="WinJS.PromiseStateMachine.then">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The value is passed as the single argument. If the value is null, the value is returned.
                /// The value returned from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while this function is being executed, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function becomes the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
                /// The promise whose value is the result of executing the complete or
                /// error function.
                /// </returns>
                /// </signature>

                // If the promise is already in a error state and no error handler is provided
                // we optimize by simply returning the promise instead of creating a new one.
                //
                if (!onError) { return this; }
                var result;
                var value = this._value;
                try {
                    if (!onError.handlesOnError) {
                        callonerror(null, value, detailsForHandledError, this, onError);
                    }
                    result = new CompletePromise(onError(value));
                } catch (ex) {
                    // If the value throw from the error handler is the same as the value
                    // provided to the error handler then there is no need for a new promise.
                    //
                    if (ex === value) {
                        result = this;
                    } else {
                        result = new ExceptionPromise(ex);
                    }
                }
                return result;
            }
        }, {
            supportedForProcessing: false
        }
    );

    var ExceptionPromise = WinJS.Class.derive(ErrorPromise,
        function ExceptionPromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.exceptionPromise))) {
                this._stack = WinJS.Promise._getStack();
            }

            this._value = value;
            callonerror(this, value, detailsForException);
        }, {
            /* empty */
        }, {
            supportedForProcessing: false
        }
    );

    var CompletePromise = WinJS.Class.define(
        function CompletePromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.completePromise))) {
                this._stack = WinJS.Promise._getStack();
            }

            if (value && typeof value === "object" && typeof value.then === "function") {
                var result = new ThenPromise(null);
                result._setCompleteValue(value);
                return result;
            }
            this._value = value;
        }, {
            cancel: function () {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
                /// <summary locid="WinJS.PromiseStateMachine.cancel">
                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
                /// already been fulfilled and cancellation is supported, the promise enters
                /// the error state with a value of Error("Canceled").
                /// </summary>
                /// </signature>
            },
            done: function CompletePromise_done(onComplete) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
                /// <summary locid="WinJS.PromiseStateMachine.done">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                ///
                /// After the handlers have finished executing, this function throws any error that would have been returned
                /// from then() as a promise in the error state.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The fulfilled value is passed as the single argument. If the value is null,
                /// the fulfilled value is returned. The value returned
                /// from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while executing the function, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function is the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
                /// the function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// </signature>
                if (!onComplete) { return; }
                try {
                    var result = onComplete(this._value);
                    if (result && typeof result === "object" && typeof result.done === "function") {
                        result.done();
                    }
                } catch (ex) {
                    // force the exception to be thrown asynchronously to avoid any try/catch blocks
                    setImmediate(function () {
                        throw ex;
                    });
                }
            },
            then: function CompletePromise_then(onComplete) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
                /// <summary locid="WinJS.PromiseStateMachine.then">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The value is passed as the single argument. If the value is null, the value is returned.
                /// The value returned from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while this function is being executed, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function becomes the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
                /// The promise whose value is the result of executing the complete or
                /// error function.
                /// </returns>
                /// </signature>
                try {
                    // If the value returned from the completion handler is the same as the value
                    // provided to the completion handler then there is no need for a new promise.
                    //
                    var newValue = onComplete ? onComplete(this._value) : this._value;
                    return newValue === this._value ? this : new CompletePromise(newValue);
                } catch (ex) {
                    return new ExceptionPromise(ex);
                }
            }
        }, {
            supportedForProcessing: false
        }
    );

    //
    // Promise is the user-creatable WinJS.Promise object.
    //

    function timeout(timeoutMS) {
        var id;
        return new WinJS.Promise(
            function (c) {
                if (timeoutMS) {
                    id = setTimeout(c, timeoutMS);
                } else {
                    setImmediate(c);
                }
            },
            function () {
                if (id) {
                    clearTimeout(id);
                }
            }
        );
    }

    function timeoutWithPromise(timeout, promise) {
        var cancelPromise = function () { promise.cancel(); }
        var cancelTimeout = function () { timeout.cancel(); }
        timeout.then(cancelPromise);
        promise.then(cancelTimeout, cancelTimeout);
        return promise;
    }

    var staticCanceledPromise;

    var Promise = WinJS.Class.derive(PromiseStateMachine,
        function Promise_ctor(init, oncancel) {
            /// <signature helpKeyword="WinJS.Promise">
            /// <summary locid="WinJS.Promise">
            /// A promise provides a mechanism to schedule work to be done on a value that
            /// has not yet been computed. It is a convenient abstraction for managing
            /// interactions with asynchronous APIs.
            /// </summary>
            /// <param name="init" type="Function" locid="WinJS.Promise_p:init">
            /// The function that is called during construction of the  promise. The function
            /// is given three arguments (complete, error, progress). Inside this function
            /// you should add event listeners for the notifications supported by this value.
            /// </param>
            /// <param name="oncancel" optional="true" locid="WinJS.Promise_p:oncancel">
            /// The function to call if a consumer of this promise wants
            /// to cancel its undone work. Promises are not required to
            /// support cancellation.
            /// </param>
            /// </signature>

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.promise))) {
                this._stack = WinJS.Promise._getStack();
            }

            this._oncancel = oncancel;
            this._setState(state_created);
            this._run();

            try {
                var complete = this._completed.bind(this);
                var error = this._error.bind(this);
                var progress = this._progress.bind(this);
                init(complete, error, progress);
            } catch (ex) {
                this._setExceptionValue(ex);
            }
        }, {
            _oncancel: null,

            _cancelAction: function () {
				try {
            		if (this._oncancel) {
						this._oncancel();
					} else {
						throw new Error('Promise did not implement oncancel');
					}
				} catch (ex) {
					// Access fields to get them created
					var msg = ex.message;
					var stack = ex.stack;
					promiseEventListeners.dispatchEvent('error', ex);
				}
            },
            _cleanupAction: function () { this._oncancel = null; }
        }, {

            addEventListener: function Promise_addEventListener(eventType, listener, capture) {
                /// <signature helpKeyword="WinJS.Promise.addEventListener">
                /// <summary locid="WinJS.Promise.addEventListener">
                /// Adds an event listener to the control.
                /// </summary>
                /// <param name="eventType" locid="WinJS.Promise.addEventListener_p:eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name="listener" locid="WinJS.Promise.addEventListener_p:listener">
                /// The listener to invoke when the event is raised.
                /// </param>
                /// <param name="capture" locid="WinJS.Promise.addEventListener_p:capture">
                /// Specifies whether or not to initiate capture.
                /// </param>
                /// </signature>
                promiseEventListeners.addEventListener(eventType, listener, capture);
            },
            any: function Promise_any(values) {
                /// <signature helpKeyword="WinJS.Promise.any">
                /// <summary locid="WinJS.Promise.any">
                /// Returns a promise that is fulfilled when one of the input promises
                /// has been fulfilled.
                /// </summary>
                /// <param name="values" type="Array" locid="WinJS.Promise.any_p:values">
                /// An array that contains promise objects or objects whose property
                /// values include promise objects.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.any_returnValue">
                /// A promise that on fulfillment yields the value of the input (complete or error).
                /// </returns>
                /// </signature>
                return new Promise(
                    function (complete, error, progress) {
                        var keys = Object.keys(values);
                        var errors = Array.isArray(values) ? [] : {};
                        if (keys.length === 0) {
                            complete();
                        }
                        var canceled = 0;
                        keys.forEach(function (key) {
                            Promise.as(values[key]).then(
                                function () { complete({ key: key, value: values[key] }); },
                                function (e) {
                                    if (e instanceof Error && e.name === canceledName) {
                                        if ((++canceled) === keys.length) {
                                            complete(WinJS.Promise.cancel);
                                        }
                                        return;
                                    }
                                    error({ key: key, value: values[key] });
                                }
                            );
                        });
                    },
                    function () {
                        var keys = Object.keys(values);
                        keys.forEach(function (key) {
                            var promise = Promise.as(values[key]);
                            if (typeof promise.cancel === "function") {
                                promise.cancel();
                            }
                        });
                    }
                );
            },
            as: function Promise_as(value) {
                /// <signature helpKeyword="WinJS.Promise.as">
                /// <summary locid="WinJS.Promise.as">
                /// Returns a promise. If the object is already a promise it is returned;
                /// otherwise the object is wrapped in a promise.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.as_p:value">
                /// The value to be treated as a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.as_returnValue">
                /// A promise.
                /// </returns>
                /// </signature>
                if (value && typeof value === "object" && typeof value.then === "function") {
                    return value;
                }
                return new CompletePromise(value);
            },
            /// <field type="WinJS.Promise" helpKeyword="WinJS.Promise.cancel" locid="WinJS.Promise.cancel">
            /// Canceled promise value, can be returned from a promise completion handler
            /// to indicate cancelation of the promise chain.
            /// </field>
            cancel: {
                get: function () {
                    return (staticCanceledPromise = staticCanceledPromise || new ErrorPromise(new WinJS.ErrorFromName(canceledName)));
                }
            },
            dispatchEvent: function Promise_dispatchEvent(eventType, details) {
                /// <signature helpKeyword="WinJS.Promise.dispatchEvent">
                /// <summary locid="WinJS.Promise.dispatchEvent">
                /// Raises an event of the specified type and properties.
                /// </summary>
                /// <param name="eventType" locid="WinJS.Promise.dispatchEvent_p:eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name="details" locid="WinJS.Promise.dispatchEvent_p:details">
                /// The set of additional properties to be attached to the event object.
                /// </param>
                /// <returns type="Boolean" locid="WinJS.Promise.dispatchEvent_returnValue">
                /// Specifies whether preventDefault was called on the event.
                /// </returns>
                /// </signature>
                return promiseEventListeners.dispatchEvent(eventType, details);
            },
            is: function Promise_is(value) {
                /// <signature helpKeyword="WinJS.Promise.is">
                /// <summary locid="WinJS.Promise.is">
                /// Determines whether a value fulfills the promise contract.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.is_p:value">
                /// A value that may be a promise.
                /// </param>
                /// <returns type="Boolean" locid="WinJS.Promise.is_returnValue">
                /// true if the specified value is a promise, otherwise false.
                /// </returns>
                /// </signature>
                return value && typeof value === "object" && typeof value.then === "function";
            },
            join: function Promise_join(values) {
                /// <signature helpKeyword="WinJS.Promise.join">
                /// <summary locid="WinJS.Promise.join">
                /// Creates a promise that is fulfilled when all the values are fulfilled.
                /// </summary>
                /// <param name="values" type="Object" locid="WinJS.Promise.join_p:values">
                /// An object whose fields contain values, some of which may be promises.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.join_returnValue">
                /// A promise whose value is an object with the same field names as those of the object in the values parameter, where
                /// each field value is the fulfilled value of a promise.
                /// </returns>
                /// </signature>
                return new Promise(
                    function (complete, error, progress) {
                        var keys = Object.keys(values);
                        var errors = Array.isArray(values) ? [] : {};
                        var results = Array.isArray(values) ? [] : {};
                        var undefineds = 0;
                        var pending = keys.length;
                        var argDone = function (key) {
                            if ((--pending) === 0) {
                                var errorCount = Object.keys(errors).length;
                                if (errorCount === 0) {
                                    complete(results);
                                } else {
                                    var canceledCount = 0;
                                    keys.forEach(function (key) {
                                        var e = errors[key];
                                        if (e instanceof Error && e.name === canceledName) {
                                            canceledCount++;
                                        }
                                    });
                                    if (canceledCount === errorCount) {
                                        complete(WinJS.Promise.cancel);
                                    } else {
                                        error(errors);
                                    }
                                }
                            } else {
                                progress({ Key: key, Done: true });
                            }
                        };
                        keys.forEach(function (key) {
                            var value = values[key];
                            if (value === undefined) {
                                undefineds++;
                            } else {
                                Promise.then(value,
                                    function (value) { results[key] = value; argDone(key); },
                                    function (value) { errors[key] = value; argDone(key); }
                                );
                            }
                        });
                        pending -= undefineds;
                        if (pending === 0) {
                            complete(results);
                            return;
                        }
                    },
                    function () {
                        Object.keys(values).forEach(function (key) {
                            var promise = Promise.as(values[key]);
                            if (typeof promise.cancel === "function") {
                                promise.cancel();
                            }
                        });
                    }
                );
            },
            removeEventListener: function Promise_removeEventListener(eventType, listener, capture) {
                /// <signature helpKeyword="WinJS.Promise.removeEventListener">
                /// <summary locid="WinJS.Promise.removeEventListener">
                /// Removes an event listener from the control.
                /// </summary>
                /// <param name='eventType' locid="WinJS.Promise.removeEventListener_eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name='listener' locid="WinJS.Promise.removeEventListener_listener">
                /// The listener to remove.
                /// </param>
                /// <param name='capture' locid="WinJS.Promise.removeEventListener_capture">
                /// Specifies whether or not to initiate capture.
                /// </param>
                /// </signature>
                promiseEventListeners.removeEventListener(eventType, listener, capture);
            },
            supportedForProcessing: false,
            then: function Promise_then(value, onComplete, onError, onProgress) {
                /// <signature helpKeyword="WinJS.Promise.then">
                /// <summary locid="WinJS.Promise.then">
                /// A static version of the promise instance method then().
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.then_p:value">
                /// the value to be treated as a promise.
                /// </param>
                /// <param name="onComplete" type="Function" locid="WinJS.Promise.then_p:complete">
                /// The function to be called if the promise is fulfilled with a value.
                /// If it is null, the promise simply
                /// returns the value. The value is passed as the single argument.
                /// </param>
                /// <param name="onError" type="Function" optional="true" locid="WinJS.Promise.then_p:error">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument.
                /// </param>
                /// <param name="onProgress" type="Function" optional="true" locid="WinJS.Promise.then_p:progress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.then_returnValue">
                /// A promise whose value is the result of executing the provided complete function.
                /// </returns>
                /// </signature>
                return Promise.as(value).then(onComplete, onError, onProgress);
            },
            thenEach: function Promise_thenEach(values, onComplete, onError, onProgress) {
                /// <signature helpKeyword="WinJS.Promise.thenEach">
                /// <summary locid="WinJS.Promise.thenEach">
                /// Performs an operation on all the input promises and returns a promise
                /// that has the shape of the input and contains the result of the operation
                /// that has been performed on each input.
                /// </summary>
                /// <param name="values" locid="WinJS.Promise.thenEach_p:values">
                /// A set of values (which could be either an array or an object) of which some or all are promises.
                /// </param>
                /// <param name="onComplete" type="Function" locid="WinJS.Promise.thenEach_p:complete">
                /// The function to be called if the promise is fulfilled with a value.
                /// If the value is null, the promise returns the value.
                /// The value is passed as the single argument.
                /// </param>
                /// <param name="onError" type="Function" optional="true" locid="WinJS.Promise.thenEach_p:error">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument.
                /// </param>
                /// <param name="onProgress" type="Function" optional="true" locid="WinJS.Promise.thenEach_p:progress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.thenEach_returnValue">
                /// A promise that is the result of calling Promise.join on the values parameter.
                /// </returns>
                /// </signature>
                var result = Array.isArray(values) ? [] : {};
                Object.keys(values).forEach(function (key) {
                    result[key] = Promise.as(values[key]).then(onComplete, onError, onProgress);
                });
                return Promise.join(result);
            },
            timeout: function Promise_timeout(time, promise) {
                /// <signature helpKeyword="WinJS.Promise.timeout">
                /// <summary locid="WinJS.Promise.timeout">
                /// Creates a promise that is fulfilled after a timeout.
                /// </summary>
                /// <param name="timeout" type="Number" optional="true" locid="WinJS.Promise.timeout_p:timeout">
                /// The timeout period in milliseconds. If this value is zero or not specified
                /// setImmediate is called, otherwise setTimeout is called.
                /// </param>
                /// <param name="promise" type="Promise" optional="true" locid="WinJS.Promise.timeout_p:promise">
                /// A promise that will be canceled if it doesn't complete before the
                /// timeout has expired.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.timeout_returnValue">
                /// A promise that is completed asynchronously after the specified timeout.
                /// </returns>
                /// </signature>
                var to = timeout(time);
                return promise ? timeoutWithPromise(to, promise) : to;
            },
            wrap: function Promise_wrap(value) {
                /// <signature helpKeyword="WinJS.Promise.wrap">
                /// <summary locid="WinJS.Promise.wrap">
                /// Wraps a non-promise value in a promise. You can use this function if you need
                /// to pass a value to a function that requires a promise.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.wrap_p:value">
                /// Some non-promise value to be wrapped in a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.wrap_returnValue">
                /// A promise that is successfully fulfilled with the specified value
                /// </returns>
                /// </signature>
                return new CompletePromise(value);
            },
            wrapError: function Promise_wrapError(error) {
                /// <signature helpKeyword="WinJS.Promise.wrapError">
                /// <summary locid="WinJS.Promise.wrapError">
                /// Wraps a non-promise error value in a promise. You can use this function if you need
                /// to pass an error to a function that requires a promise.
                /// </summary>
                /// <param name="error" locid="WinJS.Promise.wrapError_p:error">
                /// A non-promise error value to be wrapped in a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.wrapError_returnValue">
                /// A promise that is in an error state with the specified value.
                /// </returns>
                /// </signature>
                return new ErrorPromise(error);
            },

            _veryExpensiveTagWithStack: {
                get: function () { return tagWithStack; },
                set: function (value) { tagWithStack = value; }
            },
            _veryExpensiveTagWithStack_tag: tag,
            _getStack: function () {
                if (Debug.debuggerEnabled) {
                    try { throw new Error(); } catch (e) { return e.stack; }
                }
            },

        }
    );
    Object.defineProperties(Promise, WinJS.Utilities.createEventProperties(errorET));

    var SignalPromise = WinJS.Class.derive(PromiseStateMachine,
        function (cancel) {
            this._oncancel = cancel;
            this._setState(state_created);
            this._run();
        }, {
            _cancelAction: function () { this._oncancel && this._oncancel(); },
            _cleanupAction: function () { this._oncancel = null; }
        }, {
            supportedForProcessing: false
        }
    );

    var Signal = WinJS.Class.define(
        function Signal_ctor(oncancel) {
            this._promise = new SignalPromise(oncancel);
        }, {
            promise: {
                get: function () { return this._promise; }
            },

            cancel: function Signal_cancel() {
                this._promise.cancel();
            },
            complete: function Signal_complete(value) {
                this._promise._completed(value);
            },
            error: function Signal_error(value) {
                this._promise._error(value);
            },
            progress: function Signal_progress(value) {
                this._promise._progress(value);
            }
        }, {
            supportedForProcessing: false,
        }
    );

    // Publish WinJS.Promise
    //
    WinJS.Namespace.define("WinJS", {
        Promise: Promise,
        _Signal: Signal
    });

}(this, this.WinJS));

(function errorsInit(global, WinJS) {
    "use strict";


    WinJS.Namespace.define("WinJS", {
        // ErrorFromName establishes a simple pattern for returning error codes.
        //
        ErrorFromName: WinJS.Class.derive(Error, function (name, message) {
            /// <signature helpKeyword="WinJS.ErrorFromName">
            /// <summary locid="WinJS.ErrorFromName">
            /// Creates an Error object with the specified name and message properties.
            /// </summary>
            /// <param name="name" type="String" locid="WinJS.ErrorFromName_p:name">The name of this error. The name is meant to be consumed programmatically and should not be localized.</param>
            /// <param name="message" type="String" optional="true" locid="WinJS.ErrorFromName_p:message">The message for this error. The message is meant to be consumed by humans and should be localized.</param>
            /// <returns type="Error" locid="WinJS.ErrorFromName_returnValue">Error instance with .name and .message properties populated</returns>
            /// </signature>
            this.name = name;
            this.message = message || name;
        }, {
            /* empty */
        }, {
            supportedForProcessing: false,
        })
    });

})(this, this.WinJS);


(function xhrInit(WinJS) {
    "use strict";


    WinJS.Namespace.define("WinJS", {
        xhr: function (options) {
            /// <signature helpKeyword="WinJS.xhr">
            /// <summary locid="WinJS.xhr">
            /// Wraps calls to XMLHttpRequest in a promise.
            /// </summary>
            /// <param name="options" type="Object" locid="WinJS.xhr_p:options">
            /// The options that are applied to the XMLHttpRequest object. They are: type,
            /// url, user, password, headers, responseType, data, and customRequestInitializer.
            /// </param>
            /// <returns type="WinJS.Promise" locid="WinJS.xhr_returnValue">
            /// A promise that returns the XMLHttpRequest object when it completes.
            /// </returns>
            /// </signature>
            var req;
            return new WinJS.Promise(
                function (c, e, p) {
                    /// <returns value="c(new XMLHttpRequest())" locid="WinJS.xhr.constructor._returnValue" />
                    req = new XMLHttpRequest();
                    req.onreadystatechange = function () {
                        if (req._canceled) { return; }

                        if (req.readyState === 4) {
							// MONACO CHANGE: Handle 1223: http://bugs.jquery.com/ticket/1450
                            if ((req.status >= 200 && req.status < 300) || req.status === 1223) {
                                c(req);
                            } else {
                                e(req);
                            }
                            req.onreadystatechange = function () { };
                        } else {
                            p(req);
                        }
                    };

                    req.open(
                        options.type || "GET",
                        options.url,
                        // Promise based XHR does not support sync.
                        //
                        true,
                        options.user,
                        options.password
                    );
                    req.responseType = options.responseType || "";

                    Object.keys(options.headers || {}).forEach(function (k) {
                        req.setRequestHeader(k, options.headers[k]);
                    });

                    if (options.customRequestInitializer) {
                        options.customRequestInitializer(req);
                    }

                    req.send(options.data);
                },
                function () {
                    req._canceled = true;
                    req.abort();
                }
            );
        }
    });

})(this.WinJS);


(function safeHTMLInit(global, WinJS, undefined) {
    "use strict";


    var setInnerHTML,
        setInnerHTMLUnsafe,
        setOuterHTML,
        setOuterHTMLUnsafe,
        insertAdjacentHTML,
        insertAdjacentHTMLUnsafe;

    var strings = {
		// MONACO CHANGE
        //get nonStaticHTML() { return WinJS.Resources._getWinJSString("base/nonStaticHTML").value; },
		nonStaticHTML: "Unable to add dynamic content. A script attempted to inject dynamic content, or elements previously modified dynamically, that might be unsafe. For example, using the innerHTML property or the document.write method to add a script element will generate this exception. If the content is safe and from a trusted source, use a method to explicitly manipulate elements and attributes, such as createElement, or use setInnerHTMLUnsafe (or other unsafe method)."
    };

    setInnerHTML = setInnerHTMLUnsafe = function (element, text) {
        /// <signature helpKeyword="WinJS.Utilities.setInnerHTML">
        /// <summary locid="WinJS.Utilities.setInnerHTML">
        /// Sets the innerHTML property of the specified element to the specified text.
        /// </summary>
        /// <param name="element" type="HTMLElement" locid="WinJS.Utilities.setInnerHTML_p:element">
        /// The element on which the innerHTML property is to be set.
        /// </param>
        /// <param name="text" type="String" locid="WinJS.Utilities.setInnerHTML_p:text">
        /// The value to be set to the innerHTML property.
        /// </param>
        /// </signature>
        element.innerHTML = text;
    };
    setOuterHTML = setOuterHTMLUnsafe = function (element, text) {
        /// <signature helpKeyword="WinJS.Utilities.setOuterHTML">
        /// <summary locid="WinJS.Utilities.setOuterHTML">
        /// Sets the outerHTML property of the specified element to the specified text.
        /// </summary>
        /// <param name="element" type="HTMLElement" locid="WinJS.Utilities.setOuterHTML_p:element">
        /// The element on which the outerHTML property is to be set.
        /// </param>
        /// <param name="text" type="String" locid="WinJS.Utilities.setOuterHTML_p:text">
        /// The value to be set to the outerHTML property.
        /// </param>
        /// </signature>
        element.outerHTML = text;
    };
    insertAdjacentHTML = insertAdjacentHTMLUnsafe = function (element, position, text) {
        /// <signature helpKeyword="WinJS.Utilities.insertAdjacentHTML">
        /// <summary locid="WinJS.Utilities.insertAdjacentHTML">
        /// Calls insertAdjacentHTML on the specified element.
        /// </summary>
        /// <param name="element" type="HTMLElement" locid="WinJS.Utilities.insertAdjacentHTML_p:element">
        /// The element on which insertAdjacentHTML is to be called.
        /// </param>
        /// <param name="position" type="String" locid="WinJS.Utilities.insertAdjacentHTML_p:position">
        /// The position relative to the element at which to insert the HTML.
        /// </param>
        /// <param name="text" type="String" locid="WinJS.Utilities.insertAdjacentHTML_p:text">
        /// The value to be provided to insertAdjacentHTML.
        /// </param>
        /// </signature>
        element.insertAdjacentHTML(position, text);
    };

    var msApp = global.MSApp;
    if (msApp) {
        setInnerHTMLUnsafe = function (element, text) {
            /// <signature helpKeyword="WinJS.Utilities.setInnerHTMLUnsafe">
            /// <summary locid="WinJS.Utilities.setInnerHTMLUnsafe">
            /// Sets the innerHTML property of the specified element to the specified text.
            /// </summary>
            /// <param name='element' type='HTMLElement' locid="WinJS.Utilities.setInnerHTMLUnsafe_p:element">
            /// The element on which the innerHTML property is to be set.
            /// </param>
            /// <param name='text' type="String" locid="WinJS.Utilities.setInnerHTMLUnsafe_p:text">
            /// The value to be set to the innerHTML property.
            /// </param>
            /// </signature>
            msApp.execUnsafeLocalFunction(function () {
                element.innerHTML = text;
            });
        };
        setOuterHTMLUnsafe = function (element, text) {
            /// <signature helpKeyword="WinJS.Utilities.setOuterHTMLUnsafe">
            /// <summary locid="WinJS.Utilities.setOuterHTMLUnsafe">
            /// Sets the outerHTML property of the specified element to the specified text
            /// in the context of msWWA.execUnsafeLocalFunction.
            /// </summary>
            /// <param name="element" type="HTMLElement" locid="WinJS.Utilities.setOuterHTMLUnsafe_p:element">
            /// The element on which the outerHTML property is to be set.
            /// </param>
            /// <param name="text" type="String" locid="WinJS.Utilities.setOuterHTMLUnsafe_p:text">
            /// The value to be set to the outerHTML property.
            /// </param>
            /// </signature>
            msApp.execUnsafeLocalFunction(function () {
                element.outerHTML = text;
            });
        };
        insertAdjacentHTMLUnsafe = function (element, position, text) {
            /// <signature helpKeyword="WinJS.Utilities.insertAdjacentHTMLUnsafe">
            /// <summary locid="WinJS.Utilities.insertAdjacentHTMLUnsafe">
            /// Calls insertAdjacentHTML on the specified element in the context
            /// of msWWA.execUnsafeLocalFunction.
            /// </summary>
            /// <param name="element" type="HTMLElement" locid="WinJS.Utilities.insertAdjacentHTMLUnsafe_p:element">
            /// The element on which insertAdjacentHTML is to be called.
            /// </param>
            /// <param name="position" type="String" locid="WinJS.Utilities.insertAdjacentHTMLUnsafe_p:position">
            /// The position relative to the element at which to insert the HTML.
            /// </param>
            /// <param name="text" type="String" locid="WinJS.Utilities.insertAdjacentHTMLUnsafe_p:text">
            /// Value to be provided to insertAdjacentHTML.
            /// </param>
            /// </signature>
            msApp.execUnsafeLocalFunction(function () {
                element.insertAdjacentHTML(position, text);
            });
        };
    }
    else if (global.msIsStaticHTML) {
        var check = function (str) {
            if (!global.msIsStaticHTML(str)) {
                throw new WinJS.ErrorFromName("WinJS.Utitilies.NonStaticHTML", strings.nonStaticHTML);
            }
        }
        // If we ever get isStaticHTML we can attempt to recreate the behavior we have in the local
        // compartment, in the mean-time all we can do is sanitize the input.
        //
        setInnerHTML = function (element, text) {
            /// <signature helpKeyword="WinJS.Utilities.setInnerHTML">
            /// <summary locid="WinJS.Utilities.msIsStaticHTML.setInnerHTML">
            /// Sets the innerHTML property of a element to the specified text
            /// if it passes a msIsStaticHTML check.
            /// </summary>
            /// <param name="element" type="HTMLElement" locid="WinJS.Utilities.msIsStaticHTML.setInnerHTML_p:element">
            /// The element on which the innerHTML property is to be set.
            /// </param>
            /// <param name="text" type="String" locid="WinJS.Utilities.msIsStaticHTML.setInnerHTML_p:text">
            /// The value to be set to the innerHTML property.
            /// </param>
            /// </signature>
            check(text);
            element.innerHTML = text;
        };
        setOuterHTML = function (element, text) {
            /// <signature helpKeyword="WinJS.Utilities.setOuterHTML">
            /// <summary locid="WinJS.Utilities.msIsStaticHTML.setOuterHTML">
            /// Sets the outerHTML property of a element to the specified text
            /// if it passes a msIsStaticHTML check.
            /// </summary>
            /// <param name="element" type="HTMLElement" locid="WinJS.Utilities.msIsStaticHTML.setOuterHTML_p:element">
            /// The element on which the outerHTML property is to be set.
            /// </param>
            /// <param name="text" type="String" locid="WinJS.Utilities.msIsStaticHTML.setOuterHTML_p:text">
            /// The value to be set to the outerHTML property.
            /// </param>
            /// </signature>
            check(text);
            element.outerHTML = text;
        };
        insertAdjacentHTML = function (element, position, text) {
            /// <signature helpKeyword="WinJS.Utilities.insertAdjacentHTML">
            /// <summary locid="WinJS.Utilities.msIsStaticHTML.insertAdjacentHTML">
            /// Calls insertAdjacentHTML on the element if it passes
            /// a msIsStaticHTML check.
            /// </summary>
            /// <param name="element" type="HTMLElement" locid="WinJS.Utilities.msIsStaticHTML.insertAdjacentHTML_p:element">
            /// The element on which insertAdjacentHTML is to be called.
            /// </param>
            /// <param name="position" type="String" locid="WinJS.Utilities.msIsStaticHTML.insertAdjacentHTML_p:position">
            /// The position relative to the element at which to insert the HTML.
            /// </param>
            /// <param name="text" type="String" locid="WinJS.Utilities.msIsStaticHTML.insertAdjacentHTML_p:text">
            /// The value to be provided to insertAdjacentHTML.
            /// </param>
            /// </signature>
            check(text);
            element.insertAdjacentHTML(position, text);
        };
    }

    WinJS.Namespace.define("WinJS.Utilities", {
        setInnerHTML: setInnerHTML,
        setInnerHTMLUnsafe: setInnerHTMLUnsafe,
        setOuterHTML: setOuterHTML,
        setOuterHTMLUnsafe: setOuterHTMLUnsafe,
        insertAdjacentHTML: insertAdjacentHTML,
        insertAdjacentHTMLUnsafe: insertAdjacentHTMLUnsafe
    });

}(this, this.WinJS));



// MONACO CHANGE
} // if (typeof WinJS === 'undefined')

(function(global) {

    if (typeof exports === 'undefined' && typeof define === 'function' && define.amd) {
        define("vs/base/common/winjs.base.raw", global.WinJS);
    } else {
        module.exports = global.WinJS;
    }

})(this);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/base/node/flow", ["require", "exports", 'assert'], function (require, exports, assert) {
    'use strict';
    /**
     * Executes the given function (fn) over the given array of items (list) in parallel and returns the resulting errors and results as
     * array to the callback (callback). The resulting errors and results are evaluated by calling the provided callback function.
     */
    function parallel(list, fn, callback) {
        var results = new Array(list.length);
        var errors = new Array(list.length);
        var didErrorOccur = false;
        var doneCount = 0;
        if (list.length === 0) {
            return callback(null, []);
        }
        list.forEach(function (item, index) {
            fn(item, function (error, result) {
                if (error) {
                    didErrorOccur = true;
                    results[index] = null;
                    errors[index] = error;
                }
                else {
                    results[index] = result;
                    errors[index] = null;
                }
                if (++doneCount === list.length) {
                    return callback(didErrorOccur ? errors : null, results);
                }
            });
        });
    }
    exports.parallel = parallel;
    function loop(param, fn, callback) {
        // Assert
        assert.ok(param, 'Missing first parameter');
        assert.ok(typeof (fn) === 'function', 'Second parameter must be a function that is called for each element');
        assert.ok(typeof (callback) === 'function', 'Third parameter must be a function that is called on error and success');
        // Param is function, execute to retrieve array
        if (typeof (param) === 'function') {
            try {
                param(function (error, result) {
                    if (error) {
                        callback(error, null);
                    }
                    else {
                        loop(result, fn, callback);
                    }
                });
            }
            catch (error) {
                callback(error, null);
            }
        }
        else {
            var results_1 = [];
            var looper_1 = function (i) {
                // Still work to do
                if (i < param.length) {
                    // Execute function on array element
                    try {
                        fn(param[i], function (error, result) {
                            // A method might only send a boolean value as return value (e.g. fs.exists), support this case gracefully
                            if (error === true || error === false) {
                                result = error;
                                error = null;
                            }
                            // Quit looping on error
                            if (error) {
                                callback(error, null);
                            }
                            else {
                                if (result) {
                                    results_1.push(result);
                                }
                                process.nextTick(function () {
                                    looper_1(i + 1);
                                });
                            }
                        }, i, param.length);
                    }
                    catch (error) {
                        callback(error, null);
                    }
                }
                else {
                    callback(null, results_1);
                }
            };
            // Start looping with first element in array
            looper_1(0);
        }
    }
    exports.loop = loop;
    function Sequence(sequences) {
        // Assert
        assert.ok(sequences.length > 1, 'Need at least one error handler and one function to process sequence');
        sequences.forEach(function (sequence) {
            assert.ok(typeof (sequence) === 'function');
        });
        // Execute in Loop
        var errorHandler = sequences.splice(0, 1)[0]; //Remove error handler
        var sequenceResult = null;
        loop(sequences, function (sequence, clb) {
            var sequenceFunction = function (error, result) {
                // A method might only send a boolean value as return value (e.g. fs.exists), support this case gracefully
                if (error === true || error === false) {
                    result = error;
                    error = null;
                }
                // Handle Error and Result
                if (error) {
                    clb(error, null);
                }
                else {
                    sequenceResult = result; //Remember result of sequence
                    clb(null, null); //Don't pass on result to Looper as we are not aggregating it
                }
            };
            // We call the sequence function setting "this" to be the callback we define here
            // and we pass in the "sequenceResult" as first argument. Doing all this avoids having
            // to pass in a callback to the sequence because the callback is already "this".
            try {
                sequence.call(sequenceFunction, sequenceResult);
            }
            catch (error) {
                clb(error, null);
            }
        }, function (error, result) {
            if (error) {
                errorHandler(error);
            }
        });
    }
    function sequence(sequences) {
        Sequence((Array.isArray(sequences)) ? sequences : Array.prototype.slice.call(arguments));
    }
    exports.sequence = sequence;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/base/node/extfs", ["require", "exports", 'vs/base/common/uuid', 'vs/base/common/strings', 'vs/base/common/platform', 'vs/base/node/flow', 'fs', 'path'], function (require, exports, uuid, strings, platform, flow, fs, paths) {
    'use strict';
    var loop = flow.loop;
    function readdir(path, callback) {
        // Mac: uses NFD unicode form on disk, but we want NFC
        // See also https://github.com/nodejs/node/issues/2165
        if (platform.isMacintosh) {
            return readdirNormalize(path, function (error, children) {
                if (error) {
                    return callback(error, null);
                }
                return callback(null, children.map(function (c) { return strings.normalizeNFC(c); }));
            });
        }
        return readdirNormalize(path, callback);
    }
    exports.readdir = readdir;
    function readdirNormalize(path, callback) {
        fs.readdir(path, function (error, children) {
            if (error) {
                return callback(error, null);
            }
            // Bug in node: In some environments we get "." and ".." as entries from the call to readdir().
            // For example Sharepoint via WebDav on Windows includes them. We never want those
            // entries in the result set though because they are not valid children of the folder
            // for our concerns.
            // See https://github.com/nodejs/node/issues/4002
            return callback(null, children.filter(function (c) { return c !== '.' && c !== '..'; }));
        });
    }
    function mkdirp(path, mode, callback) {
        fs.exists(path, function (exists) {
            if (exists) {
                return isDirectory(path, function (err, itIs) {
                    if (err) {
                        return callback(err);
                    }
                    if (!itIs) {
                        return callback(new Error('"' + path + '" is not a directory.'));
                    }
                    callback(null);
                });
            }
            mkdirp(paths.dirname(path), mode, function (err) {
                if (err) {
                    callback(err);
                    return;
                }
                if (mode) {
                    fs.mkdir(path, mode, function (error) {
                        if (error) {
                            return callback(error);
                        }
                        fs.chmod(path, mode, callback); // we need to explicitly chmod because of https://github.com/nodejs/node/issues/1104
                    });
                }
                else {
                    fs.mkdir(path, null, callback);
                }
            });
        });
    }
    exports.mkdirp = mkdirp;
    function isDirectory(path, callback) {
        fs.stat(path, function (error, stat) {
            if (error) {
                return callback(error);
            }
            callback(null, stat.isDirectory());
        });
    }
    function copy(source, target, callback, copiedSources) {
        if (!copiedSources) {
            copiedSources = Object.create(null);
        }
        fs.stat(source, function (error, stat) {
            if (error) {
                return callback(error);
            }
            if (!stat.isDirectory()) {
                return pipeFs(source, target, stat.mode & 511, callback);
            }
            if (copiedSources[source]) {
                return callback(null); // escape when there are cycles (can happen with symlinks)
            }
            else {
                copiedSources[source] = true; // remember as copied
            }
            mkdirp(target, stat.mode & 511, function (err) {
                readdir(source, function (err, files) {
                    loop(files, function (file, clb) {
                        copy(paths.join(source, file), paths.join(target, file), clb, copiedSources);
                    }, callback);
                });
            });
        });
    }
    exports.copy = copy;
    function pipeFs(source, target, mode, callback) {
        var callbackHandled = false;
        var readStream = fs.createReadStream(source);
        var writeStream = fs.createWriteStream(target, { mode: mode });
        var onError = function (error) {
            if (!callbackHandled) {
                callbackHandled = true;
                callback(error);
            }
        };
        readStream.on('error', onError);
        writeStream.on('error', onError);
        readStream.on('end', function () {
            writeStream.end(function () {
                if (!callbackHandled) {
                    callbackHandled = true;
                    fs.chmod(target, mode, callback); // we need to explicitly chmod because of https://github.com/nodejs/node/issues/1104
                }
            });
        });
        // In node 0.8 there is no easy way to find out when the pipe operation has finished. As such, we use the end property = false
        // so that we are in charge of calling end() on the write stream and we will be notified when the write stream is really done.
        // We can do this because file streams have an end() method that allows to pass in a callback.
        // In node 0.10 there is an event 'finish' emitted from the write stream that can be used. See
        // https://groups.google.com/forum/?fromgroups=#!topic/nodejs/YWQ1sRoXOdI
        readStream.pipe(writeStream, { end: false });
    }
    // Deletes the given path by first moving it out of the workspace. This has two benefits. For one, the operation can return fast because
    // after the rename, the contents are out of the workspace although not yet deleted. The greater benefit however is that this operation
    // will fail in case any file is used by another process. fs.unlink() in node will not bail if a file unlinked is used by another process.
    // However, the consequences are bad as outlined in all the related bugs from https://github.com/joyent/node/issues/7164
    function del(path, tmpFolder, callback, done) {
        fs.exists(path, function (exists) {
            if (!exists) {
                return callback(null);
            }
            fs.stat(path, function (err, stat) {
                if (err || !stat) {
                    return callback(err);
                }
                // Special windows workaround: A file or folder that ends with a "." cannot be moved to another place
                // because it is not a valid file name. In this case, we really have to do the deletion without prior move.
                if (path[path.length - 1] === '.' || strings.endsWith(path, './') || strings.endsWith(path, '.\\')) {
                    return rmRecursive(path, callback);
                }
                var pathInTemp = paths.join(tmpFolder, uuid.generateUuid());
                fs.rename(path, pathInTemp, function (error) {
                    if (error) {
                        return rmRecursive(path, callback); // if rename fails, delete without tmp dir
                    }
                    // Return early since the move succeeded
                    callback(null);
                    // do the heavy deletion outside the callers callback
                    rmRecursive(pathInTemp, function (error) {
                        if (error) {
                            console.error(error);
                        }
                        if (done) {
                            done(error);
                        }
                    });
                });
            });
        });
    }
    exports.del = del;
    function rmRecursive(path, callback) {
        if (path === '\\' || path === '/') {
            return callback(new Error('Will not delete root!'));
        }
        fs.exists(path, function (exists) {
            if (!exists) {
                callback(null);
            }
            else {
                fs.lstat(path, function (err, stat) {
                    if (err || !stat) {
                        callback(err);
                    }
                    else if (!stat.isDirectory() || stat.isSymbolicLink() /* !!! never recurse into links when deleting !!! */) {
                        var mode = stat.mode;
                        if (!(mode & 128)) {
                            fs.chmod(path, mode | 128, function (err) {
                                if (err) {
                                    callback(err);
                                }
                                else {
                                    fs.unlink(path, callback);
                                }
                            });
                        }
                        else {
                            fs.unlink(path, callback);
                        }
                    }
                    else {
                        readdir(path, function (err, children) {
                            if (err || !children) {
                                callback(err);
                            }
                            else if (children.length === 0) {
                                fs.rmdir(path, callback);
                            }
                            else {
                                var firstError_1 = null;
                                var childrenLeft_1 = children.length;
                                children.forEach(function (child) {
                                    rmRecursive(paths.join(path, child), function (err) {
                                        childrenLeft_1--;
                                        if (err) {
                                            firstError_1 = firstError_1 || err;
                                        }
                                        if (childrenLeft_1 === 0) {
                                            if (firstError_1) {
                                                callback(firstError_1);
                                            }
                                            else {
                                                fs.rmdir(path, callback);
                                            }
                                        }
                                    });
                                });
                            }
                        });
                    }
                });
            }
        });
    }
    function mv(source, target, callback) {
        if (source === target) {
            return callback(null);
        }
        function updateMtime(err) {
            if (err) {
                return callback(err);
            }
            fs.stat(target, function (error, stat) {
                if (error) {
                    return callback(error);
                }
                if (stat.isDirectory()) {
                    return callback(null);
                }
                fs.open(target, 'a', null, function (err, fd) {
                    if (err) {
                        return callback(err);
                    }
                    fs.futimes(fd, stat.atime, new Date(), function (err) {
                        if (err) {
                            return callback(err);
                        }
                        fs.close(fd, callback);
                    });
                });
            });
        }
        // Try native rename()
        fs.rename(source, target, function (err) {
            if (!err) {
                return updateMtime(null);
            }
            // In two cases we fallback to classic copy and delete:
            //
            // 1.) The EXDEV error indicates that source and target are on different devices
            // In this case, fallback to using a copy() operation as there is no way to
            // rename() between different devices.
            //
            // 2.) The user tries to rename a file/folder that ends with a dot. This is not
            // really possible to move then, at least on UNC devices.
            if (err && source.toLowerCase() !== target.toLowerCase() && (err.code === 'EXDEV') || strings.endsWith(source, '.')) {
                return copy(source, target, function (err) {
                    if (err) {
                        return callback(err);
                    }
                    rmRecursive(source, updateMtime);
                });
            }
            return callback(err);
        });
    }
    exports.mv = mv;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/base/node/proxy", ["require", "exports", 'url', 'vs/base/common/types', 'http-proxy-agent', 'https-proxy-agent'], function (require, exports, url_1, types_1, HttpProxyAgent, HttpsProxyAgent) {
    'use strict';
    function getSystemProxyURI(requestURL) {
        if (requestURL.protocol === 'http:') {
            return process.env.HTTP_PROXY || process.env.http_proxy || null;
        }
        else if (requestURL.protocol === 'https:') {
            return process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null;
        }
        return null;
    }
    function getProxyAgent(rawRequestURL, options) {
        if (options === void 0) { options = {}; }
        var requestURL = url_1.parse(rawRequestURL);
        var proxyURL = options.proxyUrl || getSystemProxyURI(requestURL);
        if (!proxyURL) {
            return null;
        }
        var proxyEndpoint = url_1.parse(proxyURL);
        if (!/^https?:$/.test(proxyEndpoint.protocol)) {
            return null;
        }
        var opts = {
            host: proxyEndpoint.hostname,
            port: Number(proxyEndpoint.port),
            auth: proxyEndpoint.auth,
            rejectUnauthorized: types_1.isBoolean(options.strictSSL) ? options.strictSSL : true
        };
        return requestURL.protocol === 'http:' ? new HttpProxyAgent(opts) : new HttpsProxyAgent(opts);
    }
    exports.getProxyAgent = getProxyAgent;
});

define("vs/editor/common/core/arrays", ["require", "exports"], function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Arrays;
    (function (Arrays) {
        /**
         * Given a sorted array of natural number segments, find the segment containing a natural number.
         *    For example, the segments [0, 5), [5, 9), [9, infinity) will be represented in the following manner:
         *       [{ startIndex: 0 }, { startIndex: 5 }, { startIndex: 9 }]
         *    Searching for 0, 1, 2, 3 or 4 will return 0.
         *    Searching for 5, 6, 7 or 8 will return 1.
         *    Searching for 9, 10, 11, ... will return 2.
         * @param arr A sorted array representing natural number segments
         * @param desiredIndex The search
         * @return The index of the containing segment in the array.
         */
        function findIndexInSegmentsArray(arr, desiredIndex) {
            var low = 0, high = arr.length - 1, mid;
            while (low < high) {
                mid = low + Math.ceil((high - low) / 2);
                if (arr[mid].startIndex > desiredIndex) {
                    high = mid - 1;
                }
                else {
                    low = mid;
                }
            }
            return low;
        }
        Arrays.findIndexInSegmentsArray = findIndexInSegmentsArray;
    })(Arrays = exports.Arrays || (exports.Arrays = {}));
});

define("vs/editor/common/core/position", ["require", "exports"], function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Position = (function () {
        function Position(lineNumber, column) {
            this.lineNumber = lineNumber;
            this.column = column;
        }
        Position.prototype.equals = function (other) {
            return Position.equals(this, other);
        };
        Position.equals = function (a, b) {
            if (!a && !b) {
                return true;
            }
            return (!!a &&
                !!b &&
                a.lineNumber === b.lineNumber &&
                a.column === b.column);
        };
        Position.prototype.isBefore = function (other) {
            return Position.isBefore(this, other);
        };
        Position.isBefore = function (a, b) {
            if (a.lineNumber < b.lineNumber) {
                return true;
            }
            if (b.lineNumber < a.lineNumber) {
                return false;
            }
            return a.column < b.column;
        };
        Position.prototype.isBeforeOrEqual = function (other) {
            return Position.isBeforeOrEqual(this, other);
        };
        Position.isBeforeOrEqual = function (a, b) {
            if (a.lineNumber < b.lineNumber) {
                return true;
            }
            if (b.lineNumber < a.lineNumber) {
                return false;
            }
            return a.column <= b.column;
        };
        Position.prototype.clone = function () {
            return new Position(this.lineNumber, this.column);
        };
        Position.prototype.toString = function () {
            return '(' + this.lineNumber + ',' + this.column + ')';
        };
        // ---
        Position.lift = function (pos) {
            return new Position(pos.lineNumber, pos.column);
        };
        Position.isIPosition = function (obj) {
            return (obj
                && (typeof obj.lineNumber === 'number')
                && (typeof obj.column === 'number'));
        };
        Position.asEmptyRange = function (position) {
            return {
                startLineNumber: position.lineNumber,
                startColumn: position.column,
                endLineNumber: position.lineNumber,
                endColumn: position.column
            };
        };
        Position.startPosition = function (range) {
            return {
                lineNumber: range.startLineNumber,
                column: range.startColumn
            };
        };
        Position.endPosition = function (range) {
            return {
                lineNumber: range.endLineNumber,
                column: range.endColumn
            };
        };
        return Position;
    }());
    exports.Position = Position;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/editor/common/core/range", ["require", "exports", 'vs/editor/common/core/position'], function (require, exports, position_1) {
    'use strict';
    var Range = (function () {
        function Range(startLineNumber, startColumn, endLineNumber, endColumn) {
            if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {
                this.startLineNumber = endLineNumber;
                this.startColumn = endColumn;
                this.endLineNumber = startLineNumber;
                this.endColumn = startColumn;
            }
            else {
                this.startLineNumber = startLineNumber;
                this.startColumn = startColumn;
                this.endLineNumber = endLineNumber;
                this.endColumn = endColumn;
            }
        }
        Range.prototype.isEmpty = function () {
            return Range.isEmpty(this);
        };
        Range.prototype.containsPosition = function (position) {
            return Range.containsPosition(this, position);
        };
        Range.prototype.containsRange = function (range) {
            return Range.containsRange(this, range);
        };
        Range.prototype.plusRange = function (range) {
            return Range.plusRange(this, range);
        };
        Range.prototype.intersectRanges = function (range) {
            return Range.intersectRanges(this, range);
        };
        Range.prototype.equalsRange = function (other) {
            return Range.equalsRange(this, other);
        };
        Range.prototype.getEndPosition = function () {
            return new position_1.Position(this.endLineNumber, this.endColumn);
        };
        Range.prototype.getStartPosition = function () {
            return new position_1.Position(this.startLineNumber, this.startColumn);
        };
        Range.prototype.cloneRange = function () {
            return new Range(this.startLineNumber, this.startColumn, this.endLineNumber, this.endColumn);
        };
        Range.prototype.toString = function () {
            return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';
        };
        Range.prototype.setEndPosition = function (endLineNumber, endColumn) {
            return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
        };
        Range.prototype.setStartPosition = function (startLineNumber, startColumn) {
            return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
        };
        Range.prototype.collapseToStart = function () {
            return new Range(this.startLineNumber, this.startColumn, this.startLineNumber, this.startColumn);
        };
        // ---
        Range.lift = function (range) {
            if (!range) {
                return null;
            }
            return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
        };
        Range.isIRange = function (obj) {
            return (obj
                && (typeof obj.startLineNumber === 'number')
                && (typeof obj.startColumn === 'number')
                && (typeof obj.endLineNumber === 'number')
                && (typeof obj.endColumn === 'number'));
        };
        Range.isEmpty = function (range) {
            return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);
        };
        Range.containsPosition = function (range, position) {
            if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
                return false;
            }
            if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {
                return false;
            }
            if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {
                return false;
            }
            return true;
        };
        Range.containsRange = function (range, otherRange) {
            if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
                return false;
            }
            if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
                return false;
            }
            if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {
                return false;
            }
            if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {
                return false;
            }
            return true;
        };
        Range.areIntersectingOrTouching = function (a, b) {
            // Check if `a` is before `b`
            if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {
                return false;
            }
            // Check if `b` is before `a`
            if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {
                return false;
            }
            // These ranges must intersect
            return true;
        };
        Range.intersectRanges = function (a, b) {
            var resultStartLineNumber = a.startLineNumber, resultStartColumn = a.startColumn, resultEndLineNumber = a.endLineNumber, resultEndColumn = a.endColumn, otherStartLineNumber = b.startLineNumber, otherStartColumn = b.startColumn, otherEndLineNumber = b.endLineNumber, otherEndColumn = b.endColumn;
            if (resultStartLineNumber < otherStartLineNumber) {
                resultStartLineNumber = otherStartLineNumber;
                resultStartColumn = otherStartColumn;
            }
            else if (resultStartLineNumber === otherStartLineNumber) {
                resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
            }
            if (resultEndLineNumber > otherEndLineNumber) {
                resultEndLineNumber = otherEndLineNumber;
                resultEndColumn = otherEndColumn;
            }
            else if (resultEndLineNumber === otherEndLineNumber) {
                resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
            }
            // Check if selection is now empty
            if (resultStartLineNumber > resultEndLineNumber) {
                return null;
            }
            if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
                return null;
            }
            return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
        };
        Range.plusRange = function (a, b) {
            var startLineNumber, startColumn, endLineNumber, endColumn;
            if (b.startLineNumber < a.startLineNumber) {
                startLineNumber = b.startLineNumber;
                startColumn = b.startColumn;
            }
            else if (b.startLineNumber === a.startLineNumber) {
                startLineNumber = b.startLineNumber;
                startColumn = Math.min(b.startColumn, a.startColumn);
            }
            else {
                startLineNumber = a.startLineNumber;
                startColumn = a.startColumn;
            }
            if (b.endLineNumber > a.endLineNumber) {
                endLineNumber = b.endLineNumber;
                endColumn = b.endColumn;
            }
            else if (b.endLineNumber === a.endLineNumber) {
                endLineNumber = b.endLineNumber;
                endColumn = Math.max(b.endColumn, a.endColumn);
            }
            else {
                endLineNumber = a.endLineNumber;
                endColumn = a.endColumn;
            }
            return new Range(startLineNumber, startColumn, endLineNumber, endColumn);
        };
        Range.equalsRange = function (a, b) {
            return (!!a &&
                !!b &&
                a.startLineNumber === b.startLineNumber &&
                a.startColumn === b.startColumn &&
                a.endLineNumber === b.endLineNumber &&
                a.endColumn === b.endColumn);
        };
        /**
         * A function that compares ranges, useful for sorting ranges
         * It will first compare ranges on the startPosition and then on the endPosition
         */
        Range.compareRangesUsingStarts = function (a, b) {
            if (a.startLineNumber === b.startLineNumber) {
                if (a.startColumn === b.startColumn) {
                    if (a.endLineNumber === b.endLineNumber) {
                        return a.endColumn - b.endColumn;
                    }
                    return a.endLineNumber - b.endLineNumber;
                }
                return a.startColumn - b.startColumn;
            }
            return a.startLineNumber - b.startLineNumber;
        };
        /**
         * A function that compares ranges, useful for sorting ranges
         * It will first compare ranges on the endPosition and then on the startPosition
         */
        Range.compareRangesUsingEnds = function (a, b) {
            if (a.endLineNumber === b.endLineNumber) {
                if (a.endColumn === b.endColumn) {
                    if (a.startLineNumber === b.startLineNumber) {
                        return a.startColumn - b.startColumn;
                    }
                    return a.startLineNumber - b.startLineNumber;
                }
                return a.endColumn - b.endColumn;
            }
            return a.endLineNumber - b.endLineNumber;
        };
        Range.spansMultipleLines = function (range) {
            return range.endLineNumber > range.startLineNumber;
        };
        Range.collapseToStart = function (range) {
            return {
                startLineNumber: range.startLineNumber,
                startColumn: range.startColumn,
                endLineNumber: range.startLineNumber,
                endColumn: range.startColumn
            };
        };
        return Range;
    }());
    exports.Range = Range;
});

define("vs/editor/common/core/editOperation", ["require", "exports", 'vs/editor/common/core/range'], function (require, exports, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EditOperation = (function () {
        function EditOperation() {
        }
        EditOperation.insert = function (position, text) {
            return {
                identifier: null,
                range: new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column),
                text: text,
                forceMoveMarkers: true
            };
        };
        EditOperation.delete = function (range) {
            return {
                identifier: null,
                range: range,
                text: null,
                forceMoveMarkers: true
            };
        };
        EditOperation.replace = function (range, text) {
            return {
                identifier: null,
                range: range,
                text: text,
                forceMoveMarkers: false
            };
        };
        EditOperation.replaceMove = function (range, text) {
            return {
                identifier: null,
                range: range,
                text: text,
                forceMoveMarkers: true
            };
        };
        return EditOperation;
    }());
    exports.EditOperation = EditOperation;
});

define("vs/editor/common/model/indentationGuesser", ["require", "exports"], function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var __space = ' '.charCodeAt(0);
    var __tab = '\t'.charCodeAt(0);
    /**
     * Compute the diff in spaces between two line's indentation.
     */
    function spacesDiff(a, aLength, b, bLength) {
        // This can go both ways (e.g.):
        //  - a: "\t"
        //  - b: "\t    "
        //  => This should count 1 tab and 4 spaces
        var i;
        for (i = 0; i < aLength && i < bLength; i++) {
            var aCharCode = a.charCodeAt(i);
            var bCharCode = b.charCodeAt(i);
            if (aCharCode !== bCharCode) {
                break;
            }
        }
        var aSpacesCnt = 0, aTabsCount = 0;
        for (var j = i; j < aLength; j++) {
            var aCharCode = a.charCodeAt(j);
            if (aCharCode === __space) {
                aSpacesCnt++;
            }
            else {
                aTabsCount++;
            }
        }
        var bSpacesCnt = 0, bTabsCount = 0;
        for (var j = i; j < bLength; j++) {
            var bCharCode = b.charCodeAt(j);
            if (bCharCode === __space) {
                bSpacesCnt++;
            }
            else {
                bTabsCount++;
            }
        }
        if (aSpacesCnt > 0 && aTabsCount > 0) {
            return 0;
        }
        if (bSpacesCnt > 0 && bTabsCount > 0) {
            return 0;
        }
        var tabsDiff = Math.abs(aTabsCount - bTabsCount);
        var spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);
        if (tabsDiff === 0) {
            return spacesDiff;
        }
        if (spacesDiff % tabsDiff === 0) {
            return spacesDiff / tabsDiff;
        }
        return 0;
    }
    function guessIndentation(lines, defaultTabSize, defaultInsertSpaces) {
        var linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation
        var linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation
        var previousLineText = ''; // content of latest line that contained non-whitespace chars
        var previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char
        var ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8]; // limit guesses for `tabSize` to 2, 4, 6 or 8.
        var MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(2,4,6,8) = 8
        var spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores
        for (var i = 0, len = lines.length; i < len; i++) {
            var currentLineText = lines[i];
            var currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars
            var currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char
            var currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation
            var currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation
            for (var j = 0, lenJ = currentLineText.length; j < lenJ; j++) {
                var charCode = currentLineText.charCodeAt(j);
                if (charCode === __tab) {
                    currentLineTabsCount++;
                }
                else if (charCode === __space) {
                    currentLineSpacesCount++;
                }
                else {
                    // Hit non whitespace character on this line
                    currentLineHasContent = true;
                    currentLineIndentation = j;
                    break;
                }
            }
            // Ignore empty or only whitespace lines
            if (!currentLineHasContent) {
                continue;
            }
            if (currentLineTabsCount > 0) {
                linesIndentedWithTabsCount++;
            }
            else if (currentLineSpacesCount > 1) {
                linesIndentedWithSpacesCount++;
            }
            var currentSpacesDiff = spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation);
            if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {
                spacesDiffCount[currentSpacesDiff]++;
            }
            previousLineText = currentLineText;
            previousLineIndentation = currentLineIndentation;
        }
        // Take into account the last line as well
        var deltaSpacesCount = spacesDiff(previousLineText, previousLineIndentation, '', 0);
        if (deltaSpacesCount <= MAX_ALLOWED_TAB_SIZE_GUESS) {
            spacesDiffCount[deltaSpacesCount]++;
        }
        var insertSpaces = defaultInsertSpaces;
        if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {
            insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);
        }
        var tabSize = defaultTabSize;
        var tabSizeScore = (insertSpaces ? 0 : 0.1 * lines.length);
        // console.log("score threshold: " + tabSizeScore);
        ALLOWED_TAB_SIZE_GUESSES.forEach(function (possibleTabSize) {
            var possibleTabSizeScore = spacesDiffCount[possibleTabSize];
            if (possibleTabSizeScore > tabSizeScore) {
                tabSizeScore = possibleTabSizeScore;
                tabSize = possibleTabSize;
            }
        });
        // console.log('--------------------------');
        // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);
        // console.log('spacesDiffCount: ' + spacesDiffCount);
        // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);
        return {
            insertSpaces: insertSpaces,
            tabSize: tabSize
        };
    }
    exports.guessIndentation = guessIndentation;
});

define("vs/editor/common/modes", ["require", "exports"], function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    (function (IndentAction) {
        IndentAction[IndentAction["None"] = 0] = "None";
        IndentAction[IndentAction["Indent"] = 1] = "Indent";
        IndentAction[IndentAction["IndentOutdent"] = 2] = "IndentOutdent";
        IndentAction[IndentAction["Outdent"] = 3] = "Outdent";
    })(exports.IndentAction || (exports.IndentAction = {}));
    var IndentAction = exports.IndentAction;
});

define("vs/editor/common/modes/abstractState", ["require", "exports"], function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var AbstractState = (function () {
        function AbstractState(mode, stateData) {
            if (stateData === void 0) { stateData = null; }
            this.mode = mode;
            this.stateData = stateData;
        }
        AbstractState.prototype.getMode = function () {
            return this.mode;
        };
        AbstractState.prototype.clone = function () {
            var result = this.makeClone();
            result.initializeFrom(this);
            return result;
        };
        AbstractState.prototype.makeClone = function () {
            throw new Error('Abstract Method');
        };
        AbstractState.prototype.initializeFrom = function (other) {
            this.stateData = other.stateData !== null ? other.stateData.clone() : null;
        };
        AbstractState.prototype.getStateData = function () {
            return this.stateData;
        };
        AbstractState.prototype.setStateData = function (state) {
            this.stateData = state;
        };
        AbstractState.prototype.equals = function (other) {
            if (other === null || this.mode !== other.getMode()) {
                return false;
            }
            if (other instanceof AbstractState) {
                return AbstractState.safeEquals(this.stateData, other.stateData);
            }
            return false;
        };
        AbstractState.prototype.tokenize = function (stream) {
            throw new Error('Abstract Method');
        };
        AbstractState.safeEquals = function (a, b) {
            if (a === null && b === null) {
                return true;
            }
            if (a === null || b === null) {
                return false;
            }
            return a.equals(b);
        };
        AbstractState.safeClone = function (state) {
            if (state) {
                return state.clone();
            }
            return null;
        };
        return AbstractState;
    }());
    exports.AbstractState = AbstractState;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/editor/common/modes/languageSelector", ["require", "exports", 'vs/base/common/glob'], function (require, exports, glob_1) {
    'use strict';
    function matches(selection, uri, language) {
        return score(selection, uri, language) > 0;
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = matches;
    function score(selector, uri, language) {
        if (Array.isArray(selector)) {
            // for each
            var values = selector.map(function (item) { return score(item, uri, language); });
            return Math.max.apply(Math, values);
        }
        else if (typeof selector === 'string') {
            // compare language id
            if (selector === language) {
                return 10;
            }
            else if (selector === '*') {
                return 5;
            }
            else {
                return 0;
            }
        }
        else if (selector) {
            var filter = selector;
            var value = 0;
            // language id
            if (filter.language) {
                if (filter.language === language) {
                    value += 10;
                }
                else if (filter.language === '*') {
                    value += 5;
                }
                else {
                    return 0;
                }
            }
            // scheme
            if (filter.scheme) {
                if (filter.scheme === uri.scheme) {
                    value += 10;
                }
                else {
                    return 0;
                }
            }
            // match fsPath with pattern
            if (filter.pattern) {
                if (filter.pattern === uri.fsPath) {
                    value += 10;
                }
                else if (glob_1.match(filter.pattern, uri.fsPath)) {
                    value += 5;
                }
                else {
                    return 0;
                }
            }
            return value;
        }
    }
    exports.score = score;
});

define("vs/editor/common/modes/lineStream", ["require", "exports"], function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var LineStream = (function () {
        function LineStream(source) {
            this._source = source;
            this.sourceLength = source.length;
            this._pos = 0;
            this.whitespace = '\t \u00a0';
            this.whitespaceArr = this.stringToArray(this.whitespace);
            this.separators = '';
            this.separatorsArr = this.stringToArray(this.separators);
            this.tokenStart = -1;
            this.tokenEnd = -1;
        }
        LineStream.prototype.stringToArray = function (str) {
            if (!LineStream.STRING_TO_ARRAY_CACHE.hasOwnProperty(str)) {
                LineStream.STRING_TO_ARRAY_CACHE[str] = this.actualStringToArray(str);
            }
            return LineStream.STRING_TO_ARRAY_CACHE[str];
        };
        LineStream.prototype.actualStringToArray = function (str) {
            var maxCharCode = 0;
            for (var i = 0; i < str.length; i++) {
                maxCharCode = Math.max(maxCharCode, str.charCodeAt(i));
            }
            var r = [];
            for (var i = 0; i <= maxCharCode; i++) {
                r[i] = false;
            }
            for (var i = 0; i < str.length; i++) {
                r[str.charCodeAt(i)] = true;
            }
            return r;
        };
        LineStream.prototype.pos = function () {
            return this._pos;
        };
        LineStream.prototype.eos = function () {
            return this._pos >= this.sourceLength;
        };
        LineStream.prototype.peek = function () {
            // Check EOS
            if (this._pos >= this.sourceLength) {
                throw new Error('Stream is at the end');
            }
            return this._source[this._pos];
        };
        LineStream.prototype.next = function () {
            // Check EOS
            if (this._pos >= this.sourceLength) {
                throw new Error('Stream is at the end');
            }
            // Reset peeked token
            this.tokenStart = -1;
            this.tokenEnd = -1;
            return this._source[this._pos++];
        };
        LineStream.prototype.next2 = function () {
            // Check EOS
            if (this._pos >= this.sourceLength) {
                throw new Error('Stream is at the end');
            }
            // Reset peeked token
            this.tokenStart = -1;
            this.tokenEnd = -1;
            this._pos++;
        };
        LineStream.prototype.advance = function (n) {
            if (n === 0) {
                return '';
            }
            var oldPos = this._pos;
            this._pos += n;
            // Reset peeked token
            this.tokenStart = -1;
            this.tokenEnd = -1;
            return this._source.substring(oldPos, this._pos);
        };
        LineStream.prototype._advance2 = function (n) {
            if (n === 0) {
                return n;
            }
            this._pos += n;
            // Reset peeked token
            this.tokenStart = -1;
            this.tokenEnd = -1;
            return n;
        };
        LineStream.prototype.advanceToEOS = function () {
            var oldPos = this._pos;
            this._pos = this.sourceLength;
            this.resetPeekedToken();
            return this._source.substring(oldPos, this._pos);
        };
        LineStream.prototype.goBack = function (n) {
            this._pos -= n;
            this.resetPeekedToken();
        };
        LineStream.prototype.createPeeker = function (condition) {
            var _this = this;
            if (condition instanceof RegExp) {
                return function () {
                    var result = condition.exec(_this._source.substr(_this._pos));
                    if (result === null) {
                        return 0;
                    }
                    else if (result.index !== 0) {
                        throw new Error('Regular expression must begin with the character "^"');
                    }
                    return result[0].length;
                };
            }
            else if ((condition instanceof String || (typeof condition) === 'string') && condition) {
                return function () {
                    var len = condition.length, match = _this._pos + len <= _this.sourceLength;
                    for (var i = 0; match && i < len; i++) {
                        match = _this._source.charCodeAt(_this._pos + i) === condition.charCodeAt(i);
                    }
                    return match ? len : 0;
                };
            }
            throw new Error('Condition must be either a regular expression, function or a non-empty string');
        };
        // --- BEGIN `_advanceIfStringCaseInsensitive`
        LineStream.prototype._advanceIfStringCaseInsensitive = function (condition) {
            var oldPos = this._pos, source = this._source, len = condition.length, i;
            if (len < 1 || oldPos + len > this.sourceLength) {
                return 0;
            }
            for (i = 0; i < len; i++) {
                if (source.charAt(oldPos + i).toLowerCase() !== condition.charAt(i).toLowerCase()) {
                    return 0;
                }
            }
            return len;
        };
        LineStream.prototype.advanceIfStringCaseInsensitive = function (condition) {
            return this.advance(this._advanceIfStringCaseInsensitive(condition));
        };
        LineStream.prototype.advanceIfStringCaseInsensitive2 = function (condition) {
            return this._advance2(this._advanceIfStringCaseInsensitive(condition));
        };
        // --- END
        // --- BEGIN `advanceIfString`
        LineStream.prototype._advanceIfString = function (condition) {
            var oldPos = this._pos, source = this._source, len = condition.length, i;
            if (len < 1 || oldPos + len > this.sourceLength) {
                return 0;
            }
            for (i = 0; i < len; i++) {
                if (source.charCodeAt(oldPos + i) !== condition.charCodeAt(i)) {
                    return 0;
                }
            }
            return len;
        };
        LineStream.prototype.advanceIfString = function (condition) {
            return this.advance(this._advanceIfString(condition));
        };
        LineStream.prototype.advanceIfString2 = function (condition) {
            return this._advance2(this._advanceIfString(condition));
        };
        // --- END
        // --- BEGIN `advanceIfString`
        LineStream.prototype._advanceIfCharCode = function (charCode) {
            if (this._pos < this.sourceLength && this._source.charCodeAt(this._pos) === charCode) {
                return 1;
            }
            return 0;
        };
        LineStream.prototype.advanceIfCharCode = function (charCode) {
            return this.advance(this._advanceIfCharCode(charCode));
        };
        LineStream.prototype.advanceIfCharCode2 = function (charCode) {
            return this._advance2(this._advanceIfCharCode(charCode));
        };
        // --- END
        // --- BEGIN `advanceIfRegExp`
        LineStream.prototype._advanceIfRegExp = function (condition) {
            if (this._pos >= this.sourceLength) {
                return 0;
            }
            if (!condition.test(this._source.substr(this._pos))) {
                return 0;
            }
            return RegExp.lastMatch.length;
        };
        LineStream.prototype.advanceIfRegExp = function (condition) {
            return this.advance(this._advanceIfRegExp(condition));
        };
        LineStream.prototype.advanceIfRegExp2 = function (condition) {
            return this._advance2(this._advanceIfRegExp(condition));
        };
        // --- END
        LineStream.prototype.advanceLoop = function (condition, isWhile, including) {
            if (this.eos()) {
                return '';
            }
            var peeker = this.createPeeker(condition);
            var oldPos = this._pos;
            var n = 0;
            var f = null;
            if (isWhile) {
                f = function (n) {
                    return n > 0;
                };
            }
            else {
                f = function (n) {
                    return n === 0;
                };
            }
            while (!this.eos() && f(n = peeker())) {
                if (n > 0) {
                    this.advance(n);
                }
                else {
                    this.next();
                }
            }
            if (including && !this.eos()) {
                this.advance(n);
            }
            return this._source.substring(oldPos, this._pos);
        };
        LineStream.prototype.advanceWhile = function (condition) {
            return this.advanceLoop(condition, true, false);
        };
        LineStream.prototype.advanceUntil = function (condition, including) {
            return this.advanceLoop(condition, false, including);
        };
        // --- BEGIN `advanceUntilString`
        LineStream.prototype._advanceUntilString = function (condition, including) {
            if (this.eos() || condition.length === 0) {
                return 0;
            }
            var oldPos = this._pos;
            var index = this._source.indexOf(condition, oldPos);
            if (index === -1) {
                // String was not found => advanced to `eos`
                return (this.sourceLength - oldPos);
            }
            if (including) {
                // String was found => advance to include `condition`
                return (index + condition.length - oldPos);
            }
            // String was found => advance right before `condition`
            return (index - oldPos);
        };
        LineStream.prototype.advanceUntilString = function (condition, including) {
            return this.advance(this._advanceUntilString(condition, including));
        };
        LineStream.prototype.advanceUntilString2 = function (condition, including) {
            return this._advance2(this._advanceUntilString(condition, including));
        };
        // --- END
        LineStream.prototype.resetPeekedToken = function () {
            this.tokenStart = -1;
            this.tokenEnd = -1;
        };
        LineStream.prototype.setTokenRules = function (separators, whitespace) {
            if (this.separators !== separators || this.whitespace !== whitespace) {
                this.separators = separators;
                this.separatorsArr = this.stringToArray(this.separators);
                this.whitespace = whitespace;
                this.whitespaceArr = this.stringToArray(this.whitespace);
                this.resetPeekedToken();
            }
        };
        // --- tokens
        LineStream.prototype.peekToken = function () {
            if (this.tokenStart !== -1) {
                return this._source.substring(this.tokenStart, this.tokenEnd);
            }
            var source = this._source, sourceLength = this.sourceLength, whitespaceArr = this.whitespaceArr, separatorsArr = this.separatorsArr, tokenStart = this._pos;
            // Check EOS
            if (tokenStart >= sourceLength) {
                throw new Error('Stream is at the end');
            }
            // Skip whitespace
            while (whitespaceArr[source.charCodeAt(tokenStart)] && tokenStart < sourceLength) {
                tokenStart++;
            }
            var tokenEnd = tokenStart;
            // If a separator is hit, it is a token
            if (separatorsArr[source.charCodeAt(tokenEnd)] && tokenEnd < sourceLength) {
                tokenEnd++;
            }
            else {
                // Advance until a separator or a whitespace is hit
                while (!separatorsArr[source.charCodeAt(tokenEnd)] && !whitespaceArr[source.charCodeAt(tokenEnd)] && tokenEnd < sourceLength) {
                    tokenEnd++;
                }
            }
            // Cache peeked token
            this.tokenStart = tokenStart;
            this.tokenEnd = tokenEnd;
            return source.substring(tokenStart, tokenEnd);
        };
        LineStream.prototype.nextToken = function () {
            // Check EOS
            if (this._pos >= this.sourceLength) {
                throw new Error('Stream is at the end');
            }
            // Peek token if necessary
            var result;
            if (this.tokenStart === -1) {
                result = this.peekToken();
            }
            else {
                result = this._source.substring(this.tokenStart, this.tokenEnd);
            }
            // Advance to tokenEnd
            this._pos = this.tokenEnd;
            // Reset peeked token
            this.tokenStart = -1;
            this.tokenEnd = -1;
            return result;
        };
        // -- whitespace
        LineStream.prototype.peekWhitespace = function () {
            var source = this._source, sourceLength = this.sourceLength, whitespaceArr = this.whitespaceArr, peek = this._pos;
            while (whitespaceArr[source.charCodeAt(peek)] && peek < sourceLength) {
                peek++;
            }
            return source.substring(this._pos, peek);
        };
        // --- BEGIN `advanceIfRegExp`
        LineStream.prototype._skipWhitespace = function () {
            var source = this._source, sourceLength = this.sourceLength, whitespaceArr = this.whitespaceArr, oldPos = this._pos, peek = this._pos;
            while (whitespaceArr[source.charCodeAt(peek)] && peek < sourceLength) {
                peek++;
            }
            return (peek - oldPos);
        };
        LineStream.prototype.skipWhitespace = function () {
            return this.advance(this._skipWhitespace());
        };
        LineStream.prototype.skipWhitespace2 = function () {
            return this._advance2(this._skipWhitespace());
        };
        LineStream.STRING_TO_ARRAY_CACHE = {};
        return LineStream;
    }());
    exports.LineStream = LineStream;
});

define("vs/editor/common/modes/modesFilters", ["require", "exports", 'vs/base/common/arrays', 'vs/base/common/filters'], function (require, exports, arrays_1, filters) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function wrapBaseFilter(filter) {
        return function (word, suggestion) {
            var result = filter(word, suggestion.filterText || suggestion.label);
            return arrays_1.isFalsyOrEmpty(result) ? undefined : result;
        };
    }
    exports.StrictPrefix = wrapBaseFilter(filters.matchesStrictPrefix);
    exports.Prefix = wrapBaseFilter(filters.matchesPrefix);
    exports.CamelCase = wrapBaseFilter(filters.matchesCamelCase);
    exports.ContiguousSubString = wrapBaseFilter(filters.matchesContiguousSubString);
    // Combined Filters
    function or(first, second) {
        return function (word, suggestion) { return first(word, suggestion) || second(word, suggestion); };
    }
    exports.or = or;
    function and(first, second) {
        return function (word, suggestion) { return first(word, suggestion) && second(word, suggestion); };
    }
    exports.and = and;
    exports.DefaultFilter = or(or(exports.Prefix, exports.CamelCase), exports.ContiguousSubString);
});

define("vs/editor/common/modes/monarch/monarchCommon", ["require", "exports"], function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /*
     * This module exports common types and functionality shared between
     * the Monarch compiler that compiles JSON to ILexer, and the Monarch
     * Tokenizer (that highlights at runtime)
     */
    /*
     * Type definitions to be used internally to Monarch.
     * Inside monarch we use fully typed definitions and compiled versions of the more abstract JSON descriptions.
     */
    (function (MonarchBracket) {
        MonarchBracket[MonarchBracket["None"] = 0] = "None";
        MonarchBracket[MonarchBracket["Open"] = 1] = "Open";
        MonarchBracket[MonarchBracket["Close"] = -1] = "Close";
    })(exports.MonarchBracket || (exports.MonarchBracket = {}));
    var MonarchBracket = exports.MonarchBracket;
    // Small helper functions
    /**
     * Is a string null, undefined, or empty?
     */
    function empty(s) {
        return (s ? false : true);
    }
    exports.empty = empty;
    /**
     * Puts a string to lower case if 'ignoreCase' is set.
     */
    function fixCase(lexer, str) {
        return (lexer.ignoreCase && str ? str.toLowerCase() : str);
    }
    exports.fixCase = fixCase;
    /**
     * Ensures there are no bad characters in a CSS token class.
     */
    function sanitize(s) {
        return s.replace(/[&<>'"_]/g, '-'); // used on all output token CSS classes
    }
    exports.sanitize = sanitize;
    // Logging
    /**
     * Logs a message.
     */
    function log(lexer, msg) {
        console.log(lexer.name + ": " + msg);
    }
    exports.log = log;
    // Throwing errors
    /**
     * Throws error. May actually just log the error and continue.
     */
    function throwError(lexer, msg) {
        throw new Error(lexer.name + ": " + msg);
    }
    exports.throwError = throwError;
    // Helper functions for rule finding and substitution
    /**
     * substituteMatches is used on lexer strings and can substitutes predefined patterns:
     * 		$$  => $
     * 		$#  => id
     * 		$n  => matched entry n
     * 		@attr => contents of lexer[attr]
     *
     * See documentation for more info
     */
    function substituteMatches(lexer, str, id, matches, state) {
        var re = /\$((\$)|(#)|(\d\d?)|[sS](\d\d?)|@(\w+))/g;
        var stateMatches = null;
        return str.replace(re, function (full, sub, dollar, hash, n, s, attr, ofs, total) {
            if (!empty(dollar)) {
                return '$'; // $$
            }
            if (!empty(hash)) {
                return fixCase(lexer, id); // default $#
            }
            if (!empty(n) && n < matches.length) {
                return fixCase(lexer, matches[n]); // $n
            }
            if (!empty(attr) && lexer && typeof (lexer[attr]) === 'string') {
                return lexer[attr]; //@attribute
            }
            if (stateMatches === null) {
                stateMatches = state.split('.');
                stateMatches.unshift(state);
            }
            if (!empty(s) && s < stateMatches.length) {
                return fixCase(lexer, stateMatches[s]); //$Sn
            }
            return '';
        });
    }
    exports.substituteMatches = substituteMatches;
    /**
     * Find the tokenizer rules for a specific state (i.e. next action)
     */
    function findRules(lexer, state) {
        while (state && state.length > 0) {
            var rules = lexer.tokenizer[state];
            if (rules) {
                return rules;
            }
            var idx = state.lastIndexOf('.');
            if (idx < 0) {
                state = null; // no further parent
            }
            else {
                state = state.substr(0, idx);
            }
        }
        return null;
    }
    exports.findRules = findRules;
    /**
     * Is a certain state defined? In contrast to 'findRules' this works on a ILexerMin.
     * This is used during compilation where we may know the defined states
     * but not yet whether the corresponding rules are correct.
     */
    function stateExists(lexer, state) {
        while (state && state.length > 0) {
            var exist = lexer.stateNames[state];
            if (exist) {
                return true;
            }
            var idx = state.lastIndexOf('.');
            if (idx < 0) {
                state = null; // no further parent
            }
            else {
                state = state.substr(0, idx);
            }
        }
        return false;
    }
    exports.stateExists = stateExists;
});

define("vs/editor/common/modes/monarch/monarchCompile", ["require", "exports", 'vs/base/common/objects', 'vs/editor/common/modes/monarch/monarchCommon'], function (require, exports, objects, monarchCommon) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /*
     * Type helpers
     *
     * Note: this is just for sanity checks on the JSON description which is
     * helpful for the programmer. No checks are done anymore once the lexer is
     * already 'compiled and checked'.
     *
     */
    function isArrayOf(elemType, obj) {
        if (!obj) {
            return false;
        }
        if (!(Array.isArray(obj))) {
            return false;
        }
        var idx;
        for (idx in obj) {
            if (obj.hasOwnProperty(idx)) {
                if (!(elemType(obj[idx]))) {
                    return false;
                }
            }
        }
        return true;
    }
    function bool(prop, def, onerr) {
        if (typeof (prop) === 'boolean') {
            return prop;
        }
        if (onerr && (prop || def === undefined)) {
            onerr(); // type is wrong, or there is no default
        }
        return (def === undefined ? null : def);
    }
    function string(prop, def, onerr) {
        if (typeof (prop) === 'string') {
            return prop;
        }
        if (onerr && (prop || def === undefined)) {
            onerr(); // type is wrong, or there is no default
        }
        return (def === undefined ? null : def);
    }
    // Lexer helpers
    /**
     * Compiles a regular expression string, adding the 'i' flag if 'ignoreCase' is set.
     * Also replaces @\w+ or sequences with the content of the specified attribute
     */
    function compileRegExp(lexer, str) {
        if (typeof (str) !== 'string') {
            return null;
        }
        var n = 0;
        while (str.indexOf('@') >= 0 && n < 5) {
            n++;
            str = str.replace(/@(\w+)/g, function (s, attr) {
                var sub = '';
                if (typeof (lexer[attr]) === 'string') {
                    sub = lexer[attr];
                }
                else if (lexer[attr] && lexer[attr] instanceof RegExp) {
                    sub = lexer[attr].source;
                }
                else {
                    if (lexer[attr] === undefined) {
                        monarchCommon.throwError(lexer, 'language definition does not contain attribute \'' + attr + '\', used at: ' + str);
                    }
                    else {
                        monarchCommon.throwError(lexer, 'attribute reference \'' + attr + '\' must be a string, used at: ' + str);
                    }
                }
                return (monarchCommon.empty(sub) ? '' : '(?:' + sub + ')');
            });
        }
        return new RegExp(str, (lexer.ignoreCase ? 'i' : ''));
    }
    /**
     * Compiles guard functions for case matches.
     * This compiles 'cases' attributes into efficient match functions.
     *
     */
    function selectScrutinee(id, matches, state, num) {
        if (num < 0) {
            return id;
        }
        if (num < matches.length) {
            return matches[num];
        }
        if (num >= 100) {
            num = num - 100;
            var parts = state.split('.');
            parts.unshift(state);
            if (num < parts.length) {
                return parts[num];
            }
        }
        return null;
    }
    function createGuard(lexer, ruleName, tkey, val) {
        // get the scrutinee and pattern
        var scrut = -1; // -1: $!, 0-99: $n, 100+n: $Sn
        var oppat = tkey;
        var matches = tkey.match(/^\$(([sS]?)(\d\d?)|#)(.*)$/);
        if (matches) {
            if (matches[3]) {
                scrut = parseInt(matches[3]);
                if (matches[2]) {
                    scrut = scrut + 100; // if [sS] present
                }
            }
            oppat = matches[4];
        }
        // get operator
        var op = '~';
        var pat = oppat;
        if (!oppat || oppat.length === 0) {
            op = '!=';
            pat = '';
        }
        else if (/^\w*$/.test(pat)) {
            op = '==';
        }
        else {
            matches = oppat.match(/^(@|!@|~|!~|==|!=)(.*)$/);
            if (matches) {
                op = matches[1];
                pat = matches[2];
            }
        }
        // set the tester function
        var tester;
        // special case a regexp that matches just words
        if ((op === '~' || op === '!~') && /^(\w|\|)*$/.test(pat)) {
            var inWords = objects.createKeywordMatcher(pat.split('|'), lexer.ignoreCase);
            tester = function (s) { return (op === '~' ? inWords(s) : !inWords(s)); };
        }
        else if (op === '@' || op === '!@') {
            var words = lexer[pat];
            if (!words) {
                monarchCommon.throwError(lexer, 'the @ match target \'' + pat + '\' is not defined, in rule: ' + ruleName);
            }
            if (!(isArrayOf(function (elem) { return (typeof (elem) === 'string'); }, words))) {
                monarchCommon.throwError(lexer, 'the @ match target \'' + pat + '\' must be an array of strings, in rule: ' + ruleName);
            }
            var inWords = objects.createKeywordMatcher(words, lexer.ignoreCase);
            tester = function (s) { return (op === '@' ? inWords(s) : !inWords(s)); };
        }
        else if (op === '~' || op === '!~') {
            if (pat.indexOf('$') < 0) {
                // precompile regular expression
                var re = compileRegExp(lexer, '^' + pat + '$');
                tester = function (s) { return (op === '~' ? re.test(s) : !re.test(s)); };
            }
            else {
                tester = function (s, id, matches, state) {
                    var re = compileRegExp(lexer, '^' + monarchCommon.substituteMatches(lexer, pat, id, matches, state) + '$');
                    return re.test(s);
                };
            }
        }
        else {
            if (pat.indexOf('$') < 0) {
                var patx = monarchCommon.fixCase(lexer, pat);
                tester = function (s) { return (op === '==' ? s === patx : s !== patx); };
            }
            else {
                var patx = monarchCommon.fixCase(lexer, pat);
                tester = function (s, id, matches, state, eos) {
                    var patexp = monarchCommon.substituteMatches(lexer, patx, id, matches, state);
                    return (op === '==' ? s === patexp : s !== patexp);
                };
            }
        }
        // return the branch object
        if (scrut === -1) {
            return {
                name: tkey, value: val, test: function (id, matches, state, eos) {
                    return tester(id, id, matches, state, eos);
                }
            };
        }
        else {
            return {
                name: tkey, value: val, test: function (id, matches, state, eos) {
                    var scrutinee = selectScrutinee(id, matches, state, scrut);
                    return tester(!scrutinee ? '' : scrutinee, id, matches, state, eos);
                }
            };
        }
    }
    /**
     * Compiles an action: i.e. optimize regular expressions and case matches
     * and do many sanity checks.
     *
     * This is called only during compilation but if the lexer definition
     * contains user functions as actions (which is usually not allowed), then this
     * may be called during lexing. It is important therefore to compile common cases efficiently
     */
    function compileAction(lexer, ruleName, action) {
        if (!action) {
            return { token: '' };
        }
        else if (typeof (action) === 'string') {
            return action; // { token: action };
        }
        else if (action.token || action.token === '') {
            if (typeof (action.token) !== 'string') {
                monarchCommon.throwError(lexer, 'a \'token\' attribute must be of type string, in rule: ' + ruleName);
                return { token: '' };
            }
            else {
                // only copy specific typed fields (only happens once during compile Lexer)
                var newAction = { token: action.token };
                if (action.token.indexOf('$') >= 0) {
                    newAction.tokenSubst = true;
                }
                if (typeof (action.bracket) === 'string') {
                    if (action.bracket === '@open') {
                        newAction.bracket = monarchCommon.MonarchBracket.Open;
                    }
                    else if (action.bracket === '@close') {
                        newAction.bracket = monarchCommon.MonarchBracket.Close;
                    }
                    else {
                        monarchCommon.throwError(lexer, 'a \'bracket\' attribute must be either \'@open\' or \'@close\', in rule: ' + ruleName);
                    }
                }
                if (action.next) {
                    if (typeof (action.next) !== 'string') {
                        monarchCommon.throwError(lexer, 'the next state must be a string value in rule: ' + ruleName);
                    }
                    else {
                        var next = action.next;
                        if (!/^(@pop|@push|@popall)$/.test(next)) {
                            if (next[0] === '@') {
                                next = next.substr(1); // peel off starting @ sign
                            }
                            if (next.indexOf('$') < 0) {
                                if (!monarchCommon.stateExists(lexer, monarchCommon.substituteMatches(lexer, next, '', [], ''))) {
                                    monarchCommon.throwError(lexer, 'the next state \'' + action.next + '\' is not defined in rule: ' + ruleName);
                                }
                            }
                        }
                        newAction.next = next;
                    }
                }
                if (typeof (action.goBack) === 'number') {
                    newAction.goBack = action.goBack;
                }
                if (typeof (action.switchTo) === 'string') {
                    newAction.switchTo = action.switchTo;
                }
                if (typeof (action.log) === 'string') {
                    newAction.log = action.log;
                }
                if (typeof (action.nextEmbedded) === 'string') {
                    newAction.nextEmbedded = action.nextEmbedded;
                    lexer.usesEmbedded = true;
                }
                return newAction;
            }
        }
        else if (Array.isArray(action)) {
            var results = [];
            var idx;
            for (idx in action) {
                if (action.hasOwnProperty(idx)) {
                    results[idx] = compileAction(lexer, ruleName, action[idx]);
                }
            }
            return { group: results };
        }
        else if (action.cases) {
            // build an array of test cases
            var cases = [];
            // for each case, push a test function and result value
            var tkey;
            for (tkey in action.cases) {
                if (action.cases.hasOwnProperty(tkey)) {
                    var val = compileAction(lexer, ruleName, action.cases[tkey]);
                    // what kind of case
                    if (tkey === '@default' || tkey === '@' || tkey === '') {
                        cases.push({ test: null, value: val, name: tkey });
                    }
                    else if (tkey === '@eos') {
                        cases.push({ test: function (id, matches, state, eos) { return eos; }, value: val, name: tkey });
                    }
                    else {
                        cases.push(createGuard(lexer, ruleName, tkey, val)); // call separate function to avoid local variable capture
                    }
                }
            }
            // create a matching function
            var def = lexer.defaultToken;
            return {
                test: function (id, matches, state, eos) {
                    var idx;
                    for (idx in cases) {
                        if (cases.hasOwnProperty(idx)) {
                            var didmatch = (!cases[idx].test || cases[idx].test(id, matches, state, eos));
                            if (didmatch) {
                                return cases[idx].value;
                            }
                        }
                    }
                    return def;
                }
            };
        }
        else {
            monarchCommon.throwError(lexer, 'an action must be a string, an object with a \'token\' or \'cases\' attribute, or an array of actions; in rule: ' + ruleName);
            return '';
        }
    }
    /**
     * Helper class for creating matching rules
     */
    var Rule = (function () {
        function Rule(name) {
            this.regex = new RegExp('');
            this.action = { token: '' };
            this.matchOnlyAtLineStart = false;
            this.name = '';
            this.name = name;
        }
        Rule.prototype.setRegex = function (lexer, re) {
            var sregex;
            if (typeof (re) === 'string') {
                sregex = re;
            }
            else if (re instanceof RegExp) {
                sregex = re.source;
            }
            else {
                monarchCommon.throwError(lexer, 'rules must start with a match string or regular expression: ' + this.name);
            }
            this.matchOnlyAtLineStart = (sregex.length > 0 && sregex[0] === '^');
            this.name = this.name + ': ' + sregex;
            this.regex = compileRegExp(lexer, '^(?:' + (this.matchOnlyAtLineStart ? sregex.substr(1) : sregex) + ')');
        };
        Rule.prototype.setAction = function (lexer, act) {
            this.action = compileAction(lexer, this.name, act);
        };
        return Rule;
    }());
    /**
     * Compiles a json description function into json where all regular expressions,
     * case matches etc, are compiled and all include rules are expanded.
     * We also compile the bracket definitions, supply defaults, and do many sanity checks.
     * If the 'jsonStrict' parameter is 'false', we allow at certain locations
     * regular expression objects and functions that get called during lexing.
     * (Currently we have no samples that need this so perhaps we should always have
     * jsonStrict to true).
     */
    function compile(json) {
        if (!json || typeof (json) !== 'object') {
            throw new Error('Monarch: expecting a language definition object');
        }
        // Get names
        if (typeof (json.name) !== 'string') {
            throw new Error('Monarch: a language definition must include a string \'name\' attribute');
        }
        // Create our lexer
        var lexer = {};
        lexer.name = json.name;
        lexer.displayName = string(json.displayName, lexer.name);
        lexer.noThrow = false; // raise exceptions during compilation
        lexer.maxStack = 100;
        // Set standard fields: be defensive about types
        lexer.start = string(json.start);
        lexer.ignoreCase = bool(json.ignoreCase, false);
        lexer.lineComment = string(json.lineComment, '//');
        lexer.blockCommentStart = string(json.blockCommentStart, '/*');
        lexer.blockCommentEnd = string(json.blockCommentEnd, '*/');
        lexer.tokenPostfix = string(json.tokenPostfix, '.' + lexer.name);
        lexer.defaultToken = string(json.defaultToken, 'source', function () { monarchCommon.throwError(lexer, 'the \'defaultToken\' must be a string'); });
        lexer.usesEmbedded = false; // becomes true if we find a nextEmbedded action
        lexer.wordDefinition = json.wordDefinition || undefined;
        // COMPAT: with earlier monarch versions
        if (!lexer.lineComment && json.lineComments) {
            if (typeof (json.lineComments) === 'string') {
                lexer.lineComment = json.lineComments;
            }
            else if (typeof (json.lineComments[0]) === 'string') {
                lexer.lineComment = json.lineComments[0];
            }
        }
        lexer.suggestSupport = {
            textualCompletions: true,
            disableAutoTrigger: false,
            triggerCharacters: [],
            snippets: []
        };
        if (typeof json.suggestSupport !== 'undefined') {
            var suggestSupport = json.suggestSupport;
            if (Array.isArray(suggestSupport.snippets)) {
                var _snippets = suggestSupport.snippets;
                for (var i = 0, len = _snippets.length; i < len; i++) {
                    if (typeof _snippets[i] === 'string') {
                        lexer.suggestSupport.snippets.push({
                            type: 'snippet',
                            label: _snippets[i],
                            codeSnippet: _snippets[i]
                        });
                    }
                    else {
                        lexer.suggestSupport.snippets.push(_snippets[i]);
                    }
                }
            }
            if (Array.isArray(suggestSupport.triggerCharacters)) {
                lexer.suggestSupport.triggerCharacters = suggestSupport.triggerCharacters;
            }
            if (typeof suggestSupport.textualCompletions !== 'undefined') {
                lexer.suggestSupport.textualCompletions = suggestSupport.textualCompletions;
            }
            if (typeof suggestSupport.disableAutoTrigger !== 'undefined') {
                lexer.suggestSupport.disableAutoTrigger = suggestSupport.disableAutoTrigger;
            }
        }
        // For calling compileAction later on
        var lexerMin = json;
        lexerMin.name = lexer.name;
        lexerMin.displayName = lexer.displayName;
        lexerMin.ignoreCase = lexer.ignoreCase;
        lexerMin.noThrow = lexer.noThrow;
        lexerMin.usesEmbedded = lexer.usesEmbedded;
        lexerMin.stateNames = json.tokenizer;
        lexerMin.defaultToken = lexer.defaultToken;
        // Compile an array of rules into newrules where RegExp objects are created.
        function addRules(state, newrules, rules) {
            var idx;
            for (idx in rules) {
                if (rules.hasOwnProperty(idx)) {
                    var rule = rules[idx];
                    var include = rule.include;
                    if (include) {
                        if (typeof (include) !== 'string') {
                            monarchCommon.throwError(lexer, 'an \'include\' attribute must be a string at: ' + state);
                        }
                        if (include[0] === '@') {
                            include = include.substr(1); // peel off starting @
                        }
                        if (!json.tokenizer[include]) {
                            monarchCommon.throwError(lexer, 'include target \'' + include + '\' is not defined at: ' + state);
                        }
                        addRules(state + '.' + include, newrules, json.tokenizer[include]);
                    }
                    else {
                        var newrule = new Rule(state);
                        // Set up new rule attributes
                        if (Array.isArray(rule) && rule.length >= 1 && rule.length <= 3) {
                            newrule.setRegex(lexerMin, rule[0]);
                            if (rule.length >= 3) {
                                if (typeof (rule[1]) === 'string') {
                                    newrule.setAction(lexerMin, { token: rule[1], next: rule[2] });
                                }
                                else if (typeof (rule[1]) === 'object') {
                                    var rule1 = rule[1];
                                    rule1.next = rule[2];
                                    newrule.setAction(lexerMin, rule1);
                                }
                                else {
                                    monarchCommon.throwError(lexer, 'a next state as the last element of a rule can only be given if the action is either an object or a string, at: ' + state);
                                }
                            }
                            else {
                                newrule.setAction(lexerMin, rule[1]);
                            }
                        }
                        else {
                            if (!rule.regex) {
                                monarchCommon.throwError(lexer, 'a rule must either be an array, or an object with a \'regex\' or \'include\' field at: ' + state);
                            }
                            if (rule.name) {
                                newrule.name = string(rule.name);
                            }
                            if (rule.matchOnlyAtStart) {
                                newrule.matchOnlyAtLineStart = bool(rule.matchOnlyAtLineStart);
                            }
                            newrule.setRegex(lexerMin, rule.regex);
                            newrule.setAction(lexerMin, rule.action);
                        }
                        newrules.push(newrule);
                    }
                }
            }
        }
        // compile the tokenizer rules
        if (!json.tokenizer || typeof (json.tokenizer) !== 'object') {
            monarchCommon.throwError(lexer, 'a language definition must define the \'tokenizer\' attribute as an object');
        }
        lexer.tokenizer = [];
        var key;
        for (key in json.tokenizer) {
            if (json.tokenizer.hasOwnProperty(key)) {
                if (!lexer.start) {
                    lexer.start = key;
                }
                var rules = json.tokenizer[key];
                lexer.tokenizer[key] = new Array();
                addRules('tokenizer.' + key, lexer.tokenizer[key], rules);
            }
        }
        lexer.usesEmbedded = lexerMin.usesEmbedded; // can be set during compileAction
        // Set simple brackets
        if (json.brackets) {
            if (!(Array.isArray(json.brackets))) {
                monarchCommon.throwError(lexer, 'the \'brackets\' attribute must be defined as an array');
            }
        }
        else {
            json.brackets = [
                { open: '{', close: '}', token: 'delimiter.curly' },
                { open: '[', close: ']', token: 'delimiter.square' },
                { open: '(', close: ')', token: 'delimiter.parenthesis' },
                { open: '<', close: '>', token: 'delimiter.angle' }];
        }
        var brackets = [];
        for (var bracketIdx in json.brackets) {
            if (json.brackets.hasOwnProperty(bracketIdx)) {
                var desc = json.brackets[bracketIdx];
                if (desc && Array.isArray(desc) && desc.length === 3) {
                    desc = { token: desc[2], open: desc[0], close: desc[1] };
                }
                if (desc.open === desc.close) {
                    monarchCommon.throwError(lexer, 'open and close brackets in a \'brackets\' attribute must be different: ' + desc.open +
                        '\n hint: use the \'bracket\' attribute if matching on equal brackets is required.');
                }
                if (typeof (desc.open) === 'string' && typeof (desc.token) === 'string') {
                    brackets.push({
                        token: string(desc.token) + lexer.tokenPostfix,
                        open: monarchCommon.fixCase(lexer, string(desc.open)),
                        close: monarchCommon.fixCase(lexer, string(desc.close))
                    });
                }
                else {
                    monarchCommon.throwError(lexer, 'every element in the \'brackets\' array must be a \'{open,close,token}\' object or array');
                }
            }
        }
        lexer.brackets = brackets;
        // Set default auto closing pairs
        var autoClosingPairs;
        if (json.autoClosingPairs) {
            if (!(Array.isArray(json.autoClosingPairs))) {
                monarchCommon.throwError(lexer, 'the \'autoClosingPairs\' attribute must be an array of string pairs (as arrays)');
            }
            autoClosingPairs = json.autoClosingPairs.slice(0);
        }
        else {
            autoClosingPairs = [['"', '"'], ['\'', '\''], ['@brackets']];
        }
        // set auto closing pairs
        lexer.autoClosingPairs = [];
        if (autoClosingPairs) {
            for (var autoClosingPairIdx in autoClosingPairs) {
                if (autoClosingPairs.hasOwnProperty(autoClosingPairIdx)) {
                    var pair = autoClosingPairs[autoClosingPairIdx];
                    var openClose;
                    if (pair === '@brackets' || pair[0] === '@brackets') {
                        var bidx;
                        for (bidx in brackets) {
                            if (brackets.hasOwnProperty(bidx)) {
                                if (brackets[bidx].open && brackets[bidx].open.length === 1 &&
                                    brackets[bidx].close && brackets[bidx].close.length === 1) {
                                    openClose = { open: brackets[bidx].open, close: brackets[bidx].close, notIn: ['string', 'comment'] };
                                    lexer.autoClosingPairs.push(openClose);
                                }
                            }
                        }
                    }
                    else if (Array.isArray(pair) && pair.length === 2 &&
                        typeof (pair[0]) === 'string' && pair[0].length === 1 &&
                        typeof (pair[1]) === 'string' && pair[1].length === 1) {
                        openClose = { open: monarchCommon.fixCase(lexer, pair[0]), close: monarchCommon.fixCase(lexer, pair[1]), notIn: ['string', 'comment'] };
                        lexer.autoClosingPairs.push(openClose);
                    }
                    else if (typeof (pair.open) === 'string' && pair.open.length === 1 &&
                        typeof (pair.close) === 'string' && pair.close.length === 1) {
                        openClose = { open: monarchCommon.fixCase(lexer, pair.open[0]), close: monarchCommon.fixCase(lexer, pair.close[0]), notIn: ['string', 'comment'] };
                        lexer.autoClosingPairs.push(openClose);
                    }
                    else {
                        monarchCommon.throwError(lexer, 'every element in an \'autoClosingPairs\' array must be a pair of 1 character strings, or a \'@brackets\' directive');
                    }
                }
            }
        }
        // Set enhanced brackets
        // var enhancedBrackets : IRegexBracketPair[] = [];
        // if (json.enhancedBrackets) {
        // 	if (!(Array.isArray(<any>json.enhancedBrackets))) {
        // 		monarchCommon.throwError(lexer, 'the \'enhancedBrackets\' attribute must be defined as an array');
        // 	}
        // 	for (var bracketIdx in json.enhancedBrackets) {
        // 		if (json.enhancedBrackets.hasOwnProperty(bracketIdx)) {
        // 			var desc = <any> json.enhancedBrackets[bracketIdx];
        // 			if (desc.hasOwnProperty('openTrigger') && typeof (desc.openTrigger) !== 'string') {
        // 				monarchCommon.throwError(lexer, 'openTrigger in the \'enhancedBrackets\' array must be a string');
        // 			}
        // 			if (desc.hasOwnProperty('open') && !(desc.open instanceof RegExp)) {
        // 				monarchCommon.throwError(lexer, 'open in the \'enhancedBrackets\' array must be a regex');
        // 			}
        // 			if (desc.hasOwnProperty('closeComplete') && typeof (desc.closeComplete) !== 'string') {
        // 				monarchCommon.throwError(lexer, 'closeComplete in the \'enhancedBrackets\' array must be a string');
        // 			}
        // 			if (desc.hasOwnProperty('matchCase') && typeof (desc.matchCase) !== 'boolean') {
        // 				monarchCommon.throwError(lexer, 'matchCase in the \'enhancedBrackets\' array must be a boolean');
        // 			}
        // 			if (desc.hasOwnProperty('closeTrigger') && typeof (desc.closeTrigger) !== 'string') {
        // 				monarchCommon.throwError(lexer, 'closeTrigger in the \'enhancedBrackets\' array must be a string');
        // 			}
        // 			if (desc.hasOwnProperty('close') && !(desc.close instanceof RegExp)) {
        // 				monarchCommon.throwError(lexer, 'close in the \'enhancedBrackets\' array must be a regex');
        // 			}
        // 			if (desc.hasOwnProperty('tokenType')) {
        // 				if (typeof (desc.tokenType) !== 'string') {
        // 					monarchCommon.throwError(lexer, 'tokenType in the \'enhancedBrackets\' array must be a string');
        // 				}
        // 				else {
        // 					desc.tokenType += lexer.tokenPostfix;
        // 				}
        // 			}
        // 			enhancedBrackets.push(desc);
        // 		}
        // 	}
        // }
        // lexer.enhancedBrackets = enhancedBrackets;
        var standardBrackets = [];
        for (var i = 0; i < brackets.length; ++i) {
            standardBrackets.push([brackets[i].open, brackets[i].close]);
        }
        lexer.standardBrackets = standardBrackets;
        lexer.outdentTriggers = string(json.outdentTriggers, '');
        // Disable throw so the syntax highlighter goes, no matter what
        lexer.noThrow = true;
        return lexer;
    }
    exports.compile = compile;
});

define("vs/editor/common/modes/supports", ["require", "exports", 'vs/base/common/strings', 'vs/editor/common/core/arrays'], function (require, exports, strings, arrays_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Token = (function () {
        function Token(startIndex, type) {
            this.startIndex = startIndex;
            this.type = type;
        }
        Token.prototype.toString = function () {
            return '(' + this.startIndex + ', ' + this.type + ')';
        };
        return Token;
    }());
    exports.Token = Token;
    function handleEvent(context, offset, runner) {
        var modeTransitions = context.modeTransitions;
        if (modeTransitions.length === 1) {
            return runner(modeTransitions[0].mode, context, offset);
        }
        var modeIndex = arrays_1.Arrays.findIndexInSegmentsArray(modeTransitions, offset);
        var nestedMode = modeTransitions[modeIndex].mode;
        var modeStartIndex = modeTransitions[modeIndex].startIndex;
        var firstTokenInModeIndex = context.findIndexOfOffset(modeStartIndex);
        var nextCharacterAfterModeIndex = -1;
        var nextTokenAfterMode = -1;
        if (modeIndex + 1 < modeTransitions.length) {
            nextTokenAfterMode = context.findIndexOfOffset(modeTransitions[modeIndex + 1].startIndex);
            nextCharacterAfterModeIndex = context.getTokenStartIndex(nextTokenAfterMode);
        }
        else {
            nextTokenAfterMode = context.getTokenCount();
            nextCharacterAfterModeIndex = context.getLineContent().length;
        }
        var firstTokenCharacterOffset = context.getTokenStartIndex(firstTokenInModeIndex);
        var newCtx = new FilteredLineContext(context, nestedMode, firstTokenInModeIndex, nextTokenAfterMode, firstTokenCharacterOffset, nextCharacterAfterModeIndex);
        return runner(nestedMode, newCtx, offset - firstTokenCharacterOffset);
    }
    exports.handleEvent = handleEvent;
    /**
     * Returns {{true}} if the line token at the specified
     * offset matches one of the provided types. Matching
     * happens on a substring start from the end, unless
     * anywhereInToken is set to true in which case matches
     * happen on a substring at any position.
     */
    function isLineToken(context, offset, types, anywhereInToken) {
        if (anywhereInToken === void 0) { anywhereInToken = false; }
        if (!Array.isArray(types) || types.length === 0) {
            return false;
        }
        if (context.getLineContent().length <= offset) {
            return false;
        }
        var tokenIdx = context.findIndexOfOffset(offset);
        var type = context.getTokenType(tokenIdx);
        for (var i = 0, len = types.length; i < len; i++) {
            if (anywhereInToken) {
                if (type.indexOf(types[i]) >= 0) {
                    return true;
                }
            }
            else {
                if (strings.endsWith(type, types[i])) {
                    return true;
                }
            }
        }
        return false;
    }
    exports.isLineToken = isLineToken;
    var FilteredLineContext = (function () {
        function FilteredLineContext(actual, mode, firstTokenInModeIndex, nextTokenAfterMode, firstTokenCharacterOffset, nextCharacterAfterModeIndex) {
            this.modeTransitions = [{
                    startIndex: 0,
                    mode: mode
                }];
            this._actual = actual;
            this._firstTokenInModeIndex = firstTokenInModeIndex;
            this._nextTokenAfterMode = nextTokenAfterMode;
            this._firstTokenCharacterOffset = firstTokenCharacterOffset;
            this._nextCharacterAfterModeIndex = nextCharacterAfterModeIndex;
        }
        FilteredLineContext.prototype.getLineContent = function () {
            var actualLineContent = this._actual.getLineContent();
            return actualLineContent.substring(this._firstTokenCharacterOffset, this._nextCharacterAfterModeIndex);
        };
        FilteredLineContext.prototype.getTokenCount = function () {
            return this._nextTokenAfterMode - this._firstTokenInModeIndex;
        };
        FilteredLineContext.prototype.findIndexOfOffset = function (offset) {
            return this._actual.findIndexOfOffset(offset + this._firstTokenCharacterOffset) - this._firstTokenInModeIndex;
        };
        FilteredLineContext.prototype.getTokenStartIndex = function (tokenIndex) {
            return this._actual.getTokenStartIndex(tokenIndex + this._firstTokenInModeIndex) - this._firstTokenCharacterOffset;
        };
        FilteredLineContext.prototype.getTokenEndIndex = function (tokenIndex) {
            return this._actual.getTokenEndIndex(tokenIndex + this._firstTokenInModeIndex) - this._firstTokenCharacterOffset;
        };
        FilteredLineContext.prototype.getTokenType = function (tokenIndex) {
            return this._actual.getTokenType(tokenIndex + this._firstTokenInModeIndex);
        };
        FilteredLineContext.prototype.getTokenText = function (tokenIndex) {
            return this._actual.getTokenText(tokenIndex + this._firstTokenInModeIndex);
        };
        return FilteredLineContext;
    }());
    exports.FilteredLineContext = FilteredLineContext;
    function ignoreBracketsInToken(tokenType) {
        return /\b(comment|string|regex)\b/.test(tokenType);
    }
    exports.ignoreBracketsInToken = ignoreBracketsInToken;
    // TODO@Martin: find a better home for this code:
    // TODO@Martin: modify suggestSupport to return a boolean if snippets should be presented or not
    //       and turn this into a real registry
    var SnippetsRegistry = (function () {
        function SnippetsRegistry() {
        }
        SnippetsRegistry.registerDefaultSnippets = function (modeId, snippets) {
            this._defaultSnippets[modeId] = (this._defaultSnippets[modeId] || []).concat(snippets);
        };
        SnippetsRegistry.registerSnippets = function (modeId, path, snippets) {
            var snippetsByMode = this._snippets[modeId];
            if (!snippetsByMode) {
                this._snippets[modeId] = snippetsByMode = {};
            }
            snippetsByMode[path] = snippets;
        };
        SnippetsRegistry.getSnippets = function (model, position) {
            var word = model.getWordAtPosition(position);
            var currentPrefix = word ? word.word.substring(0, position.column - word.startColumn) : '';
            var result = {
                currentWord: currentPrefix,
                suggestions: []
            };
            // to avoid that snippets are too prominent in the intellisense proposals:
            // - force that the current prefix matches with the snippet prefix
            // if there's no prfix, only show snippets at the beginning of the line, or after a whitespace
            var filter = null;
            if (currentPrefix.length === 0) {
                if (position.column > 1) {
                    var previousCharacter = model.getValueInRange({ startLineNumber: position.lineNumber, startColumn: position.column - 1, endLineNumber: position.lineNumber, endColumn: position.column });
                    if (previousCharacter.trim().length !== 0) {
                        return result;
                    }
                }
            }
            else {
                var lowerCasePrefix_1 = currentPrefix.toLowerCase();
                filter = function (p) {
                    return strings.startsWith(p.label.toLowerCase(), lowerCasePrefix_1);
                };
            }
            var modeId = model.getMode().getId();
            var snippets = [];
            var snipppetsByMode = this._snippets[modeId];
            if (snipppetsByMode) {
                for (var s in snipppetsByMode) {
                    snippets = snippets.concat(snipppetsByMode[s]);
                }
            }
            var defaultSnippets = this._defaultSnippets[modeId];
            if (defaultSnippets) {
                snippets = snippets.concat(defaultSnippets);
            }
            result.suggestions = filter ? snippets.filter(filter) : snippets;
            // if (result.suggestions.length > 0) {
            // 	if (word) {
            // 		// Push also the current word as first suggestion, to avoid unexpected snippet acceptance on Enter.
            // 		result.suggestions = result.suggestions.slice(0);
            // 		result.suggestions.unshift({
            // 			codeSnippet: word.word,
            // 			label: word.word,
            // 			type: 'text'
            // 		});
            // 	}
            // 	result.incomplete = true;
            // }
            return result;
        };
        SnippetsRegistry._defaultSnippets = Object.create(null);
        SnippetsRegistry._snippets = Object.create(null);
        return SnippetsRegistry;
    }());
    exports.SnippetsRegistry = SnippetsRegistry;
});

define("vs/editor/common/modes/supports/characterPair", ["require", "exports", 'vs/editor/common/modes/supports'], function (require, exports, supports_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CharacterPairSupport = (function () {
        function CharacterPairSupport(modeId, contribution) {
            this._modeId = modeId;
            this._autoClosingPairs = contribution.autoClosingPairs;
            this._surroundingPairs = Array.isArray(contribution.surroundingPairs) ? contribution.surroundingPairs : contribution.autoClosingPairs;
        }
        CharacterPairSupport.prototype.getAutoClosingPairs = function () {
            return this._autoClosingPairs;
        };
        CharacterPairSupport.prototype.shouldAutoClosePair = function (character, context, offset) {
            var _this = this;
            return supports_1.handleEvent(context, offset, function (nestedMode, context, offset) {
                if (_this._modeId === nestedMode.getId()) {
                    // Always complete on empty line
                    if (context.getTokenCount() === 0) {
                        return true;
                    }
                    var tokenIndex = context.findIndexOfOffset(offset - 1);
                    var tokenType = context.getTokenType(tokenIndex);
                    for (var i = 0; i < _this._autoClosingPairs.length; ++i) {
                        if (_this._autoClosingPairs[i].open === character) {
                            if (_this._autoClosingPairs[i].notIn) {
                                for (var notInIndex = 0; notInIndex < _this._autoClosingPairs[i].notIn.length; ++notInIndex) {
                                    if (tokenType.indexOf(_this._autoClosingPairs[i].notIn[notInIndex]) > -1) {
                                        return false;
                                    }
                                }
                            }
                            break;
                        }
                    }
                    return true;
                }
                else if (nestedMode.richEditSupport && nestedMode.richEditSupport.characterPair) {
                    return nestedMode.richEditSupport.characterPair.shouldAutoClosePair(character, context, offset);
                }
                else {
                    return null;
                }
            });
        };
        CharacterPairSupport.prototype.getSurroundingPairs = function () {
            return this._surroundingPairs;
        };
        return CharacterPairSupport;
    }());
    exports.CharacterPairSupport = CharacterPairSupport;
});

define("vs/editor/common/modes/supports/declarationSupport", ["require", "exports", 'vs/editor/common/modes/supports'], function (require, exports, supports_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var DeclarationSupport = (function () {
        /**
         * Provide the token type postfixes for the tokens where a declaration can be found in the 'tokens' argument.
         */
        function DeclarationSupport(modeId, contribution) {
            this._modeId = modeId;
            this.contribution = contribution;
        }
        DeclarationSupport.prototype.canFindDeclaration = function (context, offset) {
            var _this = this;
            return supports_1.handleEvent(context, offset, function (nestedMode, context, offset) {
                if (_this._modeId === nestedMode.getId()) {
                    return (!Array.isArray(_this.contribution.tokens) ||
                        _this.contribution.tokens.length < 1 ||
                        supports_1.isLineToken(context, offset, _this.contribution.tokens));
                }
                else if (nestedMode.declarationSupport) {
                    return nestedMode.declarationSupport.canFindDeclaration(context, offset);
                }
                else {
                    return false;
                }
            });
        };
        DeclarationSupport.prototype.findDeclaration = function (resource, position) {
            return this.contribution.findDeclaration(resource, position);
        };
        return DeclarationSupport;
    }());
    exports.DeclarationSupport = DeclarationSupport;
});

define("vs/editor/common/modes/supports/parameterHintsSupport", ["require", "exports", 'vs/editor/common/modes/supports'], function (require, exports, supports_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ParameterHintsSupport = (function () {
        function ParameterHintsSupport(modeId, contribution) {
            this._modeId = modeId;
            this.contribution = contribution;
        }
        ParameterHintsSupport.prototype.getParameterHintsTriggerCharacters = function () {
            return this.contribution.triggerCharacters;
        };
        ParameterHintsSupport.prototype.shouldTriggerParameterHints = function (context, offset) {
            var _this = this;
            return supports_1.handleEvent(context, offset, function (nestedMode, context, offset) {
                if (_this._modeId === nestedMode.getId()) {
                    if (!Array.isArray(_this.contribution.excludeTokens)) {
                        return true;
                    }
                    if (_this.contribution.excludeTokens.length === 1 && _this.contribution.excludeTokens[0] === '*') {
                        return false;
                    }
                    return !supports_1.isLineToken(context, offset - 1, _this.contribution.excludeTokens);
                }
                else if (nestedMode.parameterHintsSupport) {
                    return nestedMode.parameterHintsSupport.shouldTriggerParameterHints(context, offset);
                }
                else {
                    return false;
                }
            });
        };
        ParameterHintsSupport.prototype.getParameterHints = function (resource, position) {
            return this.contribution.getParameterHints(resource, position);
        };
        return ParameterHintsSupport;
    }());
    exports.ParameterHintsSupport = ParameterHintsSupport;
});

define("vs/editor/common/modes/supports/referenceSupport", ["require", "exports", 'vs/editor/common/modes/supports'], function (require, exports, supports_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ReferenceSupport = (function () {
        /**
         * Provide the token type postfixes for the tokens where a reference can be found in the 'tokens' argument.
         */
        function ReferenceSupport(modeId, contribution) {
            this._modeId = modeId;
            this.contribution = contribution;
        }
        ReferenceSupport.prototype.canFindReferences = function (context, offset) {
            var _this = this;
            return supports_1.handleEvent(context, offset, function (nestedMode, context, offset) {
                if (_this._modeId === nestedMode.getId()) {
                    return (!Array.isArray(_this.contribution.tokens) ||
                        _this.contribution.tokens.length < 1 ||
                        supports_1.isLineToken(context, offset, _this.contribution.tokens));
                }
                else if (nestedMode.referenceSupport) {
                    return nestedMode.referenceSupport.canFindReferences(context, offset);
                }
                else {
                    return false;
                }
            });
        };
        ReferenceSupport.prototype.findReferences = function (resource, position, includeDeclaration) {
            return this.contribution.findReferences(resource, position, includeDeclaration);
        };
        return ReferenceSupport;
    }());
    exports.ReferenceSupport = ReferenceSupport;
});

define("vs/editor/common/modes/supports/richEditBrackets", ["require", "exports", 'vs/base/common/strings', 'vs/editor/common/core/range'], function (require, exports, strings, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var RichEditBrackets = (function () {
        function RichEditBrackets(modeId, brackets) {
            var _this = this;
            this.brackets = brackets.map(function (b) {
                return {
                    modeId: modeId,
                    open: b[0],
                    close: b[1],
                    forwardRegex: getRegexForBracketPair({ open: b[0], close: b[1] }),
                    reversedRegex: getReversedRegexForBracketPair({ open: b[0], close: b[1] })
                };
            });
            this.forwardRegex = getRegexForBrackets(this.brackets);
            this.reversedRegex = getReversedRegexForBrackets(this.brackets);
            this.textIsBracket = {};
            this.textIsOpenBracket = {};
            this.maxBracketLength = 0;
            this.brackets.forEach(function (b) {
                _this.textIsBracket[b.open] = b;
                _this.textIsBracket[b.close] = b;
                _this.textIsOpenBracket[b.open] = true;
                _this.textIsOpenBracket[b.close] = false;
                _this.maxBracketLength = Math.max(_this.maxBracketLength, b.open.length);
                _this.maxBracketLength = Math.max(_this.maxBracketLength, b.close.length);
            });
        }
        return RichEditBrackets;
    }());
    exports.RichEditBrackets = RichEditBrackets;
    function once(keyFn, computeFn) {
        var cache = {};
        return function (input) {
            var key = keyFn(input);
            if (!cache.hasOwnProperty(key)) {
                cache[key] = computeFn(input);
            }
            return cache[key];
        };
    }
    var getRegexForBracketPair = once(function (input) { return (input.open + ";" + input.close); }, function (input) {
        return createOrRegex([input.open, input.close]);
    });
    var getReversedRegexForBracketPair = once(function (input) { return (input.open + ";" + input.close); }, function (input) {
        return createOrRegex([toReversedString(input.open), toReversedString(input.close)]);
    });
    var getRegexForBrackets = once(function (input) { return input.map(function (b) { return (b.open + ";" + b.close); }).join(';'); }, function (input) {
        var pieces = [];
        input.forEach(function (b) {
            pieces.push(b.open);
            pieces.push(b.close);
        });
        return createOrRegex(pieces);
    });
    var getReversedRegexForBrackets = once(function (input) { return input.map(function (b) { return (b.open + ";" + b.close); }).join(';'); }, function (input) {
        var pieces = [];
        input.forEach(function (b) {
            pieces.push(toReversedString(b.open));
            pieces.push(toReversedString(b.close));
        });
        return createOrRegex(pieces);
    });
    function createOrRegex(pieces) {
        var regexStr = "(" + pieces.map(strings.escapeRegExpCharacters).join(')|(') + ")";
        return strings.createRegExp(regexStr, true, false, false, false);
    }
    function toReversedString(str) {
        var reversedStr = '';
        for (var i = str.length - 1; i >= 0; i--) {
            reversedStr += str.charAt(i);
        }
        return reversedStr;
    }
    var BracketsUtils = (function () {
        function BracketsUtils() {
        }
        BracketsUtils._findPrevBracketInText = function (reversedBracketRegex, lineNumber, reversedText, offset) {
            var m = reversedText.match(reversedBracketRegex);
            if (!m) {
                return null;
            }
            var matchOffset = reversedText.length - m.index;
            var matchLength = m[0].length;
            var absoluteMatchOffset = offset + matchOffset;
            return new range_1.Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);
        };
        BracketsUtils.findPrevBracketInToken = function (reversedBracketRegex, lineNumber, lineText, currentTokenStart, currentTokenEnd) {
            // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)
            var currentTokenReversedText = '';
            for (var index = currentTokenEnd - 1; index >= currentTokenStart; index--) {
                currentTokenReversedText += lineText.charAt(index);
            }
            return this._findPrevBracketInText(reversedBracketRegex, lineNumber, currentTokenReversedText, currentTokenStart);
        };
        BracketsUtils.findNextBracketInText = function (bracketRegex, lineNumber, text, offset) {
            var m = text.match(bracketRegex);
            if (!m) {
                return null;
            }
            var matchOffset = m.index;
            var matchLength = m[0].length;
            var absoluteMatchOffset = offset + matchOffset;
            return new range_1.Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);
        };
        BracketsUtils.findNextBracketInToken = function (bracketRegex, lineNumber, lineText, currentTokenStart, currentTokenEnd) {
            var currentTokenText = lineText.substring(currentTokenStart, currentTokenEnd);
            return this.findNextBracketInText(bracketRegex, lineNumber, currentTokenText, currentTokenStart);
        };
        return BracketsUtils;
    }());
    exports.BracketsUtils = BracketsUtils;
});

define("vs/editor/common/modes/supports/electricCharacter", ["require", "exports", 'vs/base/common/strings', 'vs/editor/common/modes/supports', 'vs/editor/common/modes/supports/richEditBrackets'], function (require, exports, strings, supports_1, richEditBrackets_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var BracketElectricCharacterSupport = (function () {
        function BracketElectricCharacterSupport(modeId, brackets, contribution) {
            this._modeId = modeId;
            this.contribution = contribution || {};
            this.brackets = new Brackets(modeId, brackets, this.contribution.docComment, this.contribution.caseInsensitive);
        }
        BracketElectricCharacterSupport.prototype.getElectricCharacters = function () {
            if (Array.isArray(this.contribution.embeddedElectricCharacters)) {
                return this.contribution.embeddedElectricCharacters.concat(this.brackets.getElectricCharacters());
            }
            return this.brackets.getElectricCharacters();
        };
        BracketElectricCharacterSupport.prototype.onElectricCharacter = function (context, offset) {
            var _this = this;
            return supports_1.handleEvent(context, offset, function (nestedMode, context, offset) {
                if (_this._modeId === nestedMode.getId()) {
                    return _this.brackets.onElectricCharacter(context, offset);
                }
                else if (nestedMode.richEditSupport && nestedMode.richEditSupport.electricCharacter) {
                    return nestedMode.richEditSupport.electricCharacter.onElectricCharacter(context, offset);
                }
                else {
                    return null;
                }
            });
        };
        return BracketElectricCharacterSupport;
    }());
    exports.BracketElectricCharacterSupport = BracketElectricCharacterSupport;
    var Brackets = (function () {
        function Brackets(modeId, richEditBrackets, docComment, caseInsensitive) {
            if (docComment === void 0) { docComment = null; }
            if (caseInsensitive === void 0) { caseInsensitive = false; }
            this._modeId = modeId;
            this._richEditBrackets = richEditBrackets;
            this._docComment = docComment ? docComment : null;
        }
        Brackets.prototype.getElectricCharacters = function () {
            var result = [];
            if (this._richEditBrackets) {
                for (var i = 0, len = this._richEditBrackets.brackets.length; i < len; i++) {
                    var bracketPair = this._richEditBrackets.brackets[i];
                    var lastChar = bracketPair.close.charAt(bracketPair.close.length - 1);
                    result.push(lastChar);
                }
            }
            // Doc comments
            if (this._docComment) {
                result.push(this._docComment.open.charAt(this._docComment.open.length - 1));
            }
            // Filter duplicate entries
            result = result.filter(function (item, pos, array) {
                return array.indexOf(item) === pos;
            });
            return result;
        };
        Brackets.prototype.onElectricCharacter = function (context, offset) {
            if (context.getTokenCount() === 0) {
                return null;
            }
            return (this._onElectricCharacterDocComment(context, offset) ||
                this._onElectricCharacterStandardBrackets(context, offset));
        };
        Brackets.prototype.containsTokenTypes = function (fullTokenSpec, tokensToLookFor) {
            var array = tokensToLookFor.split('.');
            for (var i = 0; i < array.length; ++i) {
                if (fullTokenSpec.indexOf(array[i]) < 0) {
                    return false;
                }
            }
            return true;
        };
        Brackets.prototype._onElectricCharacterStandardBrackets = function (context, offset) {
            if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {
                return null;
            }
            var reversedBracketRegex = this._richEditBrackets.reversedRegex;
            var lineText = context.getLineContent();
            var tokenIndex = context.findIndexOfOffset(offset);
            var tokenStart = context.getTokenStartIndex(tokenIndex);
            var tokenEnd = offset + 1;
            var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(context.getLineContent());
            if (firstNonWhitespaceIndex !== -1 && firstNonWhitespaceIndex < tokenStart) {
                return null;
            }
            if (!supports_1.ignoreBracketsInToken(context.getTokenType(tokenIndex))) {
                var r = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(reversedBracketRegex, 1, lineText, tokenStart, tokenEnd);
                if (r) {
                    var text = lineText.substring(r.startColumn - 1, r.endColumn - 1);
                    var isOpen = this._richEditBrackets.textIsOpenBracket[text];
                    if (!isOpen) {
                        return {
                            matchOpenBracket: text
                        };
                    }
                }
            }
            return null;
        };
        Brackets.prototype._onElectricCharacterDocComment = function (context, offset) {
            // We only auto-close, so do nothing if there is no closing part.
            if (!this._docComment || !this._docComment.close) {
                return null;
            }
            var line = context.getLineContent();
            var char = line[offset];
            // See if the right electric character was pressed
            if (char !== this._docComment.open.charAt(this._docComment.open.length - 1)) {
                return null;
            }
            // If this line already contains the closing tag, do nothing.
            if (line.indexOf(this._docComment.close, offset) >= 0) {
                return null;
            }
            // If we're not in a documentation comment, do nothing.
            var lastTokenIndex = context.findIndexOfOffset(offset);
            if (!this.containsTokenTypes(context.getTokenType(lastTokenIndex), this._docComment.scope)) {
                return null;
            }
            if (line.substring(context.getTokenStartIndex(lastTokenIndex), offset + 1 /* include electric char*/) !== this._docComment.open) {
                return null;
            }
            return { appendText: this._docComment.close };
        };
        return Brackets;
    }());
    exports.Brackets = Brackets;
});

define("vs/editor/common/viewModel/prefixSumComputer", ["require", "exports"], function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var PrefixSumComputer = (function () {
        function PrefixSumComputer(values) {
            this.values = values;
            this.prefixSum = [];
            for (var i = 0, len = this.values.length; i < len; i++) {
                this.prefixSum[i] = 0;
            }
            this.prefixSumValidIndex = -1;
        }
        PrefixSumComputer.prototype.getCount = function () {
            return this.values.length;
        };
        PrefixSumComputer.prototype.insertValue = function (insertIndex, value) {
            this.values.splice(insertIndex, 0, value);
            this.prefixSum.splice(insertIndex, 0, 0);
            if (insertIndex - 1 < this.prefixSumValidIndex) {
                this.prefixSumValidIndex = insertIndex - 1;
            }
        };
        PrefixSumComputer.prototype.insertValues = function (insertIndex, values) {
            if (values.length === 0) {
                return;
            }
            this.values = this.values.slice(0, insertIndex).concat(values).concat(this.values.slice(insertIndex));
            this.prefixSum = this.prefixSum.slice(0, insertIndex).concat(PrefixSumComputer._zeroArray(values.length)).concat(this.prefixSum.slice(insertIndex));
            if (insertIndex - 1 < this.prefixSumValidIndex) {
                this.prefixSumValidIndex = insertIndex - 1;
            }
        };
        PrefixSumComputer._zeroArray = function (count) {
            var r = new Array(count);
            for (var i = 0; i < count; i++) {
                r[i] = 0;
            }
            return r;
        };
        PrefixSumComputer.prototype.changeValue = function (index, value) {
            if (this.values[index] === value) {
                return;
            }
            this.values[index] = value;
            if (index - 1 < this.prefixSumValidIndex) {
                this.prefixSumValidIndex = index - 1;
            }
        };
        PrefixSumComputer.prototype.removeValues = function (startIndex, cnt) {
            this.values.splice(startIndex, cnt);
            this.prefixSum.splice(startIndex, cnt);
            if (startIndex - 1 < this.prefixSumValidIndex) {
                this.prefixSumValidIndex = startIndex - 1;
            }
        };
        PrefixSumComputer.prototype.getTotalValue = function () {
            if (this.values.length === 0) {
                return 0;
            }
            return this.getAccumulatedValue(this.values.length - 1);
        };
        PrefixSumComputer.prototype.getAccumulatedValue = function (index) {
            if (index < 0) {
                return 0;
            }
            if (index <= this.prefixSumValidIndex) {
                return this.prefixSum[index];
            }
            var startIndex = this.prefixSumValidIndex + 1;
            if (startIndex === 0) {
                this.prefixSum[0] = this.values[0];
                startIndex++;
            }
            if (index >= this.values.length) {
                index = this.values.length - 1;
            }
            for (var i = startIndex; i <= index; i++) {
                this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
            }
            this.prefixSumValidIndex = Math.max(this.prefixSumValidIndex, index);
            return this.prefixSum[index];
        };
        PrefixSumComputer.prototype.getIndexOf = function (accumulatedValue, result) {
            var low = 0, high = this.values.length - 1, mid, midStart, midStop;
            while (low <= high) {
                mid = low + ((high - low) / 2) | 0;
                midStop = this.getAccumulatedValue(mid);
                midStart = midStop - this.values[mid];
                if (accumulatedValue < midStart) {
                    high = mid - 1;
                }
                else if (accumulatedValue >= midStop) {
                    low = mid + 1;
                }
                else {
                    break;
                }
            }
            result.index = mid;
            result.remainder = accumulatedValue - midStart;
        };
        return PrefixSumComputer;
    }());
    exports.PrefixSumComputer = PrefixSumComputer;
});

define("vs/editor/common/model/mirrorModel2", ["require", "exports", 'vs/editor/common/viewModel/prefixSumComputer'], function (require, exports, prefixSumComputer_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var MirrorModel2 = (function () {
        function MirrorModel2(uri, lines, eol, versionId) {
            this._uri = uri;
            this._lines = lines;
            this._eol = eol;
            this._versionId = versionId;
        }
        MirrorModel2.prototype.dispose = function () {
            this._lines.length = 0;
        };
        Object.defineProperty(MirrorModel2.prototype, "version", {
            get: function () {
                return this._versionId;
            },
            enumerable: true,
            configurable: true
        });
        MirrorModel2.prototype.getText = function () {
            return this._lines.join(this._eol);
        };
        MirrorModel2.prototype.onEvents = function (events) {
            var newEOL = null;
            for (var i = 0, len = events.length; i < len; i++) {
                var e = events[i];
                if (e.eol) {
                    newEOL = e.eol;
                }
            }
            if (newEOL && newEOL !== this._eol) {
                this._eol = newEOL;
                this._lineStarts = null;
            }
            // Update my lines
            var lastVersionId = -1;
            for (var i = 0, len = events.length; i < len; i++) {
                var e = events[i];
                this._acceptDeleteRange(e.range);
                this._acceptInsertText({
                    lineNumber: e.range.startLineNumber,
                    column: e.range.startColumn
                }, e.text);
                lastVersionId = Math.max(lastVersionId, e.versionId);
            }
            if (lastVersionId !== -1) {
                this._versionId = lastVersionId;
            }
        };
        MirrorModel2.prototype._ensureLineStarts = function () {
            if (!this._lineStarts) {
                var lineStartValues = [];
                var eolLength = this._eol.length;
                for (var i = 0, len = this._lines.length; i < len; i++) {
                    lineStartValues.push(this._lines[i].length + eolLength);
                }
                this._lineStarts = new prefixSumComputer_1.PrefixSumComputer(lineStartValues);
            }
        };
        /**
         * All changes to a line's text go through this method
         */
        MirrorModel2.prototype._setLineText = function (lineIndex, newValue) {
            this._lines[lineIndex] = newValue;
            if (this._lineStarts) {
                // update prefix sum
                this._lineStarts.changeValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
            }
        };
        MirrorModel2.prototype._acceptDeleteRange = function (range) {
            if (range.startLineNumber === range.endLineNumber) {
                if (range.startColumn === range.endColumn) {
                    // Nothing to delete
                    return;
                }
                // Delete text on the affected line
                this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)
                    + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));
                return;
            }
            // Take remaining text on last line and append it to remaining text on first line
            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)
                + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));
            // Delete middle lines
            this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);
            if (this._lineStarts) {
                // update prefix sum
                this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);
            }
        };
        MirrorModel2.prototype._acceptInsertText = function (position, insertText) {
            if (insertText.length === 0) {
                // Nothing to insert
                return;
            }
            var insertLines = insertText.split(/\r\n|\r|\n/);
            if (insertLines.length === 1) {
                // Inserting text on one line
                this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)
                    + insertLines[0]
                    + this._lines[position.lineNumber - 1].substring(position.column - 1));
                return;
            }
            // Append overflowing text from first line to the end of text to insert
            insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);
            // Delete overflowing text from first line and insert text on first line
            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)
                + insertLines[0]);
            // Insert new lines & store lengths
            var newLengths = new Array(insertLines.length - 1);
            for (var i = 1; i < insertLines.length; i++) {
                this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);
                newLengths[i - 1] = insertLines[i].length + this._eol.length;
            }
            if (this._lineStarts) {
                // update prefix sum
                this._lineStarts.insertValues(position.lineNumber, newLengths);
            }
        };
        return MirrorModel2;
    }());
    exports.MirrorModel2 = MirrorModel2;
});

define("vs/nls!vs/base/common/errors",['vs/nls', 'vs/nls!vs/workbench/node/pluginHostProcess'], function(nls, data) { return nls.create("vs/base/common/errors", data); });
define("vs/base/common/errors", ["require", "exports", 'vs/nls!vs/base/common/errors', 'vs/base/common/objects', 'vs/base/common/platform', 'vs/base/common/types', 'vs/base/common/arrays', 'vs/base/common/strings'], function (require, exports, nls, objects, platform, types, arrays, strings) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // Avoid circular dependency on EventEmitter by implementing a subset of the interface.
    var ErrorHandler = (function () {
        function ErrorHandler() {
            this.listeners = [];
            this.unexpectedErrorHandler = function (e) {
                platform.setTimeout(function () {
                    if (e.stack) {
                        throw new Error(e.message + '\n\n' + e.stack);
                    }
                    throw e;
                }, 0);
            };
        }
        ErrorHandler.prototype.addListener = function (listener) {
            var _this = this;
            this.listeners.push(listener);
            return function () {
                _this._removeListener(listener);
            };
        };
        ErrorHandler.prototype.emit = function (e) {
            this.listeners.forEach(function (listener) {
                listener(e);
            });
        };
        ErrorHandler.prototype._removeListener = function (listener) {
            this.listeners.splice(this.listeners.indexOf(listener), 1);
        };
        ErrorHandler.prototype.setUnexpectedErrorHandler = function (newUnexpectedErrorHandler) {
            this.unexpectedErrorHandler = newUnexpectedErrorHandler;
        };
        ErrorHandler.prototype.getUnexpectedErrorHandler = function () {
            return this.unexpectedErrorHandler;
        };
        ErrorHandler.prototype.onUnexpectedError = function (e) {
            this.unexpectedErrorHandler(e);
            this.emit(e);
        };
        return ErrorHandler;
    }());
    exports.ErrorHandler = ErrorHandler;
    exports.errorHandler = new ErrorHandler();
    function setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
        exports.errorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);
    }
    exports.setUnexpectedErrorHandler = setUnexpectedErrorHandler;
    function onUnexpectedError(e) {
        // ignore errors from cancelled promises
        if (!isPromiseCanceledError(e)) {
            exports.errorHandler.onUnexpectedError(e);
        }
    }
    exports.onUnexpectedError = onUnexpectedError;
    function onUnexpectedPromiseError(promise) {
        return promise.then(null, onUnexpectedError);
    }
    exports.onUnexpectedPromiseError = onUnexpectedPromiseError;
    function transformErrorForSerialization(error) {
        if (error instanceof Error) {
            var name_1 = error.name, message = error.message;
            var stack = error.stacktrace || error.stack;
            return {
                $isError: true,
                name: name_1,
                message: message,
                stack: stack
            };
        }
        // return as is
        return error;
    }
    exports.transformErrorForSerialization = transformErrorForSerialization;
    /**
     * The base class for all connection errors originating from XHR requests.
     */
    var ConnectionError = (function () {
        function ConnectionError(arg) {
            this.status = arg.status;
            this.statusText = arg.statusText;
            this.name = 'ConnectionError';
            try {
                this.responseText = arg.responseText;
            }
            catch (e) {
                this.responseText = '';
            }
            this.errorMessage = null;
            this.errorCode = null;
            this.errorObject = null;
            if (this.responseText) {
                try {
                    var errorObj = JSON.parse(this.responseText);
                    this.errorMessage = errorObj.message;
                    this.errorCode = errorObj.code;
                    this.errorObject = errorObj;
                }
                catch (error) {
                }
            }
        }
        Object.defineProperty(ConnectionError.prototype, "message", {
            get: function () {
                return this.connectionErrorToMessage(this, false);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConnectionError.prototype, "verboseMessage", {
            get: function () {
                return this.connectionErrorToMessage(this, true);
            },
            enumerable: true,
            configurable: true
        });
        ConnectionError.prototype.connectionErrorDetailsToMessage = function (error, verbose) {
            var errorCode = error.errorCode;
            var errorMessage = error.errorMessage;
            if (errorCode !== null && errorMessage !== null) {
                return nls.localize(0, null, strings.rtrim(errorMessage, '.'), errorCode);






            }
            if (errorMessage !== null) {
                return errorMessage;
            }
            if (verbose && error.responseText !== null) {
                return error.responseText;
            }
            return null;
        };
        ConnectionError.prototype.connectionErrorToMessage = function (error, verbose) {
            var details = this.connectionErrorDetailsToMessage(error, verbose);
            // Status Code based Error
            if (error.status === 401) {
                if (details !== null) {
                    return nls.localize(1, null, details);





                }
                return nls.localize(2, null);
            }
            // Return error details if present
            if (details) {
                return details;
            }
            // Fallback to HTTP Status and Code
            if (error.status > 0 && error.statusText !== null) {
                if (verbose && error.responseText !== null && error.responseText.length > 0) {
                    return nls.localize(3, null, error.statusText, error.status, error.responseText);
                }
                return nls.localize(4, null, error.statusText, error.status);
            }
            // Finally its an Unknown Connection Error
            if (verbose && error.responseText !== null && error.responseText.length > 0) {
                return nls.localize(5, null, error.responseText);
            }
            return nls.localize(6, null);
        };
        return ConnectionError;
    }());
    exports.ConnectionError = ConnectionError;
    // Bug: Can not subclass a JS Type. Do it manually (as done in WinJS.Class.derive)
    objects.derive(Error, ConnectionError);
    function xhrToErrorMessage(xhr, verbose) {
        var ce = new ConnectionError(xhr);
        if (verbose) {
            return ce.verboseMessage;
        }
        else {
            return ce.message;
        }
    }
    function exceptionToErrorMessage(exception, verbose) {
        if (exception.message) {
            if (verbose && (exception.stack || exception.stacktrace)) {
                return nls.localize(7, null, detectSystemErrorMessage(exception), exception.stack || exception.stacktrace);
            }
            return detectSystemErrorMessage(exception);
        }
        return nls.localize(8, null);
    }
    function detectSystemErrorMessage(exception) {
        // See https://nodejs.org/api/errors.html#errors_class_system_error
        if (typeof exception.code === 'string' && typeof exception.errno === 'number' && typeof exception.syscall === 'string') {
            return nls.localize(9, null, exception.message);
        }
        return exception.message;
    }
    /**
     * Tries to generate a human readable error message out of the error. If the verbose parameter
     * is set to true, the error message will include stacktrace details if provided.
     * @returns A string containing the error message.
     */
    function toErrorMessage(error, verbose) {
        if (error === void 0) { error = null; }
        if (verbose === void 0) { verbose = false; }
        if (!error) {
            return nls.localize(10, null);
        }
        if (Array.isArray(error)) {
            var errors = arrays.coalesce(error);
            var msg = toErrorMessage(errors[0], verbose);
            if (errors.length > 1) {
                return nls.localize(11, null, msg, errors.length);
            }
            return msg;
        }
        if (types.isString(error)) {
            return error;
        }
        if (!types.isUndefinedOrNull(error.status)) {
            return xhrToErrorMessage(error, verbose);
        }
        if (error.detail) {
            var detail = error.detail;
            if (detail.error) {
                if (detail.error && !types.isUndefinedOrNull(detail.error.status)) {
                    return xhrToErrorMessage(detail.error, verbose);
                }
                if (types.isArray(detail.error)) {
                    for (var i = 0; i < detail.error.length; i++) {
                        if (detail.error[i] && !types.isUndefinedOrNull(detail.error[i].status)) {
                            return xhrToErrorMessage(detail.error[i], verbose);
                        }
                    }
                }
                else {
                    return exceptionToErrorMessage(detail.error, verbose);
                }
            }
            if (detail.exception) {
                if (!types.isUndefinedOrNull(detail.exception.status)) {
                    return xhrToErrorMessage(detail.exception, verbose);
                }
                return exceptionToErrorMessage(detail.exception, verbose);
            }
        }
        if (error.stack) {
            return exceptionToErrorMessage(error, verbose);
        }
        if (error.message) {
            return error.message;
        }
        return nls.localize(12, null);
    }
    exports.toErrorMessage = toErrorMessage;
    var canceledName = 'Canceled';
    /**
     * Checks if the given error is a promise in canceled state
     */
    function isPromiseCanceledError(error) {
        return error instanceof Error && error.name === canceledName && error.message === canceledName;
    }
    exports.isPromiseCanceledError = isPromiseCanceledError;
    /**
     * Returns an error that signals cancellation.
     */
    function canceled() {
        var error = new Error(canceledName);
        error.name = error.message;
        return error;
    }
    exports.canceled = canceled;
    /**
     * Returns an error that signals something is not implemented.
     */
    function notImplemented() {
        return new Error(nls.localize(13, null));
    }
    exports.notImplemented = notImplemented;
    function illegalArgument(name) {
        if (name) {
            return new Error(nls.localize(14, null, name));
        }
        else {
            return new Error(nls.localize(15, null));
        }
    }
    exports.illegalArgument = illegalArgument;
    function illegalState(name) {
        if (name) {
            return new Error(nls.localize(16, null, name));
        }
        else {
            return new Error(nls.localize(17, null));
        }
    }
    exports.illegalState = illegalState;
    function readonly() {
        return new Error('readonly property cannot be changed');
    }
    exports.readonly = readonly;
    function loaderError(err) {
        if (platform.isWeb) {
            return new Error(nls.localize(18, null));
        }
        return new Error(nls.localize(19, null, JSON.stringify(err)));
    }
    exports.loaderError = loaderError;
    function create(message, options) {
        if (options === void 0) { options = {}; }
        var result = new Error(message);
        if (types.isNumber(options.severity)) {
            result.severity = options.severity;
        }
        if (options.actions) {
            result.actions = options.actions;
        }
        return result;
    }
    exports.create = create;
});

define("vs/base/common/callbackList", ["require", "exports", 'vs/base/common/errors'], function (require, exports, errors_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CallbackList = (function () {
        function CallbackList() {
        }
        CallbackList.prototype.add = function (callback, context, bucket) {
            var _this = this;
            if (context === void 0) { context = null; }
            if (!this._callbacks) {
                this._callbacks = [];
                this._contexts = [];
            }
            this._callbacks.push(callback);
            this._contexts.push(context);
            if (Array.isArray(bucket)) {
                bucket.push({ dispose: function () { return _this.remove(callback, context); } });
            }
        };
        CallbackList.prototype.remove = function (callback, context) {
            if (context === void 0) { context = null; }
            if (!this._callbacks) {
                return;
            }
            var foundCallbackWithDifferentContext = false;
            for (var i = 0, len = this._callbacks.length; i < len; i++) {
                if (this._callbacks[i] === callback) {
                    if (this._contexts[i] === context) {
                        // callback & context match => remove it
                        this._callbacks.splice(i, 1);
                        this._contexts.splice(i, 1);
                        return;
                    }
                    else {
                        foundCallbackWithDifferentContext = true;
                    }
                }
            }
            if (foundCallbackWithDifferentContext) {
                throw new Error('When adding a listener with a context, you should remove it with the same context');
            }
        };
        CallbackList.prototype.invoke = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (!this._callbacks) {
                return;
            }
            var ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
            for (var i = 0, len = callbacks.length; i < len; i++) {
                try {
                    ret.push(callbacks[i].apply(contexts[i], args));
                }
                catch (e) {
                    errors_1.onUnexpectedError(e);
                }
            }
            return ret;
        };
        CallbackList.prototype.isEmpty = function () {
            return !this._callbacks || this._callbacks.length === 0;
        };
        CallbackList.prototype.dispose = function () {
            this._callbacks = undefined;
            this._contexts = undefined;
        };
        return CallbackList;
    }());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = CallbackList;
});

define("vs/base/common/event", ["require", "exports", 'vs/base/common/callbackList'], function (require, exports, callbackList_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Event;
    (function (Event) {
        var _disposable = { dispose: function () { } };
        Event.None = function () { return _disposable; };
    })(Event || (Event = {}));
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Event;
    /**
     * The Emitter can be used to expose an Event to the public
     * to fire it from the insides.
     * Sample:
        class Document {
    
            private _onDidChange = new Emitter<(value:string)=>any>();
    
            public onDidChange = this._onDidChange.event;
    
            // getter-style
            // get onDidChange(): Event<(value:string)=>any> {
            // 	return this._onDidChange.event;
            // }
    
            private _doIt() {
                //...
                this._onDidChange.fire(value);
            }
        }
     */
    var Emitter = (function () {
        function Emitter(_options) {
            this._options = _options;
        }
        Object.defineProperty(Emitter.prototype, "event", {
            /**
             * For the public to allow to subscribe
             * to events from this Emitter
             */
            get: function () {
                var _this = this;
                if (!this._event) {
                    this._event = function (listener, thisArgs, disposables) {
                        if (!_this._callbacks) {
                            _this._callbacks = new callbackList_1.default();
                        }
                        if (_this._options && _this._options.onFirstListenerAdd && _this._callbacks.isEmpty()) {
                            _this._options.onFirstListenerAdd(_this);
                        }
                        _this._callbacks.add(listener, thisArgs);
                        var result;
                        result = {
                            dispose: function () {
                                result.dispose = Emitter._noop;
                                if (!_this._disposed) {
                                    _this._callbacks.remove(listener, thisArgs);
                                    if (_this._options && _this._options.onLastListenerRemove && _this._callbacks.isEmpty()) {
                                        _this._options.onLastListenerRemove(_this);
                                    }
                                }
                            }
                        };
                        if (Array.isArray(disposables)) {
                            disposables.push(result);
                        }
                        return result;
                    };
                }
                return this._event;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * To be kept private to fire an event to
         * subscribers
         */
        Emitter.prototype.fire = function (event) {
            if (this._callbacks) {
                this._callbacks.invoke.call(this._callbacks, event);
            }
        };
        Emitter.prototype.dispose = function () {
            if (this._callbacks) {
                this._callbacks.dispose();
                this._callbacks = undefined;
                this._disposed = true;
            }
        };
        Emitter._noop = function () { };
        return Emitter;
    }());
    exports.Emitter = Emitter;
    /**
     * Creates an Event which is backed-up by the event emitter. This allows
     * to use the existing eventing pattern and is likely using less memory.
     * Sample:
     *
     * 	class Document {
     *
     *		private _eventbus = new EventEmitter();
     *
     *		public onDidChange = fromEventEmitter(this._eventbus, 'changed');
     *
     *		// getter-style
     *		// get onDidChange(): Event<(value:string)=>any> {
     *		// 	cache fromEventEmitter result and return
     *		// }
     *
     *		private _doIt() {
     *			// ...
     *			this._eventbus.emit('changed', value)
     *		}
     *	}
     */
    function fromEventEmitter(emitter, eventType) {
        return function (listener, thisArgs, disposables) {
            var result = emitter.addListener2(eventType, function () {
                listener.apply(thisArgs, arguments);
            });
            if (Array.isArray(disposables)) {
                disposables.push(result);
            }
            return result;
        };
    }
    exports.fromEventEmitter = fromEventEmitter;
    function mapEvent(event, map) {
        return function (listener, thisArgs, disposables) {
            return event(function (i) { return listener(map(i)); }, thisArgs, disposables);
        };
    }
    exports.mapEvent = mapEvent;
    var EventDelayerState;
    (function (EventDelayerState) {
        EventDelayerState[EventDelayerState["Idle"] = 0] = "Idle";
        EventDelayerState[EventDelayerState["Running"] = 1] = "Running";
    })(EventDelayerState || (EventDelayerState = {}));
    /**
     * The EventDelayer is useful in situations in which you want
     * to delay firing your events during some code.
     * You can wrap that code and be sure that the event will not
     * be fired during that wrap.
     *
     * ```
     * const emitter: Emitter;
     * const delayer = new EventDelayer();
     * const delayedEvent = delayer.delay(emitter.event);
     *
     * delayedEvent(console.log);
     *
     * delayer.wrap(() => {
     *   emitter.fire(); // event will not be fired yet
     * });
     *
     * // event will only be fired at this point
     * ```
     */
    var EventBufferer = (function () {
        function EventBufferer() {
            this.buffers = [];
        }
        EventBufferer.prototype.wrapEvent = function (event) {
            var _this = this;
            return function (listener, thisArgs, disposables) {
                return event(function (i) {
                    var buffer = _this.buffers[_this.buffers.length - 1];
                    if (buffer) {
                        buffer.push(function () { return listener.call(thisArgs, i); });
                    }
                    else {
                        listener.call(thisArgs, i);
                    }
                }, void 0, disposables);
            };
        };
        EventBufferer.prototype.bufferEvents = function (fn) {
            var buffer = [];
            this.buffers.push(buffer);
            fn();
            this.buffers.pop();
            buffer.forEach(function (flush) { return flush(); });
        };
        return EventBufferer;
    }());
    exports.EventBufferer = EventBufferer;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/base/common/cancellation", ["require", "exports", 'vs/base/common/event'], function (require, exports, event_1) {
    'use strict';
    var CancellationToken;
    (function (CancellationToken) {
        CancellationToken.None = Object.freeze({
            isCancellationRequested: false,
            onCancellationRequested: event_1.default.None
        });
        CancellationToken.Cancelled = Object.freeze({
            isCancellationRequested: true,
            onCancellationRequested: event_1.default.None
        });
    })(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
    var shortcutEvent = Object.freeze(function (callback, context) {
        var handle = setTimeout(callback.bind(context), 0);
        return { dispose: function () { clearTimeout(handle); } };
    });
    var MutableToken = (function () {
        function MutableToken() {
            this._isCancelled = false;
        }
        MutableToken.prototype.cancel = function () {
            if (!this._isCancelled) {
                this._isCancelled = true;
                if (this._emitter) {
                    this._emitter.fire(undefined);
                    this._emitter = undefined;
                }
            }
        };
        Object.defineProperty(MutableToken.prototype, "isCancellationRequested", {
            get: function () {
                return this._isCancelled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MutableToken.prototype, "onCancellationRequested", {
            get: function () {
                if (this._isCancelled) {
                    return shortcutEvent;
                }
                if (!this._emitter) {
                    this._emitter = new event_1.Emitter();
                }
                return this._emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        return MutableToken;
    }());
    var CancellationTokenSource = (function () {
        function CancellationTokenSource() {
        }
        Object.defineProperty(CancellationTokenSource.prototype, "token", {
            get: function () {
                if (!this._token) {
                    // be lazy and create the token only when
                    // actually needed
                    this._token = new MutableToken();
                }
                return this._token;
            },
            enumerable: true,
            configurable: true
        });
        CancellationTokenSource.prototype.cancel = function () {
            if (!this._token) {
                // save an object by returning the default
                // cancelled token when cancellation happens
                // before someone asks for the token
                this._token = CancellationToken.Cancelled;
            }
            else {
                this._token.cancel();
            }
        };
        CancellationTokenSource.prototype.dispose = function () {
            this.cancel();
        };
        return CancellationTokenSource;
    }());
    exports.CancellationTokenSource = CancellationTokenSource;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("vs/base/common/eventEmitter", ["require", "exports", 'vs/base/common/errors'], function (require, exports, Errors) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EmitterEvent = (function () {
        function EmitterEvent(eventType, data, emitterType) {
            if (emitterType === void 0) { emitterType = null; }
            this._type = eventType;
            this._data = data;
            this._emitterType = emitterType;
        }
        EmitterEvent.prototype.getType = function () {
            return this._type;
        };
        EmitterEvent.prototype.getData = function () {
            return this._data;
        };
        EmitterEvent.prototype.getEmitterType = function () {
            return this._emitterType;
        };
        return EmitterEvent;
    }());
    exports.EmitterEvent = EmitterEvent;
    var EventEmitter = (function () {
        function EventEmitter(allowedEventTypes) {
            if (allowedEventTypes === void 0) { allowedEventTypes = null; }
            this._listeners = {};
            this._bulkListeners = [];
            this._collectedEvents = [];
            this._deferredCnt = 0;
            if (allowedEventTypes) {
                this._allowedEventTypes = {};
                for (var i = 0; i < allowedEventTypes.length; i++) {
                    this._allowedEventTypes[allowedEventTypes[i]] = true;
                }
            }
            else {
                this._allowedEventTypes = null;
            }
        }
        EventEmitter.prototype.dispose = function () {
            this._listeners = {};
            this._bulkListeners = [];
            this._collectedEvents = [];
            this._deferredCnt = 0;
            this._allowedEventTypes = null;
        };
        EventEmitter.prototype.addListener = function (eventType, listener) {
            if (eventType === '*') {
                throw new Error('Use addBulkListener(listener) to register your listener!');
            }
            if (this._allowedEventTypes && !this._allowedEventTypes.hasOwnProperty(eventType)) {
                throw new Error('This object will never emit this event type!');
            }
            if (this._listeners.hasOwnProperty(eventType)) {
                this._listeners[eventType].push(listener);
            }
            else {
                this._listeners[eventType] = [listener];
            }
            var bound = this;
            return function () {
                if (!bound) {
                    // Already called
                    return;
                }
                bound._removeListener(eventType, listener);
                // Prevent leakers from holding on to the event emitter
                bound = null;
                listener = null;
            };
        };
        EventEmitter.prototype.addListener2 = function (eventType, listener) {
            var dispose = this.addListener(eventType, listener);
            return {
                dispose: dispose
            };
        };
        EventEmitter.prototype.on = function (eventType, listener) {
            return this.addListener(eventType, listener);
        };
        EventEmitter.prototype.addOneTimeListener = function (eventType, listener) {
            var unbind = this.addListener(eventType, function (value) {
                unbind();
                listener(value);
            });
            return unbind;
        };
        EventEmitter.prototype.addOneTimeDisposableListener = function (eventType, listener) {
            var dispose = this.addOneTimeListener(eventType, listener);
            return {
                dispose: dispose
            };
        };
        EventEmitter.prototype.addBulkListener = function (listener) {
            var _this = this;
            this._bulkListeners.push(listener);
            return function () {
                _this._removeBulkListener(listener);
            };
        };
        EventEmitter.prototype.addBulkListener2 = function (listener) {
            var dispose = this.addBulkListener(listener);
            return {
                dispose: dispose
            };
        };
        EventEmitter.prototype.addEmitter = function (eventEmitter, emitterType) {
            var _this = this;
            if (emitterType === void 0) { emitterType = null; }
            return eventEmitter.addBulkListener(function (events) {
                var newEvents = events;
                if (emitterType) {
                    // If the emitter has an emitterType, recreate events
                    newEvents = [];
                    for (var i = 0, len = events.length; i < len; i++) {
                        newEvents.push(new EmitterEvent(events[i].getType(), events[i].getData(), emitterType));
                    }
                }
                if (_this._deferredCnt === 0) {
                    _this._emitEvents(newEvents);
                }
                else {
                    // Collect for later
                    _this._collectedEvents.push.apply(_this._collectedEvents, newEvents);
                }
            });
        };
        EventEmitter.prototype.addEmitter2 = function (eventEmitter, emitterType) {
            var dispose = this.addEmitter(eventEmitter, emitterType);
            return {
                dispose: dispose
            };
        };
        EventEmitter.prototype.addEmitterTypeListener = function (eventType, emitterType, listener) {
            if (emitterType) {
                if (eventType === '*') {
                    throw new Error('Bulk listeners cannot specify an emitter type');
                }
                return this.addListener(eventType + '/' + emitterType, listener);
            }
            else {
                return this.addListener(eventType, listener);
            }
        };
        EventEmitter.prototype._removeListener = function (eventType, listener) {
            if (this._listeners.hasOwnProperty(eventType)) {
                var listeners = this._listeners[eventType];
                for (var i = 0, len = listeners.length; i < len; i++) {
                    if (listeners[i] === listener) {
                        listeners.splice(i, 1);
                        break;
                    }
                }
            }
        };
        EventEmitter.prototype._removeBulkListener = function (listener) {
            for (var i = 0, len = this._bulkListeners.length; i < len; i++) {
                if (this._bulkListeners[i] === listener) {
                    this._bulkListeners.splice(i, 1);
                    break;
                }
            }
        };
        EventEmitter.prototype._emitToSpecificTypeListeners = function (eventType, data) {
            if (this._listeners.hasOwnProperty(eventType)) {
                var listeners = this._listeners[eventType].slice(0);
                for (var i = 0, len = listeners.length; i < len; i++) {
                    try {
                        listeners[i](data);
                    }
                    catch (e) {
                        Errors.onUnexpectedError(e);
                    }
                }
            }
        };
        EventEmitter.prototype._emitToBulkListeners = function (events) {
            var bulkListeners = this._bulkListeners.slice(0);
            for (var i = 0, len = bulkListeners.length; i < len; i++) {
                try {
                    bulkListeners[i](events);
                }
                catch (e) {
                    Errors.onUnexpectedError(e);
                }
            }
        };
        EventEmitter.prototype._emitEvents = function (events) {
            if (this._bulkListeners.length > 0) {
                this._emitToBulkListeners(events);
            }
            for (var i = 0, len = events.length; i < len; i++) {
                var e = events[i];
                this._emitToSpecificTypeListeners(e.getType(), e.getData());
                if (e.getEmitterType()) {
                    this._emitToSpecificTypeListeners(e.getType() + '/' + e.getEmitterType(), e.getData());
                }
            }
        };
        EventEmitter.prototype.emit = function (eventType, data) {
            if (data === void 0) { data = {}; }
            if (this._allowedEventTypes && !this._allowedEventTypes.hasOwnProperty(eventType)) {
                throw new Error('Cannot emit this event type because it wasn\'t white-listed!');
            }
            // Early return if no listeners would get this
            if (!this._listeners.hasOwnProperty(eventType) && this._bulkListeners.length === 0) {
                return;
            }
            var emitterEvent = new EmitterEvent(eventType, data);
            if (this._deferredCnt === 0) {
                this._emitEvents([emitterEvent]);
            }
            else {
                // Collect for later
                this._collectedEvents.push(emitterEvent);
            }
        };
        EventEmitter.prototype.deferredEmit = function (callback) {
            this._deferredCnt = this._deferredCnt + 1;
            var result = null;
            try {
                result = callback();
            }
            catch (e) {
                Errors.onUnexpectedError(e);
            }
            this._deferredCnt = this._deferredCnt - 1;
            if (this._deferredCnt === 0) {
                this._emitCollected();
            }
            return result;
        };
        EventEmitter.prototype._emitCollected = function () {
            // Flush collected events
            var events = this._collectedEvents;
            this._collectedEvents = [];
            if (events.length > 0) {
                this._emitEvents(events);
            }
        };
        return EventEmitter;
    }());
    exports.EventEmitter = EventEmitter;
    var EmitQueueElement = (function () {
        function EmitQueueElement(target, arg) {
            this.target = target;
            this.arg = arg;
        }
        return EmitQueueElement;
    }());
    /**
     * Same as EventEmitter, but guarantees events are delivered in order to each listener
     */
    var OrderGuaranteeEventEmitter = (function (_super) {
        __extends(OrderGuaranteeEventEmitter, _super);
        function OrderGuaranteeEventEmitter(allowedEventTypes) {
            if (allowedEventTypes === void 0) { allowedEventTypes = null; }
            _super.call(this, allowedEventTypes);
            this._emitQueue = [];
        }
        OrderGuaranteeEventEmitter.prototype._emitToSpecificTypeListeners = function (eventType, data) {
            if (this._listeners.hasOwnProperty(eventType)) {
                var listeners = this._listeners[eventType];
                for (var i = 0, len = listeners.length; i < len; i++) {
                    this._emitQueue.push(new EmitQueueElement(listeners[i], data));
                }
            }
        };
        OrderGuaranteeEventEmitter.prototype._emitToBulkListeners = function (events) {
            var bulkListeners = this._bulkListeners;
            for (var i = 0, len = bulkListeners.length; i < len; i++) {
                this._emitQueue.push(new EmitQueueElement(bulkListeners[i], events));
            }
        };
        OrderGuaranteeEventEmitter.prototype._emitEvents = function (events) {
            _super.prototype._emitEvents.call(this, events);
            while (this._emitQueue.length > 0) {
                var queueElement = this._emitQueue.shift();
                try {
                    queueElement.target(queueElement.arg);
                }
                catch (e) {
                    Errors.onUnexpectedError(e);
                }
            }
        };
        return OrderGuaranteeEventEmitter;
    }(EventEmitter));
    exports.OrderGuaranteeEventEmitter = OrderGuaranteeEventEmitter;
});

define("vs/base/common/timer", ["require", "exports", 'vs/base/common/platform', 'vs/base/common/errors', 'vs/base/common/stopwatch'], function (require, exports, Platform, errors, precision) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.ENABLE_TIMER = false;
    var msWriteProfilerMark = Platform.globals['msWriteProfilerMark'];
    (function (Topic) {
        Topic[Topic["EDITOR"] = 0] = "EDITOR";
        Topic[Topic["LANGUAGES"] = 1] = "LANGUAGES";
        Topic[Topic["WORKER"] = 2] = "WORKER";
        Topic[Topic["WORKBENCH"] = 3] = "WORKBENCH";
        Topic[Topic["STARTUP"] = 4] = "STARTUP";
    })(exports.Topic || (exports.Topic = {}));
    var Topic = exports.Topic;
    var NullTimerEvent = (function () {
        function NullTimerEvent() {
        }
        NullTimerEvent.prototype.stop = function () {
            return;
        };
        NullTimerEvent.prototype.timeTaken = function () {
            return -1;
        };
        return NullTimerEvent;
    }());
    var TimerEvent = (function () {
        function TimerEvent(timeKeeper, name, topic, startTime, description) {
            this.timeKeeper = timeKeeper;
            this.name = name;
            this.description = description;
            this.topic = topic;
            this.stopTime = null;
            if (startTime) {
                this.startTime = startTime;
                return;
            }
            this.startTime = new Date();
            this.sw = precision.StopWatch.create();
            if (msWriteProfilerMark) {
                var profilerName = ['Monaco', this.topic, this.name, 'start'];
                msWriteProfilerMark(profilerName.join('|'));
            }
        }
        TimerEvent.prototype.stop = function (stopTime) {
            // already stopped
            if (this.stopTime !== null) {
                return;
            }
            if (stopTime) {
                this.stopTime = stopTime;
                this.sw = null;
                this.timeKeeper._onEventStopped(this);
                return;
            }
            this.stopTime = new Date();
            if (this.sw) {
                this.sw.stop();
            }
            this.timeKeeper._onEventStopped(this);
            if (msWriteProfilerMark) {
                var profilerName = ['Monaco', this.topic, this.name, 'stop'];
                msWriteProfilerMark(profilerName.join('|'));
            }
        };
        TimerEvent.prototype.timeTaken = function () {
            if (this.sw) {
                return this.sw.elapsed();
            }
            if (this.stopTime) {
                return this.stopTime.getTime() - this.startTime.getTime();
            }
            return -1;
        };
        return TimerEvent;
    }());
    var TimeKeeper /*extends EventEmitter.EventEmitter*/ = (function () {
        function TimeKeeper /*extends EventEmitter.EventEmitter*/() {
            this.cleaningIntervalId = -1;
            this.collectedEvents = [];
            this.listeners = [];
        }
        TimeKeeper /*extends EventEmitter.EventEmitter*/.prototype.isEnabled = function () {
            return exports.ENABLE_TIMER;
        };
        TimeKeeper /*extends EventEmitter.EventEmitter*/.prototype.start = function (topic, name, start, description) {
            if (!this.isEnabled()) {
                return exports.nullEvent;
            }
            var strTopic;
            if (typeof topic === 'string') {
                strTopic = topic;
            }
            else if (topic === Topic.EDITOR) {
                strTopic = 'Editor';
            }
            else if (topic === Topic.LANGUAGES) {
                strTopic = 'Languages';
            }
            else if (topic === Topic.WORKER) {
                strTopic = 'Worker';
            }
            else if (topic === Topic.WORKBENCH) {
                strTopic = 'Workbench';
            }
            else if (topic === Topic.STARTUP) {
                strTopic = 'Startup';
            }
            this.initAutoCleaning();
            var event = new TimerEvent(this, name, strTopic, start, description);
            this.addEvent(event);
            return event;
        };
        TimeKeeper /*extends EventEmitter.EventEmitter*/.prototype.dispose = function () {
            if (this.cleaningIntervalId !== -1) {
                Platform.clearInterval(this.cleaningIntervalId);
                this.cleaningIntervalId = -1;
            }
        };
        TimeKeeper /*extends EventEmitter.EventEmitter*/.prototype.addListener = function (listener) {
            this.listeners.push(listener);
        };
        TimeKeeper /*extends EventEmitter.EventEmitter*/.prototype.removeListener = function (listener) {
            for (var i = 0; i < this.listeners.length; i++) {
                if (this.listeners[i] === listener) {
                    this.listeners.splice(i, 1);
                    return;
                }
            }
        };
        TimeKeeper /*extends EventEmitter.EventEmitter*/.prototype.addEvent = function (event) {
            event.id = TimeKeeper.EVENT_ID;
            TimeKeeper.EVENT_ID++;
            this.collectedEvents.push(event);
            // expire items from the front of the cache
            if (this.collectedEvents.length > TimeKeeper._EVENT_CACHE_LIMIT) {
                this.collectedEvents.shift();
            }
        };
        TimeKeeper /*extends EventEmitter.EventEmitter*/.prototype.initAutoCleaning = function () {
            var _this = this;
            if (this.cleaningIntervalId === -1) {
                this.cleaningIntervalId = Platform.setInterval(function () {
                    var now = Date.now();
                    _this.collectedEvents.forEach(function (event) {
                        if (!event.stopTime && (now - event.startTime.getTime()) >= TimeKeeper._MAX_TIMER_LENGTH) {
                            event.stop();
                        }
                    });
                }, TimeKeeper._CLEAN_UP_INTERVAL);
            }
        };
        TimeKeeper /*extends EventEmitter.EventEmitter*/.prototype.getCollectedEvents = function () {
            return this.collectedEvents.slice(0);
        };
        TimeKeeper /*extends EventEmitter.EventEmitter*/.prototype.clearCollectedEvents = function () {
            this.collectedEvents = [];
        };
        TimeKeeper /*extends EventEmitter.EventEmitter*/.prototype._onEventStopped = function (event) {
            var emitEvents = [event];
            var listeners = this.listeners.slice(0);
            for (var i = 0; i < listeners.length; i++) {
                try {
                    listeners[i](emitEvents);
                }
                catch (e) {
                    errors.onUnexpectedError(e);
                }
            }
        };
        TimeKeeper /*extends EventEmitter.EventEmitter*/.prototype.setInitialCollectedEvents = function (events, startTime) {
            var _this = this;
            if (!this.isEnabled()) {
                return;
            }
            if (startTime) {
                TimeKeeper.PARSE_TIME = startTime;
            }
            events.forEach(function (event) {
                var e = new TimerEvent(_this, event.name, event.topic, event.startTime, event.description);
                e.stop(event.stopTime);
                _this.addEvent(e);
            });
        };
        /**
         * After being started for 1 minute, all timers are automatically stopped.
         */
        TimeKeeper /*extends EventEmitter.EventEmitter*/._MAX_TIMER_LENGTH = 60000; // 1 minute
        /**
         * Every 2 minutes, a sweep of current started timers is done.
         */
        TimeKeeper /*extends EventEmitter.EventEmitter*/._CLEAN_UP_INTERVAL = 120000; // 2 minutes
        /**
         * Collect at most 1000 events.
         */
        TimeKeeper /*extends EventEmitter.EventEmitter*/._EVENT_CACHE_LIMIT = 1000;
        TimeKeeper /*extends EventEmitter.EventEmitter*/.EVENT_ID = 1;
        TimeKeeper /*extends EventEmitter.EventEmitter*/.PARSE_TIME = new Date();
        return TimeKeeper /*extends EventEmitter.EventEmitter*/;
    }());
    exports.TimeKeeper /*extends EventEmitter.EventEmitter*/ = TimeKeeper /*extends EventEmitter.EventEmitter*/;
    var timeKeeper = new TimeKeeper();
    exports.nullEvent = new NullTimerEvent();
    function start(topic, name, start, description) {
        return timeKeeper.start(topic, name, start, description);
    }
    exports.start = start;
    function getTimeKeeper() {
        return timeKeeper;
    }
    exports.getTimeKeeper = getTimeKeeper;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

define("vs/base/common/winjs.base", ['./winjs.base.raw', 'vs/base/common/errors'], function (raw, __Errors__) {
	'use strict';

	var winjs = raw;

	var outstandingPromiseErrors = {};
	function promiseErrorHandler(e) {

		//
		// e.detail looks like: { exception, error, promise, handler, id, parent }
		//
		var details = e.detail;
		var id = details.id;

		// If the error has a parent promise then this is not the origination of the
		//  error so we check if it has a handler, and if so we mark that the error
		//  was handled by removing it from outstandingPromiseErrors
		//
		if (details.parent) {
			if (details.handler && outstandingPromiseErrors) {
				delete outstandingPromiseErrors[id];
			}
			return;
		}

		// Indicate that this error was originated and needs to be handled
		outstandingPromiseErrors[id] = details;

		// The first time the queue fills up this iteration, schedule a timeout to
		// check if any errors are still unhandled.
		if (Object.keys(outstandingPromiseErrors).length === 1) {
			setTimeout(function () {
				var errors = outstandingPromiseErrors;
				outstandingPromiseErrors = {};
				Object.keys(errors).forEach(function (errorId) {
					var error = errors[errorId];
					if(error.exception) {
						__Errors__.onUnexpectedError(error.exception);
					} else if(error.error) {
						__Errors__.onUnexpectedError(error.error);
					}
					console.log("WARNING: Promise with no error callback:" + error.id);
					console.log(error);
					if(error.exception) {
						console.log(error.exception.stack);
					}
				});
			}, 0);
		}
	}

	winjs.Promise.addEventListener("error", promiseErrorHandler);


	function decoratePromise(promise, completeCallback, errorCallback) {
		var pc, pe, pp;

		var resultPromise = new winjs.Promise(
			function (c, e, p) {
				pc = c;
				pe = e;
				pp = p;
			}, function () {
				promise.cancel();
			}
		);

		promise.then(function (r) {
			if (completeCallback) {
				completeCallback(r);
			}
			pc(r);
		}, function (e) {
			if (errorCallback) {
				errorCallback(e);
			}
			pe(e);
		}, pp);

		return resultPromise;
	}

	return {
		decoratePromise: decoratePromise,
		Class: winjs.Class,
		xhr: winjs.xhr,
		Promise: winjs.Promise,
		TPromise: winjs.Promise,
		PPromise: winjs.Promise,
		Utilities: winjs.Utilities
	};
});
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("vs/base/common/actions", ["require", "exports", 'vs/base/common/winjs.base', 'vs/base/common/eventEmitter', 'vs/base/common/events'], function (require, exports, winjs_base_1, eventEmitter_1, Events) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Checks if the provided object is compatible
     * with the IAction interface.
     * @param thing an object
     */
    function isAction(thing) {
        if (!thing) {
            return false;
        }
        else if (thing instanceof Action) {
            return true;
        }
        else if (typeof thing.id !== 'string') {
            return false;
        }
        else if (typeof thing.label !== 'string') {
            return false;
        }
        else if (typeof thing.class !== 'string') {
            return false;
        }
        else if (typeof thing.enabled !== 'boolean') {
            return false;
        }
        else if (typeof thing.checked !== 'boolean') {
            return false;
        }
        else if (typeof thing.run !== 'function') {
            return false;
        }
        else {
            return true;
        }
    }
    exports.isAction = isAction;
    var Action = (function (_super) {
        __extends(Action, _super);
        function Action(id, label, cssClass, enabled, actionCallback) {
            if (label === void 0) { label = ''; }
            if (cssClass === void 0) { cssClass = ''; }
            if (enabled === void 0) { enabled = true; }
            if (actionCallback === void 0) { actionCallback = null; }
            _super.call(this);
            this._id = id;
            this._label = label;
            this._cssClass = cssClass;
            this._enabled = enabled;
            this._actionCallback = actionCallback;
        }
        Object.defineProperty(Action.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "label", {
            get: function () {
                return this._label;
            },
            set: function (value) {
                this._setLabel(value);
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype._setLabel = function (value) {
            if (this._label !== value) {
                this._label = value;
                this.emit(Action.LABEL, { source: this });
            }
        };
        Object.defineProperty(Action.prototype, "tooltip", {
            get: function () {
                return this._tooltip;
            },
            set: function (value) {
                this._setTooltip(value);
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype._setTooltip = function (value) {
            if (this._tooltip !== value) {
                this._tooltip = value;
                this.emit(Action.TOOLTIP, { source: this });
            }
        };
        Object.defineProperty(Action.prototype, "class", {
            get: function () {
                return this._cssClass;
            },
            set: function (value) {
                this._setClass(value);
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype._setClass = function (value) {
            if (this._cssClass !== value) {
                this._cssClass = value;
                this.emit(Action.CLASS, { source: this });
            }
        };
        Object.defineProperty(Action.prototype, "enabled", {
            get: function () {
                return this._enabled;
            },
            set: function (value) {
                this._setEnabled(value);
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype._setEnabled = function (value) {
            if (this._enabled !== value) {
                this._enabled = value;
                this.emit(Action.ENABLED, { source: this });
            }
        };
        Object.defineProperty(Action.prototype, "checked", {
            get: function () {
                return this._checked;
            },
            set: function (value) {
                this._setChecked(value);
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype._setChecked = function (value) {
            if (this._checked !== value) {
                this._checked = value;
                this.emit(Action.CHECKED, { source: this });
            }
        };
        Object.defineProperty(Action.prototype, "order", {
            get: function () {
                return this._order;
            },
            set: function (value) {
                this._order = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "actionCallback", {
            get: function () {
                return this._actionCallback;
            },
            set: function (value) {
                this._actionCallback = value;
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype.run = function (event) {
            if (this._actionCallback !== null) {
                return this._actionCallback(event);
            }
            else {
                return winjs_base_1.TPromise.as(true);
            }
        };
        Action.LABEL = 'label';
        Action.TOOLTIP = 'tooltip';
        Action.CLASS = 'class';
        Action.ENABLED = 'enabled';
        Action.CHECKED = 'checked';
        return Action;
    }(eventEmitter_1.EventEmitter));
    exports.Action = Action;
    var ProxyAction = (function (_super) {
        __extends(ProxyAction, _super);
        function ProxyAction(delegate, runHandler) {
            _super.call(this, delegate.id, delegate.label, delegate.class, delegate.enabled, null);
            this.delegate = delegate;
            this.runHandler = runHandler;
        }
        Object.defineProperty(ProxyAction.prototype, "id", {
            get: function () {
                return this.delegate.id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ProxyAction.prototype, "label", {
            get: function () {
                return this.delegate.label;
            },
            set: function (value) {
                this.delegate.label = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ProxyAction.prototype, "class", {
            get: function () {
                return this.delegate.class;
            },
            set: function (value) {
                this.delegate.class = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ProxyAction.prototype, "enabled", {
            get: function () {
                return this.delegate.enabled;
            },
            set: function (value) {
                this.delegate.enabled = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ProxyAction.prototype, "checked", {
            get: function () {
                return this.delegate.checked;
            },
            set: function (value) {
                this.delegate.checked = value;
            },
            enumerable: true,
            configurable: true
        });
        ProxyAction.prototype.run = function (event) {
            this.runHandler(event);
            return this.delegate.run(event);
        };
        ProxyAction.prototype.addListener = function (eventType, listener) {
            return this.delegate.addListener(eventType, listener);
        };
        ProxyAction.prototype.addBulkListener = function (listener) {
            return this.delegate.addBulkListener(listener);
        };
        ProxyAction.prototype.addEmitter = function (eventEmitter, emitterType) {
            return this.delegate.addEmitter(eventEmitter, emitterType);
        };
        ProxyAction.prototype.addEmitterTypeListener = function (eventType, emitterType, listener) {
            return this.delegate.addEmitterTypeListener(eventType, emitterType, listener);
        };
        ProxyAction.prototype.emit = function (eventType, data) {
            this.delegate.emit(eventType, data);
        };
        return ProxyAction;
    }(Action));
    var ActionRunner = (function (_super) {
        __extends(ActionRunner, _super);
        function ActionRunner() {
            _super.apply(this, arguments);
        }
        ActionRunner.prototype.run = function (action, context) {
            var _this = this;
            if (!action.enabled) {
                return winjs_base_1.TPromise.as(null);
            }
            this.emit(Events.EventType.BEFORE_RUN, { action: action });
            return winjs_base_1.TPromise.as(action.run(context)).then(function (result) {
                _this.emit(Events.EventType.RUN, { action: action, result: result });
            }, function (error) {
                _this.emit(Events.EventType.RUN, { action: action, error: error });
            });
        };
        return ActionRunner;
    }(eventEmitter_1.EventEmitter));
    exports.ActionRunner = ActionRunner;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("vs/base/common/async", ["require", "exports", 'vs/base/common/errors', 'vs/base/common/winjs.base', 'vs/base/common/platform', 'vs/base/common/cancellation', 'vs/base/common/lifecycle'], function (require, exports, errors, winjs_base_1, platform, cancellation_1, lifecycle_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function isThenable(obj) {
        return obj && typeof obj.then === 'function';
    }
    function asWinJsPromise(callback) {
        var source = new cancellation_1.CancellationTokenSource();
        return new winjs_base_1.TPromise(function (resolve, reject) {
            var item = callback(source.token);
            if (isThenable(item)) {
                item.then(resolve, reject);
            }
            else {
                resolve(item);
            }
        }, function () {
            source.cancel();
        });
    }
    exports.asWinJsPromise = asWinJsPromise;
    /**
     * A helper to prevent accumulation of sequential async tasks.
     *
     * Imagine a mail man with the sole task of delivering letters. As soon as
     * a letter submitted for delivery, he drives to the destination, delivers it
     * and returns to his base. Imagine that during the trip, N more letters were submitted.
     * When the mail man returns, he picks those N letters and delivers them all in a
     * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.
     *
     * The throttler implements this via the queue() method, by providing it a task
     * factory. Following the example:
     *
     * 		var throttler = new Throttler();
     * 		var letters = [];
     *
     * 		function letterReceived(l) {
     * 			letters.push(l);
     * 			throttler.queue(() => { return makeTheTrip(); });
     * 		}
     */
    var Throttler = (function () {
        function Throttler() {
            this.activePromise = null;
            this.queuedPromise = null;
            this.queuedPromiseFactory = null;
        }
        Throttler.prototype.queue = function (promiseFactory) {
            var _this = this;
            if (this.activePromise) {
                this.queuedPromiseFactory = promiseFactory;
                if (!this.queuedPromise) {
                    var onComplete_1 = function () {
                        _this.queuedPromise = null;
                        var result = _this.queue(_this.queuedPromiseFactory);
                        _this.queuedPromiseFactory = null;
                        return result;
                    };
                    this.queuedPromise = new winjs_base_1.Promise(function (c, e, p) {
                        _this.activePromise.then(onComplete_1, onComplete_1, p).done(c);
                    }, function () {
                        _this.activePromise.cancel();
                    });
                }
                return new winjs_base_1.Promise(function (c, e, p) {
                    _this.queuedPromise.then(c, e, p);
                }, function () {
                    // no-op
                });
            }
            this.activePromise = promiseFactory();
            return new winjs_base_1.Promise(function (c, e, p) {
                _this.activePromise.done(function (result) {
                    _this.activePromise = null;
                    c(result);
                }, function (err) {
                    _this.activePromise = null;
                    e(err);
                }, p);
            }, function () {
                _this.activePromise.cancel();
            });
        };
        return Throttler;
    }());
    exports.Throttler = Throttler;
    /**
     * A helper to delay execution of a task that is being requested often.
     *
     * Following the throttler, now imagine the mail man wants to optimize the number of
     * trips proactively. The trip itself can be long, so the he decides not to make the trip
     * as soon as a letter is submitted. Instead he waits a while, in case more
     * letters are submitted. After said waiting period, if no letters were submitted, he
     * decides to make the trip. Imagine that N more letters were submitted after the first
     * one, all within a short period of time between each other. Even though N+1
     * submissions occurred, only 1 delivery was made.
     *
     * The delayer offers this behavior via the trigger() method, into which both the task
     * to be executed and the waiting period (delay) must be passed in as arguments. Following
     * the example:
     *
     * 		var delayer = new Delayer(WAITING_PERIOD);
     * 		var letters = [];
     *
     * 		function letterReceived(l) {
     * 			letters.push(l);
     * 			delayer.trigger(() => { return makeTheTrip(); });
     * 		}
     */
    var Delayer = (function () {
        function Delayer(defaultDelay) {
            this.defaultDelay = defaultDelay;
            this.timeout = null;
            this.completionPromise = null;
            this.onSuccess = null;
            this.task = null;
        }
        Delayer.prototype.trigger = function (task, delay) {
            var _this = this;
            if (delay === void 0) { delay = this.defaultDelay; }
            this.task = task;
            this.cancelTimeout();
            if (!this.completionPromise) {
                this.completionPromise = new winjs_base_1.Promise(function (c) {
                    _this.onSuccess = c;
                }, function () {
                    // no-op
                }).then(function () {
                    _this.completionPromise = null;
                    _this.onSuccess = null;
                    var task = _this.task;
                    _this.task = null;
                    return task();
                });
            }
            this.timeout = setTimeout(function () {
                _this.timeout = null;
                _this.onSuccess(null);
            }, delay);
            return this.completionPromise;
        };
        Delayer.prototype.isTriggered = function () {
            return this.timeout !== null;
        };
        Delayer.prototype.cancel = function () {
            this.cancelTimeout();
            if (this.completionPromise) {
                this.completionPromise.cancel();
                this.completionPromise = null;
            }
        };
        Delayer.prototype.cancelTimeout = function () {
            if (this.timeout !== null) {
                clearTimeout(this.timeout);
                this.timeout = null;
            }
        };
        return Delayer;
    }());
    exports.Delayer = Delayer;
    /**
     * A helper to delay execution of a task that is being requested often, while
     * preventing accumulation of consecutive executions, while the task runs.
     *
     * Simply combine the two mail man strategies from the Throttler and Delayer
     * helpers, for an analogy.
     */
    var ThrottledDelayer = (function (_super) {
        __extends(ThrottledDelayer, _super);
        function ThrottledDelayer(defaultDelay) {
            _super.call(this, defaultDelay);
            this.throttler = new Throttler();
        }
        ThrottledDelayer.prototype.trigger = function (promiseFactory, delay) {
            var _this = this;
            return _super.prototype.trigger.call(this, function () { return _this.throttler.queue(promiseFactory); }, delay);
        };
        return ThrottledDelayer;
    }(Delayer));
    exports.ThrottledDelayer = ThrottledDelayer;
    /**
     * Similar to the ThrottledDelayer, except it also guarantees that the promise
     * factory doesn't get called more often than every `minimumPeriod` milliseconds.
     */
    var PeriodThrottledDelayer = (function (_super) {
        __extends(PeriodThrottledDelayer, _super);
        function PeriodThrottledDelayer(defaultDelay, minimumPeriod) {
            if (minimumPeriod === void 0) { minimumPeriod = 0; }
            _super.call(this, defaultDelay);
            this.minimumPeriod = minimumPeriod;
            this.periodThrottler = new Throttler();
        }
        PeriodThrottledDelayer.prototype.trigger = function (promiseFactory, delay) {
            var _this = this;
            return _super.prototype.trigger.call(this, function () {
                return _this.periodThrottler.queue(function () {
                    return winjs_base_1.Promise.join([
                        winjs_base_1.TPromise.timeout(_this.minimumPeriod),
                        promiseFactory()
                    ]).then(function (r) { return r[1]; });
                });
            }, delay);
        };
        return PeriodThrottledDelayer;
    }(ThrottledDelayer));
    exports.PeriodThrottledDelayer = PeriodThrottledDelayer;
    var PromiseSource = (function () {
        function PromiseSource() {
            var _this = this;
            this._value = new winjs_base_1.TPromise(function (c, e) {
                _this._completeCallback = c;
                _this._errorCallback = e;
            });
        }
        Object.defineProperty(PromiseSource.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: true,
            configurable: true
        });
        PromiseSource.prototype.complete = function (value) {
            this._completeCallback(value);
        };
        PromiseSource.prototype.error = function (err) {
            this._errorCallback(err);
        };
        return PromiseSource;
    }());
    exports.PromiseSource = PromiseSource;
    var ShallowCancelThenPromise = (function (_super) {
        __extends(ShallowCancelThenPromise, _super);
        function ShallowCancelThenPromise(outer) {
            var completeCallback, errorCallback, progressCallback;
            _super.call(this, function (c, e, p) {
                completeCallback = c;
                errorCallback = e;
                progressCallback = p;
            }, function () {
                // cancel this promise but not the
                // outer promise
                errorCallback(errors.canceled());
            });
            outer.then(completeCallback, errorCallback, progressCallback);
        }
        return ShallowCancelThenPromise;
    }(winjs_base_1.TPromise));
    exports.ShallowCancelThenPromise = ShallowCancelThenPromise;
    /**
     * Returns a new promise that joins the provided promise. Upon completion of
     * the provided promise the provided function will always be called. This
     * method is comparable to a try-finally code block.
     * @param promise a promise
     * @param f a function that will be call in the success and error case.
     */
    function always(promise, f) {
        return new winjs_base_1.TPromise(function (c, e, p) {
            promise.done(function (result) {
                try {
                    f(result);
                }
                catch (e1) {
                    errors.onUnexpectedError(e1);
                }
                c(result);
            }, function (err) {
                try {
                    f(err);
                }
                catch (e1) {
                    errors.onUnexpectedError(e1);
                }
                e(err);
            }, function (progress) {
                p(progress);
            });
        }, function () {
            promise.cancel();
        });
    }
    exports.always = always;
    /**
     * Runs the provided list of promise factories in sequential order. The returned
     * promise will complete to an array of results from each promise.
     */
    function sequence(promiseFactory) {
        var results = [];
        // reverse since we start with last element using pop()
        promiseFactory = promiseFactory.reverse();
        function next() {
            if (promiseFactory.length) {
                return promiseFactory.pop()();
            }
            return null;
        }
        function thenHandler(result) {
            if (result) {
                results.push(result);
            }
            var n = next();
            if (n) {
                return n.then(thenHandler);
            }
            return winjs_base_1.TPromise.as(results);
        }
        return winjs_base_1.TPromise.as(null).then(thenHandler);
    }
    exports.sequence = sequence;
    function once(fn) {
        var _this = this;
        var didCall = false;
        var result;
        return function () {
            if (didCall) {
                return result;
            }
            didCall = true;
            result = fn.apply(_this, arguments);
            return result;
        };
    }
    exports.once = once;
    /**
     * A helper to queue N promises and run them all with a max degree of parallelism. The helper
     * ensures that at any time no more than M promises are running at the same time.
     */
    var Limiter = (function () {
        function Limiter(maxDegreeOfParalellism) {
            this.maxDegreeOfParalellism = maxDegreeOfParalellism;
            this.outstandingPromises = [];
            this.runningPromises = 0;
        }
        Limiter.prototype.queue = function (promiseFactory) {
            var _this = this;
            return new winjs_base_1.TPromise(function (c, e, p) {
                _this.outstandingPromises.push({
                    factory: promiseFactory,
                    c: c,
                    e: e,
                    p: p
                });
                _this.consume();
            });
        };
        Limiter.prototype.consume = function () {
            var _this = this;
            while (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {
                var iLimitedTask = this.outstandingPromises.shift();
                this.runningPromises++;
                var promise = iLimitedTask.factory();
                promise.done(iLimitedTask.c, iLimitedTask.e, iLimitedTask.p);
                promise.done(function () { return _this.consumed(); }, function () { return _this.consumed(); });
            }
        };
        Limiter.prototype.consumed = function () {
            this.runningPromises--;
            this.consume();
        };
        return Limiter;
    }());
    exports.Limiter = Limiter;
    var TimeoutTimer = (function (_super) {
        __extends(TimeoutTimer, _super);
        function TimeoutTimer() {
            _super.call(this);
            this._token = -1;
        }
        TimeoutTimer.prototype.dispose = function () {
            this.cancel();
            _super.prototype.dispose.call(this);
        };
        TimeoutTimer.prototype.cancel = function () {
            if (this._token !== -1) {
                platform.clearTimeout(this._token);
                this._token = -1;
            }
        };
        TimeoutTimer.prototype.cancelAndSet = function (runner, timeout) {
            var _this = this;
            this.cancel();
            this._token = platform.setTimeout(function () {
                _this._token = -1;
                runner();
            }, timeout);
        };
        TimeoutTimer.prototype.setIfNotSet = function (runner, timeout) {
            var _this = this;
            if (this._token !== -1) {
                // timer is already set
                return;
            }
            this._token = platform.setTimeout(function () {
                _this._token = -1;
                runner();
            }, timeout);
        };
        return TimeoutTimer;
    }(lifecycle_1.Disposable));
    exports.TimeoutTimer = TimeoutTimer;
    var IntervalTimer = (function (_super) {
        __extends(IntervalTimer, _super);
        function IntervalTimer() {
            _super.call(this);
            this._token = -1;
        }
        IntervalTimer.prototype.dispose = function () {
            this.cancel();
            _super.prototype.dispose.call(this);
        };
        IntervalTimer.prototype.cancel = function () {
            if (this._token !== -1) {
                platform.clearInterval(this._token);
                this._token = -1;
            }
        };
        IntervalTimer.prototype.cancelAndSet = function (runner, interval) {
            this.cancel();
            this._token = platform.setInterval(function () {
                runner();
            }, interval);
        };
        return IntervalTimer;
    }(lifecycle_1.Disposable));
    exports.IntervalTimer = IntervalTimer;
    var RunOnceScheduler = (function () {
        function RunOnceScheduler(runner, timeout) {
            this.timeoutToken = -1;
            this.runner = runner;
            this.timeout = timeout;
            this.timeoutHandler = this.onTimeout.bind(this);
        }
        /**
         * Dispose RunOnceScheduler
         */
        RunOnceScheduler.prototype.dispose = function () {
            this.cancel();
            this.runner = null;
        };
        /**
         * Cancel current scheduled runner (if any).
         */
        RunOnceScheduler.prototype.cancel = function () {
            if (this.isScheduled()) {
                platform.clearTimeout(this.timeoutToken);
                this.timeoutToken = -1;
            }
        };
        /**
         * Replace runner. If there is a runner already scheduled, the new runner will be called.
         */
        RunOnceScheduler.prototype.setRunner = function (runner) {
            this.runner = runner;
        };
        /**
         * Set timeout. This change will only impact new schedule calls.
         */
        RunOnceScheduler.prototype.setTimeout = function (timeout) {
            this.timeout = timeout;
        };
        /**
         * Cancel previous runner (if any) & schedule a new runner.
         */
        RunOnceScheduler.prototype.schedule = function () {
            this.cancel();
            this.timeoutToken = platform.setTimeout(this.timeoutHandler, this.timeout);
        };
        /**
         * Returns true if scheduled.
         */
        RunOnceScheduler.prototype.isScheduled = function () {
            return this.timeoutToken !== -1;
        };
        RunOnceScheduler.prototype.onTimeout = function () {
            this.timeoutToken = -1;
            if (this.runner) {
                this.runner();
            }
        };
        return RunOnceScheduler;
    }());
    exports.RunOnceScheduler = RunOnceScheduler;
    function nfcall(fn) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return new winjs_base_1.Promise(function (c, e) { return fn.apply(void 0, args.concat([function (err, result) { return err ? e(err) : c(result); }])); });
    }
    exports.nfcall = nfcall;
    function ninvoke(thisArg, fn) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        return new winjs_base_1.Promise(function (c, e) { return fn.call.apply(fn, [thisArg].concat(args, [function (err, result) { return err ? e(err) : c(result); }])); });
    }
    exports.ninvoke = ninvoke;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/base/common/service", ["require", "exports", 'vs/base/common/winjs.base', 'vs/base/common/objects', 'vs/base/common/lifecycle', 'vs/base/common/event'], function (require, exports, winjs_base_1, objects_1, lifecycle_1, event_1) {
    'use strict';
    var RequestType;
    (function (RequestType) {
        RequestType[RequestType["Common"] = 0] = "Common";
        RequestType[RequestType["Cancel"] = 1] = "Cancel";
    })(RequestType || (RequestType = {}));
    var ResponseType;
    (function (ResponseType) {
        ResponseType[ResponseType["Initialize"] = 0] = "Initialize";
        ResponseType[ResponseType["Success"] = 1] = "Success";
        ResponseType[ResponseType["Progress"] = 2] = "Progress";
        ResponseType[ResponseType["Error"] = 3] = "Error";
        ResponseType[ResponseType["ErrorObj"] = 4] = "ErrorObj";
    })(ResponseType || (ResponseType = {}));
    var ServiceState;
    (function (ServiceState) {
        ServiceState[ServiceState["Uninitialized"] = 0] = "Uninitialized";
        ServiceState[ServiceState["Idle"] = 1] = "Idle";
    })(ServiceState || (ServiceState = {}));
    var ServiceEventProperty = '$__SERVICE_EVENT';
    /**
     * Use this as a property decorator.
     */
    function ServiceEvent(target, key) {
        target[key] = (_a = {}, _a[ServiceEventProperty] = true, _a);
        var _a;
    }
    exports.ServiceEvent = ServiceEvent;
    function isServiceEvent(target) {
        return target[ServiceEventProperty];
    }
    exports.isServiceEvent = isServiceEvent;
    var Server = (function () {
        function Server(protocol) {
            var _this = this;
            this.protocol = protocol;
            this.services = Object.create(null);
            this.activeRequests = Object.create(null);
            this.protocol.onMessage(function (r) { return _this.onMessage(r); });
            this.protocol.send({ type: ResponseType.Initialize });
        }
        Server.prototype.registerService = function (serviceName, service) {
            this.services[serviceName] = service;
        };
        Server.prototype.onMessage = function (request) {
            switch (request.type) {
                case RequestType.Common:
                    this.onCommonRequest(request);
                    break;
                case RequestType.Cancel:
                    this.onCancelRequest(request);
                    break;
            }
        };
        Server.prototype.onCommonRequest = function (request) {
            var service = this.services[request.serviceName];
            var servicePrototype = service.constructor.prototype;
            var prototypeMethod = servicePrototype && servicePrototype[request.name];
            var isEvent = prototypeMethod && prototypeMethod[ServiceEventProperty];
            var method = service[request.name];
            var promise;
            if (isEvent) {
                var disposable_1;
                promise = new winjs_base_1.Promise(function (c, e, p) { return disposable_1 = method.call(service, p); }, function () { return disposable_1.dispose(); });
            }
            else {
                if (!method) {
                    promise = winjs_base_1.Promise.wrapError(new Error(request.name + " is not a valid method on " + request.serviceName));
                }
                else {
                    try {
                        promise = method.call.apply(method, [service].concat(request.args));
                    }
                    catch (err) {
                        promise = winjs_base_1.Promise.wrapError(err);
                    }
                }
                if (!winjs_base_1.Promise.is(promise)) {
                    var message = "'" + request.name + "' did not return a promise";
                    console.warn(message);
                    promise = winjs_base_1.Promise.wrapError(new Error(message));
                }
            }
            this.onPromiseRequest(promise, request);
        };
        Server.prototype.onPromiseRequest = function (promise, request) {
            var _this = this;
            var id = request.id;
            var requestPromise = promise.then(function (data) {
                _this.protocol.send({ id: id, data: data, type: ResponseType.Success });
                delete _this.activeRequests[request.id];
            }, function (data) {
                if (data instanceof Error) {
                    _this.protocol.send({ id: id, data: {
                            message: data.message,
                            name: data.name,
                            stack: data.stack ? data.stack.split('\n') : void 0
                        }, type: ResponseType.Error });
                }
                else {
                    _this.protocol.send({ id: id, data: data, type: ResponseType.ErrorObj });
                }
                delete _this.activeRequests[request.id];
            }, function (data) {
                _this.protocol.send({ id: id, data: data, type: ResponseType.Progress });
            });
            this.activeRequests[request.id] = lifecycle_1.fnToDisposable(function () { return requestPromise.cancel(); });
        };
        Server.prototype.onCancelRequest = function (request) {
            var disposable = this.activeRequests[request.id];
            if (disposable) {
                disposable.dispose();
                delete this.activeRequests[request.id];
            }
        };
        Server.prototype.dispose = function () {
            var _this = this;
            Object.keys(this.activeRequests).forEach(function (id) {
                _this.activeRequests[id].dispose();
            });
            this.activeRequests = null;
        };
        return Server;
    }());
    exports.Server = Server;
    var Client = (function () {
        function Client(protocol) {
            var _this = this;
            this.protocol = protocol;
            this.state = ServiceState.Uninitialized;
            this.bufferedRequests = [];
            this.handlers = Object.create(null);
            this.lastRequestId = 0;
            this.protocol.onMessage(function (r) { return _this.onMessage(r); });
        }
        Client.prototype.getService = function (serviceName, serviceCtor) {
            var _this = this;
            var props = Object.keys(serviceCtor.prototype)
                .filter(function (key) { return key !== 'constructor'; });
            return props.reduce(function (service, key) {
                if (serviceCtor.prototype[key][ServiceEventProperty]) {
                    var promise_1;
                    var emitter_1 = new event_1.Emitter({
                        onFirstListenerAdd: function () {
                            promise_1 = _this.request(serviceName, key)
                                .then(null, null, function (event) { return emitter_1.fire(event); });
                        },
                        onLastListenerRemove: function () {
                            promise_1.cancel();
                            promise_1 = null;
                        }
                    });
                    return objects_1.assign(service, (_a = {}, _a[key] = emitter_1.event, _a));
                }
                return objects_1.assign(service, (_b = {}, _b[key] = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i - 0] = arguments[_i];
                    }
                    return _this.request.apply(_this, [serviceName, key].concat(args));
                }, _b));
                var _a, _b;
            }, {});
        };
        Client.prototype.request = function (serviceName, name) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            var request = {
                raw: {
                    id: this.lastRequestId++,
                    type: RequestType.Common,
                    serviceName: serviceName,
                    name: name,
                    args: args
                }
            };
            if (this.state === ServiceState.Uninitialized) {
                return this.bufferRequest(request);
            }
            return this.doRequest(request);
        };
        Client.prototype.doRequest = function (request) {
            var _this = this;
            var id = request.raw.id;
            return new winjs_base_1.Promise(function (c, e, p) {
                _this.handlers[id] = function (response) {
                    switch (response.type) {
                        case ResponseType.Success:
                            delete _this.handlers[id];
                            c(response.data);
                            break;
                        case ResponseType.Error:
                            delete _this.handlers[id];
                            var error = new Error(response.data.message);
                            error.stack = response.data.stack;
                            error.name = response.data.name;
                            e(error);
                            break;
                        case ResponseType.ErrorObj:
                            delete _this.handlers[id];
                            e(response.data);
                            break;
                        case ResponseType.Progress:
                            p(response.data);
                            break;
                    }
                };
                _this.send(request.raw);
            }, function () { return _this.send({ id: id, type: RequestType.Cancel }); });
        };
        Client.prototype.bufferRequest = function (request) {
            var _this = this;
            var flushedRequest = null;
            return new winjs_base_1.Promise(function (c, e, p) {
                _this.bufferedRequests.push(request);
                request.flush = function () {
                    request.flush = null;
                    flushedRequest = _this.doRequest(request).then(c, e, p);
                };
            }, function () {
                request.flush = null;
                if (_this.state !== ServiceState.Uninitialized) {
                    if (flushedRequest) {
                        flushedRequest.cancel();
                        flushedRequest = null;
                    }
                    return;
                }
                var idx = _this.bufferedRequests.indexOf(request);
                if (idx === -1) {
                    return;
                }
                _this.bufferedRequests.splice(idx, 1);
            });
        };
        Client.prototype.onMessage = function (response) {
            if (this.state === ServiceState.Uninitialized && response.type === ResponseType.Initialize) {
                this.state = ServiceState.Idle;
                this.bufferedRequests.forEach(function (r) { return r.flush && r.flush(); });
                this.bufferedRequests = null;
                return;
            }
            var handler = this.handlers[response.id];
            if (handler) {
                handler(response);
            }
        };
        Client.prototype.send = function (raw) {
            try {
                this.protocol.send(raw);
            }
            catch (err) {
            }
        };
        return Client;
    }());
    exports.Client = Client;
    /**
     * Useful when the service itself is needed right away but the client
     * is wrapped within a promise.
     */
    function getService(clientPromise, serviceName, serviceCtor) {
        var _servicePromise;
        var servicePromise = function () {
            if (!_servicePromise) {
                _servicePromise = clientPromise.then(function (client) { return client.getService(serviceName, serviceCtor); });
            }
            return _servicePromise;
        };
        return Object.keys(serviceCtor.prototype)
            .filter(function (key) { return key !== 'constructor'; })
            .reduce(function (result, key) {
            if (isServiceEvent(serviceCtor.prototype[key])) {
                var promise_2;
                var disposable_2;
                var emitter_2 = new event_1.Emitter({
                    onFirstListenerAdd: function () {
                        promise_2 = servicePromise().then(function (service) {
                            disposable_2 = service[key](function (e) { return emitter_2.fire(e); });
                        });
                    },
                    onLastListenerRemove: function () {
                        if (disposable_2) {
                            disposable_2.dispose();
                            disposable_2 = null;
                        }
                        promise_2.cancel();
                        promise_2 = null;
                    }
                });
                return objects_1.assign(result, (_a = {}, _a[key] = emitter_2.event, _a));
            }
            return objects_1.assign(result, (_b = {},
                _b[key] = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i - 0] = arguments[_i];
                    }
                    return servicePromise().then(function (service) { return service[key].apply(service, args); });
                },
                _b
            ));
            var _a, _b;
        }, {});
    }
    exports.getService = getService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/base/node/pfs", ["require", "exports", 'vs/base/common/winjs.base', 'vs/base/node/extfs', 'vs/base/common/paths', 'path', 'vs/base/common/async', 'fs'], function (require, exports, winjs_base_1, extfs, paths, path_1, async_1, fs) {
    'use strict';
    function isRoot(path) {
        return path === path_1.dirname(path);
    }
    exports.isRoot = isRoot;
    function readdir(path) {
        return async_1.nfcall(extfs.readdir, path);
    }
    exports.readdir = readdir;
    function exists(path) {
        return new winjs_base_1.Promise(function (c) { return fs.exists(path, c); });
    }
    exports.exists = exists;
    function chmod(path, mode) {
        return async_1.nfcall(fs.chmod, path, mode);
    }
    exports.chmod = chmod;
    function mkdirp(path, mode) {
        var mkdir = function () { return async_1.nfcall(fs.mkdir, path, mode)
            .then(null, function (err) {
            if (err.code === 'EEXIST') {
                return async_1.nfcall(fs.stat, path)
                    .then(function (stat) { return stat.isDirectory
                    ? null
                    : winjs_base_1.Promise.wrapError(new Error("'" + path + "' exists and is not a directory.")); });
            }
            return winjs_base_1.TPromise.wrapError(err);
        }); };
        if (isRoot(path)) {
            return winjs_base_1.TPromise.as(true);
        }
        return mkdir().then(null, function (err) {
            if (err.code === 'ENOENT') {
                return mkdirp(path_1.dirname(path), mode).then(mkdir);
            }
            return winjs_base_1.TPromise.wrapError(err);
        });
    }
    exports.mkdirp = mkdirp;
    function rimraf(path) {
        return stat(path).then(function (stat) {
            if (stat.isDirectory()) {
                return readdir(path)
                    .then(function (children) { return winjs_base_1.TPromise.join(children.map(function (child) { return rimraf(path_1.join(path, child)); })); })
                    .then(function () { return rmdir(path); });
            }
            else {
                return unlink(path);
            }
        }, function (err) {
            if (err.code === 'ENOENT') {
                return;
            }
            return winjs_base_1.TPromise.wrapError(err);
        });
    }
    exports.rimraf = rimraf;
    function realpath(path) {
        return async_1.nfcall(fs.realpath, path, null);
    }
    exports.realpath = realpath;
    function stat(path) {
        return async_1.nfcall(fs.stat, path);
    }
    exports.stat = stat;
    function lstat(path) {
        return async_1.nfcall(fs.lstat, path);
    }
    exports.lstat = lstat;
    function mstat(paths) {
        return doStatMultiple(paths.slice(0));
    }
    exports.mstat = mstat;
    function rename(oldPath, newPath) {
        return async_1.nfcall(fs.rename, oldPath, newPath);
    }
    exports.rename = rename;
    function rmdir(path) {
        return async_1.nfcall(fs.rmdir, path);
    }
    exports.rmdir = rmdir;
    function unlink(path) {
        return async_1.nfcall(fs.unlink, path);
    }
    exports.unlink = unlink;
    function symlink(target, path, type) {
        return async_1.nfcall(fs.symlink, target, path, type);
    }
    exports.symlink = symlink;
    function readlink(path) {
        return async_1.nfcall(fs.readlink, path);
    }
    exports.readlink = readlink;
    function doStatMultiple(paths) {
        var path = paths.shift();
        return stat(path).then(function (value) {
            return {
                path: path,
                stats: value
            };
        }, function (err) {
            if (paths.length === 0) {
                return err;
            }
            return mstat(paths);
        });
    }
    function readFile(path, encoding) {
        return async_1.nfcall(fs.readFile, path, encoding);
    }
    exports.readFile = readFile;
    function writeFile(path, data, encoding) {
        if (encoding === void 0) { encoding = 'utf8'; }
        return async_1.nfcall(fs.writeFile, path, data, encoding);
    }
    exports.writeFile = writeFile;
    /**
    * Read a dir and return only subfolders
    */
    function readDirsInDir(dirPath) {
        return readdir(dirPath).then(function (children) {
            return winjs_base_1.TPromise.join(children.map(function (child) { return dirExistsWithResult(paths.join(dirPath, child), child); })).then(function (subdirs) {
                return removeNull(subdirs);
            });
        });
    }
    exports.readDirsInDir = readDirsInDir;
    function dirExistsWithResult(path, successResult) {
        return dirExists(path).then(function (exists) {
            return exists ? successResult : null;
        });
    }
    /**
    * `path` exists and is a directory
    */
    function dirExists(path) {
        return stat(path).then(function (stat) { return stat.isDirectory(); }, function () { return false; });
    }
    exports.dirExists = dirExists;
    /**
    * `path` exists and is a file.
    */
    function fileExists(path) {
        return stat(path).then(function (stat) { return stat.isFile(); }, function () { return false; });
    }
    exports.fileExists = fileExists;
    /**
    * Read dir at `path` and return only files matching `pattern`
    */
    function readFiles(path, pattern) {
        return readdir(path).then(function (children) {
            children = children.filter(function (child) {
                return pattern.test(child);
            });
            var fileChildren = children.map(function (child) {
                return fileExistsWithResult(paths.join(path, child), child);
            });
            return winjs_base_1.TPromise.join(fileChildren).then(function (subdirs) {
                return removeNull(subdirs);
            });
        });
    }
    exports.readFiles = readFiles;
    function fileExistsWithResult(path, successResult) {
        return fileExists(path).then(function (exists) {
            return exists ? successResult : null;
        }, function (err) {
            return winjs_base_1.TPromise.wrapError(err);
        });
    }
    exports.fileExistsWithResult = fileExistsWithResult;
    function removeNull(arr) {
        return arr.filter(function (item) { return (item !== null); });
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/base/node/request", ["require", "exports", 'vs/base/common/winjs.base', 'vs/base/common/types', 'https', 'http', 'url', 'fs', 'vs/base/common/objects'], function (require, exports, winjs_base_1, types_1, https, http, url_1, fs_1, objects_1) {
    'use strict';
    function request(options) {
        var req;
        return new winjs_base_1.TPromise(function (c, e) {
            var endpoint = url_1.parse(options.url);
            var opts = {
                hostname: endpoint.hostname,
                port: endpoint.port ? parseInt(endpoint.port) : (endpoint.protocol === 'https:' ? 443 : 80),
                path: endpoint.path,
                method: options.type || 'GET',
                headers: options.headers,
                agent: options.agent,
                rejectUnauthorized: types_1.isBoolean(options.strictSSL) ? options.strictSSL : true
            };
            if (options.user && options.password) {
                opts.auth = options.user + ':' + options.password;
            }
            var protocol = endpoint.protocol === 'https:' ? https : http;
            req = protocol.request(opts, function (res) {
                if (res.statusCode >= 300 && res.statusCode < 400 && options.followRedirects && options.followRedirects > 0 && res.headers['location']) {
                    c(request(objects_1.assign({}, options, {
                        url: res.headers['location'],
                        followRedirects: options.followRedirects - 1
                    })));
                }
                else {
                    c({ req: req, res: res });
                }
            });
            req.on('error', e);
            if (options.timeout) {
                req.setTimeout(options.timeout);
            }
            if (options.data) {
                req.write(options.data);
            }
            req.end();
        }, function () { return req && req.abort(); });
    }
    exports.request = request;
    function download(filePath, opts) {
        return request(objects_1.assign(opts, { followRedirects: 3 })).then(function (pair) { return new winjs_base_1.TPromise(function (c, e) {
            var out = fs_1.createWriteStream(filePath);
            out.once('finish', function () { return c(null); });
            pair.res.once('error', e);
            pair.res.pipe(out);
        }); });
    }
    exports.download = download;
    function json(opts) {
        return request(opts).then(function (pair) { return new winjs_base_1.Promise(function (c, e) {
            if (!((pair.res.statusCode >= 200 && pair.res.statusCode < 300) || pair.res.statusCode === 1223)) {
                return e('Server returned ' + pair.res.statusCode);
            }
            if (pair.res.statusCode === 204) {
                return c(null);
            }
            if (!/application\/json/.test(pair.res.headers['content-type'])) {
                return e('Response doesn\'t appear to be JSON');
            }
            var buffer = [];
            pair.res.on('data', function (d) { return buffer.push(d); });
            pair.res.on('end', function () { return c(JSON.parse(buffer.join(''))); });
            pair.res.on('error', e);
        }); });
    }
    exports.json = json;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/base/node/service.net", ["require", "exports", 'net', 'vs/base/common/event', 'vs/base/common/service', 'vs/base/common/winjs.base'], function (require, exports, net, event_1, service_1, winjs_base_1) {
    'use strict';
    function bufferIndexOf(buffer, value, start) {
        if (start === void 0) { start = 0; }
        while (start < buffer.length && buffer[start] !== value) {
            start++;
        }
        return start;
    }
    var Protocol = (function () {
        function Protocol(socket) {
            this.socket = socket;
            this.buffer = null;
        }
        Protocol.prototype.send = function (message) {
            this.socket.write(JSON.stringify(message));
            this.socket.write(Protocol.Boundary);
        };
        Protocol.prototype.onMessage = function (callback) {
            var _this = this;
            this.socket.on('data', function (data) {
                var lastIndex = 0;
                var index = 0;
                while ((index = bufferIndexOf(data, 0, lastIndex)) < data.length) {
                    var dataToParse = data.slice(lastIndex, index);
                    if (_this.buffer) {
                        callback(JSON.parse(Buffer.concat([_this.buffer, dataToParse]).toString('utf8')));
                        _this.buffer = null;
                    }
                    else {
                        callback(JSON.parse(dataToParse.toString('utf8')));
                    }
                    lastIndex = index + 1;
                }
                if (index - lastIndex > 0) {
                    var dataToBuffer = data.slice(lastIndex, index);
                    if (_this.buffer) {
                        _this.buffer = Buffer.concat([_this.buffer, dataToBuffer]);
                    }
                    else {
                        _this.buffer = dataToBuffer;
                    }
                }
            });
        };
        Protocol.Boundary = new Buffer([0]);
        return Protocol;
    }());
    var Server = (function () {
        function Server(server) {
            var _this = this;
            this.server = server;
            this.services = Object.create(null);
            this.server.on('connection', function (socket) {
                var ipcServer = new service_1.Server(new Protocol(socket));
                Object.keys(_this.services)
                    .forEach(function (name) { return ipcServer.registerService(name, _this.services[name]); });
                socket.once('close', function () { return ipcServer.dispose(); });
            });
        }
        Server.prototype.registerService = function (serviceName, service) {
            this.services[serviceName] = service;
        };
        Server.prototype.dispose = function () {
            this.services = null;
            this.server.close();
            this.server = null;
        };
        return Server;
    }());
    exports.Server = Server;
    var Client = (function () {
        function Client(socket) {
            var _this = this;
            this.socket = socket;
            this._onClose = new event_1.Emitter();
            this.ipcClient = new service_1.Client(new Protocol(socket));
            socket.once('close', function () { return _this._onClose.fire(); });
        }
        Object.defineProperty(Client.prototype, "onClose", {
            get: function () { return this._onClose.event; },
            enumerable: true,
            configurable: true
        });
        Client.prototype.getService = function (serviceName, serviceCtor) {
            return this.ipcClient.getService(serviceName, serviceCtor);
        };
        Client.prototype.dispose = function () {
            this.socket.end();
            this.socket = null;
            this.ipcClient = null;
        };
        return Client;
    }());
    exports.Client = Client;
    function serve(hook) {
        return new winjs_base_1.TPromise(function (c, e) {
            var server = net.createServer();
            server.on('error', e);
            server.listen(hook, function () {
                server.removeListener('error', e);
                c(new Server(server));
            });
        });
    }
    exports.serve = serve;
    function connect(hook) {
        return new winjs_base_1.TPromise(function (c, e) {
            var socket = net.createConnection(hook, function () {
                socket.removeListener('error', e);
                c(new Client(socket));
            });
            socket.once('error', e);
        });
    }
    exports.connect = connect;
});

define("vs/editor/common/model/tokensBinaryEncoding", ["require", "exports", 'vs/base/common/errors', 'vs/base/common/strings'], function (require, exports, errors_1, strings) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var InflatedToken = (function () {
        function InflatedToken(startIndex, type) {
            this.startIndex = startIndex;
            this.type = type;
        }
        InflatedToken.prototype.toString = function () {
            return '{ ' + this.startIndex + ', \'' + this.type + '\'}';
        };
        return InflatedToken;
    }());
    exports.START_INDEX_MASK = 0xffffffff;
    exports.TYPE_MASK = 0xffff;
    exports.START_INDEX_OFFSET = 1;
    exports.TYPE_OFFSET = Math.pow(2, 32);
    var DEFAULT_TOKEN = {
        startIndex: 0,
        type: ''
    };
    var INFLATED_TOKENS_EMPTY_TEXT = [];
    var DEFLATED_TOKENS_EMPTY_TEXT = [];
    var INFLATED_TOKENS_NON_EMPTY_TEXT = [DEFAULT_TOKEN];
    var DEFLATED_TOKENS_NON_EMPTY_TEXT = [0];
    function deflateArr(map, tokens) {
        if (tokens.length === 0) {
            return DEFLATED_TOKENS_EMPTY_TEXT;
        }
        if (tokens.length === 1 && tokens[0].startIndex === 0 && !tokens[0].type) {
            return DEFLATED_TOKENS_NON_EMPTY_TEXT;
        }
        var i, len, deflatedToken, deflated, token, inflateMap = map._inflate, deflateMap = map._deflate, prevStartIndex = -1, result = new Array(tokens.length);
        for (i = 0, len = tokens.length; i < len; i++) {
            token = tokens[i];
            if (token.startIndex <= prevStartIndex) {
                token.startIndex = prevStartIndex + 1;
                errors_1.onUnexpectedError({
                    message: 'Invalid tokens detected',
                    tokens: tokens
                });
            }
            if (deflateMap.hasOwnProperty(token.type)) {
                deflatedToken = deflateMap[token.type];
            }
            else {
                deflatedToken = inflateMap.length;
                deflateMap[token.type] = deflatedToken;
                inflateMap.push(token.type);
            }
            // http://stackoverflow.com/a/2803010
            // All numbers in JavaScript are actually IEEE-754 compliant floating-point doubles.
            // These have a 53-bit mantissa which should mean that any integer value with a magnitude
            // of approximately 9 quadrillion or less -- more specifically, 9,007,199,254,740,991 --
            // will be represented accurately.
            // http://stackoverflow.com/a/6729252
            // Bitwise operations cast numbers to 32bit representation in JS
            // 32 bits for startIndex => up to 2^32 = 4,294,967,296
            // 16 bits for token => up to 2^16 = 65,536
            // [token][startIndex]
            deflated = deflatedToken * exports.TYPE_OFFSET + token.startIndex * exports.START_INDEX_OFFSET;
            result[i] = deflated;
            prevStartIndex = token.startIndex;
        }
        return result;
    }
    exports.deflateArr = deflateArr;
    function inflate(map, binaryEncodedToken) {
        if (binaryEncodedToken === 0) {
            return DEFAULT_TOKEN;
        }
        var startIndex = (binaryEncodedToken / exports.START_INDEX_OFFSET) & exports.START_INDEX_MASK;
        var deflatedType = (binaryEncodedToken / exports.TYPE_OFFSET) & exports.TYPE_MASK;
        return new InflatedToken(startIndex, map._inflate[deflatedType]);
    }
    exports.inflate = inflate;
    function getStartIndex(binaryEncodedToken) {
        return (binaryEncodedToken / exports.START_INDEX_OFFSET) & exports.START_INDEX_MASK;
    }
    exports.getStartIndex = getStartIndex;
    function getType(map, binaryEncodedToken) {
        var deflatedType = (binaryEncodedToken / exports.TYPE_OFFSET) & exports.TYPE_MASK;
        if (deflatedType === 0) {
            return strings.empty;
        }
        return map._inflate[deflatedType];
    }
    exports.getType = getType;
    function inflateArr(map, binaryEncodedTokens) {
        if (binaryEncodedTokens.length === 0) {
            return INFLATED_TOKENS_EMPTY_TEXT;
        }
        if (binaryEncodedTokens.length === 1 && binaryEncodedTokens[0] === 0) {
            return INFLATED_TOKENS_NON_EMPTY_TEXT;
        }
        var result = new Array(binaryEncodedTokens.length), i, len, deflated, startIndex, deflatedType, inflateMap = map._inflate;
        for (i = 0, len = binaryEncodedTokens.length; i < len; i++) {
            deflated = binaryEncodedTokens[i];
            startIndex = (deflated / exports.START_INDEX_OFFSET) & exports.START_INDEX_MASK;
            deflatedType = (deflated / exports.TYPE_OFFSET) & exports.TYPE_MASK;
            result[i] = new InflatedToken(startIndex, inflateMap[deflatedType]);
        }
        return result;
    }
    exports.inflateArr = inflateArr;
    function findIndexOfOffset(binaryEncodedTokens, offset) {
        return findIndexInSegmentsArray(binaryEncodedTokens, offset);
    }
    exports.findIndexOfOffset = findIndexOfOffset;
    function sliceAndInflate(map, binaryEncodedTokens, startOffset, endOffset, deltaStartIndex) {
        if (binaryEncodedTokens.length === 0) {
            return INFLATED_TOKENS_EMPTY_TEXT;
        }
        if (binaryEncodedTokens.length === 1 && binaryEncodedTokens[0] === 0) {
            return INFLATED_TOKENS_NON_EMPTY_TEXT;
        }
        var startIndex = findIndexInSegmentsArray(binaryEncodedTokens, startOffset), i, len, originalToken, originalStartIndex, newStartIndex, deflatedType, result = [], inflateMap = map._inflate;
        originalToken = binaryEncodedTokens[startIndex];
        deflatedType = (originalToken / exports.TYPE_OFFSET) & exports.TYPE_MASK;
        newStartIndex = 0;
        result.push(new InflatedToken(newStartIndex, inflateMap[deflatedType]));
        for (i = startIndex + 1, len = binaryEncodedTokens.length; i < len; i++) {
            originalToken = binaryEncodedTokens[i];
            originalStartIndex = (originalToken / exports.START_INDEX_OFFSET) & exports.START_INDEX_MASK;
            if (originalStartIndex >= endOffset) {
                break;
            }
            deflatedType = (originalToken / exports.TYPE_OFFSET) & exports.TYPE_MASK;
            newStartIndex = originalStartIndex - startOffset + deltaStartIndex;
            result.push(new InflatedToken(newStartIndex, inflateMap[deflatedType]));
        }
        return result;
    }
    exports.sliceAndInflate = sliceAndInflate;
    function findIndexInSegmentsArray(arr, desiredIndex) {
        var low = 0, high = arr.length - 1, mid, value;
        while (low < high) {
            mid = low + Math.ceil((high - low) / 2);
            value = arr[mid] & 0xffffffff;
            if (value > desiredIndex) {
                high = mid - 1;
            }
            else {
                low = mid;
            }
        }
        return low;
    }
    exports.findIndexInSegmentsArray = findIndexInSegmentsArray;
});

define("vs/editor/common/editorCommon", ["require", "exports", 'vs/editor/common/model/tokensBinaryEncoding'], function (require, exports, TokensBinaryEncoding) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * The direction of a selection.
     */
    (function (SelectionDirection) {
        /**
         * The selection starts above where it ends.
         */
        SelectionDirection[SelectionDirection["LTR"] = 0] = "LTR";
        /**
         * The selection starts below where it ends.
         */
        SelectionDirection[SelectionDirection["RTL"] = 1] = "RTL";
    })(exports.SelectionDirection || (exports.SelectionDirection = {}));
    var SelectionDirection = exports.SelectionDirection;
    (function (WrappingIndent) {
        WrappingIndent[WrappingIndent["None"] = 0] = "None";
        WrappingIndent[WrappingIndent["Same"] = 1] = "Same";
        WrappingIndent[WrappingIndent["Indent"] = 2] = "Indent";
    })(exports.WrappingIndent || (exports.WrappingIndent = {}));
    var WrappingIndent = exports.WrappingIndent;
    function wrappingIndentFromString(wrappingIndent) {
        if (wrappingIndent === 'indent') {
            return WrappingIndent.Indent;
        }
        else if (wrappingIndent === 'same') {
            return WrappingIndent.Same;
        }
        else {
            return WrappingIndent.None;
        }
    }
    exports.wrappingIndentFromString = wrappingIndentFromString;
    /**
     * Vertical Lane in the overview ruler of the editor.
     */
    (function (OverviewRulerLane) {
        OverviewRulerLane[OverviewRulerLane["Left"] = 1] = "Left";
        OverviewRulerLane[OverviewRulerLane["Center"] = 2] = "Center";
        OverviewRulerLane[OverviewRulerLane["Right"] = 4] = "Right";
        OverviewRulerLane[OverviewRulerLane["Full"] = 7] = "Full";
    })(exports.OverviewRulerLane || (exports.OverviewRulerLane = {}));
    var OverviewRulerLane = exports.OverviewRulerLane;
    /**
     * End of line character preference.
     */
    (function (EndOfLinePreference) {
        /**
         * Use the end of line character identified in the text buffer.
         */
        EndOfLinePreference[EndOfLinePreference["TextDefined"] = 0] = "TextDefined";
        /**
         * Use line feed (\n) as the end of line character.
         */
        EndOfLinePreference[EndOfLinePreference["LF"] = 1] = "LF";
        /**
         * Use carriage return and line feed (\r\n) as the end of line character.
         */
        EndOfLinePreference[EndOfLinePreference["CRLF"] = 2] = "CRLF";
    })(exports.EndOfLinePreference || (exports.EndOfLinePreference = {}));
    var EndOfLinePreference = exports.EndOfLinePreference;
    /**
     * The default end of line to use when instantiating models.
     */
    (function (DefaultEndOfLine) {
        /**
         * Use line feed (\n) as the end of line character.
         */
        DefaultEndOfLine[DefaultEndOfLine["LF"] = 1] = "LF";
        /**
         * Use carriage return and line feed (\r\n) as the end of line character.
         */
        DefaultEndOfLine[DefaultEndOfLine["CRLF"] = 2] = "CRLF";
    })(exports.DefaultEndOfLine || (exports.DefaultEndOfLine = {}));
    var DefaultEndOfLine = exports.DefaultEndOfLine;
    /**
     * End of line character preference.
     */
    (function (EndOfLineSequence) {
        /**
         * Use line feed (\n) as the end of line character.
         */
        EndOfLineSequence[EndOfLineSequence["LF"] = 0] = "LF";
        /**
         * Use carriage return and line feed (\r\n) as the end of line character.
         */
        EndOfLineSequence[EndOfLineSequence["CRLF"] = 1] = "CRLF";
    })(exports.EndOfLineSequence || (exports.EndOfLineSequence = {}));
    var EndOfLineSequence = exports.EndOfLineSequence;
    exports.LineTokensBinaryEncoding = TokensBinaryEncoding;
    (function (TrackedRangeStickiness) {
        TrackedRangeStickiness[TrackedRangeStickiness["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
        TrackedRangeStickiness[TrackedRangeStickiness["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
        TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
        TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
    })(exports.TrackedRangeStickiness || (exports.TrackedRangeStickiness = {}));
    var TrackedRangeStickiness = exports.TrackedRangeStickiness;
    (function (VerticalRevealType) {
        VerticalRevealType[VerticalRevealType["Simple"] = 0] = "Simple";
        VerticalRevealType[VerticalRevealType["Center"] = 1] = "Center";
        VerticalRevealType[VerticalRevealType["CenterIfOutsideViewport"] = 2] = "CenterIfOutsideViewport";
    })(exports.VerticalRevealType || (exports.VerticalRevealType = {}));
    var VerticalRevealType = exports.VerticalRevealType;
    /**
     * Type of hit element with the mouse in the editor.
     */
    (function (MouseTargetType) {
        /**
         * Mouse is on top of an unknown element.
         */
        MouseTargetType[MouseTargetType["UNKNOWN"] = 0] = "UNKNOWN";
        /**
         * Mouse is on top of the textarea used for input.
         */
        MouseTargetType[MouseTargetType["TEXTAREA"] = 1] = "TEXTAREA";
        /**
         * Mouse is on top of the glyph margin
         */
        MouseTargetType[MouseTargetType["GUTTER_GLYPH_MARGIN"] = 2] = "GUTTER_GLYPH_MARGIN";
        /**
         * Mouse is on top of the line numbers
         */
        MouseTargetType[MouseTargetType["GUTTER_LINE_NUMBERS"] = 3] = "GUTTER_LINE_NUMBERS";
        /**
         * Mouse is on top of the line decorations
         */
        MouseTargetType[MouseTargetType["GUTTER_LINE_DECORATIONS"] = 4] = "GUTTER_LINE_DECORATIONS";
        /**
         * Mouse is on top of the whitespace left in the gutter by a view zone.
         */
        MouseTargetType[MouseTargetType["GUTTER_VIEW_ZONE"] = 5] = "GUTTER_VIEW_ZONE";
        /**
         * Mouse is on top of text in the content.
         */
        MouseTargetType[MouseTargetType["CONTENT_TEXT"] = 6] = "CONTENT_TEXT";
        /**
         * Mouse is on top of empty space in the content (e.g. after line text or below last line)
         */
        MouseTargetType[MouseTargetType["CONTENT_EMPTY"] = 7] = "CONTENT_EMPTY";
        /**
         * Mouse is on top of a view zone in the content.
         */
        MouseTargetType[MouseTargetType["CONTENT_VIEW_ZONE"] = 8] = "CONTENT_VIEW_ZONE";
        /**
         * Mouse is on top of a content widget.
         */
        MouseTargetType[MouseTargetType["CONTENT_WIDGET"] = 9] = "CONTENT_WIDGET";
        /**
         * Mouse is on top of the decorations overview ruler.
         */
        MouseTargetType[MouseTargetType["OVERVIEW_RULER"] = 10] = "OVERVIEW_RULER";
        /**
         * Mouse is on top of a scrollbar.
         */
        MouseTargetType[MouseTargetType["SCROLLBAR"] = 11] = "SCROLLBAR";
        /**
         * Mouse is on top of an overlay widget.
         */
        MouseTargetType[MouseTargetType["OVERLAY_WIDGET"] = 12] = "OVERLAY_WIDGET";
    })(exports.MouseTargetType || (exports.MouseTargetType = {}));
    var MouseTargetType = exports.MouseTargetType;
    exports.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS = 'editorTextFocus';
    exports.KEYBINDING_CONTEXT_EDITOR_FOCUS = 'editorFocus';
    exports.KEYBINDING_CONTEXT_EDITOR_TAB_MOVES_FOCUS = 'editorTabMovesFocus';
    exports.KEYBINDING_CONTEXT_EDITOR_HAS_MULTIPLE_SELECTIONS = 'editorHasMultipleSelections';
    exports.KEYBINDING_CONTEXT_EDITOR_HAS_NON_EMPTY_SELECTION = 'editorHasSelection';
    exports.KEYBINDING_CONTEXT_EDITOR_LANGUAGE_ID = 'editorLangId';
    exports.SHOW_ACCESSIBILITY_HELP_ACTION_ID = 'editor.action.showAccessibilityHelp';
    exports.ViewEventNames = {
        ModelFlushedEvent: 'modelFlushedEvent',
        LinesDeletedEvent: 'linesDeletedEvent',
        LinesInsertedEvent: 'linesInsertedEvent',
        LineChangedEvent: 'lineChangedEvent',
        TokensChangedEvent: 'tokensChangedEvent',
        DecorationsChangedEvent: 'decorationsChangedEvent',
        CursorPositionChangedEvent: 'cursorPositionChangedEvent',
        CursorSelectionChangedEvent: 'cursorSelectionChangedEvent',
        RevealRangeEvent: 'revealRangeEvent',
        LineMappingChangedEvent: 'lineMappingChangedEvent',
        ScrollRequestEvent: 'scrollRequestEvent'
    };
    (function (CodeEditorStateFlag) {
        CodeEditorStateFlag[CodeEditorStateFlag["Value"] = 0] = "Value";
        CodeEditorStateFlag[CodeEditorStateFlag["Selection"] = 1] = "Selection";
        CodeEditorStateFlag[CodeEditorStateFlag["Position"] = 2] = "Position";
        CodeEditorStateFlag[CodeEditorStateFlag["Scroll"] = 3] = "Scroll";
    })(exports.CodeEditorStateFlag || (exports.CodeEditorStateFlag = {}));
    var CodeEditorStateFlag = exports.CodeEditorStateFlag;
    exports.EditorType = {
        ICodeEditor: 'vs.editor.ICodeEditor',
        IDiffEditor: 'vs.editor.IDiffEditor'
    };
    exports.ClassName = {
        EditorWarningDecoration: 'greensquiggly',
        EditorErrorDecoration: 'redsquiggly'
    };
    exports.EventType = {
        Disposed: 'disposed',
        ConfigurationChanged: 'configurationChanged',
        ModelDispose: 'modelDispose',
        ModelChanged: 'modelChanged',
        ModelTokensChanged: 'modelTokensChanged',
        ModelModeChanged: 'modelsModeChanged',
        ModelModeSupportChanged: 'modelsModeSupportChanged',
        ModelOptionsChanged: 'modelOptionsChanged',
        ModelContentChanged: 'contentChanged',
        ModelContentChanged2: 'contentChanged2',
        ModelContentChangedFlush: 'flush',
        ModelContentChangedLinesDeleted: 'linesDeleted',
        ModelContentChangedLinesInserted: 'linesInserted',
        ModelContentChangedLineChanged: 'lineChanged',
        EditorTextBlur: 'blur',
        EditorTextFocus: 'focus',
        EditorFocus: 'widgetFocus',
        EditorBlur: 'widgetBlur',
        ModelDecorationsChanged: 'decorationsChanged',
        CursorPositionChanged: 'positionChanged',
        CursorSelectionChanged: 'selectionChanged',
        CursorRevealRange: 'revealRange',
        CursorScrollRequest: 'scrollRequest',
        ViewFocusGained: 'focusGained',
        ViewFocusLost: 'focusLost',
        ViewFocusChanged: 'focusChanged',
        ViewScrollWidthChanged: 'scrollWidthChanged',
        ViewScrollHeightChanged: 'scrollHeightChanged',
        ViewScrollChanged: 'scrollChanged',
        ViewZonesChanged: 'zonesChanged',
        ViewLayoutChanged: 'viewLayoutChanged',
        ContextMenu: 'contextMenu',
        MouseDown: 'mousedown',
        MouseUp: 'mouseup',
        MouseMove: 'mousemove',
        MouseLeave: 'mouseleave',
        KeyDown: 'keydown',
        KeyUp: 'keyup',
        EditorLayout: 'editorLayout',
        DiffUpdated: 'diffUpdated'
    };
    exports.Handler = {
        ExecuteCommand: 'executeCommand',
        ExecuteCommands: 'executeCommands',
        CursorLeft: 'cursorLeft',
        CursorLeftSelect: 'cursorLeftSelect',
        CursorWordLeft: 'cursorWordLeft',
        CursorWordStartLeft: 'cursorWordStartLeft',
        CursorWordEndLeft: 'cursorWordEndLeft',
        CursorWordLeftSelect: 'cursorWordLeftSelect',
        CursorWordStartLeftSelect: 'cursorWordStartLeftSelect',
        CursorWordEndLeftSelect: 'cursorWordEndLeftSelect',
        CursorRight: 'cursorRight',
        CursorRightSelect: 'cursorRightSelect',
        CursorWordRight: 'cursorWordRight',
        CursorWordStartRight: 'cursorWordStartRight',
        CursorWordEndRight: 'cursorWordEndRight',
        CursorWordRightSelect: 'cursorWordRightSelect',
        CursorWordStartRightSelect: 'cursorWordStartRightSelect',
        CursorWordEndRightSelect: 'cursorWordEndRightSelect',
        CursorUp: 'cursorUp',
        CursorUpSelect: 'cursorUpSelect',
        CursorDown: 'cursorDown',
        CursorDownSelect: 'cursorDownSelect',
        CursorPageUp: 'cursorPageUp',
        CursorPageUpSelect: 'cursorPageUpSelect',
        CursorPageDown: 'cursorPageDown',
        CursorPageDownSelect: 'cursorPageDownSelect',
        CursorHome: 'cursorHome',
        CursorHomeSelect: 'cursorHomeSelect',
        CursorEnd: 'cursorEnd',
        CursorEndSelect: 'cursorEndSelect',
        ExpandLineSelection: 'expandLineSelection',
        CursorTop: 'cursorTop',
        CursorTopSelect: 'cursorTopSelect',
        CursorBottom: 'cursorBottom',
        CursorBottomSelect: 'cursorBottomSelect',
        CursorColumnSelectLeft: 'cursorColumnSelectLeft',
        CursorColumnSelectRight: 'cursorColumnSelectRight',
        CursorColumnSelectUp: 'cursorColumnSelectUp',
        CursorColumnSelectPageUp: 'cursorColumnSelectPageUp',
        CursorColumnSelectDown: 'cursorColumnSelectDown',
        CursorColumnSelectPageDown: 'cursorColumnSelectPageDown',
        AddCursorDown: 'addCursorDown',
        AddCursorUp: 'addCursorUp',
        CursorUndo: 'cursorUndo',
        MoveTo: 'moveTo',
        MoveToSelect: 'moveToSelect',
        ColumnSelect: 'columnSelect',
        CreateCursor: 'createCursor',
        LastCursorMoveToSelect: 'lastCursorMoveToSelect',
        JumpToBracket: 'jumpToBracket',
        Type: 'type',
        ReplacePreviousChar: 'replacePreviousChar',
        Paste: 'paste',
        Tab: 'tab',
        Indent: 'indent',
        Outdent: 'outdent',
        DeleteLeft: 'deleteLeft',
        DeleteRight: 'deleteRight',
        DeleteWordLeft: 'deleteWordLeft',
        DeleteWordStartLeft: 'deleteWordStartLeft',
        DeleteWordEndLeft: 'deleteWordEndLeft',
        DeleteWordRight: 'deleteWordRight',
        DeleteWordStartRight: 'deleteWordStartRight',
        DeleteWordEndRight: 'deleteWordEndRight',
        DeleteAllLeft: 'deleteAllLeft',
        DeleteAllRight: 'deleteAllRight',
        Enter: 'enter',
        RemoveSecondaryCursors: 'removeSecondaryCursors',
        CancelSelection: 'cancelSelection',
        Cut: 'cut',
        Undo: 'undo',
        Redo: 'redo',
        WordSelect: 'wordSelect',
        WordSelectDrag: 'wordSelectDrag',
        LastCursorWordSelect: 'lastCursorWordSelect',
        LineSelect: 'lineSelect',
        LineSelectDrag: 'lineSelectDrag',
        LastCursorLineSelect: 'lastCursorLineSelect',
        LastCursorLineSelectDrag: 'lastCursorLineSelectDrag',
        LineInsertBefore: 'lineInsertBefore',
        LineInsertAfter: 'lineInsertAfter',
        LineBreakInsert: 'lineBreakInsert',
        SelectAll: 'selectAll',
        ScrollLineUp: 'scrollLineUp',
        ScrollLineDown: 'scrollLineDown',
        ScrollPageUp: 'scrollPageUp',
        ScrollPageDown: 'scrollPageDown'
    };
    var VisibleRange = (function () {
        function VisibleRange(top, left, width) {
            this.top = top;
            this.left = left;
            this.width = width;
        }
        return VisibleRange;
    }());
    exports.VisibleRange = VisibleRange;
    (function (TextEditorCursorStyle) {
        TextEditorCursorStyle[TextEditorCursorStyle["Line"] = 1] = "Line";
        TextEditorCursorStyle[TextEditorCursorStyle["Block"] = 2] = "Block";
        TextEditorCursorStyle[TextEditorCursorStyle["Underline"] = 3] = "Underline";
    })(exports.TextEditorCursorStyle || (exports.TextEditorCursorStyle = {}));
    var TextEditorCursorStyle = exports.TextEditorCursorStyle;
    function cursorStyleFromString(cursorStyle) {
        if (cursorStyle === 'line') {
            return TextEditorCursorStyle.Line;
        }
        else if (cursorStyle === 'block') {
            return TextEditorCursorStyle.Block;
        }
        else if (cursorStyle === 'underline') {
            return TextEditorCursorStyle.Underline;
        }
        return TextEditorCursorStyle.Line;
    }
    exports.cursorStyleFromString = cursorStyleFromString;
    function cursorStyleToString(cursorStyle) {
        if (cursorStyle === TextEditorCursorStyle.Line) {
            return 'line';
        }
        else if (cursorStyle === TextEditorCursorStyle.Block) {
            return 'block';
        }
        else if (cursorStyle === TextEditorCursorStyle.Underline) {
            return 'underline';
        }
        else {
            throw new Error('cursorStyleToString: Unknown cursorStyle');
        }
    }
    exports.cursorStyleToString = cursorStyleToString;
    var HorizontalRange = (function () {
        function HorizontalRange(left, width) {
            this.left = left;
            this.width = width;
        }
        return HorizontalRange;
    }());
    exports.HorizontalRange = HorizontalRange;
    var LineVisibleRanges = (function () {
        function LineVisibleRanges(lineNumber, ranges) {
            this.lineNumber = lineNumber;
            this.ranges = ranges;
        }
        return LineVisibleRanges;
    }());
    exports.LineVisibleRanges = LineVisibleRanges;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("vs/editor/common/core/selection", ["require", "exports", 'vs/editor/common/core/range', 'vs/editor/common/editorCommon'], function (require, exports, range_1, editorCommon_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Selection = (function (_super) {
        __extends(Selection, _super);
        function Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {
            _super.call(this, selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);
            this.selectionStartLineNumber = selectionStartLineNumber;
            this.selectionStartColumn = selectionStartColumn;
            this.positionLineNumber = positionLineNumber;
            this.positionColumn = positionColumn;
        }
        Selection.prototype.clone = function () {
            return new Selection(this.selectionStartLineNumber, this.selectionStartColumn, this.positionLineNumber, this.positionColumn);
        };
        Selection.prototype.toString = function () {
            return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';
        };
        Selection.prototype.equalsSelection = function (other) {
            return (Selection.selectionsEqual(this, other));
        };
        Selection.prototype.getDirection = function () {
            if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {
                return editorCommon_1.SelectionDirection.LTR;
            }
            return editorCommon_1.SelectionDirection.RTL;
        };
        Selection.prototype.setEndPosition = function (endLineNumber, endColumn) {
            if (this.getDirection() === editorCommon_1.SelectionDirection.LTR) {
                return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
            }
            return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);
        };
        Selection.prototype.setStartPosition = function (startLineNumber, startColumn) {
            if (this.getDirection() === editorCommon_1.SelectionDirection.LTR) {
                return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
            }
            return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);
        };
        // ----
        Selection.createSelection = function (selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {
            return new Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);
        };
        Selection.liftSelection = function (sel) {
            return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
        };
        Selection.selectionsEqual = function (a, b) {
            return (a.selectionStartLineNumber === b.selectionStartLineNumber &&
                a.selectionStartColumn === b.selectionStartColumn &&
                a.positionLineNumber === b.positionLineNumber &&
                a.positionColumn === b.positionColumn);
        };
        Selection.selectionsArrEqual = function (a, b) {
            if (a && !b || !a && b) {
                return false;
            }
            if (!a && !b) {
                return true;
            }
            if (a.length !== b.length) {
                return false;
            }
            for (var i = 0, len = a.length; i < len; i++) {
                if (!this.selectionsEqual(a[i], b[i])) {
                    return false;
                }
            }
            return true;
        };
        Selection.isISelection = function (obj) {
            return (obj
                && (typeof obj.selectionStartLineNumber === 'number')
                && (typeof obj.selectionStartColumn === 'number')
                && (typeof obj.positionLineNumber === 'number')
                && (typeof obj.positionColumn === 'number'));
        };
        Selection.createWithDirection = function (startLineNumber, startColumn, endLineNumber, endColumn, direction) {
            if (direction === editorCommon_1.SelectionDirection.LTR) {
                return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);
            }
            return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);
        };
        return Selection;
    }(range_1.Range));
    exports.Selection = Selection;
});

define("vs/editor/common/model/modelLine", ["require", "exports", 'vs/base/common/strings', 'vs/editor/common/editorCommon'], function (require, exports, strings, editorCommon_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var NO_OP_TOKENS_ADJUSTER = {
        adjust: function () { },
        finish: function () { }
    };
    var NO_OP_MARKERS_ADJUSTER = {
        adjustDelta: function () { },
        adjustSet: function () { },
        finish: function () { }
    };
    var MarkerMoveSemantics;
    (function (MarkerMoveSemantics) {
        MarkerMoveSemantics[MarkerMoveSemantics["MarkerDefined"] = 0] = "MarkerDefined";
        MarkerMoveSemantics[MarkerMoveSemantics["ForceMove"] = 1] = "ForceMove";
        MarkerMoveSemantics[MarkerMoveSemantics["ForceStay"] = 2] = "ForceStay";
    })(MarkerMoveSemantics || (MarkerMoveSemantics = {}));
    var ModelLine = (function () {
        function ModelLine(lineNumber, text) {
            this.lineNumber = lineNumber;
            this.text = text;
            this.isInvalid = false;
        }
        // --- BEGIN STATE
        ModelLine.prototype.setState = function (state) {
            this._state = state;
        };
        ModelLine.prototype.getState = function () {
            return this._state || null;
        };
        // --- END STATE
        // --- BEGIN MODE TRANSITIONS
        ModelLine.prototype._setModeTransitions = function (topLevelMode, modeTransitions) {
            var desired = toModeTransitions(topLevelMode, modeTransitions);
            if (desired === null) {
                // saving memory
                if (typeof this._modeTransitions === 'undefined') {
                    return;
                }
                this._modeTransitions = null;
                return;
            }
            this._modeTransitions = desired;
        };
        ModelLine.prototype.getModeTransitions = function () {
            if (this._modeTransitions) {
                return this._modeTransitions;
            }
            return DefaultModeTransitions.INSTANCE;
        };
        // --- END MODE TRANSITIONS
        // --- BEGIN TOKENS
        ModelLine.prototype.setTokens = function (map, tokens, topLevelMode, modeTransitions) {
            this._setLineTokens(map, tokens);
            this._setModeTransitions(topLevelMode, modeTransitions);
        };
        ModelLine.prototype._setLineTokens = function (map, tokens) {
            var desired = toLineTokens(map, tokens, this.text.length);
            if (desired === null) {
                // saving memory
                if (typeof this._lineTokens === 'undefined') {
                    return;
                }
                this._lineTokens = null;
                return;
            }
            this._lineTokens = desired;
        };
        ModelLine.prototype.getTokens = function () {
            if (this._lineTokens) {
                return this._lineTokens;
            }
            if (this.text.length === 0) {
                return EmptyLineTokens.INSTANCE;
            }
            return DefaultLineTokens.INSTANCE;
        };
        // --- END TOKENS
        ModelLine.prototype._createTokensAdjuster = function () {
            if (!this._lineTokens) {
                // This line does not have real tokens, so there is nothing to adjust
                return NO_OP_TOKENS_ADJUSTER;
            }
            var lineTokens = this._lineTokens;
            var BIN = editorCommon_1.LineTokensBinaryEncoding;
            var tokens = lineTokens.getBinaryEncodedTokens();
            var tokensLength = tokens.length;
            var tokensIndex = 0;
            var currentTokenStartIndex = 0;
            var adjust = function (toColumn, delta, minimumAllowedColumn) {
                // console.log('before call: tokensIndex: ' + tokensIndex + ': ' + String(this.getTokens()));
                // console.log('adjustTokens: ' + toColumn + ' with delta: ' + delta + ' and [' + minimumAllowedColumn + ']');
                // console.log('currentTokenStartIndex: ' + currentTokenStartIndex);
                var minimumAllowedIndex = minimumAllowedColumn - 1;
                while (currentTokenStartIndex < toColumn && tokensIndex < tokensLength) {
                    if (currentTokenStartIndex > 0 && delta !== 0) {
                        // adjust token's `startIndex` by `delta`
                        var deflatedType = (tokens[tokensIndex] / BIN.TYPE_OFFSET) & BIN.TYPE_MASK;
                        var newStartIndex = Math.max(minimumAllowedIndex, currentTokenStartIndex + delta);
                        var newToken = deflatedType * BIN.TYPE_OFFSET + newStartIndex * BIN.START_INDEX_OFFSET;
                        if (delta < 0) {
                            // pop all previous tokens that have become `collapsed`
                            while (tokensIndex > 0) {
                                var prevTokenStartIndex = (tokens[tokensIndex - 1] / BIN.START_INDEX_OFFSET) & BIN.START_INDEX_MASK;
                                if (prevTokenStartIndex >= newStartIndex) {
                                    // Token at `tokensIndex` - 1 is now `collapsed` => pop it
                                    tokens.splice(tokensIndex - 1, 1);
                                    tokensLength--;
                                    tokensIndex--;
                                }
                                else {
                                    break;
                                }
                            }
                        }
                        tokens[tokensIndex] = newToken;
                    }
                    tokensIndex++;
                    if (tokensIndex < tokensLength) {
                        currentTokenStartIndex = (tokens[tokensIndex] / BIN.START_INDEX_OFFSET) & BIN.START_INDEX_MASK;
                    }
                }
                // console.log('after call: tokensIndex: ' + tokensIndex + ': ' + String(this.getTokens()));
            };
            var finish = function (delta, lineTextLength) {
                adjust(Number.MAX_VALUE, delta, 1);
            };
            return {
                adjust: adjust,
                finish: finish
            };
        };
        ModelLine.prototype._setText = function (text) {
            this.text = text;
            if (this._lineTokens) {
                var BIN = editorCommon_1.LineTokensBinaryEncoding, map = this._lineTokens.getBinaryEncodedTokensMap(), tokens = this._lineTokens.getBinaryEncodedTokens(), lineTextLength = this.text.length;
                // Remove overflowing tokens
                while (tokens.length > 0) {
                    var lastTokenStartIndex = (tokens[tokens.length - 1] / BIN.START_INDEX_OFFSET) & BIN.START_INDEX_MASK;
                    if (lastTokenStartIndex < lineTextLength) {
                        // Valid token
                        break;
                    }
                    // This token now overflows the text => remove it
                    tokens.pop();
                }
                this._setLineTokens(map, tokens);
            }
        };
        // private _printMarkers(): string {
        // 	if (!this._markers) {
        // 		return '[]';
        // 	}
        // 	if (this._markers.length === 0) {
        // 		return '[]';
        // 	}
        // 	var markers = this._markers;
        // 	var printMarker = (m:ILineMarker) => {
        // 		if (m.stickToPreviousCharacter) {
        // 			return '|' + m.column;
        // 		}
        // 		return m.column + '|';
        // 	};
        // 	return '[' + markers.map(printMarker).join(', ') + ']';
        // }
        ModelLine.prototype._createMarkersAdjuster = function (changedMarkers) {
            var _this = this;
            if (!this._markers) {
                return NO_OP_MARKERS_ADJUSTER;
            }
            if (this._markers.length === 0) {
                return NO_OP_MARKERS_ADJUSTER;
            }
            this._markers.sort(ModelLine._compareMarkers);
            var markers = this._markers;
            var markersLength = markers.length;
            var markersIndex = 0;
            var marker = markers[markersIndex];
            // console.log('------------- INITIAL MARKERS: ' + this._printMarkers());
            var adjustMarkerBeforeColumn = function (toColumn, moveSemantics) {
                if (marker.column < toColumn) {
                    return true;
                }
                if (marker.column > toColumn) {
                    return false;
                }
                if (moveSemantics === MarkerMoveSemantics.ForceMove) {
                    return false;
                }
                if (moveSemantics === MarkerMoveSemantics.ForceStay) {
                    return true;
                }
                return marker.stickToPreviousCharacter;
            };
            var adjustDelta = function (toColumn, delta, minimumAllowedColumn, moveSemantics) {
                // console.log('------------------------------');
                // console.log('adjustDelta called: toColumn: ' + toColumn + ', delta: ' + delta + ', minimumAllowedColumn: ' + minimumAllowedColumn + ', moveSemantics: ' + MarkerMoveSemantics[moveSemantics]);
                // console.log('BEFORE::: markersIndex: ' + markersIndex + ' : ' + this._printMarkers());
                while (markersIndex < markersLength && adjustMarkerBeforeColumn(toColumn, moveSemantics)) {
                    if (delta !== 0) {
                        var newColumn = Math.max(minimumAllowedColumn, marker.column + delta);
                        if (marker.column !== newColumn) {
                            changedMarkers[marker.id] = true;
                            marker.oldLineNumber = marker.oldLineNumber || _this.lineNumber;
                            marker.oldColumn = marker.oldColumn || marker.column;
                            marker.column = newColumn;
                        }
                    }
                    markersIndex++;
                    if (markersIndex < markersLength) {
                        marker = markers[markersIndex];
                    }
                }
                // console.log('AFTER::: markersIndex: ' + markersIndex + ' : ' + this._printMarkers());
            };
            var adjustSet = function (toColumn, newColumn, moveSemantics) {
                // console.log('------------------------------');
                // console.log('adjustSet called: toColumn: ' + toColumn + ', newColumn: ' + newColumn + ', moveSemantics: ' + MarkerMoveSemantics[moveSemantics]);
                // console.log('BEFORE::: markersIndex: ' + markersIndex + ' : ' + this._printMarkers());
                while (markersIndex < markersLength && adjustMarkerBeforeColumn(toColumn, moveSemantics)) {
                    if (marker.column !== newColumn) {
                        changedMarkers[marker.id] = true;
                        marker.oldLineNumber = marker.oldLineNumber || _this.lineNumber;
                        marker.oldColumn = marker.oldColumn || marker.column;
                        marker.column = newColumn;
                    }
                    markersIndex++;
                    if (markersIndex < markersLength) {
                        marker = markers[markersIndex];
                    }
                }
                // console.log('AFTER::: markersIndex: ' + markersIndex + ' : ' + this._printMarkers());
            };
            var finish = function (delta, lineTextLength) {
                adjustDelta(Number.MAX_VALUE, delta, 1, MarkerMoveSemantics.MarkerDefined);
                // console.log('------------- FINAL MARKERS: ' + this._printMarkers());
            };
            return {
                adjustDelta: adjustDelta,
                adjustSet: adjustSet,
                finish: finish
            };
        };
        ModelLine.prototype.applyEdits = function (changedMarkers, edits) {
            var deltaColumn = 0;
            var resultText = this.text;
            var tokensAdjuster = this._createTokensAdjuster();
            var markersAdjuster = this._createMarkersAdjuster(changedMarkers);
            for (var i = 0, len = edits.length; i < len; i++) {
                var edit = edits[i];
                // console.log();
                // console.log('=============================');
                // console.log('EDIT #' + i + ' [ ' + edit.startColumn + ' -> ' + edit.endColumn + ' ] : <<<' + edit.text + '>>>, forceMoveMarkers: ' + edit.forceMoveMarkers);
                // console.log('deltaColumn: ' + deltaColumn);
                var startColumn = deltaColumn + edit.startColumn;
                var endColumn = deltaColumn + edit.endColumn;
                var deletingCnt = endColumn - startColumn;
                var insertingCnt = edit.text.length;
                // Adjust tokens & markers before this edit
                // console.log('Adjust tokens & markers before this edit');
                tokensAdjuster.adjust(edit.startColumn - 1, deltaColumn, 1);
                markersAdjuster.adjustDelta(edit.startColumn, deltaColumn, 1, edit.forceMoveMarkers ? MarkerMoveSemantics.ForceMove : (deletingCnt > 0 ? MarkerMoveSemantics.ForceStay : MarkerMoveSemantics.MarkerDefined));
                // Adjust tokens & markers for the common part of this edit
                var commonLength = Math.min(deletingCnt, insertingCnt);
                if (commonLength > 0) {
                    // console.log('Adjust tokens & markers for the common part of this edit');
                    tokensAdjuster.adjust(edit.startColumn - 1 + commonLength, deltaColumn, startColumn);
                    if (!edit.forceMoveMarkers) {
                        markersAdjuster.adjustDelta(edit.startColumn + commonLength, deltaColumn, startColumn, edit.forceMoveMarkers ? MarkerMoveSemantics.ForceMove : (deletingCnt > insertingCnt ? MarkerMoveSemantics.ForceStay : MarkerMoveSemantics.MarkerDefined));
                    }
                }
                // Perform the edit & update `deltaColumn`
                resultText = resultText.substring(0, startColumn - 1) + edit.text + resultText.substring(endColumn - 1);
                deltaColumn += insertingCnt - deletingCnt;
                // Adjust tokens & markers inside this edit
                // console.log('Adjust tokens & markers inside this edit');
                tokensAdjuster.adjust(edit.endColumn, deltaColumn, startColumn);
                markersAdjuster.adjustSet(edit.endColumn, startColumn + insertingCnt, edit.forceMoveMarkers ? MarkerMoveSemantics.ForceMove : MarkerMoveSemantics.MarkerDefined);
            }
            // Wrap up tokens & markers; adjust remaining if needed
            tokensAdjuster.finish(deltaColumn, resultText.length);
            markersAdjuster.finish(deltaColumn, resultText.length);
            // Save the resulting text
            this._setText(resultText);
            return deltaColumn;
        };
        ModelLine.prototype.split = function (changedMarkers, splitColumn, forceMoveMarkers) {
            // console.log('--> split @ ' + splitColumn + '::: ' + this._printMarkers());
            var myText = this.text.substring(0, splitColumn - 1);
            var otherText = this.text.substring(splitColumn - 1);
            var otherMarkers = null;
            if (this._markers) {
                this._markers.sort(ModelLine._compareMarkers);
                for (var i = 0, len = this._markers.length; i < len; i++) {
                    var marker = this._markers[i];
                    if (marker.column > splitColumn
                        || (marker.column === splitColumn
                            && (forceMoveMarkers
                                || !marker.stickToPreviousCharacter))) {
                        var myMarkers = this._markers.slice(0, i);
                        otherMarkers = this._markers.slice(i);
                        this._markers = myMarkers;
                        break;
                    }
                }
                if (otherMarkers) {
                    for (var i = 0, len = otherMarkers.length; i < len; i++) {
                        var marker = otherMarkers[i];
                        changedMarkers[marker.id] = true;
                        marker.oldLineNumber = marker.oldLineNumber || this.lineNumber;
                        marker.oldColumn = marker.oldColumn || marker.column;
                        marker.column -= splitColumn - 1;
                    }
                }
            }
            this._setText(myText);
            var otherLine = new ModelLine(this.lineNumber + 1, otherText);
            if (otherMarkers) {
                otherLine.addMarkers(otherMarkers);
            }
            return otherLine;
        };
        ModelLine.prototype.append = function (changedMarkers, other) {
            // console.log('--> append: THIS :: ' + this._printMarkers());
            // console.log('--> append: OTHER :: ' + this._printMarkers());
            var thisTextLength = this.text.length;
            this._setText(this.text + other.text);
            var otherLineTokens = other._lineTokens;
            if (otherLineTokens) {
                // Other has real tokens
                var otherTokens = otherLineTokens.getBinaryEncodedTokens();
                // Adjust other tokens
                if (thisTextLength > 0) {
                    var BIN = editorCommon_1.LineTokensBinaryEncoding;
                    for (var i = 0, len = otherTokens.length; i < len; i++) {
                        var token = otherTokens[i];
                        var deflatedStartIndex = (token / BIN.START_INDEX_OFFSET) & BIN.START_INDEX_MASK;
                        var deflatedType = (token / BIN.TYPE_OFFSET) & BIN.TYPE_MASK;
                        var newStartIndex = deflatedStartIndex + thisTextLength;
                        var newToken = deflatedType * BIN.TYPE_OFFSET + newStartIndex * BIN.START_INDEX_OFFSET;
                        otherTokens[i] = newToken;
                    }
                }
                // Append other tokens
                var myLineTokens = this._lineTokens;
                if (myLineTokens) {
                    // I have real tokens
                    this._setLineTokens(myLineTokens.getBinaryEncodedTokensMap(), myLineTokens.getBinaryEncodedTokens().concat(otherTokens));
                }
                else {
                    // I don't have real tokens
                    this._setLineTokens(otherLineTokens.getBinaryEncodedTokensMap(), otherTokens);
                }
            }
            if (other._markers) {
                // Other has markers
                var otherMarkers = other._markers;
                // Adjust other markers
                for (var i = 0, len = otherMarkers.length; i < len; i++) {
                    var marker = otherMarkers[i];
                    changedMarkers[marker.id] = true;
                    marker.oldLineNumber = marker.oldLineNumber || other.lineNumber;
                    marker.oldColumn = marker.oldColumn || marker.column;
                    marker.column += thisTextLength;
                }
                this.addMarkers(otherMarkers);
            }
        };
        ModelLine.prototype.addMarker = function (marker) {
            marker.line = this;
            if (!this._markers) {
                this._markers = [marker];
            }
            else {
                this._markers.push(marker);
            }
        };
        ModelLine.prototype.addMarkers = function (markers) {
            if (markers.length === 0) {
                return;
            }
            var i, len;
            for (i = 0, len = markers.length; i < len; i++) {
                markers[i].line = this;
            }
            if (!this._markers) {
                this._markers = markers.slice(0);
            }
            else {
                this._markers = this._markers.concat(markers);
            }
        };
        ModelLine._compareMarkers = function (a, b) {
            if (a.column === b.column) {
                return (a.stickToPreviousCharacter ? 0 : 1) - (b.stickToPreviousCharacter ? 0 : 1);
            }
            return a.column - b.column;
        };
        ModelLine.prototype.removeMarker = function (marker) {
            var index = this._indexOfMarkerId(marker.id);
            if (index >= 0) {
                this._markers.splice(index, 1);
            }
            marker.line = null;
        };
        ModelLine.prototype.removeMarkers = function (deleteMarkers) {
            if (!this._markers) {
                return;
            }
            for (var i = 0, len = this._markers.length; i < len; i++) {
                var marker = this._markers[i];
                if (deleteMarkers[marker.id]) {
                    marker.line = null;
                    this._markers.splice(i, 1);
                    len--;
                    i--;
                }
            }
        };
        ModelLine.prototype.getMarkers = function () {
            if (!this._markers) {
                return [];
            }
            return this._markers.slice(0);
        };
        ModelLine.prototype.updateLineNumber = function (changedMarkers, newLineNumber) {
            if (this._markers) {
                var markers = this._markers, i, len, marker;
                for (i = 0, len = markers.length; i < len; i++) {
                    marker = markers[i];
                    changedMarkers[marker.id] = true;
                    marker.oldLineNumber = marker.oldLineNumber || this.lineNumber;
                }
            }
            this.lineNumber = newLineNumber;
        };
        ModelLine.prototype.deleteLine = function (changedMarkers, setMarkersColumn, setMarkersOldLineNumber) {
            // console.log('--> deleteLine: ');
            if (this._markers) {
                var markers = this._markers, i, len, marker;
                // Mark all these markers as changed
                for (i = 0, len = markers.length; i < len; i++) {
                    marker = markers[i];
                    changedMarkers[marker.id] = true;
                    marker.oldColumn = marker.oldColumn || marker.column;
                    marker.oldLineNumber = marker.oldLineNumber || setMarkersOldLineNumber;
                    marker.column = setMarkersColumn;
                }
                return markers;
            }
            return [];
        };
        ModelLine.prototype._indexOfMarkerId = function (markerId) {
            if (this._markers) {
                var markers = this._markers, i, len;
                for (i = 0, len = markers.length; i < len; i++) {
                    if (markers[i].id === markerId) {
                        return i;
                    }
                }
            }
            return -1;
        };
        return ModelLine;
    }());
    exports.ModelLine = ModelLine;
    function areDeflatedTokens(tokens) {
        return (typeof tokens[0] === 'number');
    }
    function toLineTokens(map, tokens, textLength) {
        if (textLength === 0) {
            return null;
        }
        if (!tokens || tokens.length === 0) {
            return null;
        }
        if (tokens.length === 1) {
            if (areDeflatedTokens(tokens)) {
                if (tokens[0] === 0) {
                    return null;
                }
            }
            else {
                if (tokens[0].startIndex === 0 && tokens[0].type === '') {
                    return null;
                }
            }
        }
        return new LineTokens(map, tokens);
    }
    var getStartIndex = editorCommon_1.LineTokensBinaryEncoding.getStartIndex;
    var getType = editorCommon_1.LineTokensBinaryEncoding.getType;
    var findIndexOfOffset = editorCommon_1.LineTokensBinaryEncoding.findIndexOfOffset;
    var LineTokens = (function () {
        function LineTokens(map, tokens) {
            this.map = map;
            if (areDeflatedTokens(tokens)) {
                this._tokens = tokens;
            }
            else {
                this._tokens = editorCommon_1.LineTokensBinaryEncoding.deflateArr(map, tokens);
            }
        }
        LineTokens.prototype.toString = function () {
            return editorCommon_1.LineTokensBinaryEncoding.inflateArr(this.map, this._tokens).toString();
        };
        LineTokens.prototype.getBinaryEncodedTokensMap = function () {
            return this.map;
        };
        LineTokens.prototype.getBinaryEncodedTokens = function () {
            return this._tokens;
        };
        LineTokens.prototype.getTokenCount = function () {
            return this._tokens.length;
        };
        LineTokens.prototype.getTokenStartIndex = function (tokenIndex) {
            return getStartIndex(this._tokens[tokenIndex]);
        };
        LineTokens.prototype.getTokenType = function (tokenIndex) {
            return getType(this.map, this._tokens[tokenIndex]);
        };
        LineTokens.prototype.getTokenEndIndex = function (tokenIndex, textLength) {
            if (tokenIndex + 1 < this._tokens.length) {
                return getStartIndex(this._tokens[tokenIndex + 1]);
            }
            return textLength;
        };
        LineTokens.prototype.equals = function (other) {
            return this === other;
        };
        LineTokens.prototype.findIndexOfOffset = function (offset) {
            return findIndexOfOffset(this._tokens, offset);
        };
        return LineTokens;
    }());
    exports.LineTokens = LineTokens;
    var EmptyLineTokens = (function () {
        function EmptyLineTokens() {
        }
        EmptyLineTokens.prototype.getBinaryEncodedTokens = function () {
            return EmptyLineTokens.TOKENS;
        };
        EmptyLineTokens.prototype.getBinaryEncodedTokensMap = function () {
            return null;
        };
        EmptyLineTokens.prototype.getTokenCount = function () {
            return 0;
        };
        EmptyLineTokens.prototype.getTokenStartIndex = function (tokenIndex) {
            return 0;
        };
        EmptyLineTokens.prototype.getTokenType = function (tokenIndex) {
            return strings.empty;
        };
        EmptyLineTokens.prototype.getTokenEndIndex = function (tokenIndex, textLength) {
            return 0;
        };
        EmptyLineTokens.prototype.equals = function (other) {
            return other === this;
        };
        EmptyLineTokens.prototype.findIndexOfOffset = function (offset) {
            return 0;
        };
        EmptyLineTokens.INSTANCE = new EmptyLineTokens();
        EmptyLineTokens.TOKENS = [];
        return EmptyLineTokens;
    }());
    var DefaultLineTokens = (function () {
        function DefaultLineTokens() {
        }
        DefaultLineTokens.prototype.getBinaryEncodedTokensMap = function () {
            return null;
        };
        DefaultLineTokens.prototype.getBinaryEncodedTokens = function () {
            return DefaultLineTokens.TOKENS;
        };
        DefaultLineTokens.prototype.getTokenCount = function () {
            return 1;
        };
        DefaultLineTokens.prototype.getTokenStartIndex = function (tokenIndex) {
            return 0;
        };
        DefaultLineTokens.prototype.getTokenType = function (tokenIndex) {
            return strings.empty;
        };
        DefaultLineTokens.prototype.getTokenEndIndex = function (tokenIndex, textLength) {
            return textLength;
        };
        DefaultLineTokens.prototype.equals = function (other) {
            return this === other;
        };
        DefaultLineTokens.prototype.findIndexOfOffset = function (offset) {
            return 0;
        };
        DefaultLineTokens.INSTANCE = new DefaultLineTokens();
        DefaultLineTokens.TOKENS = [0];
        return DefaultLineTokens;
    }());
    exports.DefaultLineTokens = DefaultLineTokens;
    function toModeTransitions(topLevelMode, modeTransitions) {
        if (!modeTransitions || modeTransitions.length === 0) {
            return null;
        }
        else if (modeTransitions.length === 1 && modeTransitions[0].startIndex === 0) {
            if (modeTransitions[0].mode === topLevelMode) {
                return null;
            }
            else {
                return new SingleModeTransition(modeTransitions[0].mode);
            }
        }
        return new ModeTransitions(modeTransitions);
    }
    var DefaultModeTransitions = (function () {
        function DefaultModeTransitions() {
        }
        DefaultModeTransitions.prototype.toArray = function (topLevelMode) {
            return [{
                    startIndex: 0,
                    mode: topLevelMode
                }];
        };
        DefaultModeTransitions.INSTANCE = new DefaultModeTransitions();
        return DefaultModeTransitions;
    }());
    var SingleModeTransition = (function () {
        function SingleModeTransition(mode) {
            this._mode = mode;
        }
        SingleModeTransition.prototype.toArray = function (topLevelMode) {
            return [{
                    startIndex: 0,
                    mode: this._mode
                }];
        };
        return SingleModeTransition;
    }());
    var ModeTransitions = (function () {
        function ModeTransitions(modeTransitions) {
            this._modeTransitions = modeTransitions;
        }
        ModeTransitions.prototype.toArray = function (topLevelMode) {
            return this._modeTransitions.slice(0);
        };
        return ModeTransitions;
    }());
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/editor/common/modes/languageFeatureRegistry", ["require", "exports", 'vs/base/common/arrays', 'vs/base/common/event', 'vs/editor/common/modes/languageSelector'], function (require, exports, arrays_1, event_1, languageSelector_1) {
    'use strict';
    var LanguageFeatureRegistry = (function () {
        function LanguageFeatureRegistry(supportName) {
            this._clock = 0;
            this._entries = [];
            this._onDidChange = new event_1.Emitter();
            this._supportName = supportName;
        }
        Object.defineProperty(LanguageFeatureRegistry.prototype, "onDidChange", {
            get: function () {
                return this._onDidChange.event;
            },
            enumerable: true,
            configurable: true
        });
        LanguageFeatureRegistry.prototype.register = function (selector, provider) {
            var _this = this;
            var entry = {
                selector: selector,
                provider: provider,
                _score: -1,
                _time: this._clock++
            };
            this._entries.push(entry);
            this._lastCandidate = undefined;
            this._onDidChange.fire(this._entries.length);
            return {
                dispose: function () {
                    if (entry) {
                        var idx = _this._entries.indexOf(entry);
                        if (idx >= 0) {
                            _this._entries.splice(idx, 1);
                            _this._lastCandidate = undefined;
                            _this._onDidChange.fire(_this._entries.length);
                            entry = undefined;
                        }
                    }
                }
            };
        };
        LanguageFeatureRegistry.prototype.has = function (model) {
            return this.all(model).length > 0;
        };
        LanguageFeatureRegistry.prototype.all = function (model) {
            if (!model || model.isTooLargeForHavingAMode()) {
                return [];
            }
            this._updateScores(model);
            var result = [];
            // (1) from registry
            for (var _i = 0, _a = this._entries; _i < _a.length; _i++) {
                var entry = _a[_i];
                if (entry._score > 0) {
                    result.push(entry.provider);
                }
            }
            // (2) from mode
            if (model.getMode() && model.getMode()[this._supportName]) {
                result.push(model.getMode()[this._supportName]);
            }
            return result;
        };
        LanguageFeatureRegistry.prototype.ordered = function (model) {
            var result = [];
            this._orderedForEach(model, function (entry) { return result.push(entry.provider); });
            return result;
        };
        LanguageFeatureRegistry.prototype.orderedGroups = function (model) {
            var result = [];
            var lastBucket;
            var lastBucketScore;
            this._orderedForEach(model, function (entry) {
                if (lastBucket && lastBucketScore === entry._score) {
                    lastBucket.push(entry.provider);
                }
                else {
                    lastBucketScore = entry._score;
                    lastBucket = [entry.provider];
                    result.push(lastBucket);
                }
            });
            return result;
        };
        LanguageFeatureRegistry.prototype._orderedForEach = function (model, callback) {
            if (!model || model.isTooLargeForHavingAMode()) {
                return;
            }
            this._updateScores(model);
            var supportIndex = -1;
            var supportEntry;
            if (model.getMode() && model.getMode()[this._supportName]) {
                supportEntry = {
                    selector: undefined,
                    provider: model.getMode()[this._supportName],
                    _score: .5,
                    _time: -1
                };
                supportIndex = ~arrays_1.binarySearch(this._entries, supportEntry, LanguageFeatureRegistry._compareByScoreAndTime);
            }
            var to = Math.max(supportIndex + 1, this._entries.length);
            for (var from = 0; from < to; from++) {
                if (from === supportIndex) {
                    callback(supportEntry);
                }
                else {
                    var entry = this._entries[from];
                    if (entry._score > 0) {
                        callback(entry);
                    }
                }
            }
        };
        LanguageFeatureRegistry.prototype._updateScores = function (model) {
            var candidate = {
                uri: model.getAssociatedResource().toString(),
                language: model.getModeId()
            };
            if (this._lastCandidate
                && this._lastCandidate.language === candidate.language
                && this._lastCandidate.uri === candidate.uri) {
                // nothing has changed
                return;
            }
            this._lastCandidate = candidate;
            for (var _i = 0, _a = this._entries; _i < _a.length; _i++) {
                var entry = _a[_i];
                entry._score = languageSelector_1.score(entry.selector, model.getAssociatedResource(), model.getModeId());
            }
            // needs sorting
            this._entries.sort(LanguageFeatureRegistry._compareByScoreAndTime);
        };
        LanguageFeatureRegistry._compareByScoreAndTime = function (a, b) {
            if (a._score < b._score) {
                return 1;
            }
            else if (a._score > b._score) {
                return -1;
            }
            else if (a._time < b._time) {
                return 1;
            }
            else if (a._time > b._time) {
                return -1;
            }
            else {
                return 0;
            }
        };
        return LanguageFeatureRegistry;
    }());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = LanguageFeatureRegistry;
});

define("vs/editor/common/modes/supports/onEnter", ["require", "exports", 'vs/base/common/errors', 'vs/base/common/strings', 'vs/editor/common/core/position', 'vs/editor/common/modes', 'vs/editor/common/modes/supports'], function (require, exports, errors_1, strings, position_1, modes_1, supports_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var OnEnterSupport = (function () {
        function OnEnterSupport(modeId, opts) {
            opts = opts || {};
            opts.brackets = opts.brackets || [
                ['(', ')'],
                ['{', '}'],
                ['[', ']']
            ];
            this._modeId = modeId;
            this._brackets = opts.brackets.map(function (bracket) {
                return {
                    open: bracket[0],
                    openRegExp: OnEnterSupport._createOpenBracketRegExp(bracket[0]),
                    close: bracket[1],
                    closeRegExp: OnEnterSupport._createCloseBracketRegExp(bracket[1]),
                };
            });
            this._regExpRules = opts.regExpRules || [];
            this._indentationRules = opts.indentationRules;
        }
        OnEnterSupport.prototype.onEnter = function (model, position) {
            var _this = this;
            var context = model.getLineContext(position.lineNumber);
            return supports_1.handleEvent(context, position.column - 1, function (nestedMode, context, offset) {
                if (_this._modeId === nestedMode.getId()) {
                    return _this._onEnter(model, position);
                }
                else if (nestedMode.richEditSupport && nestedMode.richEditSupport.onEnter) {
                    return nestedMode.richEditSupport.onEnter.onEnter(model, position);
                }
                else {
                    return null;
                }
            });
        };
        OnEnterSupport.prototype._onEnter = function (model, position) {
            var lineText = model.getLineContent(position.lineNumber);
            var beforeEnterText = lineText.substr(0, position.column - 1);
            var afterEnterText = lineText.substr(position.column - 1);
            var oneLineAboveText = position.lineNumber === 1 ? '' : model.getLineContent(position.lineNumber - 1);
            return this._actualOnEnter(oneLineAboveText, beforeEnterText, afterEnterText);
        };
        OnEnterSupport.prototype._actualOnEnter = function (oneLineAboveText, beforeEnterText, afterEnterText) {
            // (1): `regExpRules`
            for (var i = 0, len = this._regExpRules.length; i < len; i++) {
                var rule = this._regExpRules[i];
                if (rule.beforeText.test(beforeEnterText)) {
                    if (rule.afterText) {
                        if (rule.afterText.test(afterEnterText)) {
                            return rule.action;
                        }
                    }
                    else {
                        return rule.action;
                    }
                }
            }
            // (2): Special indent-outdent
            if (beforeEnterText.length > 0 && afterEnterText.length > 0) {
                for (var i = 0, len = this._brackets.length; i < len; i++) {
                    var bracket = this._brackets[i];
                    if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {
                        return OnEnterSupport._INDENT_OUTDENT;
                    }
                }
            }
            // (3): Indentation Support
            if (this._indentationRules) {
                if (this._indentationRules.increaseIndentPattern && this._indentationRules.increaseIndentPattern.test(beforeEnterText)) {
                    return OnEnterSupport._INDENT;
                }
                if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(beforeEnterText)) {
                    return OnEnterSupport._INDENT;
                }
                if (/^\s/.test(beforeEnterText)) {
                    // No reason to run regular expressions if there is nothing to outdent from
                    if (this._indentationRules.decreaseIndentPattern && this._indentationRules.decreaseIndentPattern.test(afterEnterText)) {
                        return OnEnterSupport._OUTDENT;
                    }
                    if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(oneLineAboveText)) {
                        return OnEnterSupport._OUTDENT;
                    }
                }
            }
            // (4): Open bracket based logic
            if (beforeEnterText.length > 0) {
                for (var i = 0, len = this._brackets.length; i < len; i++) {
                    var bracket = this._brackets[i];
                    if (bracket.openRegExp.test(beforeEnterText)) {
                        return OnEnterSupport._INDENT;
                    }
                }
            }
            return null;
        };
        OnEnterSupport._createOpenBracketRegExp = function (bracket) {
            var str = strings.escapeRegExpCharacters(bracket);
            if (!/\B/.test(str.charAt(0))) {
                str = '\\b' + str;
            }
            str += '\\s*$';
            return OnEnterSupport._safeRegExp(str);
        };
        OnEnterSupport._createCloseBracketRegExp = function (bracket) {
            var str = strings.escapeRegExpCharacters(bracket);
            if (!/\B/.test(str.charAt(str.length - 1))) {
                str = str + '\\b';
            }
            str = '^\\s*' + str;
            return OnEnterSupport._safeRegExp(str);
        };
        OnEnterSupport._safeRegExp = function (def) {
            try {
                return new RegExp(def);
            }
            catch (err) {
                errors_1.onUnexpectedError(err);
                return null;
            }
        };
        OnEnterSupport._INDENT = { indentAction: modes_1.IndentAction.Indent };
        OnEnterSupport._INDENT_OUTDENT = { indentAction: modes_1.IndentAction.IndentOutdent };
        OnEnterSupport._OUTDENT = { indentAction: modes_1.IndentAction.Outdent };
        return OnEnterSupport;
    }());
    exports.OnEnterSupport = OnEnterSupport;
    function getRawEnterActionAtPosition(model, lineNumber, column) {
        var result;
        var richEditSupport = model.getMode().richEditSupport;
        if (richEditSupport && richEditSupport.onEnter) {
            try {
                result = richEditSupport.onEnter.onEnter(model, new position_1.Position(lineNumber, column));
            }
            catch (e) {
                errors_1.onUnexpectedError(e);
            }
        }
        return result;
    }
    exports.getRawEnterActionAtPosition = getRawEnterActionAtPosition;
    function getEnterActionAtPosition(model, lineNumber, column) {
        var lineText = model.getLineContent(lineNumber);
        var indentation = strings.getLeadingWhitespace(lineText);
        if (indentation.length > column - 1) {
            indentation = indentation.substring(0, column - 1);
        }
        var enterAction = getRawEnterActionAtPosition(model, lineNumber, column);
        if (!enterAction) {
            enterAction = {
                indentAction: modes_1.IndentAction.None,
                appendText: '',
            };
        }
        else {
            if (!enterAction.appendText) {
                if ((enterAction.indentAction === modes_1.IndentAction.Indent) ||
                    (enterAction.indentAction === modes_1.IndentAction.IndentOutdent)) {
                    enterAction.appendText = '\t';
                }
                else {
                    enterAction.appendText = '';
                }
            }
        }
        if (enterAction.removeText) {
            indentation = indentation.substring(0, indentation.length - 1);
        }
        return {
            enterAction: enterAction,
            indentation: indentation
        };
    }
    exports.getEnterActionAtPosition = getEnterActionAtPosition;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("vs/editor/common/modes/supports/suggestSupport", ["require", "exports", 'vs/base/common/winjs.base', 'vs/editor/common/modes/modesFilters', 'vs/editor/common/modes/supports'], function (require, exports, winjs_base_1, modesFilters_1, supports_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var SuggestSupport = (function () {
        function SuggestSupport(modeId, contribution) {
            this._modeId = modeId;
            this.contribution = contribution;
            this.suggest = function (resource, position) { return contribution.suggest(resource, position); };
            if (typeof contribution.getSuggestionDetails === 'function') {
                this.getSuggestionDetails = function (resource, position, suggestion) { return contribution.getSuggestionDetails(resource, position, suggestion); };
            }
        }
        SuggestSupport.prototype.shouldAutotriggerSuggest = function (context, offset, triggeredByCharacter) {
            var _this = this;
            return supports_1.handleEvent(context, offset, function (nestedMode, context, offset) {
                if (_this._modeId === nestedMode.getId()) {
                    if (_this.contribution.disableAutoTrigger) {
                        return false;
                    }
                    if (!Array.isArray(_this.contribution.excludeTokens)) {
                        return true;
                    }
                    if (_this.contribution.excludeTokens.length === 1 && _this.contribution.excludeTokens[0] === '*') {
                        return false;
                    }
                    return !supports_1.isLineToken(context, offset - 1, _this.contribution.excludeTokens, true);
                }
                else if (nestedMode.suggestSupport) {
                    return nestedMode.suggestSupport.shouldAutotriggerSuggest(context, offset, triggeredByCharacter);
                }
                else {
                    return false;
                }
            });
        };
        SuggestSupport.prototype.getFilter = function () {
            return modesFilters_1.DefaultFilter;
        };
        SuggestSupport.prototype.getTriggerCharacters = function () {
            return this.contribution.triggerCharacters;
        };
        SuggestSupport.prototype.shouldShowEmptySuggestionList = function () {
            return true;
        };
        return SuggestSupport;
    }());
    exports.SuggestSupport = SuggestSupport;
    var TextualSuggestSupport = (function () {
        function TextualSuggestSupport(modeId, editorWorkerService) {
            this._modeId = modeId;
            this._editorWorkerService = editorWorkerService;
        }
        TextualSuggestSupport.prototype.suggest = function (resource, position, triggerCharacter) {
            return this._editorWorkerService.textualSuggest(resource, position);
        };
        TextualSuggestSupport.prototype.getFilter = function () {
            return modesFilters_1.StrictPrefix;
        };
        TextualSuggestSupport.prototype.getTriggerCharacters = function () {
            return [];
        };
        TextualSuggestSupport.prototype.shouldShowEmptySuggestionList = function () {
            return true;
        };
        TextualSuggestSupport.prototype.shouldAutotriggerSuggest = function (context, offset, triggeredByCharacter) {
            var _this = this;
            return supports_1.handleEvent(context, offset, function (nestedMode, context, offset) {
                if (_this._modeId === nestedMode.getId()) {
                    return true;
                }
                else if (nestedMode.suggestSupport) {
                    return nestedMode.suggestSupport.shouldAutotriggerSuggest(context, offset, triggeredByCharacter);
                }
                else {
                    return false;
                }
            });
        };
        return TextualSuggestSupport;
    }());
    exports.TextualSuggestSupport = TextualSuggestSupport;
    var PredefinedResultSuggestSupport = (function (_super) {
        __extends(PredefinedResultSuggestSupport, _super);
        function PredefinedResultSuggestSupport(modeId, modelService, predefined, triggerCharacters, disableAutoTrigger) {
            _super.call(this, modeId, {
                triggerCharacters: triggerCharacters,
                disableAutoTrigger: disableAutoTrigger,
                excludeTokens: [],
                suggest: function (resource, position) {
                    var model = modelService.getModel(resource);
                    var result = _addSuggestionsAtPosition(model, position, predefined, null);
                    return winjs_base_1.TPromise.as(result);
                }
            });
        }
        return PredefinedResultSuggestSupport;
    }(SuggestSupport));
    exports.PredefinedResultSuggestSupport = PredefinedResultSuggestSupport;
    var TextualAndPredefinedResultSuggestSupport = (function (_super) {
        __extends(TextualAndPredefinedResultSuggestSupport, _super);
        function TextualAndPredefinedResultSuggestSupport(modeId, modelService, editorWorkerService, predefined, triggerCharacters, disableAutoTrigger) {
            _super.call(this, modeId, {
                triggerCharacters: triggerCharacters,
                disableAutoTrigger: disableAutoTrigger,
                excludeTokens: [],
                suggest: function (resource, position) {
                    return editorWorkerService.textualSuggest(resource, position).then(function (textualSuggestions) {
                        var model = modelService.getModel(resource);
                        var result = _addSuggestionsAtPosition(model, position, predefined, textualSuggestions);
                        return result;
                    });
                }
            });
        }
        return TextualAndPredefinedResultSuggestSupport;
    }(SuggestSupport));
    exports.TextualAndPredefinedResultSuggestSupport = TextualAndPredefinedResultSuggestSupport;
    function _addSuggestionsAtPosition(model, position, predefined, superSuggestions) {
        if (!predefined || predefined.length === 0) {
            return superSuggestions;
        }
        if (!superSuggestions) {
            superSuggestions = [];
        }
        superSuggestions.push({
            currentWord: model.getWordUntilPosition(position).word,
            suggestions: predefined.slice(0)
        });
        return superSuggestions;
    }
    function filterSuggestions(value) {
        if (!value) {
            return;
        }
        // filter suggestions
        var accept = modesFilters_1.DefaultFilter, result = [];
        result.push({
            currentWord: value.currentWord,
            suggestions: value.suggestions.filter(function (element) { return !!accept(value.currentWord, element); }),
            incomplete: value.incomplete
        });
        return result;
    }
    exports.filterSuggestions = filterSuggestions;
});

define("vs/editor/common/modes/monarch/monarchDefinition", ["require", "exports", 'vs/editor/common/modes/supports/suggestSupport'], function (require, exports, suggestSupport_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function createRichEditSupport(lexer) {
        return {
            wordPattern: lexer.wordDefinition,
            comments: {
                lineComment: lexer.lineComment,
                blockComment: [lexer.blockCommentStart, lexer.blockCommentEnd]
            },
            brackets: lexer.standardBrackets,
            __electricCharacterSupport: {
                // regexBrackets: lexer.enhancedBrackets,
                caseInsensitive: lexer.ignoreCase,
                embeddedElectricCharacters: lexer.outdentTriggers.split('')
            },
            __characterPairSupport: {
                autoClosingPairs: lexer.autoClosingPairs
            }
        };
    }
    exports.createRichEditSupport = createRichEditSupport;
    function createSuggestSupport(modelService, editorWorkerService, modeId, lexer) {
        if (lexer.suggestSupport.textualCompletions) {
            return new suggestSupport_1.TextualAndPredefinedResultSuggestSupport(modeId, modelService, editorWorkerService, lexer.suggestSupport.snippets, lexer.suggestSupport.triggerCharacters, lexer.suggestSupport.disableAutoTrigger);
        }
        else {
            return new suggestSupport_1.PredefinedResultSuggestSupport(modeId, modelService, lexer.suggestSupport.snippets, lexer.suggestSupport.triggerCharacters, lexer.suggestSupport.disableAutoTrigger);
        }
    }
    exports.createSuggestSupport = createSuggestSupport;
});

define("vs/nls!vs/base/common/json",['vs/nls', 'vs/nls!vs/workbench/node/pluginHostProcess'], function(nls, data) { return nls.create("vs/base/common/json", data); });
define("vs/base/common/json", ["require", "exports", 'vs/nls!vs/base/common/json'], function (require, exports, nls) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    (function (ScanError) {
        ScanError[ScanError["None"] = 0] = "None";
        ScanError[ScanError["UnexpectedEndOfComment"] = 1] = "UnexpectedEndOfComment";
        ScanError[ScanError["UnexpectedEndOfString"] = 2] = "UnexpectedEndOfString";
        ScanError[ScanError["UnexpectedEndOfNumber"] = 3] = "UnexpectedEndOfNumber";
        ScanError[ScanError["InvalidUnicode"] = 4] = "InvalidUnicode";
        ScanError[ScanError["InvalidEscapeCharacter"] = 5] = "InvalidEscapeCharacter";
    })(exports.ScanError || (exports.ScanError = {}));
    var ScanError = exports.ScanError;
    (function (SyntaxKind) {
        SyntaxKind[SyntaxKind["Unknown"] = 0] = "Unknown";
        SyntaxKind[SyntaxKind["OpenBraceToken"] = 1] = "OpenBraceToken";
        SyntaxKind[SyntaxKind["CloseBraceToken"] = 2] = "CloseBraceToken";
        SyntaxKind[SyntaxKind["OpenBracketToken"] = 3] = "OpenBracketToken";
        SyntaxKind[SyntaxKind["CloseBracketToken"] = 4] = "CloseBracketToken";
        SyntaxKind[SyntaxKind["CommaToken"] = 5] = "CommaToken";
        SyntaxKind[SyntaxKind["ColonToken"] = 6] = "ColonToken";
        SyntaxKind[SyntaxKind["NullKeyword"] = 7] = "NullKeyword";
        SyntaxKind[SyntaxKind["TrueKeyword"] = 8] = "TrueKeyword";
        SyntaxKind[SyntaxKind["FalseKeyword"] = 9] = "FalseKeyword";
        SyntaxKind[SyntaxKind["StringLiteral"] = 10] = "StringLiteral";
        SyntaxKind[SyntaxKind["NumericLiteral"] = 11] = "NumericLiteral";
        SyntaxKind[SyntaxKind["LineCommentTrivia"] = 12] = "LineCommentTrivia";
        SyntaxKind[SyntaxKind["BlockCommentTrivia"] = 13] = "BlockCommentTrivia";
        SyntaxKind[SyntaxKind["LineBreakTrivia"] = 14] = "LineBreakTrivia";
        SyntaxKind[SyntaxKind["Trivia"] = 15] = "Trivia";
        SyntaxKind[SyntaxKind["EOF"] = 16] = "EOF";
    })(exports.SyntaxKind || (exports.SyntaxKind = {}));
    var SyntaxKind = exports.SyntaxKind;
    function createScanner(text, ignoreTrivia) {
        if (ignoreTrivia === void 0) { ignoreTrivia = false; }
        var pos = 0, len = text.length, value = '', tokenOffset = 0, token = SyntaxKind.Unknown, scanError = ScanError.None;
        function scanHexDigits(count, exact) {
            var digits = 0;
            var value = 0;
            while (digits < count || !exact) {
                var ch = text.charCodeAt(pos);
                if (ch >= CharacterCodes._0 && ch <= CharacterCodes._9) {
                    value = value * 16 + ch - CharacterCodes._0;
                }
                else if (ch >= CharacterCodes.A && ch <= CharacterCodes.F) {
                    value = value * 16 + ch - CharacterCodes.A + 10;
                }
                else if (ch >= CharacterCodes.a && ch <= CharacterCodes.f) {
                    value = value * 16 + ch - CharacterCodes.a + 10;
                }
                else {
                    break;
                }
                pos++;
                digits++;
            }
            if (digits < count) {
                value = -1;
            }
            return value;
        }
        function scanNumber() {
            var start = pos;
            if (text.charCodeAt(pos) === CharacterCodes._0) {
                pos++;
            }
            else {
                pos++;
                while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                }
            }
            if (pos < text.length && text.charCodeAt(pos) === CharacterCodes.dot) {
                pos++;
                if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                    while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                        pos++;
                    }
                }
                else {
                    scanError = ScanError.UnexpectedEndOfNumber;
                    return text.substring(start, end);
                }
            }
            var end = pos;
            if (pos < text.length && (text.charCodeAt(pos) === CharacterCodes.E || text.charCodeAt(pos) === CharacterCodes.e)) {
                pos++;
                if (pos < text.length && text.charCodeAt(pos) === CharacterCodes.plus || text.charCodeAt(pos) === CharacterCodes.minus) {
                    pos++;
                }
                if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                    while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                        pos++;
                    }
                    end = pos;
                }
                else {
                    scanError = ScanError.UnexpectedEndOfNumber;
                }
            }
            return text.substring(start, end);
        }
        function scanString() {
            var result = '', start = pos;
            while (true) {
                if (pos >= len) {
                    result += text.substring(start, pos);
                    scanError = ScanError.UnexpectedEndOfString;
                    break;
                }
                var ch = text.charCodeAt(pos);
                if (ch === CharacterCodes.doubleQuote) {
                    result += text.substring(start, pos);
                    pos++;
                    break;
                }
                if (ch === CharacterCodes.backslash) {
                    result += text.substring(start, pos);
                    pos++;
                    if (pos >= len) {
                        scanError = ScanError.UnexpectedEndOfString;
                        break;
                    }
                    ch = text.charCodeAt(pos++);
                    switch (ch) {
                        case CharacterCodes.doubleQuote:
                            result += '\"';
                            break;
                        case CharacterCodes.backslash:
                            result += '\\';
                            break;
                        case CharacterCodes.slash:
                            result += '/';
                            break;
                        case CharacterCodes.b:
                            result += '\b';
                            break;
                        case CharacterCodes.f:
                            result += '\f';
                            break;
                        case CharacterCodes.n:
                            result += '\n';
                            break;
                        case CharacterCodes.r:
                            result += '\r';
                            break;
                        case CharacterCodes.t:
                            result += '\t';
                            break;
                        case CharacterCodes.u:
                            var ch = scanHexDigits(4, true);
                            if (ch >= 0) {
                                result += String.fromCharCode(ch);
                            }
                            else {
                                scanError = ScanError.InvalidUnicode;
                            }
                            break;
                        default:
                            scanError = ScanError.InvalidEscapeCharacter;
                    }
                    start = pos;
                    continue;
                }
                if (isLineBreak(ch)) {
                    result += text.substring(start, pos);
                    scanError = ScanError.UnexpectedEndOfString;
                    break;
                }
                pos++;
            }
            return result;
        }
        function scanNext() {
            value = '';
            scanError = ScanError.None;
            tokenOffset = pos;
            if (pos >= len) {
                // at the end
                tokenOffset = len;
                return token = SyntaxKind.EOF;
            }
            var code = text.charCodeAt(pos);
            // trivia: whitespace
            if (isWhiteSpace(code)) {
                do {
                    pos++;
                    value += String.fromCharCode(code);
                    code = text.charCodeAt(pos);
                } while (isWhiteSpace(code));
                return token = SyntaxKind.Trivia;
            }
            // trivia: newlines
            if (isLineBreak(code)) {
                pos++;
                value += String.fromCharCode(code);
                if (code === CharacterCodes.carriageReturn && text.charCodeAt(pos) === CharacterCodes.lineFeed) {
                    pos++;
                    value += '\n';
                }
                return token = SyntaxKind.LineBreakTrivia;
            }
            switch (code) {
                // tokens: []{}:,
                case CharacterCodes.openBrace:
                    pos++;
                    return token = SyntaxKind.OpenBraceToken;
                case CharacterCodes.closeBrace:
                    pos++;
                    return token = SyntaxKind.CloseBraceToken;
                case CharacterCodes.openBracket:
                    pos++;
                    return token = SyntaxKind.OpenBracketToken;
                case CharacterCodes.closeBracket:
                    pos++;
                    return token = SyntaxKind.CloseBracketToken;
                case CharacterCodes.colon:
                    pos++;
                    return token = SyntaxKind.ColonToken;
                case CharacterCodes.comma:
                    pos++;
                    return token = SyntaxKind.CommaToken;
                // strings
                case CharacterCodes.doubleQuote:
                    pos++;
                    value = scanString();
                    return token = SyntaxKind.StringLiteral;
                // comments
                case CharacterCodes.slash:
                    var start = pos - 1;
                    // Single-line comment
                    if (text.charCodeAt(pos + 1) === CharacterCodes.slash) {
                        pos += 2;
                        while (pos < len) {
                            if (isLineBreak(text.charCodeAt(pos))) {
                                break;
                            }
                            pos++;
                        }
                        value = text.substring(start, pos);
                        return token = SyntaxKind.LineCommentTrivia;
                    }
                    // Multi-line comment
                    if (text.charCodeAt(pos + 1) === CharacterCodes.asterisk) {
                        pos += 2;
                        var safeLength = len - 1; // For lookahead.
                        var commentClosed = false;
                        while (pos < safeLength) {
                            var ch = text.charCodeAt(pos);
                            if (ch === CharacterCodes.asterisk && text.charCodeAt(pos + 1) === CharacterCodes.slash) {
                                pos += 2;
                                commentClosed = true;
                                break;
                            }
                            pos++;
                        }
                        if (!commentClosed) {
                            pos++;
                            scanError = ScanError.UnexpectedEndOfComment;
                        }
                        value = text.substring(start, pos);
                        return token = SyntaxKind.BlockCommentTrivia;
                    }
                    // just a single slash
                    value += String.fromCharCode(code);
                    pos++;
                    return token = SyntaxKind.Unknown;
                // numbers
                case CharacterCodes.minus:
                    value += String.fromCharCode(code);
                    pos++;
                    if (pos === len || !isDigit(text.charCodeAt(pos))) {
                        return token = SyntaxKind.Unknown;
                    }
                // found a minus, followed by a number so
                // we fall through to proceed with scanning
                // numbers
                case CharacterCodes._0:
                case CharacterCodes._1:
                case CharacterCodes._2:
                case CharacterCodes._3:
                case CharacterCodes._4:
                case CharacterCodes._5:
                case CharacterCodes._6:
                case CharacterCodes._7:
                case CharacterCodes._8:
                case CharacterCodes._9:
                    value += scanNumber();
                    return token = SyntaxKind.NumericLiteral;
                // literals and unknown symbols
                default:
                    // is a literal? Read the full word.
                    while (pos < len && isUnknownContentCharacter(code)) {
                        pos++;
                        code = text.charCodeAt(pos);
                    }
                    if (tokenOffset !== pos) {
                        value = text.substring(tokenOffset, pos);
                        // keywords: true, false, null
                        switch (value) {
                            case 'true': return token = SyntaxKind.TrueKeyword;
                            case 'false': return token = SyntaxKind.FalseKeyword;
                            case 'null': return token = SyntaxKind.NullKeyword;
                        }
                        return token = SyntaxKind.Unknown;
                    }
                    // some
                    value += String.fromCharCode(code);
                    pos++;
                    return token = SyntaxKind.Unknown;
            }
        }
        function isUnknownContentCharacter(code) {
            if (isWhiteSpace(code) || isLineBreak(code)) {
                return false;
            }
            switch (code) {
                case CharacterCodes.closeBrace:
                case CharacterCodes.closeBracket:
                case CharacterCodes.openBrace:
                case CharacterCodes.openBracket:
                case CharacterCodes.doubleQuote:
                case CharacterCodes.colon:
                case CharacterCodes.comma:
                    return false;
            }
            return true;
        }
        function scanNextNonTrivia() {
            var result;
            do {
                result = scanNext();
            } while (result >= SyntaxKind.LineCommentTrivia && result <= SyntaxKind.Trivia);
            return result;
        }
        return {
            getPosition: function () { return pos; },
            scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
            getToken: function () { return token; },
            getTokenValue: function () { return value; },
            getTokenOffset: function () { return tokenOffset; },
            getTokenLength: function () { return pos - tokenOffset; },
            getTokenError: function () { return scanError; }
        };
    }
    exports.createScanner = createScanner;
    function isWhiteSpace(ch) {
        return ch === CharacterCodes.space || ch === CharacterCodes.tab || ch === CharacterCodes.verticalTab || ch === CharacterCodes.formFeed ||
            ch === CharacterCodes.nonBreakingSpace || ch === CharacterCodes.ogham || ch >= CharacterCodes.enQuad && ch <= CharacterCodes.zeroWidthSpace ||
            ch === CharacterCodes.narrowNoBreakSpace || ch === CharacterCodes.mathematicalSpace || ch === CharacterCodes.ideographicSpace || ch === CharacterCodes.byteOrderMark;
    }
    function isLineBreak(ch) {
        return ch === CharacterCodes.lineFeed || ch === CharacterCodes.carriageReturn || ch === CharacterCodes.lineSeparator || ch === CharacterCodes.paragraphSeparator;
    }
    function isDigit(ch) {
        return ch >= CharacterCodes._0 && ch <= CharacterCodes._9;
    }
    function isLetter(ch) {
        return ch >= CharacterCodes.a && ch <= CharacterCodes.z || ch >= CharacterCodes.A && ch <= CharacterCodes.Z;
    }
    exports.isLetter = isLetter;
    var CharacterCodes;
    (function (CharacterCodes) {
        CharacterCodes[CharacterCodes["nullCharacter"] = 0] = "nullCharacter";
        CharacterCodes[CharacterCodes["maxAsciiCharacter"] = 127] = "maxAsciiCharacter";
        CharacterCodes[CharacterCodes["lineFeed"] = 10] = "lineFeed";
        CharacterCodes[CharacterCodes["carriageReturn"] = 13] = "carriageReturn";
        CharacterCodes[CharacterCodes["lineSeparator"] = 8232] = "lineSeparator";
        CharacterCodes[CharacterCodes["paragraphSeparator"] = 8233] = "paragraphSeparator";
        // REVIEW: do we need to support this?  The scanner doesn't, but our IText does.  This seems
        // like an odd disparity?  (Or maybe it's completely fine for them to be different).
        CharacterCodes[CharacterCodes["nextLine"] = 133] = "nextLine";
        // Unicode 3.0 space characters
        CharacterCodes[CharacterCodes["space"] = 32] = "space";
        CharacterCodes[CharacterCodes["nonBreakingSpace"] = 160] = "nonBreakingSpace";
        CharacterCodes[CharacterCodes["enQuad"] = 8192] = "enQuad";
        CharacterCodes[CharacterCodes["emQuad"] = 8193] = "emQuad";
        CharacterCodes[CharacterCodes["enSpace"] = 8194] = "enSpace";
        CharacterCodes[CharacterCodes["emSpace"] = 8195] = "emSpace";
        CharacterCodes[CharacterCodes["threePerEmSpace"] = 8196] = "threePerEmSpace";
        CharacterCodes[CharacterCodes["fourPerEmSpace"] = 8197] = "fourPerEmSpace";
        CharacterCodes[CharacterCodes["sixPerEmSpace"] = 8198] = "sixPerEmSpace";
        CharacterCodes[CharacterCodes["figureSpace"] = 8199] = "figureSpace";
        CharacterCodes[CharacterCodes["punctuationSpace"] = 8200] = "punctuationSpace";
        CharacterCodes[CharacterCodes["thinSpace"] = 8201] = "thinSpace";
        CharacterCodes[CharacterCodes["hairSpace"] = 8202] = "hairSpace";
        CharacterCodes[CharacterCodes["zeroWidthSpace"] = 8203] = "zeroWidthSpace";
        CharacterCodes[CharacterCodes["narrowNoBreakSpace"] = 8239] = "narrowNoBreakSpace";
        CharacterCodes[CharacterCodes["ideographicSpace"] = 12288] = "ideographicSpace";
        CharacterCodes[CharacterCodes["mathematicalSpace"] = 8287] = "mathematicalSpace";
        CharacterCodes[CharacterCodes["ogham"] = 5760] = "ogham";
        CharacterCodes[CharacterCodes["_"] = 95] = "_";
        CharacterCodes[CharacterCodes["$"] = 36] = "$";
        CharacterCodes[CharacterCodes["_0"] = 48] = "_0";
        CharacterCodes[CharacterCodes["_1"] = 49] = "_1";
        CharacterCodes[CharacterCodes["_2"] = 50] = "_2";
        CharacterCodes[CharacterCodes["_3"] = 51] = "_3";
        CharacterCodes[CharacterCodes["_4"] = 52] = "_4";
        CharacterCodes[CharacterCodes["_5"] = 53] = "_5";
        CharacterCodes[CharacterCodes["_6"] = 54] = "_6";
        CharacterCodes[CharacterCodes["_7"] = 55] = "_7";
        CharacterCodes[CharacterCodes["_8"] = 56] = "_8";
        CharacterCodes[CharacterCodes["_9"] = 57] = "_9";
        CharacterCodes[CharacterCodes["a"] = 97] = "a";
        CharacterCodes[CharacterCodes["b"] = 98] = "b";
        CharacterCodes[CharacterCodes["c"] = 99] = "c";
        CharacterCodes[CharacterCodes["d"] = 100] = "d";
        CharacterCodes[CharacterCodes["e"] = 101] = "e";
        CharacterCodes[CharacterCodes["f"] = 102] = "f";
        CharacterCodes[CharacterCodes["g"] = 103] = "g";
        CharacterCodes[CharacterCodes["h"] = 104] = "h";
        CharacterCodes[CharacterCodes["i"] = 105] = "i";
        CharacterCodes[CharacterCodes["j"] = 106] = "j";
        CharacterCodes[CharacterCodes["k"] = 107] = "k";
        CharacterCodes[CharacterCodes["l"] = 108] = "l";
        CharacterCodes[CharacterCodes["m"] = 109] = "m";
        CharacterCodes[CharacterCodes["n"] = 110] = "n";
        CharacterCodes[CharacterCodes["o"] = 111] = "o";
        CharacterCodes[CharacterCodes["p"] = 112] = "p";
        CharacterCodes[CharacterCodes["q"] = 113] = "q";
        CharacterCodes[CharacterCodes["r"] = 114] = "r";
        CharacterCodes[CharacterCodes["s"] = 115] = "s";
        CharacterCodes[CharacterCodes["t"] = 116] = "t";
        CharacterCodes[CharacterCodes["u"] = 117] = "u";
        CharacterCodes[CharacterCodes["v"] = 118] = "v";
        CharacterCodes[CharacterCodes["w"] = 119] = "w";
        CharacterCodes[CharacterCodes["x"] = 120] = "x";
        CharacterCodes[CharacterCodes["y"] = 121] = "y";
        CharacterCodes[CharacterCodes["z"] = 122] = "z";
        CharacterCodes[CharacterCodes["A"] = 65] = "A";
        CharacterCodes[CharacterCodes["B"] = 66] = "B";
        CharacterCodes[CharacterCodes["C"] = 67] = "C";
        CharacterCodes[CharacterCodes["D"] = 68] = "D";
        CharacterCodes[CharacterCodes["E"] = 69] = "E";
        CharacterCodes[CharacterCodes["F"] = 70] = "F";
        CharacterCodes[CharacterCodes["G"] = 71] = "G";
        CharacterCodes[CharacterCodes["H"] = 72] = "H";
        CharacterCodes[CharacterCodes["I"] = 73] = "I";
        CharacterCodes[CharacterCodes["J"] = 74] = "J";
        CharacterCodes[CharacterCodes["K"] = 75] = "K";
        CharacterCodes[CharacterCodes["L"] = 76] = "L";
        CharacterCodes[CharacterCodes["M"] = 77] = "M";
        CharacterCodes[CharacterCodes["N"] = 78] = "N";
        CharacterCodes[CharacterCodes["O"] = 79] = "O";
        CharacterCodes[CharacterCodes["P"] = 80] = "P";
        CharacterCodes[CharacterCodes["Q"] = 81] = "Q";
        CharacterCodes[CharacterCodes["R"] = 82] = "R";
        CharacterCodes[CharacterCodes["S"] = 83] = "S";
        CharacterCodes[CharacterCodes["T"] = 84] = "T";
        CharacterCodes[CharacterCodes["U"] = 85] = "U";
        CharacterCodes[CharacterCodes["V"] = 86] = "V";
        CharacterCodes[CharacterCodes["W"] = 87] = "W";
        CharacterCodes[CharacterCodes["X"] = 88] = "X";
        CharacterCodes[CharacterCodes["Y"] = 89] = "Y";
        CharacterCodes[CharacterCodes["Z"] = 90] = "Z";
        CharacterCodes[CharacterCodes["ampersand"] = 38] = "ampersand";
        CharacterCodes[CharacterCodes["asterisk"] = 42] = "asterisk";
        CharacterCodes[CharacterCodes["at"] = 64] = "at";
        CharacterCodes[CharacterCodes["backslash"] = 92] = "backslash";
        CharacterCodes[CharacterCodes["bar"] = 124] = "bar";
        CharacterCodes[CharacterCodes["caret"] = 94] = "caret";
        CharacterCodes[CharacterCodes["closeBrace"] = 125] = "closeBrace";
        CharacterCodes[CharacterCodes["closeBracket"] = 93] = "closeBracket";
        CharacterCodes[CharacterCodes["closeParen"] = 41] = "closeParen";
        CharacterCodes[CharacterCodes["colon"] = 58] = "colon";
        CharacterCodes[CharacterCodes["comma"] = 44] = "comma";
        CharacterCodes[CharacterCodes["dot"] = 46] = "dot";
        CharacterCodes[CharacterCodes["doubleQuote"] = 34] = "doubleQuote";
        CharacterCodes[CharacterCodes["equals"] = 61] = "equals";
        CharacterCodes[CharacterCodes["exclamation"] = 33] = "exclamation";
        CharacterCodes[CharacterCodes["greaterThan"] = 62] = "greaterThan";
        CharacterCodes[CharacterCodes["lessThan"] = 60] = "lessThan";
        CharacterCodes[CharacterCodes["minus"] = 45] = "minus";
        CharacterCodes[CharacterCodes["openBrace"] = 123] = "openBrace";
        CharacterCodes[CharacterCodes["openBracket"] = 91] = "openBracket";
        CharacterCodes[CharacterCodes["openParen"] = 40] = "openParen";
        CharacterCodes[CharacterCodes["percent"] = 37] = "percent";
        CharacterCodes[CharacterCodes["plus"] = 43] = "plus";
        CharacterCodes[CharacterCodes["question"] = 63] = "question";
        CharacterCodes[CharacterCodes["semicolon"] = 59] = "semicolon";
        CharacterCodes[CharacterCodes["singleQuote"] = 39] = "singleQuote";
        CharacterCodes[CharacterCodes["slash"] = 47] = "slash";
        CharacterCodes[CharacterCodes["tilde"] = 126] = "tilde";
        CharacterCodes[CharacterCodes["backspace"] = 8] = "backspace";
        CharacterCodes[CharacterCodes["formFeed"] = 12] = "formFeed";
        CharacterCodes[CharacterCodes["byteOrderMark"] = 65279] = "byteOrderMark";
        CharacterCodes[CharacterCodes["tab"] = 9] = "tab";
        CharacterCodes[CharacterCodes["verticalTab"] = 11] = "verticalTab";
    })(CharacterCodes || (CharacterCodes = {}));
    /**
     * Takes JSON with JavaScript-style comments and remove
     * them. Optionally replaces every none-newline character
     * of comments with a replaceCharacter
     */
    function stripComments(text, replaceCh) {
        var _scanner = createScanner(text), parts = [], kind, offset = 0, pos;
        do {
            pos = _scanner.getPosition();
            kind = _scanner.scan();
            switch (kind) {
                case SyntaxKind.LineCommentTrivia:
                case SyntaxKind.BlockCommentTrivia:
                case SyntaxKind.EOF:
                    if (offset !== pos) {
                        parts.push(text.substring(offset, pos));
                    }
                    if (replaceCh !== void 0) {
                        parts.push(_scanner.getTokenValue().replace(/[^\r\n]/g, replaceCh));
                    }
                    offset = _scanner.getPosition();
                    break;
            }
        } while (kind !== SyntaxKind.EOF);
        return parts.join('');
    }
    exports.stripComments = stripComments;
    function parse(text, errors) {
        if (errors === void 0) { errors = []; }
        var noMatch = Object();
        var _scanner = createScanner(text, true);
        function scanNext() {
            var token = _scanner.scan();
            while (token === SyntaxKind.Unknown) {
                handleError(nls.localize(0, null));
                token = _scanner.scan();
            }
            return token;
        }
        function handleError(message, skipUntilAfter, skipUntil) {
            if (skipUntilAfter === void 0) { skipUntilAfter = []; }
            if (skipUntil === void 0) { skipUntil = []; }
            errors.push(message);
            if (skipUntilAfter.length + skipUntil.length > 0) {
                var token = _scanner.getToken();
                while (token !== SyntaxKind.EOF) {
                    if (skipUntilAfter.indexOf(token) !== -1) {
                        scanNext();
                        break;
                    }
                    else if (skipUntil.indexOf(token) !== -1) {
                        break;
                    }
                    token = scanNext();
                }
            }
        }
        function parseString() {
            if (_scanner.getToken() !== SyntaxKind.StringLiteral) {
                return noMatch;
            }
            var value = _scanner.getTokenValue();
            scanNext();
            return value;
        }
        function parseLiteral() {
            var value;
            switch (_scanner.getToken()) {
                case SyntaxKind.NumericLiteral:
                    try {
                        value = JSON.parse(_scanner.getTokenValue());
                        if (typeof value !== 'number') {
                            handleError(nls.localize(1, null));
                            value = 0;
                        }
                    }
                    catch (e) {
                        value = 0;
                    }
                    break;
                case SyntaxKind.NullKeyword:
                    value = null;
                    break;
                case SyntaxKind.TrueKeyword:
                    value = true;
                    break;
                case SyntaxKind.FalseKeyword:
                    value = false;
                    break;
                default:
                    return noMatch;
            }
            scanNext();
            return value;
        }
        function parseProperty(result) {
            var key = parseString();
            if (key === noMatch) {
                handleError(nls.localize(2, null), [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);
                return false;
            }
            if (_scanner.getToken() === SyntaxKind.ColonToken) {
                scanNext(); // consume colon
                var value = parseValue();
                if (value !== noMatch) {
                    result[key] = value;
                }
                else {
                    handleError(nls.localize(3, null), [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);
                }
            }
            else {
                handleError(nls.localize(4, null), [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);
            }
            return true;
        }
        function parseObject() {
            if (_scanner.getToken() !== SyntaxKind.OpenBraceToken) {
                return noMatch;
            }
            var obj = {};
            scanNext(); // consume open brace
            var needsComma = false;
            while (_scanner.getToken() !== SyntaxKind.CloseBraceToken && _scanner.getToken() !== SyntaxKind.EOF) {
                if (_scanner.getToken() === SyntaxKind.CommaToken) {
                    if (!needsComma) {
                        handleError(nls.localize(5, null), [], []);
                    }
                    scanNext(); // consume comma
                }
                else if (needsComma) {
                    handleError(nls.localize(6, null), [], []);
                }
                var propertyParsed = parseProperty(obj);
                if (!propertyParsed) {
                    handleError(nls.localize(7, null), [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);
                }
                needsComma = true;
            }
            if (_scanner.getToken() !== SyntaxKind.CloseBraceToken) {
                handleError(nls.localize(8, null), [SyntaxKind.CloseBraceToken], []);
            }
            else {
                scanNext(); // consume close brace
            }
            return obj;
        }
        function parseArray() {
            if (_scanner.getToken() !== SyntaxKind.OpenBracketToken) {
                return noMatch;
            }
            var arr = [];
            scanNext(); // consume open bracket
            var needsComma = false;
            while (_scanner.getToken() !== SyntaxKind.CloseBracketToken && _scanner.getToken() !== SyntaxKind.EOF) {
                if (_scanner.getToken() === SyntaxKind.CommaToken) {
                    if (!needsComma) {
                        handleError(nls.localize(9, null), [], []);
                    }
                    scanNext(); // consume comma
                }
                else if (needsComma) {
                    handleError(nls.localize(10, null), [], []);
                }
                var value = parseValue();
                if (value === noMatch) {
                    handleError(nls.localize(11, null), [], [SyntaxKind.CloseBracketToken, SyntaxKind.CommaToken]);
                }
                else {
                    arr.push(value);
                }
                needsComma = true;
            }
            if (_scanner.getToken() !== SyntaxKind.CloseBracketToken) {
                handleError(nls.localize(12, null), [SyntaxKind.CloseBracketToken], []);
            }
            else {
                scanNext(); // consume close bracket
            }
            return arr;
        }
        function parseValue() {
            var result = parseArray();
            if (result !== noMatch) {
                return result;
            }
            result = parseObject();
            if (result !== noMatch) {
                return result;
            }
            result = parseString();
            if (result !== noMatch) {
                return result;
            }
            return parseLiteral();
        }
        scanNext();
        var value = parseValue();
        if (value === noMatch) {
            handleError(nls.localize(13, null), [], []);
            return void 0;
        }
        if (_scanner.getToken() !== SyntaxKind.EOF) {
            handleError(nls.localize(14, null), [], []);
        }
        return value;
    }
    exports.parse = parse;
});

define("vs/nls!vs/base/common/keyCodes",['vs/nls', 'vs/nls!vs/workbench/node/pluginHostProcess'], function(nls, data) { return nls.create("vs/base/common/keyCodes", data); });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/base/common/keyCodes", ["require", "exports", 'vs/nls!vs/base/common/keyCodes', 'vs/base/common/platform'], function (require, exports, nls, defaultPlatform) {
    'use strict';
    /**
     * Virtual Key Codes, the value does not hold any inherent meaning.
     * Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
     * But these are "more general", as they should work across browsers & OS`s.
     */
    (function (KeyCode) {
        /**
         * Placed first to cover the 0 value of the enum.
         */
        KeyCode[KeyCode["Unknown"] = 0] = "Unknown";
        KeyCode[KeyCode["Backspace"] = 1] = "Backspace";
        KeyCode[KeyCode["Tab"] = 2] = "Tab";
        KeyCode[KeyCode["Enter"] = 3] = "Enter";
        KeyCode[KeyCode["Shift"] = 4] = "Shift";
        KeyCode[KeyCode["Ctrl"] = 5] = "Ctrl";
        KeyCode[KeyCode["Alt"] = 6] = "Alt";
        KeyCode[KeyCode["PauseBreak"] = 7] = "PauseBreak";
        KeyCode[KeyCode["CapsLock"] = 8] = "CapsLock";
        KeyCode[KeyCode["Escape"] = 9] = "Escape";
        KeyCode[KeyCode["Space"] = 10] = "Space";
        KeyCode[KeyCode["PageUp"] = 11] = "PageUp";
        KeyCode[KeyCode["PageDown"] = 12] = "PageDown";
        KeyCode[KeyCode["End"] = 13] = "End";
        KeyCode[KeyCode["Home"] = 14] = "Home";
        KeyCode[KeyCode["LeftArrow"] = 15] = "LeftArrow";
        KeyCode[KeyCode["UpArrow"] = 16] = "UpArrow";
        KeyCode[KeyCode["RightArrow"] = 17] = "RightArrow";
        KeyCode[KeyCode["DownArrow"] = 18] = "DownArrow";
        KeyCode[KeyCode["Insert"] = 19] = "Insert";
        KeyCode[KeyCode["Delete"] = 20] = "Delete";
        KeyCode[KeyCode["KEY_0"] = 21] = "KEY_0";
        KeyCode[KeyCode["KEY_1"] = 22] = "KEY_1";
        KeyCode[KeyCode["KEY_2"] = 23] = "KEY_2";
        KeyCode[KeyCode["KEY_3"] = 24] = "KEY_3";
        KeyCode[KeyCode["KEY_4"] = 25] = "KEY_4";
        KeyCode[KeyCode["KEY_5"] = 26] = "KEY_5";
        KeyCode[KeyCode["KEY_6"] = 27] = "KEY_6";
        KeyCode[KeyCode["KEY_7"] = 28] = "KEY_7";
        KeyCode[KeyCode["KEY_8"] = 29] = "KEY_8";
        KeyCode[KeyCode["KEY_9"] = 30] = "KEY_9";
        KeyCode[KeyCode["KEY_A"] = 31] = "KEY_A";
        KeyCode[KeyCode["KEY_B"] = 32] = "KEY_B";
        KeyCode[KeyCode["KEY_C"] = 33] = "KEY_C";
        KeyCode[KeyCode["KEY_D"] = 34] = "KEY_D";
        KeyCode[KeyCode["KEY_E"] = 35] = "KEY_E";
        KeyCode[KeyCode["KEY_F"] = 36] = "KEY_F";
        KeyCode[KeyCode["KEY_G"] = 37] = "KEY_G";
        KeyCode[KeyCode["KEY_H"] = 38] = "KEY_H";
        KeyCode[KeyCode["KEY_I"] = 39] = "KEY_I";
        KeyCode[KeyCode["KEY_J"] = 40] = "KEY_J";
        KeyCode[KeyCode["KEY_K"] = 41] = "KEY_K";
        KeyCode[KeyCode["KEY_L"] = 42] = "KEY_L";
        KeyCode[KeyCode["KEY_M"] = 43] = "KEY_M";
        KeyCode[KeyCode["KEY_N"] = 44] = "KEY_N";
        KeyCode[KeyCode["KEY_O"] = 45] = "KEY_O";
        KeyCode[KeyCode["KEY_P"] = 46] = "KEY_P";
        KeyCode[KeyCode["KEY_Q"] = 47] = "KEY_Q";
        KeyCode[KeyCode["KEY_R"] = 48] = "KEY_R";
        KeyCode[KeyCode["KEY_S"] = 49] = "KEY_S";
        KeyCode[KeyCode["KEY_T"] = 50] = "KEY_T";
        KeyCode[KeyCode["KEY_U"] = 51] = "KEY_U";
        KeyCode[KeyCode["KEY_V"] = 52] = "KEY_V";
        KeyCode[KeyCode["KEY_W"] = 53] = "KEY_W";
        KeyCode[KeyCode["KEY_X"] = 54] = "KEY_X";
        KeyCode[KeyCode["KEY_Y"] = 55] = "KEY_Y";
        KeyCode[KeyCode["KEY_Z"] = 56] = "KEY_Z";
        KeyCode[KeyCode["Meta"] = 57] = "Meta";
        KeyCode[KeyCode["ContextMenu"] = 58] = "ContextMenu";
        KeyCode[KeyCode["F1"] = 59] = "F1";
        KeyCode[KeyCode["F2"] = 60] = "F2";
        KeyCode[KeyCode["F3"] = 61] = "F3";
        KeyCode[KeyCode["F4"] = 62] = "F4";
        KeyCode[KeyCode["F5"] = 63] = "F5";
        KeyCode[KeyCode["F6"] = 64] = "F6";
        KeyCode[KeyCode["F7"] = 65] = "F7";
        KeyCode[KeyCode["F8"] = 66] = "F8";
        KeyCode[KeyCode["F9"] = 67] = "F9";
        KeyCode[KeyCode["F10"] = 68] = "F10";
        KeyCode[KeyCode["F11"] = 69] = "F11";
        KeyCode[KeyCode["F12"] = 70] = "F12";
        KeyCode[KeyCode["F13"] = 71] = "F13";
        KeyCode[KeyCode["F14"] = 72] = "F14";
        KeyCode[KeyCode["F15"] = 73] = "F15";
        KeyCode[KeyCode["F16"] = 74] = "F16";
        KeyCode[KeyCode["F17"] = 75] = "F17";
        KeyCode[KeyCode["F18"] = 76] = "F18";
        KeyCode[KeyCode["F19"] = 77] = "F19";
        KeyCode[KeyCode["NumLock"] = 78] = "NumLock";
        KeyCode[KeyCode["ScrollLock"] = 79] = "ScrollLock";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the ';:' key
         */
        KeyCode[KeyCode["US_SEMICOLON"] = 80] = "US_SEMICOLON";
        /**
         * For any country/region, the '+' key
         * For the US standard keyboard, the '=+' key
         */
        KeyCode[KeyCode["US_EQUAL"] = 81] = "US_EQUAL";
        /**
         * For any country/region, the ',' key
         * For the US standard keyboard, the ',<' key
         */
        KeyCode[KeyCode["US_COMMA"] = 82] = "US_COMMA";
        /**
         * For any country/region, the '-' key
         * For the US standard keyboard, the '-_' key
         */
        KeyCode[KeyCode["US_MINUS"] = 83] = "US_MINUS";
        /**
         * For any country/region, the '.' key
         * For the US standard keyboard, the '.>' key
         */
        KeyCode[KeyCode["US_DOT"] = 84] = "US_DOT";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '/?' key
         */
        KeyCode[KeyCode["US_SLASH"] = 85] = "US_SLASH";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '`~' key
         */
        KeyCode[KeyCode["US_BACKTICK"] = 86] = "US_BACKTICK";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '[{' key
         */
        KeyCode[KeyCode["US_OPEN_SQUARE_BRACKET"] = 87] = "US_OPEN_SQUARE_BRACKET";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '\|' key
         */
        KeyCode[KeyCode["US_BACKSLASH"] = 88] = "US_BACKSLASH";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the ']}' key
         */
        KeyCode[KeyCode["US_CLOSE_SQUARE_BRACKET"] = 89] = "US_CLOSE_SQUARE_BRACKET";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the ''"' key
         */
        KeyCode[KeyCode["US_QUOTE"] = 90] = "US_QUOTE";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         */
        KeyCode[KeyCode["OEM_8"] = 91] = "OEM_8";
        /**
         * Either the angle bracket key or the backslash key on the RT 102-key keyboard.
         */
        KeyCode[KeyCode["OEM_102"] = 92] = "OEM_102";
        KeyCode[KeyCode["NUMPAD_0"] = 93] = "NUMPAD_0";
        KeyCode[KeyCode["NUMPAD_1"] = 94] = "NUMPAD_1";
        KeyCode[KeyCode["NUMPAD_2"] = 95] = "NUMPAD_2";
        KeyCode[KeyCode["NUMPAD_3"] = 96] = "NUMPAD_3";
        KeyCode[KeyCode["NUMPAD_4"] = 97] = "NUMPAD_4";
        KeyCode[KeyCode["NUMPAD_5"] = 98] = "NUMPAD_5";
        KeyCode[KeyCode["NUMPAD_6"] = 99] = "NUMPAD_6";
        KeyCode[KeyCode["NUMPAD_7"] = 100] = "NUMPAD_7";
        KeyCode[KeyCode["NUMPAD_8"] = 101] = "NUMPAD_8";
        KeyCode[KeyCode["NUMPAD_9"] = 102] = "NUMPAD_9";
        KeyCode[KeyCode["NUMPAD_MULTIPLY"] = 103] = "NUMPAD_MULTIPLY";
        KeyCode[KeyCode["NUMPAD_ADD"] = 104] = "NUMPAD_ADD";
        KeyCode[KeyCode["NUMPAD_SEPARATOR"] = 105] = "NUMPAD_SEPARATOR";
        KeyCode[KeyCode["NUMPAD_SUBTRACT"] = 106] = "NUMPAD_SUBTRACT";
        KeyCode[KeyCode["NUMPAD_DECIMAL"] = 107] = "NUMPAD_DECIMAL";
        KeyCode[KeyCode["NUMPAD_DIVIDE"] = 108] = "NUMPAD_DIVIDE";
        /**
         * Placed last to cover the length of the enum.
         */
        KeyCode[KeyCode["MAX_VALUE"] = 109] = "MAX_VALUE";
    })(exports.KeyCode || (exports.KeyCode = {}));
    var KeyCode = exports.KeyCode;
    var Mapping = (function () {
        function Mapping(fromKeyCode, toKeyCode) {
            this._fromKeyCode = fromKeyCode;
            this._toKeyCode = toKeyCode;
        }
        Mapping.prototype.fromKeyCode = function (keyCode) {
            return this._fromKeyCode[keyCode];
        };
        Mapping.prototype.toKeyCode = function (str) {
            if (this._toKeyCode.hasOwnProperty(str)) {
                return this._toKeyCode[str];
            }
            return KeyCode.Unknown;
        };
        return Mapping;
    }());
    function createMapping(fill1, fill2) {
        var MAP = [];
        fill1(MAP);
        var REVERSE_MAP = {};
        for (var i = 0, len = MAP.length; i < len; i++) {
            if (!MAP[i]) {
                continue;
            }
            REVERSE_MAP[MAP[i]] = i;
        }
        fill2(REVERSE_MAP);
        var FINAL_REVERSE_MAP = {};
        for (var entry in REVERSE_MAP) {
            if (REVERSE_MAP.hasOwnProperty(entry)) {
                FINAL_REVERSE_MAP[entry] = REVERSE_MAP[entry];
                FINAL_REVERSE_MAP[entry.toLowerCase()] = REVERSE_MAP[entry];
            }
        }
        return new Mapping(MAP, FINAL_REVERSE_MAP);
    }
    var STRING = createMapping(function (TO_STRING_MAP) {
        TO_STRING_MAP[KeyCode.Unknown] = 'unknown';
        TO_STRING_MAP[KeyCode.Backspace] = 'Backspace';
        TO_STRING_MAP[KeyCode.Tab] = 'Tab';
        TO_STRING_MAP[KeyCode.Enter] = 'Enter';
        TO_STRING_MAP[KeyCode.Shift] = 'Shift';
        TO_STRING_MAP[KeyCode.Ctrl] = 'Ctrl';
        TO_STRING_MAP[KeyCode.Alt] = 'Alt';
        TO_STRING_MAP[KeyCode.PauseBreak] = 'PauseBreak';
        TO_STRING_MAP[KeyCode.CapsLock] = 'CapsLock';
        TO_STRING_MAP[KeyCode.Escape] = 'Escape';
        TO_STRING_MAP[KeyCode.Space] = 'Space';
        TO_STRING_MAP[KeyCode.PageUp] = 'PageUp';
        TO_STRING_MAP[KeyCode.PageDown] = 'PageDown';
        TO_STRING_MAP[KeyCode.End] = 'End';
        TO_STRING_MAP[KeyCode.Home] = 'Home';
        TO_STRING_MAP[KeyCode.LeftArrow] = 'LeftArrow';
        TO_STRING_MAP[KeyCode.UpArrow] = 'UpArrow';
        TO_STRING_MAP[KeyCode.RightArrow] = 'RightArrow';
        TO_STRING_MAP[KeyCode.DownArrow] = 'DownArrow';
        TO_STRING_MAP[KeyCode.Insert] = 'Insert';
        TO_STRING_MAP[KeyCode.Delete] = 'Delete';
        TO_STRING_MAP[KeyCode.KEY_0] = '0';
        TO_STRING_MAP[KeyCode.KEY_1] = '1';
        TO_STRING_MAP[KeyCode.KEY_2] = '2';
        TO_STRING_MAP[KeyCode.KEY_3] = '3';
        TO_STRING_MAP[KeyCode.KEY_4] = '4';
        TO_STRING_MAP[KeyCode.KEY_5] = '5';
        TO_STRING_MAP[KeyCode.KEY_6] = '6';
        TO_STRING_MAP[KeyCode.KEY_7] = '7';
        TO_STRING_MAP[KeyCode.KEY_8] = '8';
        TO_STRING_MAP[KeyCode.KEY_9] = '9';
        TO_STRING_MAP[KeyCode.KEY_A] = 'A';
        TO_STRING_MAP[KeyCode.KEY_B] = 'B';
        TO_STRING_MAP[KeyCode.KEY_C] = 'C';
        TO_STRING_MAP[KeyCode.KEY_D] = 'D';
        TO_STRING_MAP[KeyCode.KEY_E] = 'E';
        TO_STRING_MAP[KeyCode.KEY_F] = 'F';
        TO_STRING_MAP[KeyCode.KEY_G] = 'G';
        TO_STRING_MAP[KeyCode.KEY_H] = 'H';
        TO_STRING_MAP[KeyCode.KEY_I] = 'I';
        TO_STRING_MAP[KeyCode.KEY_J] = 'J';
        TO_STRING_MAP[KeyCode.KEY_K] = 'K';
        TO_STRING_MAP[KeyCode.KEY_L] = 'L';
        TO_STRING_MAP[KeyCode.KEY_M] = 'M';
        TO_STRING_MAP[KeyCode.KEY_N] = 'N';
        TO_STRING_MAP[KeyCode.KEY_O] = 'O';
        TO_STRING_MAP[KeyCode.KEY_P] = 'P';
        TO_STRING_MAP[KeyCode.KEY_Q] = 'Q';
        TO_STRING_MAP[KeyCode.KEY_R] = 'R';
        TO_STRING_MAP[KeyCode.KEY_S] = 'S';
        TO_STRING_MAP[KeyCode.KEY_T] = 'T';
        TO_STRING_MAP[KeyCode.KEY_U] = 'U';
        TO_STRING_MAP[KeyCode.KEY_V] = 'V';
        TO_STRING_MAP[KeyCode.KEY_W] = 'W';
        TO_STRING_MAP[KeyCode.KEY_X] = 'X';
        TO_STRING_MAP[KeyCode.KEY_Y] = 'Y';
        TO_STRING_MAP[KeyCode.KEY_Z] = 'Z';
        TO_STRING_MAP[KeyCode.ContextMenu] = 'ContextMenu';
        TO_STRING_MAP[KeyCode.F1] = 'F1';
        TO_STRING_MAP[KeyCode.F2] = 'F2';
        TO_STRING_MAP[KeyCode.F3] = 'F3';
        TO_STRING_MAP[KeyCode.F4] = 'F4';
        TO_STRING_MAP[KeyCode.F5] = 'F5';
        TO_STRING_MAP[KeyCode.F6] = 'F6';
        TO_STRING_MAP[KeyCode.F7] = 'F7';
        TO_STRING_MAP[KeyCode.F8] = 'F8';
        TO_STRING_MAP[KeyCode.F9] = 'F9';
        TO_STRING_MAP[KeyCode.F10] = 'F10';
        TO_STRING_MAP[KeyCode.F11] = 'F11';
        TO_STRING_MAP[KeyCode.F12] = 'F12';
        TO_STRING_MAP[KeyCode.F13] = 'F13';
        TO_STRING_MAP[KeyCode.F14] = 'F14';
        TO_STRING_MAP[KeyCode.F15] = 'F15';
        TO_STRING_MAP[KeyCode.F16] = 'F16';
        TO_STRING_MAP[KeyCode.F17] = 'F17';
        TO_STRING_MAP[KeyCode.F18] = 'F18';
        TO_STRING_MAP[KeyCode.F19] = 'F19';
        TO_STRING_MAP[KeyCode.NumLock] = 'NumLock';
        TO_STRING_MAP[KeyCode.ScrollLock] = 'ScrollLock';
        TO_STRING_MAP[KeyCode.US_SEMICOLON] = ';';
        TO_STRING_MAP[KeyCode.US_EQUAL] = '=';
        TO_STRING_MAP[KeyCode.US_COMMA] = ',';
        TO_STRING_MAP[KeyCode.US_MINUS] = '-';
        TO_STRING_MAP[KeyCode.US_DOT] = '.';
        TO_STRING_MAP[KeyCode.US_SLASH] = '/';
        TO_STRING_MAP[KeyCode.US_BACKTICK] = '`';
        TO_STRING_MAP[KeyCode.US_OPEN_SQUARE_BRACKET] = '[';
        TO_STRING_MAP[KeyCode.US_BACKSLASH] = '\\';
        TO_STRING_MAP[KeyCode.US_CLOSE_SQUARE_BRACKET] = ']';
        TO_STRING_MAP[KeyCode.US_QUOTE] = '\'';
        TO_STRING_MAP[KeyCode.OEM_8] = 'OEM_8';
        TO_STRING_MAP[KeyCode.OEM_102] = 'OEM_102';
        TO_STRING_MAP[KeyCode.NUMPAD_0] = 'NumPad0';
        TO_STRING_MAP[KeyCode.NUMPAD_1] = 'NumPad1';
        TO_STRING_MAP[KeyCode.NUMPAD_2] = 'NumPad2';
        TO_STRING_MAP[KeyCode.NUMPAD_3] = 'NumPad3';
        TO_STRING_MAP[KeyCode.NUMPAD_4] = 'NumPad4';
        TO_STRING_MAP[KeyCode.NUMPAD_5] = 'NumPad5';
        TO_STRING_MAP[KeyCode.NUMPAD_6] = 'NumPad6';
        TO_STRING_MAP[KeyCode.NUMPAD_7] = 'NumPad7';
        TO_STRING_MAP[KeyCode.NUMPAD_8] = 'NumPad8';
        TO_STRING_MAP[KeyCode.NUMPAD_9] = 'NumPad9';
        TO_STRING_MAP[KeyCode.NUMPAD_MULTIPLY] = 'NumPad_Multiply';
        TO_STRING_MAP[KeyCode.NUMPAD_ADD] = 'NumPad_Add';
        TO_STRING_MAP[KeyCode.NUMPAD_SEPARATOR] = 'NumPad_Separator';
        TO_STRING_MAP[KeyCode.NUMPAD_SUBTRACT] = 'NumPad_Subtract';
        TO_STRING_MAP[KeyCode.NUMPAD_DECIMAL] = 'NumPad_Decimal';
        TO_STRING_MAP[KeyCode.NUMPAD_DIVIDE] = 'NumPad_Divide';
        // for (let i = 0; i < KeyCode.MAX_VALUE; i++) {
        // 	if (!TO_STRING_MAP[i]) {
        // 		console.warn('Missing string representation for ' + KeyCode[i]);
        // 	}
        // }
    }, function (FROM_STRING_MAP) {
        FROM_STRING_MAP['\r'] = KeyCode.Enter;
    });
    var USER_SETTINGS = createMapping(function (TO_USER_SETTINGS_MAP) {
        for (var i = 0, len = STRING._fromKeyCode.length; i < len; i++) {
            TO_USER_SETTINGS_MAP[i] = STRING._fromKeyCode[i];
        }
        TO_USER_SETTINGS_MAP[KeyCode.LeftArrow] = 'Left';
        TO_USER_SETTINGS_MAP[KeyCode.UpArrow] = 'Up';
        TO_USER_SETTINGS_MAP[KeyCode.RightArrow] = 'Right';
        TO_USER_SETTINGS_MAP[KeyCode.DownArrow] = 'Down';
    }, function (FROM_USER_SETTINGS_MAP) {
        FROM_USER_SETTINGS_MAP['OEM_1'] = KeyCode.US_SEMICOLON;
        FROM_USER_SETTINGS_MAP['OEM_PLUS'] = KeyCode.US_EQUAL;
        FROM_USER_SETTINGS_MAP['OEM_COMMA'] = KeyCode.US_COMMA;
        FROM_USER_SETTINGS_MAP['OEM_MINUS'] = KeyCode.US_MINUS;
        FROM_USER_SETTINGS_MAP['OEM_PERIOD'] = KeyCode.US_DOT;
        FROM_USER_SETTINGS_MAP['OEM_2'] = KeyCode.US_SLASH;
        FROM_USER_SETTINGS_MAP['OEM_3'] = KeyCode.US_BACKTICK;
        FROM_USER_SETTINGS_MAP['OEM_4'] = KeyCode.US_OPEN_SQUARE_BRACKET;
        FROM_USER_SETTINGS_MAP['OEM_5'] = KeyCode.US_BACKSLASH;
        FROM_USER_SETTINGS_MAP['OEM_6'] = KeyCode.US_CLOSE_SQUARE_BRACKET;
        FROM_USER_SETTINGS_MAP['OEM_7'] = KeyCode.US_QUOTE;
        FROM_USER_SETTINGS_MAP['OEM_8'] = KeyCode.OEM_8;
        FROM_USER_SETTINGS_MAP['OEM_102'] = KeyCode.OEM_102;
    });
    var KeyCode;
    (function (KeyCode) {
        function toString(key) {
            return STRING.fromKeyCode(key);
        }
        KeyCode.toString = toString;
        function fromString(key) {
            return STRING.toKeyCode(key);
        }
        KeyCode.fromString = fromString;
    })(KeyCode = exports.KeyCode || (exports.KeyCode = {}));
    // Binary encoding strategy:
    // 15:  1 bit for ctrlCmd
    // 14:  1 bit for shift
    // 13:  1 bit for alt
    // 12:  1 bit for winCtrl
    //  0: 12 bits for keyCode (up to a maximum keyCode of 4096. Given we have 83 at this point thats good enough)
    var BIN_CTRLCMD_MASK = 1 << 15;
    var BIN_SHIFT_MASK = 1 << 14;
    var BIN_ALT_MASK = 1 << 13;
    var BIN_WINCTRL_MASK = 1 << 12;
    var BIN_KEYCODE_MASK = 0x00000fff;
    var BinaryKeybindings = (function () {
        function BinaryKeybindings() {
        }
        BinaryKeybindings.extractFirstPart = function (keybinding) {
            return keybinding & 0x0000ffff;
        };
        BinaryKeybindings.extractChordPart = function (keybinding) {
            return (keybinding >> 16) & 0x0000ffff;
        };
        BinaryKeybindings.hasChord = function (keybinding) {
            return (this.extractChordPart(keybinding) !== 0);
        };
        BinaryKeybindings.hasCtrlCmd = function (keybinding) {
            return (keybinding & BIN_CTRLCMD_MASK ? true : false);
        };
        BinaryKeybindings.hasShift = function (keybinding) {
            return (keybinding & BIN_SHIFT_MASK ? true : false);
        };
        BinaryKeybindings.hasAlt = function (keybinding) {
            return (keybinding & BIN_ALT_MASK ? true : false);
        };
        BinaryKeybindings.hasWinCtrl = function (keybinding) {
            return (keybinding & BIN_WINCTRL_MASK ? true : false);
        };
        BinaryKeybindings.extractKeyCode = function (keybinding) {
            return (keybinding & BIN_KEYCODE_MASK);
        };
        return BinaryKeybindings;
    }());
    exports.BinaryKeybindings = BinaryKeybindings;
    var KeyMod = (function () {
        function KeyMod() {
        }
        KeyMod.chord = function (firstPart, secondPart) {
            return firstPart | ((secondPart & 0x0000ffff) << 16);
        };
        KeyMod.CtrlCmd = BIN_CTRLCMD_MASK;
        KeyMod.Shift = BIN_SHIFT_MASK;
        KeyMod.Alt = BIN_ALT_MASK;
        KeyMod.WinCtrl = BIN_WINCTRL_MASK;
        return KeyMod;
    }());
    exports.KeyMod = KeyMod;
    /**
     * A set of usual keybindings that can be reused in code
     */
    var CommonKeybindings = (function () {
        function CommonKeybindings() {
        }
        CommonKeybindings.ENTER = KeyCode.Enter;
        CommonKeybindings.SHIFT_ENTER = KeyMod.Shift | KeyCode.Enter;
        CommonKeybindings.CTRLCMD_ENTER = KeyMod.CtrlCmd | KeyCode.Enter;
        CommonKeybindings.WINCTRL_ENTER = KeyMod.WinCtrl | KeyCode.Enter;
        CommonKeybindings.TAB = KeyCode.Tab;
        CommonKeybindings.SHIFT_TAB = KeyMod.Shift | KeyCode.Tab;
        CommonKeybindings.ESCAPE = KeyCode.Escape;
        CommonKeybindings.SPACE = KeyCode.Space;
        CommonKeybindings.DELETE = KeyCode.Delete;
        CommonKeybindings.SHIFT_DELETE = KeyMod.Shift | KeyCode.Delete;
        CommonKeybindings.CTRLCMD_BACKSPACE = KeyMod.CtrlCmd | KeyCode.Backspace;
        CommonKeybindings.UP_ARROW = KeyCode.UpArrow;
        CommonKeybindings.SHIFT_UP_ARROW = KeyMod.Shift | KeyCode.UpArrow;
        CommonKeybindings.CTRLCMD_UP_ARROW = KeyMod.CtrlCmd | KeyCode.UpArrow;
        CommonKeybindings.DOWN_ARROW = KeyCode.DownArrow;
        CommonKeybindings.SHIFT_DOWN_ARROW = KeyMod.Shift | KeyCode.DownArrow;
        CommonKeybindings.CTRLCMD_DOWN_ARROW = KeyMod.CtrlCmd | KeyCode.DownArrow;
        CommonKeybindings.LEFT_ARROW = KeyCode.LeftArrow;
        CommonKeybindings.RIGHT_ARROW = KeyCode.RightArrow;
        CommonKeybindings.PAGE_UP = KeyCode.PageUp;
        CommonKeybindings.SHIFT_PAGE_UP = KeyMod.Shift | KeyCode.PageUp;
        CommonKeybindings.PAGE_DOWN = KeyCode.PageDown;
        CommonKeybindings.SHIFT_PAGE_DOWN = KeyMod.Shift | KeyCode.PageDown;
        CommonKeybindings.F2 = KeyCode.F2;
        CommonKeybindings.CTRLCMD_S = KeyMod.CtrlCmd | KeyCode.KEY_S;
        CommonKeybindings.CTRLCMD_C = KeyMod.CtrlCmd | KeyCode.KEY_C;
        CommonKeybindings.CTRLCMD_V = KeyMod.CtrlCmd | KeyCode.KEY_V;
        return CommonKeybindings;
    }());
    exports.CommonKeybindings = CommonKeybindings;
    var Keybinding = (function () {
        function Keybinding(keybinding) {
            this.value = keybinding;
        }
        /**
         * Format the binding to a format appropiate for rendering in the UI
         */
        Keybinding._toUSLabel = function (value, Platform) {
            return _asString(value, (Platform.isMacintosh ? MacUIKeyLabelProvider.INSTANCE : ClassicUIKeyLabelProvider.INSTANCE), Platform);
        };
        /**
         * Format the binding to a format appropiate for placing in an aria-label.
         */
        Keybinding._toUSAriaLabel = function (value, Platform) {
            return _asString(value, AriaKeyLabelProvider.INSTANCE, Platform);
        };
        /**
         * Format the binding to a format appropiate for rendering in the UI
         */
        Keybinding._toUSHTMLLabel = function (value, Platform) {
            return _asHTML(value, (Platform.isMacintosh ? MacUIKeyLabelProvider.INSTANCE : ClassicUIKeyLabelProvider.INSTANCE), Platform);
        };
        /**
         * Format the binding to a format appropiate for rendering in the UI
         */
        Keybinding._toCustomLabel = function (value, labelProvider, Platform) {
            return _asString(value, labelProvider, Platform);
        };
        /**
         * Format the binding to a format appropiate for rendering in the UI
         */
        Keybinding._toCustomHTMLLabel = function (value, labelProvider, Platform) {
            return _asHTML(value, labelProvider, Platform);
        };
        /**
         * This prints the binding in a format suitable for electron's accelerators.
         * See https://github.com/atom/electron/blob/master/docs/api/accelerator.md
         */
        Keybinding._toElectronAccelerator = function (value, Platform) {
            if (BinaryKeybindings.hasChord(value)) {
                // Electron cannot handle chords
                return null;
            }
            return _asString(value, ElectronAcceleratorLabelProvider.INSTANCE, Platform);
        };
        Keybinding.getUserSettingsKeybindingRegex = function () {
            if (!this._cachedKeybindingRegex) {
                var numpadKey = 'numpad(0|1|2|3|4|5|6|7|8|9|_multiply|_add|_subtract|_decimal|_divide|_separator)';
                var oemKey = '`|\\-|=|\\[|\\]|\\\\\\\\|;|\'|,|\\.|\\/|oem_8|oem_102';
                var specialKey = 'left|up|right|down|pageup|pagedown|end|home|tab|enter|escape|space|backspace|delete|pausebreak|capslock|insert|contextmenu|numlock|scrolllock';
                var casualKey = '[a-z]|[0-9]|f(1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19)';
                var key = '((' + [numpadKey, oemKey, specialKey, casualKey].join(')|(') + '))';
                var mod = '((ctrl|shift|alt|cmd|win|meta)\\+)*';
                var keybinding = '(' + mod + key + ')';
                this._cachedKeybindingRegex = '"\\s*(' + keybinding + '(\\s+' + keybinding + ')?' + ')\\s*"';
            }
            return this._cachedKeybindingRegex;
        };
        /**
         * Format the binding to a format appropiate for the user settings file.
         */
        Keybinding.toUserSettingsLabel = function (value, Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            var result = _asString(value, UserSettingsKeyLabelProvider.INSTANCE, Platform);
            result = result.toLowerCase();
            if (Platform.isMacintosh) {
                result = result.replace(/meta/g, 'cmd');
            }
            else if (Platform.isWindows) {
                result = result.replace(/meta/g, 'win');
            }
            return result;
        };
        Keybinding.fromUserSettingsLabel = function (input, Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            if (!input) {
                return null;
            }
            input = input.toLowerCase().trim();
            var ctrlCmd = false, shift = false, alt = false, winCtrl = false, key = '';
            while (/^(ctrl|shift|alt|meta|win|cmd)(\+|\-)/.test(input)) {
                if (/^ctrl(\+|\-)/.test(input)) {
                    if (Platform.isMacintosh) {
                        winCtrl = true;
                    }
                    else {
                        ctrlCmd = true;
                    }
                    input = input.substr('ctrl-'.length);
                }
                if (/^shift(\+|\-)/.test(input)) {
                    shift = true;
                    input = input.substr('shift-'.length);
                }
                if (/^alt(\+|\-)/.test(input)) {
                    alt = true;
                    input = input.substr('alt-'.length);
                }
                if (/^meta(\+|\-)/.test(input)) {
                    if (Platform.isMacintosh) {
                        ctrlCmd = true;
                    }
                    else {
                        winCtrl = true;
                    }
                    input = input.substr('meta-'.length);
                }
                if (/^win(\+|\-)/.test(input)) {
                    if (Platform.isMacintosh) {
                        ctrlCmd = true;
                    }
                    else {
                        winCtrl = true;
                    }
                    input = input.substr('win-'.length);
                }
                if (/^cmd(\+|\-)/.test(input)) {
                    if (Platform.isMacintosh) {
                        ctrlCmd = true;
                    }
                    else {
                        winCtrl = true;
                    }
                    input = input.substr('cmd-'.length);
                }
            }
            var chord = 0;
            var firstSpaceIdx = input.indexOf(' ');
            if (firstSpaceIdx > 0) {
                key = input.substring(0, firstSpaceIdx);
                chord = Keybinding.fromUserSettingsLabel(input.substring(firstSpaceIdx), Platform);
            }
            else {
                key = input;
            }
            var keyCode = USER_SETTINGS.toKeyCode(key);
            var result = 0;
            if (ctrlCmd) {
                result |= KeyMod.CtrlCmd;
            }
            if (shift) {
                result |= KeyMod.Shift;
            }
            if (alt) {
                result |= KeyMod.Alt;
            }
            if (winCtrl) {
                result |= KeyMod.WinCtrl;
            }
            result |= keyCode;
            return KeyMod.chord(result, chord);
        };
        Keybinding.prototype.hasCtrlCmd = function () {
            return BinaryKeybindings.hasCtrlCmd(this.value);
        };
        Keybinding.prototype.hasShift = function () {
            return BinaryKeybindings.hasShift(this.value);
        };
        Keybinding.prototype.hasAlt = function () {
            return BinaryKeybindings.hasAlt(this.value);
        };
        Keybinding.prototype.hasWinCtrl = function () {
            return BinaryKeybindings.hasWinCtrl(this.value);
        };
        Keybinding.prototype.extractKeyCode = function () {
            return BinaryKeybindings.extractKeyCode(this.value);
        };
        /**
         * Format the binding to a format appropiate for rendering in the UI
         */
        Keybinding.prototype._toUSLabel = function (Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            return Keybinding._toUSLabel(this.value, Platform);
        };
        /**
         * Format the binding to a format appropiate for placing in an aria-label.
         */
        Keybinding.prototype._toUSAriaLabel = function (Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            return Keybinding._toUSAriaLabel(this.value, Platform);
        };
        /**
         * Format the binding to a format appropiate for rendering in the UI
         */
        Keybinding.prototype._toUSHTMLLabel = function (Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            return Keybinding._toUSHTMLLabel(this.value, Platform);
        };
        /**
         * Format the binding to a format appropiate for rendering in the UI
         */
        Keybinding.prototype.toCustomLabel = function (labelProvider, Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            return Keybinding._toCustomLabel(this.value, labelProvider, Platform);
        };
        /**
         * Format the binding to a format appropiate for rendering in the UI
         */
        Keybinding.prototype.toCustomHTMLLabel = function (labelProvider, Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            return Keybinding._toCustomHTMLLabel(this.value, labelProvider, Platform);
        };
        /**
         * This prints the binding in a format suitable for electron's accelerators.
         * See https://github.com/atom/electron/blob/master/docs/api/accelerator.md
         */
        Keybinding.prototype._toElectronAccelerator = function (Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            return Keybinding._toElectronAccelerator(this.value, Platform);
        };
        /**
         * Format the binding to a format appropiate for the user settings file.
         */
        Keybinding.prototype.toUserSettingsLabel = function (Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            return Keybinding.toUserSettingsLabel(this.value, Platform);
        };
        Keybinding._cachedKeybindingRegex = null;
        return Keybinding;
    }());
    exports.Keybinding = Keybinding;
    /**
     * Print for Electron
     */
    var ElectronAcceleratorLabelProvider = (function () {
        function ElectronAcceleratorLabelProvider() {
            this.ctrlKeyLabel = 'Ctrl';
            this.shiftKeyLabel = 'Shift';
            this.altKeyLabel = 'Alt';
            this.cmdKeyLabel = 'Cmd';
            this.windowsKeyLabel = 'Super';
            this.modifierSeparator = '+';
        }
        ElectronAcceleratorLabelProvider.prototype.getLabelForKey = function (keyCode) {
            switch (keyCode) {
                case KeyCode.UpArrow:
                    return 'Up';
                case KeyCode.DownArrow:
                    return 'Down';
                case KeyCode.LeftArrow:
                    return 'Left';
                case KeyCode.RightArrow:
                    return 'Right';
            }
            return KeyCode.toString(keyCode);
        };
        ElectronAcceleratorLabelProvider.INSTANCE = new ElectronAcceleratorLabelProvider();
        return ElectronAcceleratorLabelProvider;
    }());
    exports.ElectronAcceleratorLabelProvider = ElectronAcceleratorLabelProvider;
    /**
     * Print for Mac UI
     */
    var MacUIKeyLabelProvider = (function () {
        function MacUIKeyLabelProvider() {
            this.ctrlKeyLabel = '\u2303';
            this.shiftKeyLabel = '\u21E7';
            this.altKeyLabel = '\u2325';
            this.cmdKeyLabel = '\u2318';
            this.windowsKeyLabel = nls.localize(0, null);
            this.modifierSeparator = '';
        }
        MacUIKeyLabelProvider.prototype.getLabelForKey = function (keyCode) {
            switch (keyCode) {
                case KeyCode.LeftArrow:
                    return MacUIKeyLabelProvider.leftArrowUnicodeLabel;
                case KeyCode.UpArrow:
                    return MacUIKeyLabelProvider.upArrowUnicodeLabel;
                case KeyCode.RightArrow:
                    return MacUIKeyLabelProvider.rightArrowUnicodeLabel;
                case KeyCode.DownArrow:
                    return MacUIKeyLabelProvider.downArrowUnicodeLabel;
            }
            return KeyCode.toString(keyCode);
        };
        MacUIKeyLabelProvider.INSTANCE = new MacUIKeyLabelProvider();
        MacUIKeyLabelProvider.leftArrowUnicodeLabel = String.fromCharCode(8592);
        MacUIKeyLabelProvider.upArrowUnicodeLabel = String.fromCharCode(8593);
        MacUIKeyLabelProvider.rightArrowUnicodeLabel = String.fromCharCode(8594);
        MacUIKeyLabelProvider.downArrowUnicodeLabel = String.fromCharCode(8595);
        return MacUIKeyLabelProvider;
    }());
    exports.MacUIKeyLabelProvider = MacUIKeyLabelProvider;
    /**
     * Aria label provider for Mac.
     */
    var AriaKeyLabelProvider = (function () {
        function AriaKeyLabelProvider() {
            this.ctrlKeyLabel = nls.localize(1, null);
            this.shiftKeyLabel = nls.localize(2, null);
            this.altKeyLabel = nls.localize(3, null);
            this.cmdKeyLabel = nls.localize(4, null);
            this.windowsKeyLabel = nls.localize(5, null);
            this.modifierSeparator = '+';
        }
        AriaKeyLabelProvider.prototype.getLabelForKey = function (keyCode) {
            return KeyCode.toString(keyCode);
        };
        AriaKeyLabelProvider.INSTANCE = new MacUIKeyLabelProvider();
        return AriaKeyLabelProvider;
    }());
    exports.AriaKeyLabelProvider = AriaKeyLabelProvider;
    /**
     * Print for Windows, Linux UI
     */
    var ClassicUIKeyLabelProvider = (function () {
        function ClassicUIKeyLabelProvider() {
            this.ctrlKeyLabel = nls.localize(6, null);
            this.shiftKeyLabel = nls.localize(7, null);
            this.altKeyLabel = nls.localize(8, null);
            this.cmdKeyLabel = nls.localize(9, null);
            this.windowsKeyLabel = nls.localize(10, null);
            this.modifierSeparator = '+';
        }
        ClassicUIKeyLabelProvider.prototype.getLabelForKey = function (keyCode) {
            return KeyCode.toString(keyCode);
        };
        ClassicUIKeyLabelProvider.INSTANCE = new ClassicUIKeyLabelProvider();
        return ClassicUIKeyLabelProvider;
    }());
    exports.ClassicUIKeyLabelProvider = ClassicUIKeyLabelProvider;
    /**
     * Print for the user settings file.
     */
    var UserSettingsKeyLabelProvider = (function () {
        function UserSettingsKeyLabelProvider() {
            this.ctrlKeyLabel = 'Ctrl';
            this.shiftKeyLabel = 'Shift';
            this.altKeyLabel = 'Alt';
            this.cmdKeyLabel = 'Meta';
            this.windowsKeyLabel = 'Meta';
            this.modifierSeparator = '+';
        }
        UserSettingsKeyLabelProvider.prototype.getLabelForKey = function (keyCode) {
            return USER_SETTINGS.fromKeyCode(keyCode);
        };
        UserSettingsKeyLabelProvider.INSTANCE = new UserSettingsKeyLabelProvider();
        return UserSettingsKeyLabelProvider;
    }());
    function _asString(keybinding, labelProvider, Platform) {
        var result = [], ctrlCmd = BinaryKeybindings.hasCtrlCmd(keybinding), shift = BinaryKeybindings.hasShift(keybinding), alt = BinaryKeybindings.hasAlt(keybinding), winCtrl = BinaryKeybindings.hasWinCtrl(keybinding), keyCode = BinaryKeybindings.extractKeyCode(keybinding);
        var keyLabel = labelProvider.getLabelForKey(keyCode);
        if (!keyLabel) {
            // cannot trigger this key code under this kb layout
            return '';
        }
        // translate modifier keys: Ctrl-Shift-Alt-Meta
        if ((ctrlCmd && !Platform.isMacintosh) || (winCtrl && Platform.isMacintosh)) {
            result.push(labelProvider.ctrlKeyLabel);
        }
        if (shift) {
            result.push(labelProvider.shiftKeyLabel);
        }
        if (alt) {
            result.push(labelProvider.altKeyLabel);
        }
        if (ctrlCmd && Platform.isMacintosh) {
            result.push(labelProvider.cmdKeyLabel);
        }
        if (winCtrl && !Platform.isMacintosh) {
            result.push(labelProvider.windowsKeyLabel);
        }
        // the actual key
        result.push(keyLabel);
        var actualResult = result.join(labelProvider.modifierSeparator);
        if (BinaryKeybindings.hasChord(keybinding)) {
            return actualResult + ' ' + _asString(BinaryKeybindings.extractChordPart(keybinding), labelProvider, Platform);
        }
        return actualResult;
    }
    function _pushKey(result, str) {
        if (result.length > 0) {
            result.push({
                tagName: 'span',
                text: '+'
            });
        }
        result.push({
            tagName: 'span',
            className: 'monaco-kbkey',
            text: str
        });
    }
    function _asHTML(keybinding, labelProvider, Platform, isChord) {
        if (isChord === void 0) { isChord = false; }
        var result = [], ctrlCmd = BinaryKeybindings.hasCtrlCmd(keybinding), shift = BinaryKeybindings.hasShift(keybinding), alt = BinaryKeybindings.hasAlt(keybinding), winCtrl = BinaryKeybindings.hasWinCtrl(keybinding), keyCode = BinaryKeybindings.extractKeyCode(keybinding);
        var keyLabel = labelProvider.getLabelForKey(keyCode);
        if (!keyLabel) {
            // cannot trigger this key code under this kb layout
            return [];
        }
        // translate modifier keys: Ctrl-Shift-Alt-Meta
        if ((ctrlCmd && !Platform.isMacintosh) || (winCtrl && Platform.isMacintosh)) {
            _pushKey(result, labelProvider.ctrlKeyLabel);
        }
        if (shift) {
            _pushKey(result, labelProvider.shiftKeyLabel);
        }
        if (alt) {
            _pushKey(result, labelProvider.altKeyLabel);
        }
        if (ctrlCmd && Platform.isMacintosh) {
            _pushKey(result, labelProvider.cmdKeyLabel);
        }
        if (winCtrl && !Platform.isMacintosh) {
            _pushKey(result, labelProvider.windowsKeyLabel);
        }
        // the actual key
        _pushKey(result, keyLabel);
        var chordTo = null;
        if (BinaryKeybindings.hasChord(keybinding)) {
            chordTo = _asHTML(BinaryKeybindings.extractChordPart(keybinding), labelProvider, Platform, true);
            result.push({
                tagName: 'span',
                text: ' '
            });
            result = result.concat(chordTo);
        }
        if (isChord) {
            return result;
        }
        return [{
                tagName: 'span',
                className: 'monaco-kb',
                children: result
            }];
    }
});

define("vs/nls!vs/base/common/severity",['vs/nls', 'vs/nls!vs/workbench/node/pluginHostProcess'], function(nls, data) { return nls.create("vs/base/common/severity", data); });
define("vs/base/common/severity", ["require", "exports", 'vs/nls!vs/base/common/severity', 'vs/base/common/strings'], function (require, exports, nls, strings) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Severity;
    (function (Severity) {
        Severity[Severity["Ignore"] = 0] = "Ignore";
        Severity[Severity["Info"] = 1] = "Info";
        Severity[Severity["Warning"] = 2] = "Warning";
        Severity[Severity["Error"] = 3] = "Error";
    })(Severity || (Severity = {}));
    var Severity;
    (function (Severity) {
        var _error = 'error', _warning = 'warning', _warn = 'warn', _info = 'info';
        var _displayStrings = Object.create(null);
        _displayStrings[Severity.Error] = nls.localize(0, null);
        _displayStrings[Severity.Warning] = nls.localize(1, null);
        _displayStrings[Severity.Info] = nls.localize(2, null);
        /**
         * Parses 'error', 'warning', 'warn', 'info' in call casings
         * and falls back to ignore.
         */
        function fromValue(value) {
            if (!value) {
                return Severity.Ignore;
            }
            if (strings.equalsIgnoreCase(_error, value)) {
                return Severity.Error;
            }
            if (strings.equalsIgnoreCase(_warning, value) || strings.equalsIgnoreCase(_warn, value)) {
                return Severity.Warning;
            }
            if (strings.equalsIgnoreCase(_info, value)) {
                return Severity.Info;
            }
            return Severity.Ignore;
        }
        Severity.fromValue = fromValue;
        function toString(value) {
            return _displayStrings[value] || strings.empty;
        }
        Severity.toString = toString;
        function compare(a, b) {
            return b - a;
        }
        Severity.compare = compare;
    })(Severity || (Severity = {}));
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Severity;
});

define("vs/nls!vs/base/node/zip",['vs/nls', 'vs/nls!vs/workbench/node/pluginHostProcess'], function(nls, data) { return nls.create("vs/base/node/zip", data); });
define("vs/nls!vs/editor/common/config/defaultConfig",['vs/nls', 'vs/nls!vs/workbench/node/pluginHostProcess'], function(nls, data) { return nls.create("vs/editor/common/config/defaultConfig", data); });
define("vs/editor/common/config/defaultConfig", ["require", "exports", 'vs/nls!vs/editor/common/config/defaultConfig'], function (require, exports, nls) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\|;:\'",.<>/?';
    exports.DEFAULT_INDENTATION = {
        tabSize: 4,
        insertSpaces: true,
        detectIndentation: true
    };
    var ConfigClass = (function () {
        function ConfigClass() {
            this.editor = {
                experimentalScreenReader: true,
                rulers: [],
                wordSeparators: exports.USUAL_WORD_SEPARATORS,
                selectionClipboard: false,
                ariaLabel: nls.localize(0, null),
                lineNumbers: true,
                selectOnLineNumbers: true,
                lineNumbersMinChars: 5,
                glyphMargin: false,
                lineDecorationsWidth: 10,
                revealHorizontalRightPadding: 30,
                roundedSelection: true,
                theme: 'vs',
                readOnly: false,
                scrollbar: {
                    verticalScrollbarSize: 14,
                    horizontal: 'auto',
                    useShadows: true,
                    verticalHasArrows: false,
                    horizontalHasArrows: false
                },
                overviewRulerLanes: 2,
                cursorBlinking: 'blink',
                cursorStyle: 'line',
                fontLigatures: false,
                hideCursorInOverviewRuler: false,
                scrollBeyondLastLine: true,
                automaticLayout: false,
                wrappingColumn: 300,
                wrappingIndent: 'same',
                wordWrapBreakBeforeCharacters: '{([+',
                wordWrapBreakAfterCharacters: ' \t})]?|&,;',
                wordWrapBreakObtrusiveCharacters: '.',
                tabFocusMode: false,
                // stopLineTokenizationAfter
                // stopRenderingLineAfter
                longLineBoundary: 300,
                forcedTokenizationBoundary: 1000,
                // Features
                hover: true,
                contextmenu: true,
                mouseWheelScrollSensitivity: 1,
                quickSuggestions: true,
                quickSuggestionsDelay: 10,
                iconsInSuggestions: true,
                autoClosingBrackets: true,
                formatOnType: false,
                suggestOnTriggerCharacters: true,
                acceptSuggestionOnEnter: true,
                selectionHighlight: true,
                outlineMarkers: false,
                referenceInfos: true,
                folding: true,
                renderWhitespace: false,
                fontFamily: '',
                fontSize: 0,
                lineHeight: 0
            };
        }
        return ConfigClass;
    }());
    exports.DefaultConfig = new ConfigClass();
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("vs/editor/common/model/textModel", ["require", "exports", 'vs/base/common/eventEmitter', 'vs/base/common/strings', 'vs/editor/common/core/position', 'vs/editor/common/core/range', 'vs/editor/common/editorCommon', 'vs/editor/common/model/modelLine', 'vs/editor/common/model/indentationGuesser', 'vs/editor/common/config/defaultConfig'], function (require, exports, eventEmitter_1, strings, position_1, range_1, editorCommon, modelLine_1, indentationGuesser_1, defaultConfig_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var LIMIT_FIND_COUNT = 999;
    var TextModel = (function (_super) {
        __extends(TextModel, _super);
        function TextModel(allowedEventTypes, rawText) {
            allowedEventTypes.push(editorCommon.EventType.ModelContentChanged, editorCommon.EventType.ModelOptionsChanged);
            _super.call(this, allowedEventTypes);
            this._options = rawText.options;
            this._constructLines(rawText);
            this._setVersionId(1);
            this._isDisposed = false;
            this._isDisposing = false;
        }
        TextModel.prototype.getOptions = function () {
            if (this._isDisposed) {
                throw new Error('TextModel.getOptions: Model is disposed');
            }
            return this._options;
        };
        TextModel.prototype.updateOptions = function (newOpts) {
            var somethingChanged = false;
            var changed = {
                tabSize: false,
                insertSpaces: false
            };
            if (typeof newOpts.insertSpaces !== 'undefined') {
                if (this._options.insertSpaces !== newOpts.insertSpaces) {
                    somethingChanged = true;
                    changed.insertSpaces = true;
                    this._options.insertSpaces = newOpts.insertSpaces;
                }
            }
            if (typeof newOpts.tabSize !== 'undefined') {
                if (this._options.tabSize !== newOpts.tabSize) {
                    somethingChanged = true;
                    changed.tabSize = true;
                    this._options.tabSize = newOpts.tabSize;
                }
            }
            if (somethingChanged) {
                this.emit(editorCommon.EventType.ModelOptionsChanged, changed);
            }
        };
        TextModel.prototype.detectIndentation = function (defaultInsertSpaces, defaultTabSize) {
            var lines = this._lines.map(function (line) { return line.text; });
            var guessedIndentation = indentationGuesser_1.guessIndentation(lines, defaultTabSize, defaultInsertSpaces);
            this.updateOptions({
                insertSpaces: guessedIndentation.insertSpaces,
                tabSize: guessedIndentation.tabSize
            });
        };
        TextModel.prototype._normalizeIndentationFromWhitespace = function (str) {
            var tabSize = this._options.tabSize;
            var insertSpaces = this._options.insertSpaces;
            var spacesCnt = 0;
            for (var i = 0; i < str.length; i++) {
                if (str.charAt(i) === '\t') {
                    spacesCnt += tabSize;
                }
                else {
                    spacesCnt++;
                }
            }
            var result = '';
            if (!insertSpaces) {
                var tabsCnt = Math.floor(spacesCnt / tabSize);
                spacesCnt = spacesCnt % tabSize;
                for (var i = 0; i < tabsCnt; i++) {
                    result += '\t';
                }
            }
            for (var i = 0; i < spacesCnt; i++) {
                result += ' ';
            }
            return result;
        };
        TextModel.prototype.normalizeIndentation = function (str) {
            var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);
            if (firstNonWhitespaceIndex === -1) {
                firstNonWhitespaceIndex = str.length;
            }
            return this._normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex)) + str.substring(firstNonWhitespaceIndex);
        };
        TextModel.prototype.getOneIndent = function () {
            var tabSize = this._options.tabSize;
            var insertSpaces = this._options.insertSpaces;
            if (insertSpaces) {
                var result = '';
                for (var i = 0; i < tabSize; i++) {
                    result += ' ';
                }
                return result;
            }
            else {
                return '\t';
            }
        };
        TextModel.prototype.getVersionId = function () {
            if (this._isDisposed) {
                throw new Error('TextModel.getVersionId: Model is disposed');
            }
            return this._versionId;
        };
        TextModel.prototype.getAlternativeVersionId = function () {
            if (this._isDisposed) {
                throw new Error('TextModel.getAlternativeVersionId: Model is disposed');
            }
            return this._alternativeVersionId;
        };
        TextModel.prototype._increaseVersionId = function () {
            this._setVersionId(this._versionId + 1);
        };
        TextModel.prototype._setVersionId = function (newVersionId) {
            this._versionId = newVersionId;
            this._alternativeVersionId = this._versionId;
        };
        TextModel.prototype._overwriteAlternativeVersionId = function (newAlternativeVersionId) {
            this._alternativeVersionId = newAlternativeVersionId;
        };
        TextModel.prototype.isDisposed = function () {
            return this._isDisposed;
        };
        TextModel.prototype.dispose = function () {
            if (this._isDisposed) {
                throw new Error('TextModel.dispose: Model is disposed');
            }
            this._isDisposed = true;
            // Null out members, such that any use of a disposed model will throw exceptions sooner rather than later
            this._lines = null;
            this._EOL = null;
            this._BOM = null;
            _super.prototype.dispose.call(this);
        };
        TextModel.prototype._createContentChangedFlushEvent = function () {
            return {
                changeType: editorCommon.EventType.ModelContentChangedFlush,
                detail: null,
                // TODO@Alex -> remove these fields from here
                versionId: -1,
                isUndoing: false,
                isRedoing: false
            };
        };
        TextModel.prototype._emitContentChanged2 = function (startLineNumber, startColumn, endLineNumber, endColumn, rangeLength, text, isUndoing, isRedoing) {
            var e = {
                range: new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn),
                rangeLength: rangeLength,
                text: text,
                eol: this._EOL,
                versionId: this.getVersionId(),
                isUndoing: isUndoing,
                isRedoing: isRedoing
            };
            if (!this._isDisposing) {
                this.emit(editorCommon.EventType.ModelContentChanged2, e);
            }
        };
        TextModel.prototype._resetValue = function (e, newValue) {
            this._constructLines(newValue);
            this._increaseVersionId();
            e.detail = this.toRawText();
            e.versionId = this._versionId;
        };
        TextModel.prototype.toRawText = function () {
            return {
                BOM: this._BOM,
                EOL: this._EOL,
                lines: this.getLinesContent(),
                length: this.getValueLength(),
                options: this._options
            };
        };
        TextModel.prototype.equals = function (other) {
            if (this._BOM !== other.BOM) {
                return false;
            }
            if (this._EOL !== other.EOL) {
                return false;
            }
            if (this._lines.length !== other.lines.length) {
                return false;
            }
            for (var i = 0, len = this._lines.length; i < len; i++) {
                if (this._lines[i].text !== other.lines[i]) {
                    return false;
                }
            }
            return true;
        };
        TextModel.prototype.setValue = function (value) {
            if (this._isDisposed) {
                throw new Error('TextModel.setValue: Model is disposed');
            }
            var rawText = null;
            if (value !== null) {
                rawText = TextModel.toRawText(value, {
                    tabSize: this._options.tabSize,
                    insertSpaces: this._options.insertSpaces,
                    detectIndentation: false,
                    defaultEOL: this._options.defaultEOL
                });
            }
            this.setValueFromRawText(rawText);
        };
        TextModel.prototype.setValueFromRawText = function (newValue) {
            if (this._isDisposed) {
                throw new Error('TextModel.setValueFromRawText: Model is disposed');
            }
            if (newValue === null) {
                // There's nothing to do
                return;
            }
            var oldFullModelRange = this.getFullModelRange();
            var oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);
            var endLineNumber = this.getLineCount();
            var endColumn = this.getLineMaxColumn(endLineNumber);
            var e = this._createContentChangedFlushEvent();
            this._resetValue(e, newValue);
            this._emitModelContentChangedFlushEvent(e);
            this._emitContentChanged2(1, 1, endLineNumber, endColumn, oldModelValueLength, this.getValue(), false, false);
        };
        TextModel.prototype.getValue = function (eol, preserveBOM) {
            if (preserveBOM === void 0) { preserveBOM = false; }
            if (this._isDisposed) {
                throw new Error('TextModel.getValue: Model is disposed');
            }
            var fullModelRange = this.getFullModelRange();
            var fullModelValue = this.getValueInRange(fullModelRange, eol);
            if (preserveBOM) {
                return this._BOM + fullModelValue;
            }
            return fullModelValue;
        };
        TextModel.prototype.getValueLength = function (eol, preserveBOM) {
            if (preserveBOM === void 0) { preserveBOM = false; }
            if (this._isDisposed) {
                throw new Error('TextModel.getValueLength: Model is disposed');
            }
            var fullModelRange = this.getFullModelRange();
            var fullModelValue = this.getValueLengthInRange(fullModelRange, eol);
            if (preserveBOM) {
                return this._BOM.length + fullModelValue;
            }
            return fullModelValue;
        };
        TextModel.prototype.getEmptiedValueInRange = function (rawRange, fillCharacter, eol) {
            if (fillCharacter === void 0) { fillCharacter = ''; }
            if (eol === void 0) { eol = editorCommon.EndOfLinePreference.TextDefined; }
            if (this._isDisposed) {
                throw new Error('TextModel.getEmptiedValueInRange: Model is disposed');
            }
            var range = this.validateRange(rawRange);
            if (range.isEmpty()) {
                return '';
            }
            if (range.startLineNumber === range.endLineNumber) {
                return this._repeatCharacter(fillCharacter, range.endColumn - range.startColumn);
            }
            var lineEnding = this._getEndOfLine(eol), startLineIndex = range.startLineNumber - 1, endLineIndex = range.endLineNumber - 1, resultLines = [];
            resultLines.push(this._repeatCharacter(fillCharacter, this._lines[startLineIndex].text.length - range.startColumn + 1));
            for (var i = startLineIndex + 1; i < endLineIndex; i++) {
                resultLines.push(this._repeatCharacter(fillCharacter, this._lines[i].text.length));
            }
            resultLines.push(this._repeatCharacter(fillCharacter, range.endColumn - 1));
            return resultLines.join(lineEnding);
        };
        TextModel.prototype._repeatCharacter = function (fillCharacter, count) {
            var r = '';
            for (var i = 0; i < count; i++) {
                r += fillCharacter;
            }
            return r;
        };
        TextModel.prototype.getValueInRange = function (rawRange, eol) {
            if (eol === void 0) { eol = editorCommon.EndOfLinePreference.TextDefined; }
            if (this._isDisposed) {
                throw new Error('TextModel.getValueInRange: Model is disposed');
            }
            var range = this.validateRange(rawRange);
            if (range.isEmpty()) {
                return '';
            }
            if (range.startLineNumber === range.endLineNumber) {
                return this._lines[range.startLineNumber - 1].text.substring(range.startColumn - 1, range.endColumn - 1);
            }
            var lineEnding = this._getEndOfLine(eol), startLineIndex = range.startLineNumber - 1, endLineIndex = range.endLineNumber - 1, resultLines = [];
            resultLines.push(this._lines[startLineIndex].text.substring(range.startColumn - 1));
            for (var i = startLineIndex + 1; i < endLineIndex; i++) {
                resultLines.push(this._lines[i].text);
            }
            resultLines.push(this._lines[endLineIndex].text.substring(0, range.endColumn - 1));
            return resultLines.join(lineEnding);
        };
        TextModel.prototype.getValueLengthInRange = function (rawRange, eol) {
            if (eol === void 0) { eol = editorCommon.EndOfLinePreference.TextDefined; }
            if (this._isDisposed) {
                throw new Error('TextModel.getValueInRange: Model is disposed');
            }
            var range = this.validateRange(rawRange);
            if (range.isEmpty()) {
                return 0;
            }
            if (range.startLineNumber === range.endLineNumber) {
                return (range.endColumn - range.startColumn);
            }
            var lineEndingLength = this._getEndOfLine(eol).length, startLineIndex = range.startLineNumber - 1, endLineIndex = range.endLineNumber - 1, result = 0;
            result += (this._lines[startLineIndex].text.length - range.startColumn + 1);
            for (var i = startLineIndex + 1; i < endLineIndex; i++) {
                result += lineEndingLength + this._lines[i].text.length;
            }
            result += lineEndingLength + (range.endColumn - 1);
            return result;
        };
        TextModel.prototype.isDominatedByLongLines = function (longLineBoundary) {
            if (this._isDisposed) {
                throw new Error('TextModel.isDominatedByLongLines: Model is disposed');
            }
            var smallLineCharCount = 0, longLineCharCount = 0, i, len, lines = this._lines, lineLength;
            for (i = 0, len = this._lines.length; i < len; i++) {
                lineLength = lines[i].text.length;
                if (lineLength >= longLineBoundary) {
                    longLineCharCount += lineLength;
                }
                else {
                    smallLineCharCount += lineLength;
                }
            }
            return (longLineCharCount > smallLineCharCount);
        };
        TextModel.prototype.getLineCount = function () {
            if (this._isDisposed) {
                throw new Error('TextModel.getLineCount: Model is disposed');
            }
            return this._lines.length;
        };
        TextModel.prototype.getLineContent = function (lineNumber) {
            if (this._isDisposed) {
                throw new Error('TextModel.getLineContent: Model is disposed');
            }
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
            }
            return this._lines[lineNumber - 1].text;
        };
        TextModel.prototype.getLinesContent = function () {
            if (this._isDisposed) {
                throw new Error('TextModel.getLineContent: Model is disposed');
            }
            var r = [];
            for (var i = 0, len = this._lines.length; i < len; i++) {
                r[i] = this._lines[i].text;
            }
            return r;
        };
        TextModel.prototype.getEOL = function () {
            if (this._isDisposed) {
                throw new Error('TextModel.getEOL: Model is disposed');
            }
            return this._EOL;
        };
        TextModel.prototype.setEOL = function (eol) {
            var newEOL = (eol === editorCommon.EndOfLineSequence.CRLF ? '\r\n' : '\n');
            if (this._EOL === newEOL) {
                // Nothing to do
                return;
            }
            var oldFullModelRange = this.getFullModelRange();
            var oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);
            var endLineNumber = this.getLineCount();
            var endColumn = this.getLineMaxColumn(endLineNumber);
            this._EOL = newEOL;
            this._increaseVersionId();
            var e = this._createContentChangedFlushEvent();
            e.detail = this.toRawText();
            e.versionId = this._versionId;
            this._emitModelContentChangedFlushEvent(e);
            this._emitContentChanged2(1, 1, endLineNumber, endColumn, oldModelValueLength, this.getValue(), false, false);
        };
        TextModel.prototype.getLineMinColumn = function (lineNumber) {
            return 1;
        };
        TextModel.prototype.getLineMaxColumn = function (lineNumber) {
            if (this._isDisposed) {
                throw new Error('TextModel.getLineMaxColumn: Model is disposed');
            }
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
            }
            return this._lines[lineNumber - 1].text.length + 1;
        };
        TextModel.prototype.getLineFirstNonWhitespaceColumn = function (lineNumber) {
            if (this._isDisposed) {
                throw new Error('TextModel.getLineFirstNonWhitespaceColumn: Model is disposed');
            }
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
            }
            var result = strings.firstNonWhitespaceIndex(this._lines[lineNumber - 1].text);
            if (result === -1) {
                return 0;
            }
            return result + 1;
        };
        TextModel.prototype.getLineLastNonWhitespaceColumn = function (lineNumber) {
            if (this._isDisposed) {
                throw new Error('TextModel.getLineLastNonWhitespaceColumn: Model is disposed');
            }
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
            }
            var result = strings.lastNonWhitespaceIndex(this._lines[lineNumber - 1].text);
            if (result === -1) {
                return 0;
            }
            return result + 2;
        };
        TextModel.prototype.validateLineNumber = function (lineNumber) {
            if (this._isDisposed) {
                throw new Error('TextModel.validateLineNumber: Model is disposed');
            }
            if (lineNumber < 1) {
                lineNumber = 1;
            }
            if (lineNumber > this._lines.length) {
                lineNumber = this._lines.length;
            }
            return lineNumber;
        };
        TextModel.prototype.validatePosition = function (position) {
            if (this._isDisposed) {
                throw new Error('TextModel.validatePosition: Model is disposed');
            }
            var lineNumber = position.lineNumber ? position.lineNumber : 1;
            var column = position.column ? position.column : 1;
            if (lineNumber < 1) {
                lineNumber = 1;
            }
            if (lineNumber > this._lines.length) {
                lineNumber = this._lines.length;
            }
            if (column < 1) {
                column = 1;
            }
            var maxColumn = this.getLineMaxColumn(lineNumber);
            if (column > maxColumn) {
                column = maxColumn;
            }
            return new position_1.Position(lineNumber, column);
        };
        TextModel.prototype.validateRange = function (range) {
            if (this._isDisposed) {
                throw new Error('TextModel.validateRange: Model is disposed');
            }
            var start = this.validatePosition(new position_1.Position(range.startLineNumber, range.startColumn));
            var end = this.validatePosition(new position_1.Position(range.endLineNumber, range.endColumn));
            return new range_1.Range(start.lineNumber, start.column, end.lineNumber, end.column);
        };
        TextModel.prototype.modifyPosition = function (rawPosition, offset) {
            if (this._isDisposed) {
                throw new Error('TextModel.modifyPosition: Model is disposed');
            }
            var position = this.validatePosition(rawPosition);
            // Handle positive offsets, one line at a time
            while (offset > 0) {
                var maxColumn = this.getLineMaxColumn(position.lineNumber);
                // Get to end of line
                if (position.column < maxColumn) {
                    var subtract = Math.min(offset, maxColumn - position.column);
                    offset -= subtract;
                    position.column += subtract;
                }
                if (offset === 0) {
                    break;
                }
                // Go to next line
                offset -= this._EOL.length;
                if (offset < 0) {
                    throw new Error('TextModel.modifyPosition: Breaking line terminators');
                }
                ++position.lineNumber;
                if (position.lineNumber > this._lines.length) {
                    throw new Error('TextModel.modifyPosition: Offset goes beyond the end of the model');
                }
                position.column = 1;
            }
            // Handle negative offsets, one line at a time
            while (offset < 0) {
                // Get to the start of the line
                if (position.column > 1) {
                    var add = Math.min(-offset, position.column - 1);
                    offset += add;
                    position.column -= add;
                }
                if (offset === 0) {
                    break;
                }
                // Go to the previous line
                offset += this._EOL.length;
                if (offset > 0) {
                    throw new Error('TextModel.modifyPosition: Breaking line terminators');
                }
                --position.lineNumber;
                if (position.lineNumber < 1) {
                    throw new Error('TextModel.modifyPosition: Offset goes beyond the beginning of the model');
                }
                position.column = this.getLineMaxColumn(position.lineNumber);
            }
            return position;
        };
        TextModel.prototype.getFullModelRange = function () {
            if (this._isDisposed) {
                throw new Error('TextModel.getFullModelRange: Model is disposed');
            }
            var lineCount = this.getLineCount();
            return new range_1.Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));
        };
        TextModel.prototype._emitModelContentChangedFlushEvent = function (e) {
            if (!this._isDisposing) {
                this.emit(editorCommon.EventType.ModelContentChanged, e);
            }
        };
        TextModel.toRawText = function (rawText, opts) {
            // Count the number of lines that end with \r\n
            var carriageReturnCnt = 0, lastCarriageReturnIndex = -1;
            while ((lastCarriageReturnIndex = rawText.indexOf('\r', lastCarriageReturnIndex + 1)) !== -1) {
                carriageReturnCnt++;
            }
            // Split the text into liens
            var lines = rawText.split(/\r\n|\r|\n/);
            // Remove the BOM (if present)
            var BOM = '';
            if (strings.startsWithUTF8BOM(lines[0])) {
                BOM = strings.UTF8_BOM_CHARACTER;
                lines[0] = lines[0].substr(1);
            }
            var lineFeedCnt = lines.length - 1;
            var EOL = '';
            if (lineFeedCnt === 0) {
                // This is an empty file or a file with precisely one line
                EOL = (opts.defaultEOL === editorCommon.DefaultEndOfLine.LF ? '\n' : '\r\n');
            }
            else if (carriageReturnCnt > lineFeedCnt / 2) {
                // More than half of the file contains \r\n ending lines
                EOL = '\r\n';
            }
            else {
                // At least one line more ends in \n
                EOL = '\n';
            }
            var resolvedOpts;
            if (opts.detectIndentation) {
                var guessedIndentation = indentationGuesser_1.guessIndentation(lines, opts.tabSize, opts.insertSpaces);
                resolvedOpts = {
                    tabSize: guessedIndentation.tabSize,
                    insertSpaces: guessedIndentation.insertSpaces,
                    defaultEOL: opts.defaultEOL
                };
            }
            else {
                resolvedOpts = {
                    tabSize: opts.tabSize,
                    insertSpaces: opts.insertSpaces,
                    defaultEOL: opts.defaultEOL
                };
            }
            return {
                BOM: BOM,
                EOL: EOL,
                lines: lines,
                length: rawText.length,
                options: resolvedOpts
            };
        };
        TextModel.prototype._constructLines = function (rawText) {
            var rawLines = rawText.lines, modelLines = [], i, len;
            for (i = 0, len = rawLines.length; i < len; i++) {
                modelLines.push(new modelLine_1.ModelLine(i + 1, rawLines[i]));
            }
            this._BOM = rawText.BOM;
            this._EOL = rawText.EOL;
            this._lines = modelLines;
        };
        TextModel.prototype._getEndOfLine = function (eol) {
            switch (eol) {
                case editorCommon.EndOfLinePreference.LF:
                    return '\n';
                case editorCommon.EndOfLinePreference.CRLF:
                    return '\r\n';
                case editorCommon.EndOfLinePreference.TextDefined:
                    return this.getEOL();
            }
            throw new Error('Unknown EOL preference');
        };
        TextModel.prototype.findMatches = function (searchString, rawSearchScope, isRegex, matchCase, wholeWord, limitResultCount) {
            if (limitResultCount === void 0) { limitResultCount = LIMIT_FIND_COUNT; }
            if (this._isDisposed) {
                throw new Error('Model.findMatches: Model is disposed');
            }
            var regex = strings.createSafeRegExp(searchString, isRegex, matchCase, wholeWord);
            if (!regex) {
                return [];
            }
            var searchRange;
            if (range_1.Range.isIRange(rawSearchScope)) {
                searchRange = rawSearchScope;
            }
            else {
                searchRange = this.getFullModelRange();
            }
            return this._doFindMatches(searchRange, regex, limitResultCount);
        };
        TextModel.prototype.findNextMatch = function (searchString, rawSearchStart, isRegex, matchCase, wholeWord) {
            if (this._isDisposed) {
                throw new Error('Model.findNextMatch: Model is disposed');
            }
            var regex = strings.createSafeRegExp(searchString, isRegex, matchCase, wholeWord);
            if (!regex) {
                return null;
            }
            var searchStart = this.validatePosition(rawSearchStart), lineCount = this.getLineCount(), startLineNumber = searchStart.lineNumber, text, r;
            // Look in first line
            text = this._lines[startLineNumber - 1].text.substring(searchStart.column - 1);
            r = this._findMatchInLine(regex, text, startLineNumber, searchStart.column - 1);
            if (r) {
                return r;
            }
            for (var i = 1; i <= lineCount; i++) {
                var lineIndex = (startLineNumber + i - 1) % lineCount;
                text = this._lines[lineIndex].text;
                r = this._findMatchInLine(regex, text, lineIndex + 1, 0);
                if (r) {
                    return r;
                }
            }
            return null;
        };
        TextModel.prototype.findPreviousMatch = function (searchString, rawSearchStart, isRegex, matchCase, wholeWord) {
            if (this._isDisposed) {
                throw new Error('Model.findPreviousMatch: Model is disposed');
            }
            var regex = strings.createSafeRegExp(searchString, isRegex, matchCase, wholeWord);
            if (!regex) {
                return null;
            }
            var searchStart = this.validatePosition(rawSearchStart), lineCount = this.getLineCount(), startLineNumber = searchStart.lineNumber, text, r;
            // Look in first line
            text = this._lines[startLineNumber - 1].text.substring(0, searchStart.column - 1);
            r = this._findLastMatchInLine(regex, text, startLineNumber);
            if (r) {
                return r;
            }
            for (var i = 1; i <= lineCount; i++) {
                var lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;
                text = this._lines[lineIndex].text;
                r = this._findLastMatchInLine(regex, text, lineIndex + 1);
                if (r) {
                    return r;
                }
            }
            return null;
        };
        TextModel.prototype._doFindMatches = function (searchRange, searchRegex, limitResultCount) {
            var result = [], text, counter = 0;
            // Early case for a search range that starts & stops on the same line number
            if (searchRange.startLineNumber === searchRange.endLineNumber) {
                text = this._lines[searchRange.startLineNumber - 1].text.substring(searchRange.startColumn - 1, searchRange.endColumn - 1);
                counter = this._findMatchesInLine(searchRegex, text, searchRange.startLineNumber, searchRange.startColumn - 1, counter, result, limitResultCount);
                return result;
            }
            // Collect results from first line
            text = this._lines[searchRange.startLineNumber - 1].text.substring(searchRange.startColumn - 1);
            counter = this._findMatchesInLine(searchRegex, text, searchRange.startLineNumber, searchRange.startColumn - 1, counter, result, limitResultCount);
            // Collect results from middle lines
            for (var lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && counter < limitResultCount; lineNumber++) {
                counter = this._findMatchesInLine(searchRegex, this._lines[lineNumber - 1].text, lineNumber, 0, counter, result, limitResultCount);
            }
            // Collect results from last line
            if (counter < limitResultCount) {
                text = this._lines[searchRange.endLineNumber - 1].text.substring(0, searchRange.endColumn - 1);
                counter = this._findMatchesInLine(searchRegex, text, searchRange.endLineNumber, 0, counter, result, limitResultCount);
            }
            return result;
        };
        TextModel.prototype._findMatchInLine = function (searchRegex, text, lineNumber, deltaOffset) {
            var m = searchRegex.exec(text);
            if (!m) {
                return null;
            }
            return new range_1.Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset);
        };
        TextModel.prototype._findLastMatchInLine = function (searchRegex, text, lineNumber) {
            var bestResult = null;
            var m;
            while ((m = searchRegex.exec(text))) {
                var result = new range_1.Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length);
                if (result.equalsRange(bestResult)) {
                    break;
                }
                bestResult = result;
            }
            return bestResult;
        };
        TextModel.prototype._findMatchesInLine = function (searchRegex, text, lineNumber, deltaOffset, counter, result, limitResultCount) {
            var m;
            // Reset regex to search from the beginning
            searchRegex.lastIndex = 0;
            do {
                m = searchRegex.exec(text);
                if (m) {
                    var range = new range_1.Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset);
                    // Exit early if the regex matches the same range
                    if (range.equalsRange(result[result.length - 1])) {
                        return counter;
                    }
                    result.push(range);
                    counter++;
                    if (counter >= limitResultCount) {
                        return counter;
                    }
                }
            } while (m);
            return counter;
        };
        TextModel.DEFAULT_CREATION_OPTIONS = {
            tabSize: defaultConfig_1.DEFAULT_INDENTATION.tabSize,
            insertSpaces: defaultConfig_1.DEFAULT_INDENTATION.insertSpaces,
            detectIndentation: false,
            defaultEOL: editorCommon.DefaultEndOfLine.LF
        };
        return TextModel;
    }(eventEmitter_1.OrderGuaranteeEventEmitter));
    exports.TextModel = TextModel;
    var RawText = (function () {
        function RawText() {
        }
        RawText.fromString = function (rawText, opts) {
            return TextModel.toRawText(rawText, opts);
        };
        RawText.fromStringWithModelOptions = function (rawText, model) {
            var opts = model.getOptions();
            return TextModel.toRawText(rawText, {
                tabSize: opts.tabSize,
                insertSpaces: opts.insertSpaces,
                detectIndentation: false,
                defaultEOL: opts.defaultEOL
            });
        };
        return RawText;
    }());
    exports.RawText = RawText;
});

define("vs/editor/common/modes/nullMode", ["require", "exports", 'vs/editor/common/config/defaultConfig'], function (require, exports, defaultConfig_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var NullState = (function () {
        function NullState(mode, stateData) {
            this.mode = mode;
            this.stateData = stateData;
        }
        NullState.prototype.clone = function () {
            var stateDataClone = (this.stateData ? this.stateData.clone() : null);
            return new NullState(this.mode, stateDataClone);
        };
        NullState.prototype.equals = function (other) {
            if (this.mode !== other.getMode()) {
                return false;
            }
            var otherStateData = other.getStateData();
            if (!this.stateData && !otherStateData) {
                return true;
            }
            if (this.stateData && otherStateData) {
                return this.stateData.equals(otherStateData);
            }
            return false;
        };
        NullState.prototype.getMode = function () {
            return this.mode;
        };
        NullState.prototype.tokenize = function (stream) {
            stream.advanceToEOS();
            return { type: '' };
        };
        NullState.prototype.getStateData = function () {
            return this.stateData;
        };
        NullState.prototype.setStateData = function (stateData) {
            this.stateData = stateData;
        };
        return NullState;
    }());
    exports.NullState = NullState;
    var NullMode = (function () {
        function NullMode() {
            this.richEditSupport = {
                wordDefinition: NullMode.DEFAULT_WORD_REGEXP
            };
        }
        /**
         * Create a word definition regular expression based on default word separators.
         * Optionally provide allowed separators that should be included in words.
         *
         * The default would look like this:
         * /(-?\d*\.\d\w*)|([^\`\~\!\@\#\$\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g
         */
        NullMode.createWordRegExp = function (allowInWords) {
            if (allowInWords === void 0) { allowInWords = ''; }
            var usualSeparators = defaultConfig_1.USUAL_WORD_SEPARATORS;
            var source = '(-?\\d*\\.\\d\\w*)|([^';
            for (var i = 0; i < usualSeparators.length; i++) {
                if (allowInWords.indexOf(usualSeparators[i]) >= 0) {
                    continue;
                }
                source += '\\' + usualSeparators[i];
            }
            source += '\\s]+)';
            return new RegExp(source, 'g');
        };
        NullMode.prototype.getId = function () {
            return NullMode.ID;
        };
        NullMode.prototype.toSimplifiedMode = function () {
            return this;
        };
        // catches numbers (including floating numbers) in the first group, and alphanum in the second
        NullMode.DEFAULT_WORD_REGEXP = NullMode.createWordRegExp();
        NullMode.ID = 'vs.editor.modes.nullMode';
        return NullMode;
    }());
    exports.NullMode = NullMode;
    function nullTokenize(mode, buffer, state, deltaOffset, stopAtOffset) {
        if (deltaOffset === void 0) { deltaOffset = 0; }
        var tokens = [
            {
                startIndex: deltaOffset,
                type: ''
            }
        ];
        var modeTransitions = [
            {
                startIndex: deltaOffset,
                mode: mode
            }
        ];
        return {
            tokens: tokens,
            actualStopOffset: deltaOffset + buffer.length,
            endState: state,
            modeTransitions: modeTransitions
        };
    }
    exports.nullTokenize = nullTokenize;
});

define("vs/editor/common/model/textModelWithTokensHelpers", ["require", "exports", 'vs/editor/common/core/arrays', 'vs/editor/common/modes/nullMode'], function (require, exports, arrays_1, nullMode_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var WordHelper = (function () {
        function WordHelper() {
        }
        WordHelper._safeGetWordDefinition = function (mode) {
            return (mode.richEditSupport ? mode.richEditSupport.wordDefinition : null);
        };
        WordHelper.ensureValidWordDefinition = function (wordDefinition) {
            var result = nullMode_1.NullMode.DEFAULT_WORD_REGEXP;
            if (wordDefinition && (wordDefinition instanceof RegExp)) {
                if (!wordDefinition.global) {
                    var flags = 'g';
                    if (wordDefinition.ignoreCase) {
                        flags += 'i';
                    }
                    if (wordDefinition.multiline) {
                        flags += 'm';
                    }
                    result = new RegExp(wordDefinition.source, flags);
                }
                else {
                    result = wordDefinition;
                }
            }
            result.lastIndex = 0;
            return result;
        };
        WordHelper.massageWordDefinitionOf = function (mode) {
            return WordHelper.ensureValidWordDefinition(WordHelper._safeGetWordDefinition(mode));
        };
        WordHelper.getWords = function (textSource, lineNumber) {
            if (!textSource._lineIsTokenized(lineNumber)) {
                return WordHelper._getWordsInText(textSource.getLineContent(lineNumber), WordHelper.massageWordDefinitionOf(textSource.getMode()));
            }
            var r = [], txt = textSource.getLineContent(lineNumber);
            if (txt.length > 0) {
                var modeTransitions = textSource._getLineModeTransitions(lineNumber), i, len, k, lenK, currentModeStartIndex, currentModeEndIndex, currentWordDefinition, currentModeText, words, startWord, endWord, word;
                // Go through all the modes
                for (i = 0, currentModeStartIndex = 0, len = modeTransitions.length; i < len; i++) {
                    currentWordDefinition = WordHelper.massageWordDefinitionOf(modeTransitions[i].mode);
                    currentModeStartIndex = modeTransitions[i].startIndex;
                    currentModeEndIndex = (i + 1 < len ? modeTransitions[i + 1].startIndex : txt.length);
                    currentModeText = txt.substring(currentModeStartIndex, currentModeEndIndex);
                    words = currentModeText.match(currentWordDefinition);
                    if (!words) {
                        continue;
                    }
                    endWord = 0;
                    for (k = 0, lenK = words.length; k < lenK; k++) {
                        word = words[k];
                        if (word.length > 0) {
                            startWord = currentModeText.indexOf(word, endWord);
                            endWord = startWord + word.length;
                            r.push({
                                start: currentModeStartIndex + startWord,
                                end: currentModeStartIndex + endWord
                            });
                        }
                    }
                }
            }
            return r;
        };
        WordHelper._getWordsInText = function (text, wordDefinition) {
            var words = text.match(wordDefinition) || [], k, startWord, endWord, startColumn, endColumn, word, r = [];
            for (k = 0; k < words.length; k++) {
                word = words[k].trim();
                if (word.length > 0) {
                    startWord = text.indexOf(word, endWord);
                    endWord = startWord + word.length;
                    startColumn = startWord;
                    endColumn = endWord;
                    r.push({
                        start: startColumn,
                        end: endColumn
                    });
                }
            }
            return r;
        };
        WordHelper._getWordAtColumn = function (txt, column, modeIndex, modeTransitions) {
            var modeStartIndex = modeTransitions[modeIndex].startIndex, modeEndIndex = (modeIndex + 1 < modeTransitions.length ? modeTransitions[modeIndex + 1].startIndex : txt.length), mode = modeTransitions[modeIndex].mode;
            return WordHelper._getWordAtText(column, WordHelper.massageWordDefinitionOf(mode), txt.substring(modeStartIndex, modeEndIndex), modeStartIndex);
        };
        WordHelper.getWordAtPosition = function (textSource, position) {
            if (!textSource._lineIsTokenized(position.lineNumber)) {
                return WordHelper._getWordAtText(position.column, WordHelper.massageWordDefinitionOf(textSource.getMode()), textSource.getLineContent(position.lineNumber), 0);
            }
            var result = null;
            var txt = textSource.getLineContent(position.lineNumber), modeTransitions = textSource._getLineModeTransitions(position.lineNumber), columnIndex = position.column - 1, modeIndex = arrays_1.Arrays.findIndexInSegmentsArray(modeTransitions, columnIndex);
            result = WordHelper._getWordAtColumn(txt, position.column, modeIndex, modeTransitions);
            if (!result && modeIndex > 0 && modeTransitions[modeIndex].startIndex === columnIndex) {
                // The position is right at the beginning of `modeIndex`, so try looking at `modeIndex` - 1 too
                result = WordHelper._getWordAtColumn(txt, position.column, modeIndex - 1, modeTransitions);
            }
            return result;
        };
        WordHelper._getWordAtText = function (column, wordDefinition, text, textOffset) {
            // console.log('_getWordAtText: ', column, text, textOffset);
            var words = text.match(wordDefinition), k, startWord, endWord, startColumn, endColumn, word;
            if (words) {
                for (k = 0; k < words.length; k++) {
                    word = words[k].trim();
                    if (word.length > 0) {
                        startWord = text.indexOf(word, endWord);
                        endWord = startWord + word.length;
                        startColumn = textOffset + startWord + 1;
                        endColumn = textOffset + endWord + 1;
                        if (startColumn <= column && column <= endColumn) {
                            return {
                                word: word,
                                startColumn: startColumn,
                                endColumn: endColumn
                            };
                        }
                    }
                }
            }
            return null;
        };
        return WordHelper;
    }());
    exports.WordHelper = WordHelper;
});

define("vs/editor/common/modes/supports/richEditSupport", ["require", "exports", 'vs/editor/common/modes/nullMode', 'vs/editor/common/modes/supports/characterPair', 'vs/editor/common/modes/supports/electricCharacter', 'vs/editor/common/modes/supports/onEnter', 'vs/editor/common/modes/supports/richEditBrackets'], function (require, exports, nullMode_1, characterPair_1, electricCharacter_1, onEnter_1, richEditBrackets_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var RichEditSupport = (function () {
        function RichEditSupport(modeId, previous, rawConf) {
            var prev = null;
            if (previous instanceof RichEditSupport) {
                prev = previous._conf;
            }
            this._conf = RichEditSupport._mergeConf(prev, rawConf);
            if (this._conf.brackets) {
                this.brackets = new richEditBrackets_1.RichEditBrackets(modeId, this._conf.brackets);
            }
            this._handleOnEnter(modeId, this._conf);
            this._handleComments(modeId, this._conf);
            if (this._conf.__characterPairSupport) {
                this.characterPair = new characterPair_1.CharacterPairSupport(modeId, this._conf.__characterPairSupport);
            }
            if (this._conf.__electricCharacterSupport || this._conf.brackets) {
                this.electricCharacter = new electricCharacter_1.BracketElectricCharacterSupport(modeId, this.brackets, this._conf.__electricCharacterSupport);
            }
            this.wordDefinition = this._conf.wordPattern || nullMode_1.NullMode.DEFAULT_WORD_REGEXP;
        }
        RichEditSupport._mergeConf = function (prev, current) {
            return {
                comments: (prev ? current.comments || prev.comments : current.comments),
                brackets: (prev ? current.brackets || prev.brackets : current.brackets),
                wordPattern: (prev ? current.wordPattern || prev.wordPattern : current.wordPattern),
                indentationRules: (prev ? current.indentationRules || prev.indentationRules : current.indentationRules),
                onEnterRules: (prev ? current.onEnterRules || prev.onEnterRules : current.onEnterRules),
                __electricCharacterSupport: (prev ? current.__electricCharacterSupport || prev.__electricCharacterSupport : current.__electricCharacterSupport),
                __characterPairSupport: (prev ? current.__characterPairSupport || prev.__characterPairSupport : current.__characterPairSupport),
            };
        };
        RichEditSupport.prototype._handleOnEnter = function (modeId, conf) {
            // on enter
            var onEnter = {};
            var empty = true;
            if (conf.brackets) {
                empty = false;
                onEnter.brackets = conf.brackets;
            }
            if (conf.indentationRules) {
                empty = false;
                onEnter.indentationRules = conf.indentationRules;
            }
            if (conf.onEnterRules) {
                empty = false;
                onEnter.regExpRules = conf.onEnterRules;
            }
            if (!empty) {
                this.onEnter = new onEnter_1.OnEnterSupport(modeId, onEnter);
            }
        };
        RichEditSupport.prototype._handleComments = function (modeId, conf) {
            var commentRule = conf.comments;
            // comment configuration
            if (commentRule) {
                this.comments = {};
                if (commentRule.lineComment) {
                    this.comments.lineCommentToken = commentRule.lineComment;
                }
                if (commentRule.blockComment) {
                    var _a = commentRule.blockComment, blockStart = _a[0], blockEnd = _a[1];
                    this.comments.blockCommentStartToken = blockStart;
                    this.comments.blockCommentEndToken = blockEnd;
                }
            }
        };
        return RichEditSupport;
    }());
    exports.RichEditSupport = RichEditSupport;
});

define("vs/editor/common/modes/supports/tokenizationSupport", ["require", "exports", 'vs/editor/common/modes/lineStream', 'vs/editor/common/modes/nullMode', 'vs/editor/common/modes/supports'], function (require, exports, lineStream_1, nullMode_1, supports_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function isFunction(something) {
        return typeof something === 'function';
    }
    var TokenizationSupport = (function () {
        function TokenizationSupport(mode, customization, supportsNestedModes, shouldGenerateEmbeddedModels) {
            this._mode = mode;
            this.customization = customization;
            this.supportsNestedModes = supportsNestedModes;
            this._embeddedModesListeners = {};
            if (this.supportsNestedModes) {
                if (!this._mode.registerSupport) {
                    throw new Error('Cannot be a mode with nested modes unless I can emit a tokenizationSupport changed event!');
                }
            }
            this.shouldGenerateEmbeddedModels = shouldGenerateEmbeddedModels;
            this.defaults = {
                enterNestedMode: !isFunction(customization.enterNestedMode),
                getNestedMode: !isFunction(customization.getNestedMode),
                getNestedModeInitialState: !isFunction(customization.getNestedModeInitialState),
                getLeavingNestedModeData: !isFunction(customization.getLeavingNestedModeData),
                onReturningFromNestedMode: !isFunction(customization.onReturningFromNestedMode)
            };
        }
        TokenizationSupport.prototype.dispose = function () {
            for (var listener in this._embeddedModesListeners) {
                this._embeddedModesListeners[listener].dispose();
                delete this._embeddedModesListeners[listener];
            }
        };
        TokenizationSupport.prototype.getInitialState = function () {
            return this.customization.getInitialState();
        };
        TokenizationSupport.prototype.tokenize = function (line, state, deltaOffset, stopAtOffset) {
            if (deltaOffset === void 0) { deltaOffset = 0; }
            if (stopAtOffset === void 0) { stopAtOffset = deltaOffset + line.length; }
            if (state.getMode() !== this._mode) {
                return this._nestedTokenize(line, state, deltaOffset, stopAtOffset, [], []);
            }
            else {
                return this._myTokenize(line, state, deltaOffset, stopAtOffset, [], []);
            }
        };
        /**
         * Precondition is: nestedModeState.getMode() !== this
         * This means we are in a nested mode when parsing starts on this line.
         */
        TokenizationSupport.prototype._nestedTokenize = function (buffer, nestedModeState, deltaOffset, stopAtOffset, prependTokens, prependModeTransitions) {
            var myStateBeforeNestedMode = nestedModeState.getStateData();
            var leavingNestedModeData = this.getLeavingNestedModeData(buffer, myStateBeforeNestedMode);
            // Be sure to give every embedded mode the
            // opportunity to leave nested mode.
            // i.e. Don't go straight to the most nested mode
            var stepOnceNestedState = nestedModeState;
            while (stepOnceNestedState.getStateData() && stepOnceNestedState.getStateData().getMode() !== this._mode) {
                stepOnceNestedState = stepOnceNestedState.getStateData();
            }
            var nestedMode = stepOnceNestedState.getMode();
            if (!leavingNestedModeData) {
                // tokenization will not leave nested mode
                var result;
                if (nestedMode.tokenizationSupport) {
                    result = nestedMode.tokenizationSupport.tokenize(buffer, nestedModeState, deltaOffset, stopAtOffset);
                }
                else {
                    // The nested mode doesn't have tokenization support,
                    // unfortunatelly this means we have to fake it
                    result = nullMode_1.nullTokenize(nestedMode, buffer, nestedModeState, deltaOffset);
                }
                result.tokens = prependTokens.concat(result.tokens);
                result.modeTransitions = prependModeTransitions.concat(result.modeTransitions);
                return result;
            }
            var nestedModeBuffer = leavingNestedModeData.nestedModeBuffer;
            if (nestedModeBuffer.length > 0) {
                // Tokenize with the nested mode
                var nestedModeLineTokens;
                if (nestedMode.tokenizationSupport) {
                    nestedModeLineTokens = nestedMode.tokenizationSupport.tokenize(nestedModeBuffer, nestedModeState, deltaOffset, stopAtOffset);
                }
                else {
                    // The nested mode doesn't have tokenization support,
                    // unfortunatelly this means we have to fake it
                    nestedModeLineTokens = nullMode_1.nullTokenize(nestedMode, nestedModeBuffer, nestedModeState, deltaOffset);
                }
                // Save last state of nested mode
                nestedModeState = nestedModeLineTokens.endState;
                // Prepend nested mode's result to our result
                prependTokens = prependTokens.concat(nestedModeLineTokens.tokens);
                prependModeTransitions = prependModeTransitions.concat(nestedModeLineTokens.modeTransitions);
            }
            var bufferAfterNestedMode = leavingNestedModeData.bufferAfterNestedMode;
            var myStateAfterNestedMode = leavingNestedModeData.stateAfterNestedMode;
            myStateAfterNestedMode.setStateData(myStateBeforeNestedMode.getStateData());
            this.onReturningFromNestedMode(myStateAfterNestedMode, nestedModeState);
            return this._myTokenize(bufferAfterNestedMode, myStateAfterNestedMode, deltaOffset + nestedModeBuffer.length, stopAtOffset, prependTokens, prependModeTransitions);
        };
        /**
         * Precondition is: state.getMode() === this
         * This means we are in the current mode when parsing starts on this line.
         */
        TokenizationSupport.prototype._myTokenize = function (buffer, myState, deltaOffset, stopAtOffset, prependTokens, prependModeTransitions) {
            var _this = this;
            var lineStream = new lineStream_1.LineStream(buffer);
            var tokenResult, beforeTokenizeStreamPos;
            var previousType = null;
            var retokenize = null;
            myState = myState.clone();
            if (prependModeTransitions.length <= 0 || prependModeTransitions[prependModeTransitions.length - 1].mode !== this._mode) {
                // Avoid transitioning to the same mode (this can happen in case of empty embedded modes)
                prependModeTransitions.push({
                    startIndex: deltaOffset,
                    mode: this._mode
                });
            }
            var maxPos = Math.min(stopAtOffset - deltaOffset, buffer.length);
            while (lineStream.pos() < maxPos) {
                beforeTokenizeStreamPos = lineStream.pos();
                do {
                    tokenResult = myState.tokenize(lineStream);
                    if (tokenResult === null || tokenResult === undefined ||
                        ((tokenResult.type === undefined || tokenResult.type === null) &&
                            (tokenResult.nextState === undefined || tokenResult.nextState === null))) {
                        throw new Error('Tokenizer must return a valid state');
                    }
                    if (tokenResult.nextState) {
                        tokenResult.nextState.setStateData(myState.getStateData());
                        myState = tokenResult.nextState;
                    }
                    if (lineStream.pos() <= beforeTokenizeStreamPos) {
                        throw new Error('Stream did not advance while tokenizing. Mode id is ' + this._mode.getId() + ' (stuck at token type: "' + tokenResult.type + '", prepend tokens: "' + (prependTokens.map(function (t) { return t.type; }).join(',')) + '").');
                    }
                } while (!tokenResult.type && tokenResult.type !== '');
                if (previousType !== tokenResult.type || tokenResult.dontMergeWithPrev || previousType === null) {
                    prependTokens.push(new supports_1.Token(beforeTokenizeStreamPos + deltaOffset, tokenResult.type));
                }
                previousType = tokenResult.type;
                if (this.supportsNestedModes && this.enterNestedMode(myState)) {
                    var currentEmbeddedLevels = this._getEmbeddedLevel(myState);
                    if (currentEmbeddedLevels < TokenizationSupport.MAX_EMBEDDED_LEVELS) {
                        var nestedModeState = this.getNestedModeInitialState(myState);
                        // Re-emit tokenizationSupport change events from all modes that I ever embedded
                        var embeddedMode = nestedModeState.state.getMode();
                        if (typeof embeddedMode.addSupportChangedListener === 'function' && !this._embeddedModesListeners.hasOwnProperty(embeddedMode.getId())) {
                            var emitting = false;
                            this._embeddedModesListeners[embeddedMode.getId()] = embeddedMode.addSupportChangedListener(function (e) {
                                if (emitting) {
                                    return;
                                }
                                if (e.tokenizationSupport) {
                                    emitting = true;
                                    _this._mode.registerSupport('tokenizationSupport', function (mode) {
                                        return mode.tokenizationSupport;
                                    });
                                    emitting = false;
                                }
                            });
                        }
                        if (!lineStream.eos()) {
                            // There is content from the embedded mode
                            var restOfBuffer = buffer.substr(lineStream.pos());
                            var result = this._nestedTokenize(restOfBuffer, nestedModeState.state, deltaOffset + lineStream.pos(), stopAtOffset, prependTokens, prependModeTransitions);
                            result.retokenize = result.retokenize || nestedModeState.missingModePromise;
                            return result;
                        }
                        else {
                            // Transition to the nested mode state
                            myState = nestedModeState.state;
                            retokenize = nestedModeState.missingModePromise;
                        }
                    }
                }
            }
            return {
                tokens: prependTokens,
                actualStopOffset: lineStream.pos() + deltaOffset,
                modeTransitions: prependModeTransitions,
                endState: myState,
                retokenize: retokenize
            };
        };
        TokenizationSupport.prototype._getEmbeddedLevel = function (state) {
            var result = -1;
            while (state) {
                result++;
                state = state.getStateData();
            }
            return result;
        };
        TokenizationSupport.prototype.enterNestedMode = function (state) {
            if (this.defaults.enterNestedMode) {
                return false;
            }
            return this.customization.enterNestedMode(state);
        };
        TokenizationSupport.prototype.getNestedMode = function (state) {
            if (this.defaults.getNestedMode) {
                return null;
            }
            return this.customization.getNestedMode(state);
        };
        TokenizationSupport._validatedNestedMode = function (input) {
            var mode = new nullMode_1.NullMode(), missingModePromise = null;
            if (input && input.mode) {
                mode = input.mode;
            }
            if (input && input.missingModePromise) {
                missingModePromise = input.missingModePromise;
            }
            return {
                mode: mode,
                missingModePromise: missingModePromise
            };
        };
        TokenizationSupport.prototype.getNestedModeInitialState = function (state) {
            if (this.defaults.getNestedModeInitialState) {
                var nestedMode = TokenizationSupport._validatedNestedMode(this.getNestedMode(state));
                var missingModePromise = nestedMode.missingModePromise;
                var nestedModeState;
                if (nestedMode.mode.tokenizationSupport) {
                    nestedModeState = nestedMode.mode.tokenizationSupport.getInitialState();
                }
                else {
                    nestedModeState = new nullMode_1.NullState(nestedMode.mode, null);
                }
                nestedModeState.setStateData(state);
                return {
                    state: nestedModeState,
                    missingModePromise: missingModePromise
                };
            }
            return this.customization.getNestedModeInitialState(state);
        };
        TokenizationSupport.prototype.getLeavingNestedModeData = function (line, state) {
            if (this.defaults.getLeavingNestedModeData) {
                return null;
            }
            return this.customization.getLeavingNestedModeData(line, state);
        };
        TokenizationSupport.prototype.onReturningFromNestedMode = function (myStateAfterNestedMode, lastNestedModeState) {
            if (this.defaults.onReturningFromNestedMode) {
                return null;
            }
            return this.customization.onReturningFromNestedMode(myStateAfterNestedMode, lastNestedModeState);
        };
        TokenizationSupport.MAX_EMBEDDED_LEVELS = 5;
        return TokenizationSupport;
    }());
    exports.TokenizationSupport = TokenizationSupport;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("vs/editor/common/modes/monarch/monarchLexer", ["require", "exports", 'vs/editor/common/modes/abstractState', 'vs/editor/common/modes/lineStream', 'vs/editor/common/modes/monarch/monarchCommon', 'vs/editor/common/modes/supports/tokenizationSupport'], function (require, exports, abstractState_1, lineStream_1, monarchCommon, tokenizationSupport_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * The MonarchLexer class implements a monaco lexer that highlights source code.
     * It takes a compiled lexer to guide the tokenizer and maintains a stack of
     * lexer states.
     */
    var MonarchLexer = (function (_super) {
        __extends(MonarchLexer, _super);
        function MonarchLexer(mode, modeService, lexer, stack, embeddedMode) {
            _super.call(this, mode);
            this.id = MonarchLexer.ID++; // for debugging, assigns unique id to each instance
            this.modeService = modeService;
            this.lexer = lexer; // (compiled) lexer description
            this.stack = (stack ? stack : [lexer.start]); // stack of states
            this.embeddedMode = (embeddedMode ? embeddedMode : null); // are we scanning an embedded section?
            // did we encounter an embedded start on this line?
            // no need for cloning or equality since it is used only within a line
            this.embeddedEntered = false;
            // regular expression group matching
            // these never need cloning or equality since they are only used within a line match
            this.groupActions = null;
            this.groupMatches = null;
            this.groupMatched = null;
            this.groupRule = null;
        }
        MonarchLexer.prototype.makeClone = function () {
            return new MonarchLexer(this.getMode(), this.modeService, this.lexer, this.stack.slice(0), this.embeddedMode);
        };
        MonarchLexer.prototype.equals = function (other) {
            if (!_super.prototype.equals.call(this, other)) {
                return false;
            }
            if (!(other instanceof MonarchLexer)) {
                return false;
            }
            var otherm = other;
            if ((this.stack.length !== otherm.stack.length) || (this.lexer.name !== otherm.lexer.name) ||
                (this.embeddedMode !== otherm.embeddedMode)) {
                return false;
            }
            var idx;
            for (idx in this.stack) {
                if (this.stack.hasOwnProperty(idx)) {
                    if (this.stack[idx] !== otherm.stack[idx]) {
                        return false;
                    }
                }
            }
            return true;
        };
        /**
         * The main tokenizer: this function gets called by monaco to tokenize lines
         * Note: we don't want to raise exceptions here and always keep going..
         *
         * TODO: there are many optimizations possible here for the common cases
         * but for now I concentrated on functionality and correctness.
         */
        MonarchLexer.prototype.tokenize = function (stream, noConsumeIsOk) {
            var stackLen0 = this.stack.length; // these are saved to check progress
            var groupLen0 = 0;
            var state = this.stack[0]; // the current state
            this.embeddedEntered = false;
            var matches = null;
            var matched = null;
            var action = null;
            var next = null;
            var rule = null;
            // check if we need to process group matches first
            if (this.groupActions) {
                groupLen0 = this.groupActions.length;
                matches = this.groupMatches;
                matched = this.groupMatched.shift();
                action = this.groupActions.shift();
                rule = this.groupRule;
                // cleanup if necessary
                if (this.groupActions.length === 0) {
                    this.groupActions = null;
                    this.groupMatches = null;
                    this.groupMatched = null;
                    this.groupRule = null;
                }
            }
            else {
                // nothing to do
                if (stream.eos()) {
                    return { type: '' };
                }
                // get the entire line
                var line = stream.advanceToEOS();
                stream.goBack(line.length);
                // get the rules for this state
                var rules = this.lexer.tokenizer[state];
                if (!rules) {
                    rules = monarchCommon.findRules(this.lexer, state); // do parent matching
                }
                if (!rules) {
                    monarchCommon.throwError(this.lexer, 'tokenizer state is not defined: ' + state);
                }
                else {
                    // try each rule until we match
                    rule = null;
                    var pos = stream.pos();
                    var idx;
                    for (idx in rules) {
                        if (rules.hasOwnProperty(idx)) {
                            rule = rules[idx];
                            if (pos === 0 || !rule.matchOnlyAtLineStart) {
                                matches = line.match(rule.regex);
                                if (matches) {
                                    matched = matches[0];
                                    action = rule.action;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            // We matched 'rule' with 'matches' and 'action'
            if (!matches) {
                matches = [''];
                matched = '';
            }
            if (!action) {
                // bad: we didn't match anything, and there is no action to take
                // we need to advance the stream or we get progress trouble
                if (!stream.eos()) {
                    matches = [stream.peek()];
                    matched = matches[0];
                }
                action = this.lexer.defaultToken;
            }
            // advance stream
            stream.advance(matched.length);
            // maybe call action function (used for 'cases')
            while (action.test) {
                var callres = action.test(matched, matches, state, stream.eos());
                action = callres;
            }
            // set the result: either a string or an array of actions
            var result = null;
            if (typeof (action) === 'string' || Array.isArray(action)) {
                result = action;
            }
            else if (action.group) {
                result = action.group;
            }
            else if (action.token !== null && action.token !== undefined) {
                result = action.token;
                // do $n replacements?
                if (action.tokenSubst) {
                    result = monarchCommon.substituteMatches(this.lexer, result, matched, matches, state);
                }
                // enter embedded mode?
                if (action.nextEmbedded) {
                    if (action.nextEmbedded === '@pop') {
                        if (!this.embeddedMode) {
                            monarchCommon.throwError(this.lexer, 'cannot pop embedded mode if not inside one');
                        }
                        this.embeddedMode = null;
                    }
                    else if (this.embeddedMode) {
                        monarchCommon.throwError(this.lexer, 'cannot enter embedded mode from within an embedded mode');
                    }
                    else {
                        this.embeddedMode = monarchCommon.substituteMatches(this.lexer, action.nextEmbedded, matched, matches, state);
                        // substitute language alias to known modes to support syntax highlighting
                        var embeddedMode = this.modeService.getModeIdForLanguageName(this.embeddedMode);
                        if (this.embeddedMode && embeddedMode) {
                            this.embeddedMode = embeddedMode;
                        }
                        this.embeddedEntered = true;
                    }
                }
                // state transformations
                if (action.goBack) {
                    stream.goBack(action.goBack);
                }
                if (action.switchTo && typeof action.switchTo === 'string') {
                    var nextState = monarchCommon.substituteMatches(this.lexer, action.switchTo, matched, matches, state); // switch state without a push...
                    if (nextState[0] === '@') {
                        nextState = nextState.substr(1); // peel off starting '@'
                    }
                    if (!monarchCommon.findRules(this.lexer, nextState)) {
                        monarchCommon.throwError(this.lexer, 'trying to switch to a state \'' + nextState + '\' that is undefined in rule: ' + rule.name);
                    }
                    else {
                        this.stack[0] = nextState;
                    }
                    next = null;
                }
                else if (action.transform && typeof action.transform === 'function') {
                    this.stack = action.transform(this.stack); // if you need to do really funky stuff...
                    next = null;
                }
                else if (action.next) {
                    if (action.next === '@push') {
                        if (this.stack.length >= this.lexer.maxStack) {
                            monarchCommon.throwError(this.lexer, 'maximum tokenizer stack size reached: [' +
                                this.stack[0] + ',' + this.stack[1] + ',...,' +
                                this.stack[this.stack.length - 2] + ',' + this.stack[this.stack.length - 1] + ']');
                        }
                        else {
                            this.stack.unshift(state);
                        }
                    }
                    else if (action.next === '@pop') {
                        if (this.stack.length <= 1) {
                            monarchCommon.throwError(this.lexer, 'trying to pop an empty stack in rule: ' + rule.name);
                        }
                        else {
                            this.stack.shift();
                        }
                    }
                    else if (action.next === '@popall') {
                        if (this.stack.length > 1) {
                            this.stack = [this.stack[this.stack.length - 1]];
                        }
                    }
                    else {
                        var nextState = monarchCommon.substituteMatches(this.lexer, action.next, matched, matches, state);
                        if (nextState[0] === '@') {
                            nextState = nextState.substr(1); // peel off starting '@'
                        }
                        if (!monarchCommon.findRules(this.lexer, nextState)) {
                            monarchCommon.throwError(this.lexer, 'trying to set a next state \'' + nextState + '\' that is undefined in rule: ' + rule.name);
                        }
                        else {
                            this.stack.unshift(nextState);
                        }
                    }
                }
                if (action.log && typeof (action.log) === 'string') {
                    monarchCommon.log(this.lexer, this.lexer.displayName + ': ' + monarchCommon.substituteMatches(this.lexer, action.log, matched, matches, state));
                }
            }
            // check result
            if (result === null) {
                monarchCommon.throwError(this.lexer, 'lexer rule has no well-defined action in rule: ' + rule.name);
                result = this.lexer.defaultToken;
            }
            // is the result a group match?
            if (Array.isArray(result)) {
                if (this.groupActions && this.groupActions.length > 0) {
                    monarchCommon.throwError(this.lexer, 'groups cannot be nested: ' + rule.name);
                }
                if (matches.length !== result.length + 1) {
                    monarchCommon.throwError(this.lexer, 'matched number of groups does not match the number of actions in rule: ' + rule.name);
                }
                var totalLen = 0;
                for (var i = 1; i < matches.length; i++) {
                    totalLen += matches[i].length;
                }
                if (totalLen !== matched.length) {
                    monarchCommon.throwError(this.lexer, 'with groups, all characters should be matched in consecutive groups in rule: ' + rule.name);
                }
                this.groupMatches = matches;
                this.groupMatched = matches.slice(1);
                this.groupActions = result.slice(0);
                this.groupRule = rule;
                stream.goBack(matched.length);
                return this.tokenize(stream); // call recursively to initiate first result match
            }
            else {
                // check for '@rematch'
                if (result === '@rematch') {
                    stream.goBack(matched.length);
                    matched = ''; // better set the next state too..
                    matches = null;
                    result = '';
                }
                // check progress
                if (matched.length === 0) {
                    if (stackLen0 !== this.stack.length || state !== this.stack[0]
                        || (!this.groupActions ? 0 : this.groupActions.length) !== groupLen0) {
                        if (!noConsumeIsOk) {
                            return this.tokenize(stream); // tokenize again in the new state
                        }
                    }
                    else {
                        monarchCommon.throwError(this.lexer, 'no progress in tokenizer in rule: ' + rule.name);
                        stream.advanceToEOS(); // must make progress or editor loops
                    }
                }
                // return the result (and check for brace matching)
                // todo: for efficiency we could pre-sanitize tokenPostfix and substitutions
                if (result.indexOf('@brackets') === 0) {
                    var rest = result.substr('@brackets'.length);
                    var bracket = findBracket(this.lexer, matched);
                    if (!bracket) {
                        monarchCommon.throwError(this.lexer, '@brackets token returned but no bracket defined as: ' + matched);
                        bracket = { token: '', bracketType: monarchCommon.MonarchBracket.None };
                    }
                    return { type: monarchCommon.sanitize(bracket.token + rest) };
                }
                else {
                    var token = (result === '' ? '' : result + this.lexer.tokenPostfix);
                    return { type: monarchCommon.sanitize(token) };
                }
            }
        };
        MonarchLexer.ID = 0;
        return MonarchLexer;
    }(abstractState_1.AbstractState));
    exports.MonarchLexer = MonarchLexer;
    /**
     * Searches for a bracket in the 'brackets' attribute that matches the input.
     */
    function findBracket(lexer, matched) {
        if (!matched) {
            return null;
        }
        matched = monarchCommon.fixCase(lexer, matched);
        var brackets = lexer.brackets;
        for (var i = 0; i < brackets.length; i++) {
            var bracket = brackets[i];
            if (bracket.open === matched) {
                return { token: bracket.token, bracketType: monarchCommon.MonarchBracket.Open };
            }
            else if (bracket.close === matched) {
                return { token: bracket.token, bracketType: monarchCommon.MonarchBracket.Close };
            }
        }
        return null;
    }
    function createTokenizationSupport(modeService, mode, lexer) {
        return new tokenizationSupport_1.TokenizationSupport(mode, {
            getInitialState: function () {
                return new MonarchLexer(mode, modeService, lexer);
            },
            enterNestedMode: function (state) {
                if (state instanceof MonarchLexer) {
                    return state.embeddedEntered;
                }
                return false;
            },
            getNestedMode: function (rawState) {
                var mime = rawState.embeddedMode;
                if (!modeService.isRegisteredMode(mime)) {
                    // unknown mode
                    return {
                        mode: modeService.getMode('text/plain'),
                        missingModePromise: null
                    };
                }
                var mode = modeService.getMode(mime);
                if (mode) {
                    // mode is available
                    return {
                        mode: mode,
                        missingModePromise: null
                    };
                }
                // mode is not yet loaded
                return {
                    mode: modeService.getMode('text/plain'),
                    missingModePromise: modeService.getOrCreateMode(mime).then(function () { return null; })
                };
            },
            getLeavingNestedModeData: function (line, state) {
                // state = state.clone();
                var mstate = state.clone();
                var stream = new lineStream_1.LineStream(line);
                while (!stream.eos() && mstate.embeddedMode) {
                    mstate.tokenize(stream, true); // allow no consumption for @rematch
                }
                if (mstate.embeddedMode) {
                    return null; // don't leave yet
                }
                var end = stream.pos();
                return {
                    nestedModeBuffer: line.substring(0, end),
                    bufferAfterNestedMode: line.substring(end),
                    stateAfterNestedMode: mstate
                };
            }
        }, lexer.usesEmbedded, false);
    }
    exports.createTokenizationSupport = createTokenizationSupport;
});

define("vs/nls!vs/editor/common/modes/modesRegistry",['vs/nls', 'vs/nls!vs/workbench/node/pluginHostProcess'], function(nls, data) { return nls.create("vs/editor/common/modes/modesRegistry", data); });
define("vs/nls!vs/editor/common/services/bulkEdit",['vs/nls', 'vs/nls!vs/workbench/node/pluginHostProcess'], function(nls, data) { return nls.create("vs/editor/common/services/bulkEdit", data); });
define("vs/nls!vs/editor/common/services/modeServiceImpl",['vs/nls', 'vs/nls!vs/workbench/node/pluginHostProcess'], function(nls, data) { return nls.create("vs/editor/common/services/modeServiceImpl", data); });
define("vs/nls!vs/editor/contrib/rename/common/rename",['vs/nls', 'vs/nls!vs/workbench/node/pluginHostProcess'], function(nls, data) { return nls.create("vs/editor/contrib/rename/common/rename", data); });
define("vs/nls!vs/platform/extensions/common/abstractExtensionService",['vs/nls', 'vs/nls!vs/workbench/node/pluginHostProcess'], function(nls, data) { return nls.create("vs/platform/extensions/common/abstractExtensionService", data); });
define("vs/nls!vs/platform/extensions/common/extensionsRegistry",['vs/nls', 'vs/nls!vs/workbench/node/pluginHostProcess'], function(nls, data) { return nls.create("vs/platform/extensions/common/extensionsRegistry", data); });
define("vs/nls!vs/platform/extensions/node/extensionValidator",['vs/nls', 'vs/nls!vs/workbench/node/pluginHostProcess'], function(nls, data) { return nls.create("vs/platform/extensions/node/extensionValidator", data); });
define("vs/nls!vs/platform/jsonschemas/common/jsonContributionRegistry",['vs/nls', 'vs/nls!vs/workbench/node/pluginHostProcess'], function(nls, data) { return nls.create("vs/platform/jsonschemas/common/jsonContributionRegistry", data); });
define("vs/nls!vs/platform/message/common/message",['vs/nls', 'vs/nls!vs/workbench/node/pluginHostProcess'], function(nls, data) { return nls.create("vs/platform/message/common/message", data); });
define("vs/nls!vs/workbench/api/node/extHostMessageService",['vs/nls', 'vs/nls!vs/workbench/node/pluginHostProcess'], function(nls, data) { return nls.create("vs/workbench/api/node/extHostMessageService", data); });
define("vs/nls!vs/workbench/node/extensionHostMain",['vs/nls', 'vs/nls!vs/workbench/node/pluginHostProcess'], function(nls, data) { return nls.create("vs/workbench/node/extensionHostMain", data); });
define("vs/nls!vs/workbench/node/extensionPoints",['vs/nls', 'vs/nls!vs/workbench/node/pluginHostProcess'], function(nls, data) { return nls.create("vs/workbench/node/extensionPoints", data); });
define("vs/nls!vs/workbench/parts/extensions/common/extensions",['vs/nls', 'vs/nls!vs/workbench/node/pluginHostProcess'], function(nls, data) { return nls.create("vs/workbench/parts/extensions/common/extensions", data); });
define("vs/nls!vs/workbench/parts/extensions/node/extensionsService",['vs/nls', 'vs/nls!vs/workbench/node/pluginHostProcess'], function(nls, data) { return nls.create("vs/workbench/parts/extensions/node/extensionsService", data); });
define("vs/platform/extensions/common/ipcRemoteCom", ["require", "exports", 'vs/base/common/winjs.base', 'vs/base/common/marshalling', 'vs/base/common/errors'], function (require, exports, winjs, marshalling, errors) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var pendingRPCReplies = {};
    function createRPC(serializeAndSend) {
        var lastMessageId = 0;
        return function rpc(rpcId, method, args) {
            var req = String(++lastMessageId);
            var reply = {
                c: null,
                e: null,
                p: null
            };
            var r = new winjs.TPromise(function (c, e, p) {
                reply.c = c;
                reply.e = e;
                reply.p = p;
            }, function () {
                serializeAndSend({
                    cancel: req
                });
            });
            pendingRPCReplies[req] = reply;
            serializeAndSend({
                req: req,
                rpcId: rpcId,
                method: method,
                args: args
            });
            return r;
        };
    }
    function create(send) {
        var rpc = createRPC(marshallAndSend);
        var bigHandler = null;
        var invokedHandlers = Object.create(null);
        var messagesToSend = [];
        var messagesToReceive = [];
        var receiveOneMessage = function () {
            var rawmsg = messagesToReceive.shift();
            if (messagesToReceive.length > 0) {
                process.nextTick(receiveOneMessage);
            }
            var msg = marshalling.parse(rawmsg);
            if (msg.seq) {
                if (!pendingRPCReplies.hasOwnProperty(msg.seq)) {
                    console.warn('Got reply to unknown seq');
                    return;
                }
                var reply = pendingRPCReplies[msg.seq];
                delete pendingRPCReplies[msg.seq];
                if (msg.err) {
                    var err = msg.err;
                    if (msg.err.$isError) {
                        err = new Error();
                        err.name = msg.err.name;
                        err.message = msg.err.message;
                        err.stack = msg.err.stack;
                    }
                    reply.e(err);
                    return;
                }
                reply.c(msg.res);
                return;
            }
            if (msg.cancel) {
                if (invokedHandlers[msg.cancel]) {
                    invokedHandlers[msg.cancel].cancel();
                }
                return;
            }
            if (msg.err) {
                console.error(msg.err);
                return;
            }
            var rpcId = msg.rpcId;
            if (!bigHandler) {
                throw new Error('got message before big handler attached!');
            }
            var req = msg.req;
            invokedHandlers[req] = invokeHandler(rpcId, msg.method, msg.args);
            invokedHandlers[req].then(function (r) {
                delete invokedHandlers[req];
                marshallAndSend({
                    seq: req,
                    res: r
                });
            }, function (err) {
                delete invokedHandlers[req];
                marshallAndSend({
                    seq: req,
                    err: errors.transformErrorForSerialization(err)
                });
            });
        };
        var r = {
            callOnRemote: rpc,
            setManyHandler: function (_bigHandler) {
                bigHandler = _bigHandler;
            },
            handle: function (rawmsg) {
                // console.log('RECEIVED ' + rawmsg.length + ' MESSAGES.');
                if (messagesToReceive.length === 0) {
                    process.nextTick(receiveOneMessage);
                }
                messagesToReceive = messagesToReceive.concat(rawmsg);
            }
        };
        function sendAccumulated() {
            var tmp = messagesToSend;
            messagesToSend = [];
            // console.log('SENDING ' + tmp.length + ' MESSAGES.');
            send(tmp);
        }
        function marshallAndSend(msg) {
            var value = marshalling.stringify(msg);
            if (messagesToSend.length === 0) {
                process.nextTick(sendAccumulated);
            }
            messagesToSend.push(value);
        }
        function invokeHandler(rpcId, method, args) {
            try {
                return winjs.TPromise.as(bigHandler.handle(rpcId, method, args));
            }
            catch (err) {
                return winjs.TPromise.wrapError(err);
            }
        }
        return r;
    }
    exports.create = create;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("vs/platform/instantiation/common/descriptors", ["require", "exports", 'vs/base/common/errors'], function (require, exports, errors) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var AbstractDescriptor = (function () {
        function AbstractDescriptor(_staticArguments) {
            this._staticArguments = _staticArguments;
            // empty
        }
        AbstractDescriptor.prototype.appendStaticArguments = function (more) {
            this._staticArguments.push.apply(this._staticArguments, more);
        };
        AbstractDescriptor.prototype.staticArguments = function (nth) {
            if (isNaN(nth)) {
                return this._staticArguments.slice(0);
            }
            else {
                return this._staticArguments[nth];
            }
        };
        AbstractDescriptor.prototype._validate = function (type) {
            if (!type) {
                throw errors.illegalArgument('can not be falsy');
            }
        };
        return AbstractDescriptor;
    }());
    exports.AbstractDescriptor = AbstractDescriptor;
    var SyncDescriptor = (function (_super) {
        __extends(SyncDescriptor, _super);
        function SyncDescriptor(_ctor) {
            var staticArguments = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                staticArguments[_i - 1] = arguments[_i];
            }
            _super.call(this, staticArguments);
            this._ctor = _ctor;
        }
        Object.defineProperty(SyncDescriptor.prototype, "ctor", {
            get: function () {
                return this._ctor;
            },
            enumerable: true,
            configurable: true
        });
        SyncDescriptor.prototype.equals = function (other) {
            if (other === this) {
                return true;
            }
            if (!(other instanceof SyncDescriptor)) {
                return false;
            }
            return other.ctor === this.ctor;
        };
        SyncDescriptor.prototype.bind = function () {
            var moreStaticArguments = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                moreStaticArguments[_i - 0] = arguments[_i];
            }
            var allArgs = [];
            allArgs = allArgs.concat(this.staticArguments());
            allArgs = allArgs.concat(moreStaticArguments);
            return new (SyncDescriptor.bind.apply(SyncDescriptor, [void 0].concat([this._ctor], allArgs)))();
        };
        return SyncDescriptor;
    }(AbstractDescriptor));
    exports.SyncDescriptor = SyncDescriptor;
    exports.createSyncDescriptor = function (ctor) {
        var staticArguments = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            staticArguments[_i - 1] = arguments[_i];
        }
        return new (SyncDescriptor.bind.apply(SyncDescriptor, [void 0].concat([ctor], staticArguments)))();
    };
    var AsyncDescriptor = (function (_super) {
        __extends(AsyncDescriptor, _super);
        function AsyncDescriptor(_moduleName, _ctorName) {
            var staticArguments = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                staticArguments[_i - 2] = arguments[_i];
            }
            _super.call(this, staticArguments);
            this._moduleName = _moduleName;
            this._ctorName = _ctorName;
            if (typeof _moduleName !== 'string') {
                throw new Error('Invalid AsyncDescriptor arguments, expected `moduleName` to be a string!');
            }
        }
        AsyncDescriptor.create = function (moduleName, ctorName) {
            return new AsyncDescriptor(moduleName, ctorName);
        };
        Object.defineProperty(AsyncDescriptor.prototype, "moduleName", {
            get: function () {
                return this._moduleName;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AsyncDescriptor.prototype, "ctorName", {
            get: function () {
                return this._ctorName;
            },
            enumerable: true,
            configurable: true
        });
        AsyncDescriptor.prototype.equals = function (other) {
            if (other === this) {
                return true;
            }
            if (!(other instanceof AsyncDescriptor)) {
                return false;
            }
            return other.moduleName === this.moduleName &&
                other.ctorName === this.ctorName;
        };
        AsyncDescriptor.prototype.bind = function () {
            var moreStaticArguments = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                moreStaticArguments[_i - 0] = arguments[_i];
            }
            var allArgs = [];
            allArgs = allArgs.concat(this.staticArguments());
            allArgs = allArgs.concat(moreStaticArguments);
            return new (AsyncDescriptor.bind.apply(AsyncDescriptor, [void 0].concat([this.moduleName, this.ctorName], allArgs)))();
        };
        return AsyncDescriptor;
    }(AbstractDescriptor));
    exports.AsyncDescriptor = AsyncDescriptor;
    var _createAsyncDescriptor = function (moduleName, ctorName) {
        var staticArguments = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            staticArguments[_i - 2] = arguments[_i];
        }
        return new (AsyncDescriptor.bind.apply(AsyncDescriptor, [void 0].concat([moduleName, ctorName], staticArguments)))();
    };
    exports.createAsyncDescriptor0 = _createAsyncDescriptor;
    exports.createAsyncDescriptor1 = _createAsyncDescriptor;
    exports.createAsyncDescriptor2 = _createAsyncDescriptor;
    exports.createAsyncDescriptor3 = _createAsyncDescriptor;
    exports.createAsyncDescriptor4 = _createAsyncDescriptor;
    exports.createAsyncDescriptor5 = _createAsyncDescriptor;
    exports.createAsyncDescriptor6 = _createAsyncDescriptor;
    exports.createAsyncDescriptor7 = _createAsyncDescriptor;
});

define("vs/platform/instantiation/common/instantiation", ["require", "exports"], function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // ----------------------- internal util -----------------------
    var _util;
    (function (_util) {
        _util.DI_TARGET = '$di$target';
        _util.DI_DEPENDENCIES = '$di$dependencies';
        _util.DI_PROVIDES = '$di$provides_service';
        function getServiceId(id) {
            return id[_util.DI_PROVIDES];
        }
        _util.getServiceId = getServiceId;
        function getServiceDependencies(ctor) {
            return ctor[_util.DI_DEPENDENCIES];
        }
        _util.getServiceDependencies = getServiceDependencies;
    })(_util = exports._util || (exports._util = {}));
    exports.IInstantiationService = createDecorator('instantiationService');
    /**
     * A *only* valid way to create a {{ServiceIdentifier}}.
     */
    function createDecorator(serviceId) {
        var ret = function (target, key, index) {
            if (arguments.length !== 3) {
                throw new Error('@IServiceName-decorator can only be used to decorate a parameter');
            }
            if (target[_util.DI_TARGET] === target) {
                target[_util.DI_DEPENDENCIES].push({ serviceId: serviceId, index: index });
            }
            else {
                target[_util.DI_DEPENDENCIES] = [{ serviceId: serviceId, index: index }];
                target[_util.DI_TARGET] = target;
            }
        };
        ret[_util.DI_PROVIDES] = serviceId;
        // ret['type'] = undefined;
        return ret;
    }
    exports.createDecorator = createDecorator;
});

define("vs/editor/common/services/codeEditorService", ["require", "exports", 'vs/platform/instantiation/common/instantiation'], function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.ID_CODE_EDITOR_SERVICE = 'codeEditorService';
    exports.ICodeEditorService = instantiation_1.createDecorator(exports.ID_CODE_EDITOR_SERVICE);
});

define("vs/editor/common/services/editorWorkerService", ["require", "exports", 'vs/platform/instantiation/common/instantiation'], function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.ID_EDITOR_WORKER_SERVICE = 'editorWorkerService';
    exports.IEditorWorkerService = instantiation_1.createDecorator(exports.ID_EDITOR_WORKER_SERVICE);
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/editor/common/modes/abstractMode", ["require", "exports", 'vs/base/common/eventEmitter', 'vs/base/common/winjs.base', 'vs/platform/instantiation/common/descriptors', 'vs/editor/common/modes/nullMode', 'vs/editor/common/modes/supports/suggestSupport', 'vs/editor/common/services/editorWorkerService'], function (require, exports, eventEmitter_1, winjs_base_1, descriptors_1, nullMode_1, suggestSupport_1, editorWorkerService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function createWordRegExp(allowInWords) {
        if (allowInWords === void 0) { allowInWords = ''; }
        return nullMode_1.NullMode.createWordRegExp(allowInWords);
    }
    exports.createWordRegExp = createWordRegExp;
    var ModeWorkerManager = (function () {
        function ModeWorkerManager(descriptor, workerModuleId, workerClassName, superWorkerModuleId, instantiationService) {
            this._descriptor = descriptor;
            this._workerDescriptor = descriptors_1.createAsyncDescriptor2(workerModuleId, workerClassName);
            this._superWorkerModuleId = superWorkerModuleId;
            this._instantiationService = instantiationService;
            this._workerPiecePromise = null;
        }
        ModeWorkerManager.prototype.worker = function (runner) {
            return this._getOrCreateWorker().then(runner);
        };
        ModeWorkerManager.prototype._getOrCreateWorker = function () {
            var _this = this;
            if (!this._workerPiecePromise) {
                // TODO@Alex: workaround for missing `bundles` config
                // First, load the code of the worker super class
                var superWorkerCodePromise = (this._superWorkerModuleId ? ModeWorkerManager._loadModule(this._superWorkerModuleId) : winjs_base_1.TPromise.as(null));
                this._workerPiecePromise = superWorkerCodePromise.then(function () {
                    // Second, load the code of the worker (without instantiating it)
                    return ModeWorkerManager._loadModule(_this._workerDescriptor.moduleName);
                }).then(function () {
                    // Then, load & instantiate all the participants
                    var participants = _this._descriptor.workerParticipants;
                    return winjs_base_1.TPromise.join(participants.map(function (participant) {
                        return _this._instantiationService.createInstance(participant);
                    }));
                }).then(function (participants) {
                    // Finally, create the mode worker instance
                    return _this._instantiationService.createInstance(_this._workerDescriptor, _this._descriptor.id, participants);
                });
            }
            return this._workerPiecePromise;
        };
        ModeWorkerManager._loadModule = function (moduleName) {
            return new winjs_base_1.TPromise(function (c, e, p) {
                require([moduleName], c, e);
            }, function () {
                // Cannot cancel loading code
            });
        };
        return ModeWorkerManager;
    }());
    exports.ModeWorkerManager = ModeWorkerManager;
    var AbstractMode = (function () {
        function AbstractMode(modeId) {
            this._modeId = modeId;
            this._eventEmitter = new eventEmitter_1.EventEmitter();
            this._simplifiedMode = null;
        }
        AbstractMode.prototype.getId = function () {
            return this._modeId;
        };
        AbstractMode.prototype.toSimplifiedMode = function () {
            if (!this._simplifiedMode) {
                this._simplifiedMode = new SimplifiedMode(this);
            }
            return this._simplifiedMode;
        };
        AbstractMode.prototype.addSupportChangedListener = function (callback) {
            return this._eventEmitter.addListener2('modeSupportChanged', callback);
        };
        AbstractMode.prototype.registerSupport = function (support, callback) {
            var _this = this;
            var supportImpl = callback(this);
            this[support] = supportImpl;
            this._eventEmitter.emit('modeSupportChanged', _createModeSupportChangedEvent(support));
            return {
                dispose: function () {
                    if (_this[support] === supportImpl) {
                        delete _this[support];
                        _this._eventEmitter.emit('modeSupportChanged', _createModeSupportChangedEvent(support));
                    }
                }
            };
        };
        return AbstractMode;
    }());
    exports.AbstractMode = AbstractMode;
    var SimplifiedMode = (function () {
        function SimplifiedMode(sourceMode) {
            var _this = this;
            this._sourceMode = sourceMode;
            this._eventEmitter = new eventEmitter_1.EventEmitter();
            this._id = 'vs.editor.modes.simplifiedMode:' + sourceMode.getId();
            this._assignSupports();
            if (this._sourceMode.addSupportChangedListener) {
                this._sourceMode.addSupportChangedListener(function (e) {
                    if (e.tokenizationSupport || e.richEditSupport) {
                        _this._assignSupports();
                        var newEvent = SimplifiedMode._createModeSupportChangedEvent(e);
                        _this._eventEmitter.emit('modeSupportChanged', newEvent);
                    }
                });
            }
        }
        SimplifiedMode.prototype.getId = function () {
            return this._id;
        };
        SimplifiedMode.prototype.toSimplifiedMode = function () {
            return this;
        };
        SimplifiedMode.prototype._assignSupports = function () {
            this.tokenizationSupport = this._sourceMode.tokenizationSupport;
            this.richEditSupport = this._sourceMode.richEditSupport;
        };
        SimplifiedMode._createModeSupportChangedEvent = function (originalModeEvent) {
            var event = {
                codeLensSupport: false,
                tokenizationSupport: originalModeEvent.tokenizationSupport,
                occurrencesSupport: false,
                declarationSupport: false,
                typeDeclarationSupport: false,
                navigateTypesSupport: false,
                referenceSupport: false,
                suggestSupport: false,
                parameterHintsSupport: false,
                extraInfoSupport: false,
                outlineSupport: false,
                logicalSelectionSupport: false,
                formattingSupport: false,
                inplaceReplaceSupport: false,
                emitOutputSupport: false,
                linkSupport: false,
                configSupport: false,
                quickFixSupport: false,
                richEditSupport: originalModeEvent.richEditSupport,
            };
            return event;
        };
        return SimplifiedMode;
    }());
    exports.isDigit = (function () {
        var _0 = '0'.charCodeAt(0), _1 = '1'.charCodeAt(0), _2 = '2'.charCodeAt(0), _3 = '3'.charCodeAt(0), _4 = '4'.charCodeAt(0), _5 = '5'.charCodeAt(0), _6 = '6'.charCodeAt(0), _7 = '7'.charCodeAt(0), _8 = '8'.charCodeAt(0), _9 = '9'.charCodeAt(0), _a = 'a'.charCodeAt(0), _b = 'b'.charCodeAt(0), _c = 'c'.charCodeAt(0), _d = 'd'.charCodeAt(0), _e = 'e'.charCodeAt(0), _f = 'f'.charCodeAt(0), _A = 'A'.charCodeAt(0), _B = 'B'.charCodeAt(0), _C = 'C'.charCodeAt(0), _D = 'D'.charCodeAt(0), _E = 'E'.charCodeAt(0), _F = 'F'.charCodeAt(0);
        return function isDigit(character, base) {
            var c = character.charCodeAt(0);
            switch (base) {
                case 1:
                    return c === _0;
                case 2:
                    return c >= _0 && c <= _1;
                case 3:
                    return c >= _0 && c <= _2;
                case 4:
                    return c >= _0 && c <= _3;
                case 5:
                    return c >= _0 && c <= _4;
                case 6:
                    return c >= _0 && c <= _5;
                case 7:
                    return c >= _0 && c <= _6;
                case 8:
                    return c >= _0 && c <= _7;
                case 9:
                    return c >= _0 && c <= _8;
                case 10:
                    return c >= _0 && c <= _9;
                case 11:
                    return (c >= _0 && c <= _9) || (c === _a) || (c === _A);
                case 12:
                    return (c >= _0 && c <= _9) || (c >= _a && c <= _b) || (c >= _A && c <= _B);
                case 13:
                    return (c >= _0 && c <= _9) || (c >= _a && c <= _c) || (c >= _A && c <= _C);
                case 14:
                    return (c >= _0 && c <= _9) || (c >= _a && c <= _d) || (c >= _A && c <= _D);
                case 15:
                    return (c >= _0 && c <= _9) || (c >= _a && c <= _e) || (c >= _A && c <= _E);
                default:
                    return (c >= _0 && c <= _9) || (c >= _a && c <= _f) || (c >= _A && c <= _F);
            }
        };
    })();
    var FrankensteinMode = (function (_super) {
        __extends(FrankensteinMode, _super);
        function FrankensteinMode(descriptor, editorWorkerService) {
            _super.call(this, descriptor.id);
            if (editorWorkerService) {
                this.suggestSupport = new suggestSupport_1.TextualSuggestSupport(this.getId(), editorWorkerService);
            }
        }
        FrankensteinMode = __decorate([
            __param(1, editorWorkerService_1.IEditorWorkerService)
        ], FrankensteinMode);
        return FrankensteinMode;
    }(AbstractMode));
    exports.FrankensteinMode = FrankensteinMode;
    function _createModeSupportChangedEvent() {
        var changedSupports = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            changedSupports[_i - 0] = arguments[_i];
        }
        var event = {
            codeLensSupport: false,
            tokenizationSupport: false,
            occurrencesSupport: false,
            declarationSupport: false,
            typeDeclarationSupport: false,
            navigateTypesSupport: false,
            referenceSupport: false,
            suggestSupport: false,
            parameterHintsSupport: false,
            extraInfoSupport: false,
            outlineSupport: false,
            logicalSelectionSupport: false,
            formattingSupport: false,
            inplaceReplaceSupport: false,
            emitOutputSupport: false,
            linkSupport: false,
            configSupport: false,
            quickFixSupport: false,
            richEditSupport: false
        };
        changedSupports.forEach(function (support) { return event[support] = true; });
        return event;
    }
});

define("vs/editor/common/services/modeService", ["require", "exports", 'vs/platform/instantiation/common/instantiation'], function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IModeService = instantiation_1.createDecorator('modeService');
});

define("vs/editor/common/services/modelService", ["require", "exports", 'vs/platform/instantiation/common/instantiation'], function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IModelService = instantiation_1.createDecorator('modelService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/platform/configuration/common/configuration", ["require", "exports", 'vs/platform/instantiation/common/instantiation'], function (require, exports, instantiation_1) {
    "use strict";
    exports.IConfigurationService = instantiation_1.createDecorator('configurationService');
    var ConfigurationServiceEventTypes = (function () {
        function ConfigurationServiceEventTypes() {
        }
        /**
         * This event happens after configuration is updated either programmatically
         * or through a file change. It will include a IConfigurationServiceEvent
         * object that includes the new config and which section was updated
         * or null if entire config was updated.
         *
         * Subscribers can use the provided updated configuration
         * rather than re-pulling for updates
         */
        ConfigurationServiceEventTypes.UPDATED = 'update';
        return ConfigurationServiceEventTypes;
    }());
    exports.ConfigurationServiceEventTypes = ConfigurationServiceEventTypes;
    function extractSetting(config, settingPath) {
        function accessSetting(config, path) {
            var current = config;
            for (var i = 0; i < path.length; i++) {
                current = current[path[i]];
                if (!current) {
                    return undefined;
                }
            }
            return current;
        }
        var path = settingPath.split('.');
        return accessSetting(config, path);
    }
    exports.extractSetting = extractSetting;
});

define("vs/platform/editor/common/editor", ["require", "exports", 'vs/platform/instantiation/common/instantiation'], function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IEditorService = instantiation_1.createDecorator('editorService');
    /**
     * Possible locations for opening an editor.
     */
    (function (Position) {
        /** Opens the editor in the LEFT most position replacing the input currently showing */
        Position[Position["LEFT"] = 0] = "LEFT";
        /** Opens the editor in the CENTER position replacing the input currently showing */
        Position[Position["CENTER"] = 1] = "CENTER";
        /** Opens the editor in the RIGHT most position replacing the input currently showing */
        Position[Position["RIGHT"] = 2] = "RIGHT";
    })(exports.Position || (exports.Position = {}));
    var Position = exports.Position;
    exports.POSITIONS = [Position.LEFT, Position.CENTER, Position.RIGHT];
});

define("vs/platform/event/common/event", ["require", "exports", 'vs/platform/instantiation/common/instantiation'], function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IEventService = instantiation_1.createDecorator('eventService');
});

define("vs/platform/extensions/common/extensions", ["require", "exports", 'vs/platform/instantiation/common/instantiation'], function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IExtensionService = instantiation_1.createDecorator('extensionService');
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("vs/platform/files/common/files", ["require", "exports", 'vs/base/common/paths', 'vs/base/common/events', 'vs/platform/instantiation/common/instantiation'], function (require, exports, paths, events, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IFileService = instantiation_1.createDecorator('fileService');
    /**
     * Possible changes that can occur to a file.
     */
    (function (FileChangeType) {
        FileChangeType[FileChangeType["UPDATED"] = 0] = "UPDATED";
        FileChangeType[FileChangeType["ADDED"] = 1] = "ADDED";
        FileChangeType[FileChangeType["DELETED"] = 2] = "DELETED";
    })(exports.FileChangeType || (exports.FileChangeType = {}));
    var FileChangeType = exports.FileChangeType;
    /**
     * Possible events to subscribe to
     */
    exports.EventType = {
        /**
        * Send on file changes.
        */
        FILE_CHANGES: 'files:fileChanges'
    };
    var FileChangesEvent = (function (_super) {
        __extends(FileChangesEvent, _super);
        function FileChangesEvent(changes) {
            _super.call(this);
            this._changes = changes;
        }
        Object.defineProperty(FileChangesEvent.prototype, "changes", {
            get: function () {
                return this._changes;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns true if this change event contains the provided file with the given change type. In case of
         * type DELETED, this method will also return true if a folder got deleted that is the parent of the
         * provided file path.
         */
        FileChangesEvent.prototype.contains = function (resource, type) {
            if (!resource) {
                return false;
            }
            return this.containsAny([resource], type);
        };
        /**
         * Returns true if this change event contains any of the provided files with the given change type. In case of
         * type DELETED, this method will also return true if a folder got deleted that is the parent of any of the
         * provided file paths.
         */
        FileChangesEvent.prototype.containsAny = function (resources, type) {
            if (!resources || !resources.length) {
                return false;
            }
            return this._changes.some(function (change) {
                if (change.type !== type) {
                    return false;
                }
                // For deleted also return true when deleted folder is parent of target path
                if (type === FileChangeType.DELETED) {
                    return resources.some(function (a) {
                        if (!a) {
                            return false;
                        }
                        return paths.isEqualOrParent(a.fsPath, change.resource.fsPath);
                    });
                }
                return resources.some(function (a) {
                    if (!a) {
                        return false;
                    }
                    return a.fsPath === change.resource.fsPath;
                });
            });
        };
        /**
         * Returns the changes that describe added files.
         */
        FileChangesEvent.prototype.getAdded = function () {
            return this.getOfType(FileChangeType.ADDED);
        };
        /**
         * Returns if this event contains added files.
         */
        FileChangesEvent.prototype.gotAdded = function () {
            return this.hasType(FileChangeType.ADDED);
        };
        /**
         * Returns the changes that describe deleted files.
         */
        FileChangesEvent.prototype.getDeleted = function () {
            return this.getOfType(FileChangeType.DELETED);
        };
        /**
         * Returns if this event contains deleted files.
         */
        FileChangesEvent.prototype.gotDeleted = function () {
            return this.hasType(FileChangeType.DELETED);
        };
        /**
         * Returns the changes that describe updated files.
         */
        FileChangesEvent.prototype.getUpdated = function () {
            return this.getOfType(FileChangeType.UPDATED);
        };
        /**
         * Returns if this event contains updated files.
         */
        FileChangesEvent.prototype.gotUpdated = function () {
            return this.hasType(FileChangeType.UPDATED);
        };
        FileChangesEvent.prototype.getOfType = function (type) {
            return this._changes.filter(function (change) { return change.type === type; });
        };
        FileChangesEvent.prototype.hasType = function (type) {
            return this._changes.some(function (change) {
                return change.type === type;
            });
        };
        return FileChangesEvent;
    }(events.Event));
    exports.FileChangesEvent = FileChangesEvent;
    (function (FileOperationResult) {
        FileOperationResult[FileOperationResult["FILE_IS_BINARY"] = 0] = "FILE_IS_BINARY";
        FileOperationResult[FileOperationResult["FILE_IS_DIRECTORY"] = 1] = "FILE_IS_DIRECTORY";
        FileOperationResult[FileOperationResult["FILE_NOT_FOUND"] = 2] = "FILE_NOT_FOUND";
        FileOperationResult[FileOperationResult["FILE_NOT_MODIFIED_SINCE"] = 3] = "FILE_NOT_MODIFIED_SINCE";
        FileOperationResult[FileOperationResult["FILE_MODIFIED_SINCE"] = 4] = "FILE_MODIFIED_SINCE";
        FileOperationResult[FileOperationResult["FILE_MOVE_CONFLICT"] = 5] = "FILE_MOVE_CONFLICT";
        FileOperationResult[FileOperationResult["FILE_READ_ONLY"] = 6] = "FILE_READ_ONLY";
        FileOperationResult[FileOperationResult["FILE_TOO_LARGE"] = 7] = "FILE_TOO_LARGE";
    })(exports.FileOperationResult || (exports.FileOperationResult = {}));
    var FileOperationResult = exports.FileOperationResult;
    exports.MAX_FILE_SIZE = 50 * 1024 * 1024;
    exports.AutoSaveConfiguration = {
        OFF: 'off',
        AFTER_DELAY: 'afterDelay',
        ON_FOCUS_CHANGE: 'onFocusChange'
    };
    exports.SUPPORTED_ENCODINGS = {
        utf8: {
            labelLong: 'UTF-8',
            labelShort: 'UTF-8',
            order: 1,
            alias: 'utf8bom'
        },
        utf8bom: {
            labelLong: 'UTF-8 with BOM',
            labelShort: 'UTF-8 with BOM',
            encodeOnly: true,
            order: 2,
            alias: 'utf8'
        },
        utf16le: {
            labelLong: 'UTF-16 LE',
            labelShort: 'UTF-16 LE',
            order: 3
        },
        utf16be: {
            labelLong: 'UTF-16 BE',
            labelShort: 'UTF-16 BE',
            order: 4
        },
        windows1252: {
            labelLong: 'Western (Windows 1252)',
            labelShort: 'Windows 1252',
            order: 5
        },
        iso88591: {
            labelLong: 'Western (ISO 8859-1)',
            labelShort: 'ISO 8859-1',
            order: 6
        },
        iso88593: {
            labelLong: 'Western (ISO 8859-3)',
            labelShort: 'ISO 8859-3',
            order: 7
        },
        iso885915: {
            labelLong: 'Western (ISO 8859-15)',
            labelShort: 'ISO 8859-15',
            order: 8
        },
        macroman: {
            labelLong: 'Western (Mac Roman)',
            labelShort: 'Mac Roman',
            order: 9
        },
        cp437: {
            labelLong: 'DOS (CP 437)',
            labelShort: 'CP437',
            order: 10
        },
        windows1256: {
            labelLong: 'Arabic (Windows 1256)',
            labelShort: 'Windows 1256',
            order: 11
        },
        iso88596: {
            labelLong: 'Arabic (ISO 8859-6)',
            labelShort: 'ISO 8859-6',
            order: 12
        },
        windows1257: {
            labelLong: 'Baltic (Windows 1257)',
            labelShort: 'Windows 1257',
            order: 13
        },
        iso88594: {
            labelLong: 'Baltic (ISO 8859-4)',
            labelShort: 'ISO 8859-4',
            order: 14
        },
        iso885914: {
            labelLong: 'Celtic (ISO 8859-14)',
            labelShort: 'ISO 8859-14',
            order: 15
        },
        windows1250: {
            labelLong: 'Central European (Windows 1250)',
            labelShort: 'Windows 1250',
            order: 16
        },
        iso88592: {
            labelLong: 'Central European (ISO 8859-2)',
            labelShort: 'ISO 8859-2',
            order: 17
        },
        windows1251: {
            labelLong: 'Cyrillic (Windows 1251)',
            labelShort: 'Windows 1251',
            order: 18
        },
        cp866: {
            labelLong: 'Cyrillic (CP 866)',
            labelShort: 'CP 866',
            order: 19
        },
        iso88595: {
            labelLong: 'Cyrillic (ISO 8859-5)',
            labelShort: 'ISO 8859-5',
            order: 20
        },
        koi8r: {
            labelLong: 'Cyrillic (KOI8-R)',
            labelShort: 'KOI8-R',
            order: 21
        },
        koi8u: {
            labelLong: 'Cyrillic (KOI8-U)',
            labelShort: 'KOI8-U',
            order: 22
        },
        iso885913: {
            labelLong: 'Estonian (ISO 8859-13)',
            labelShort: 'ISO 8859-13',
            order: 23
        },
        windows1253: {
            labelLong: 'Greek (Windows 1253)',
            labelShort: 'Windows 1253',
            order: 24
        },
        iso88597: {
            labelLong: 'Greek (ISO 8859-7)',
            labelShort: 'ISO 8859-7',
            order: 25
        },
        windows1255: {
            labelLong: 'Hebrew (Windows 1255)',
            labelShort: 'Windows 1255',
            order: 26
        },
        iso88598: {
            labelLong: 'Hebrew (ISO 8859-8)',
            labelShort: 'ISO 8859-8',
            order: 27
        },
        iso885910: {
            labelLong: 'Nordic (ISO 8859-10)',
            labelShort: 'ISO 8859-10',
            order: 28
        },
        iso885916: {
            labelLong: 'Romanian (ISO 8859-16)',
            labelShort: 'ISO 8859-16',
            order: 29
        },
        windows1254: {
            labelLong: 'Turkish (Windows 1254)',
            labelShort: 'Windows 1254',
            order: 30
        },
        iso88599: {
            labelLong: 'Turkish (ISO 8859-9)',
            labelShort: 'ISO 8859-9',
            order: 31
        },
        windows1258: {
            labelLong: 'Vietnamese (Windows 1258)',
            labelShort: 'Windows 1258',
            order: 32
        },
        gbk: {
            labelLong: 'Chinese (GBK)',
            labelShort: 'GBK',
            order: 33
        },
        gb18030: {
            labelLong: 'Chinese (GB18030)',
            labelShort: 'GB18030',
            order: 34
        },
        cp950: {
            labelLong: 'Traditional Chinese (Big5)',
            labelShort: 'Big5',
            order: 35
        },
        big5hkscs: {
            labelLong: 'Traditional Chinese (Big5-HKSCS)',
            labelShort: 'Big5-HKSCS',
            order: 36
        },
        shiftjis: {
            labelLong: 'Japanese (Shift JIS)',
            labelShort: 'Shift JIS',
            order: 37
        },
        eucjp: {
            labelLong: 'Japanese (EUC-JP)',
            labelShort: 'EUC-JP',
            order: 38
        },
        euckr: {
            labelLong: 'Korean (EUC-KR)',
            labelShort: 'EUC-KR',
            order: 39
        },
        windows874: {
            labelLong: 'Thai (Windows 874)',
            labelShort: 'Windows 874',
            order: 40
        },
        iso885911: {
            labelLong: 'Latin/Thai (ISO 8859-11)',
            labelShort: 'ISO 8859-11',
            order: 41
        },
        'koi8-ru': {
            labelLong: 'Cyrillic (KOI8-RU)',
            labelShort: 'KOI8-RU',
            order: 42
        },
        'koi8-t': {
            labelLong: 'Tajik (KOI8-T)',
            labelShort: 'KOI8-T',
            order: 43
        },
        GB2312: {
            labelLong: 'Simplified Chinese (GB 2312)',
            labelShort: 'GB 2312',
            order: 44
        }
    };
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("vs/editor/common/services/bulkEdit", ["require", "exports", 'vs/nls!vs/editor/common/services/bulkEdit', 'vs/base/common/arrays', 'vs/base/common/collections', 'vs/base/common/uri', 'vs/base/common/winjs.base', 'vs/platform/files/common/files', 'vs/editor/common/core/editOperation', 'vs/editor/common/core/range', 'vs/editor/common/core/selection'], function (require, exports, nls, arrays_1, collections_1, uri_1, winjs_base_1, files_1, editOperation_1, range_1, selection_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ChangeRecorder = (function () {
        function ChangeRecorder(eventService) {
            this._eventService = eventService;
        }
        ChangeRecorder.prototype.start = function () {
            var changes = Object.create(null);
            var stop = this._eventService.addListener(files_1.EventType.FILE_CHANGES, function (event) {
                event.changes.forEach(function (change) {
                    var key = String(change.resource), array = changes[key];
                    if (!array) {
                        changes[key] = array = [];
                    }
                    array.push(change);
                });
            });
            return {
                stop: stop,
                hasChanged: function (resource) { return !!changes[resource.toString()]; },
                allChanges: function () { return arrays_1.merge(collections_1.values(changes)); }
            };
        };
        return ChangeRecorder;
    }());
    var EditTask = (function () {
        function EditTask(model) {
            this._endCursorSelection = null;
            this._model = model;
            this._edits = [];
        }
        EditTask.prototype.addEdit = function (edit) {
            var range;
            if (!edit.range) {
                range = this._model.getFullModelRange();
            }
            else {
                range = edit.range;
            }
            this._edits.push(editOperation_1.EditOperation.replace(range_1.Range.lift(range), edit.newText));
        };
        EditTask.prototype.apply = function () {
            var _this = this;
            if (this._edits.length === 0) {
                return;
            }
            this._edits.sort(EditTask._editCompare);
            this._initialSelections = this._getInitialSelections();
            this._model.pushEditOperations(this._initialSelections, this._edits, function (edits) { return _this._getEndCursorSelections(edits); });
        };
        EditTask.prototype._getInitialSelections = function () {
            var firstRange = this._edits[0].range;
            var initialSelection = selection_1.Selection.createSelection(firstRange.startLineNumber, firstRange.startColumn, firstRange.endLineNumber, firstRange.endColumn);
            return [initialSelection];
        };
        EditTask.prototype._getEndCursorSelections = function (inverseEditOperations) {
            var relevantEditIndex = 0;
            for (var i = 0; i < inverseEditOperations.length; i++) {
                var editRange = inverseEditOperations[i].range;
                for (var j = 0; j < this._initialSelections.length; j++) {
                    var selectionRange = this._initialSelections[j];
                    if (range_1.Range.areIntersectingOrTouching(editRange, selectionRange)) {
                        relevantEditIndex = i;
                        break;
                    }
                }
            }
            var srcRange = inverseEditOperations[relevantEditIndex].range;
            this._endCursorSelection = selection_1.Selection.createSelection(srcRange.endLineNumber, srcRange.endColumn, srcRange.endLineNumber, srcRange.endColumn);
            return [this._endCursorSelection];
        };
        EditTask.prototype.getEndCursorSelection = function () {
            return this._endCursorSelection;
        };
        EditTask._editCompare = function (a, b) {
            return range_1.Range.compareRangesUsingStarts(a.range, b.range);
        };
        return EditTask;
    }());
    var SourceModelEditTask = (function (_super) {
        __extends(SourceModelEditTask, _super);
        function SourceModelEditTask(model, initialSelections) {
            _super.call(this, model);
            this._knownInitialSelections = initialSelections;
        }
        SourceModelEditTask.prototype._getInitialSelections = function () {
            return this._knownInitialSelections;
        };
        return SourceModelEditTask;
    }(EditTask));
    var BulkEditModel = (function () {
        function BulkEditModel(editorService, sourceModel, sourceSelections, edits) {
            this._numberOfResourcesToModify = 0;
            this._numberOfChanges = 0;
            this._edits = Object.create(null);
            this._editorService = editorService;
            this._sourceModel = sourceModel;
            this._sourceSelections = sourceSelections;
            this._sourceModelTask = null;
            for (var _i = 0, edits_1 = edits; _i < edits_1.length; _i++) {
                var edit = edits_1[_i];
                this._addEdit(edit);
            }
        }
        BulkEditModel.prototype.resourcesCount = function () {
            return this._numberOfResourcesToModify;
        };
        BulkEditModel.prototype.changeCount = function () {
            return this._numberOfChanges;
        };
        BulkEditModel.prototype._addEdit = function (edit) {
            var array = this._edits[edit.resource.toString()];
            if (!array) {
                this._edits[edit.resource.toString()] = array = [];
                this._numberOfResourcesToModify += 1;
            }
            this._numberOfChanges += 1;
            array.push(edit);
        };
        BulkEditModel.prototype.prepare = function () {
            var _this = this;
            if (this._tasks) {
                throw new Error('illegal state - already prepared');
            }
            this._tasks = [];
            var promises = [];
            collections_1.forEach(this._edits, function (entry) {
                var promise = _this._editorService.resolveEditorModel({ resource: uri_1.default.parse(entry.key) }).then(function (model) {
                    if (!model || !model.textEditorModel) {
                        throw new Error("Cannot load file " + entry.key);
                    }
                    var textEditorModel = model.textEditorModel, task;
                    if (_this._sourceModel && textEditorModel.getAssociatedResource().toString() === _this._sourceModel.toString()) {
                        _this._sourceModelTask = new SourceModelEditTask(textEditorModel, _this._sourceSelections);
                        task = _this._sourceModelTask;
                    }
                    else {
                        task = new EditTask(textEditorModel);
                    }
                    entry.value.forEach(function (edit) { return task.addEdit(edit); });
                    _this._tasks.push(task);
                });
                promises.push(promise);
            });
            return winjs_base_1.TPromise.join(promises).then(function (_) { return _this; });
        };
        BulkEditModel.prototype.apply = function () {
            this._tasks.forEach(function (task) { return task.apply(); });
            var r = null;
            if (this._sourceModelTask) {
                r = this._sourceModelTask.getEndCursorSelection();
            }
            return r;
        };
        return BulkEditModel;
    }());
    function bulkEdit(eventService, editorService, editor, edits) {
        var bulk = createBulkEdit(eventService, editorService, editor);
        bulk.add(edits);
        return bulk.finish();
    }
    exports.bulkEdit = bulkEdit;
    function createBulkEdit(eventService, editorService, editor) {
        var all = [];
        var recording = new ChangeRecorder(eventService).start();
        function add(edits) {
            all.push.apply(all, edits);
        }
        function getConcurrentEdits() {
            var names;
            for (var _i = 0, all_1 = all; _i < all_1.length; _i++) {
                var edit = all_1[_i];
                if (recording.hasChanged(edit.resource)) {
                    if (!names) {
                        names = [];
                    }
                    names.push(edit.resource.fsPath);
                }
            }
            if (names) {
                return nls.localize(0, null, names.join(', '));
            }
        }
        function finish() {
            if (all.length === 0) {
                return;
            }
            var concurrentEdits = getConcurrentEdits();
            if (concurrentEdits) {
                return winjs_base_1.TPromise.wrapError(concurrentEdits);
            }
            var uri;
            var selections;
            if (editor && editor.getModel()) {
                uri = editor.getModel().getAssociatedResource();
                selections = editor.getSelections();
            }
            var model = new BulkEditModel(editorService, uri, selections, all);
            return model.prepare().then(function (_) {
                var concurrentEdits = getConcurrentEdits();
                if (concurrentEdits) {
                    throw new Error(concurrentEdits);
                }
                recording.stop();
                return model.apply();
            });
        }
        return {
            add: add,
            finish: finish
        };
    }
    exports.createBulkEdit = createBulkEdit;
});

define("vs/platform/instantiation/common/instantiationService", ["require", "exports", 'vs/base/common/winjs.base', 'vs/base/common/errors', 'vs/base/common/strings', 'vs/base/common/types', 'vs/base/common/collections', './descriptors', 'vs/base/common/graph', './instantiation'], function (require, exports, winjs, errors, strings, types, collections, descriptors, graph_1, instantiation) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var IInstantiationService = instantiation.IInstantiationService;
    /**
     * Creates a new instance of an instantiation service.
     */
    function createInstantiationService(services) {
        if (services === void 0) { services = Object.create(null); }
        var result = new InstantiationService(services, new AccessLock());
        return result;
    }
    exports.createInstantiationService = createInstantiationService;
    var AccessLock = (function () {
        function AccessLock() {
            this._value = 0;
        }
        Object.defineProperty(AccessLock.prototype, "locked", {
            get: function () {
                return this._value === 0;
            },
            enumerable: true,
            configurable: true
        });
        AccessLock.prototype.runUnlocked = function (r) {
            this._value++;
            try {
                return r();
            }
            finally {
                this._value--;
            }
        };
        return AccessLock;
    }());
    var ServicesMap = (function () {
        function ServicesMap(_services, _lock) {
            var _this = this;
            this._services = _services;
            this._lock = _lock;
            collections.forEach(this._services, function (entry) {
                // add a accessor to myselves
                _this.registerService(entry.key, entry.value);
            });
        }
        ServicesMap.prototype.registerService = function (name, service) {
            var _this = this;
            // add a accessor to myselves
            Object.defineProperty(this, name, {
                get: function () {
                    if (_this._lock.locked) {
                        throw errors.illegalState('the services map can only be used during construction');
                    }
                    if (!service) {
                        throw errors.illegalArgument(strings.format('service with \'{0}\' not found', name));
                    }
                    if (service instanceof descriptors.SyncDescriptor) {
                        var cached = _this._services[name];
                        if (cached instanceof descriptors.SyncDescriptor) {
                            _this._ensureInstances(name, service);
                            service = _this._services[name];
                        }
                        else {
                            service = cached;
                        }
                    }
                    return service;
                },
                set: function (value) {
                    throw errors.illegalState('services cannot be changed');
                },
                configurable: false,
                enumerable: false
            });
            // add to services map
            this._services[name] = service;
        };
        Object.defineProperty(ServicesMap.prototype, "lock", {
            get: function () {
                return this._lock;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ServicesMap.prototype, "services", {
            get: function () {
                return this._services;
            },
            enumerable: true,
            configurable: true
        });
        ServicesMap.prototype._ensureInstances = function (serviceId, desc) {
            var seen = Object.create(null);
            var graph = new graph_1.Graph(function (i) { return i.serviceId; });
            var stack = [{ serviceId: serviceId, desc: desc }];
            while (stack.length) {
                var item = stack.pop();
                graph.lookupOrInsertNode(item);
                // check for cycles between the descriptors
                if (seen[item.serviceId]) {
                    throw new Error("[createInstance] cyclic dependency: " + Object.keys(seen).join('>>'));
                }
                seen[item.serviceId] = true;
                // check all dependencies for existence and if the need to be created first
                var dependencies = instantiation._util.getServiceDependencies(item.desc.ctor);
                if (Array.isArray(dependencies)) {
                    for (var _i = 0, dependencies_1 = dependencies; _i < dependencies_1.length; _i++) {
                        var dependency = dependencies_1[_i];
                        var instanceOrDesc = this.services[dependency.serviceId];
                        if (!instanceOrDesc) {
                            throw new Error("[createInstance] " + serviceId + " depends on " + dependency.serviceId + " which is NOT registered.");
                        }
                        if (instanceOrDesc instanceof descriptors.SyncDescriptor) {
                            var d = { serviceId: dependency.serviceId, desc: instanceOrDesc };
                            stack.push(d);
                            graph.insertEdge(item, d);
                        }
                    }
                }
            }
            while (true) {
                var roots = graph.roots();
                // if there is no more roots but still
                // nodes in the graph we have a cycle
                if (roots.length === 0) {
                    if (graph.length !== 0) {
                        throw new Error('[createInstance] cyclinc dependency!');
                    }
                    break;
                }
                for (var _a = 0, roots_1 = roots; _a < roots_1.length; _a++) {
                    var root = roots_1[_a];
                    var instance = this.createInstance(root.data.desc, []);
                    this._services[root.data.serviceId] = instance;
                    graph.removeNode(root.data);
                }
            }
        };
        ServicesMap.prototype.invokeFunction = function (fn, args) {
            var _this = this;
            return this._lock.runUnlocked(function () {
                var accessor = {
                    get: function (id) {
                        var value = instantiation._util.getServiceId(id);
                        return _this[value];
                    }
                };
                return fn.apply(undefined, [accessor].concat(args));
            });
        };
        ServicesMap.prototype.createInstance = function (descriptor, args) {
            var _this = this;
            var allArguments = [];
            var serviceInjections = instantiation._util.getServiceDependencies(descriptor.ctor) || [];
            var fixedArguments = descriptor.staticArguments().concat(args);
            var expectedFirstServiceIndex = fixedArguments.length;
            var actualFirstServiceIndex = Number.MAX_VALUE;
            serviceInjections.forEach(function (si) {
                // @IServiceName
                var serviceId = si.serviceId, index = si.index;
                var service = _this._lock.runUnlocked(function () { return _this[serviceId]; });
                allArguments[index] = service;
                actualFirstServiceIndex = Math.min(actualFirstServiceIndex, si.index);
            });
            // insert the fixed arguments into the array of all ctor
            // arguments. don't overwrite existing values tho it indicates
            // something is off
            var i = 0;
            for (var _i = 0, fixedArguments_1 = fixedArguments; _i < fixedArguments_1.length; _i++) {
                var arg = fixedArguments_1[_i];
                var hasValue = allArguments[i] !== void 0;
                if (!hasValue) {
                    allArguments[i] = arg;
                }
                i += 1;
            }
            allArguments.unshift(descriptor.ctor); // ctor is first arg
            // services are the last arguments of ctor-calls. We check if static ctor arguments
            // (like those from a [sync|async] desriptor) or args that are passed by createInstance
            // don't override positions of those arguments
            if (actualFirstServiceIndex !== Number.MAX_VALUE
                && actualFirstServiceIndex !== expectedFirstServiceIndex) {
                var msg = ("[createInstance] constructor '" + descriptor.ctor.name + "' has first") +
                    (" service dependency at position " + (actualFirstServiceIndex + 1) + " but is called with") +
                    (" " + (expectedFirstServiceIndex - 1) + " static arguments that are expected to come first");
                // throw new Error(msg);
                console.warn(msg);
            }
            return this._lock.runUnlocked(function () {
                var instance = types.create.apply(null, allArguments);
                descriptor._validate(instance);
                return instance;
            });
        };
        return ServicesMap;
    }());
    var InstantiationService = (function () {
        function InstantiationService(services, lock) {
            this.serviceId = IInstantiationService;
            services['instantiationService'] = this;
            this._servicesMap = new ServicesMap(services, lock);
        }
        InstantiationService.prototype.createChild = function (services) {
            var childServices = {};
            // copy existing services
            collections.forEach(this._servicesMap.services, function (entry) {
                childServices[entry.key] = entry.value;
            });
            // insert new services (might overwrite)
            collections.forEach(services, function (entry) {
                childServices[entry.key] = entry.value;
            });
            return new InstantiationService(childServices, this._servicesMap.lock);
        };
        InstantiationService.prototype.registerService = function (name, service) {
            this._servicesMap.registerService(name, service);
        };
        InstantiationService.prototype.addSingleton = function (id, instanceOrDescriptor) {
            var name = instantiation._util.getServiceId(id);
            this._servicesMap.registerService(name, instanceOrDescriptor);
        };
        InstantiationService.prototype.getInstance = function (id) {
            var _this = this;
            var name = instantiation._util.getServiceId(id);
            var result = this._servicesMap.lock.runUnlocked(function () { return _this._servicesMap[name]; });
            return result;
        };
        InstantiationService.prototype.createInstance = function (param) {
            var rest = new Array(arguments.length - 1);
            for (var i = 1, len = arguments.length; i < len; i++) {
                rest[i - 1] = arguments[i];
            }
            if (param instanceof descriptors.SyncDescriptor) {
                return this._servicesMap.createInstance(param, rest);
            }
            else if (param instanceof descriptors.AsyncDescriptor) {
                return this._createInstanceAsync(param, rest);
            }
            else {
                return this._servicesMap.createInstance(new descriptors.SyncDescriptor(param), rest);
            }
        };
        InstantiationService.prototype._createInstanceAsync = function (descriptor, args) {
            var _this = this;
            var canceled;
            return new winjs.TPromise(function (c, e, p) {
                require([descriptor.moduleName], function (_module) {
                    if (canceled) {
                        e(canceled);
                    }
                    if (!_module) {
                        return e(errors.illegalArgument('module not found: ' + descriptor.moduleName));
                    }
                    var ctor;
                    if (!descriptor.ctorName) {
                        ctor = _module;
                    }
                    else {
                        ctor = _module[descriptor.ctorName];
                    }
                    if (typeof ctor !== 'function') {
                        return e(errors.illegalArgument('not a function: ' + descriptor.ctorName || descriptor.moduleName));
                    }
                    try {
                        args.unshift.apply(args, descriptor.staticArguments()); // instead of spread in ctor call
                        c(_this._servicesMap.createInstance(new descriptors.SyncDescriptor(ctor), args));
                    }
                    catch (error) {
                        return e(error);
                    }
                }, e);
            }, function () {
                canceled = errors.canceled();
            });
        };
        InstantiationService.prototype.invokeFunction = function (signature) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return this._servicesMap.invokeFunction(signature, args);
        };
        return InstantiationService;
    }());
});

define("vs/platform/keybinding/common/keybindingService", ["require", "exports", 'vs/platform/instantiation/common/instantiation'], function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var KbDefinedExpression = (function () {
        function KbDefinedExpression(key) {
            this.key = key;
        }
        KbDefinedExpression.prototype.equals = function (other) {
            if (other instanceof KbDefinedExpression) {
                return (this.key === other.key);
            }
            return false;
        };
        KbDefinedExpression.prototype.evaluate = function (context) {
            return (!!context[this.key]);
        };
        KbDefinedExpression.prototype.normalize = function () {
            return this;
        };
        KbDefinedExpression.prototype.serialize = function () {
            return this.key;
        };
        return KbDefinedExpression;
    }());
    exports.KbDefinedExpression = KbDefinedExpression;
    var KbEqualsExpression = (function () {
        function KbEqualsExpression(key, value) {
            this.key = key;
            this.value = value;
        }
        KbEqualsExpression.prototype.equals = function (other) {
            if (other instanceof KbEqualsExpression) {
                return (this.key === other.key && this.value === other.value);
            }
            return false;
        };
        KbEqualsExpression.prototype.evaluate = function (context) {
            /* tslint:disable:triple-equals */
            // Intentional ==
            return (context[this.key] == this.value);
            /* tslint:enable:triple-equals */
        };
        KbEqualsExpression.prototype.normalize = function () {
            if (typeof this.value === 'boolean') {
                if (this.value) {
                    return new KbDefinedExpression(this.key);
                }
                return new KbNotExpression(this.key);
            }
            return this;
        };
        KbEqualsExpression.prototype.serialize = function () {
            if (typeof this.value === 'boolean') {
                return this.normalize().serialize();
            }
            return this.key + ' == \'' + this.value + '\'';
        };
        return KbEqualsExpression;
    }());
    exports.KbEqualsExpression = KbEqualsExpression;
    var KbNotEqualsExpression = (function () {
        function KbNotEqualsExpression(key, value) {
            this.key = key;
            this.value = value;
        }
        KbNotEqualsExpression.prototype.equals = function (other) {
            if (other instanceof KbNotEqualsExpression) {
                return (this.key === other.key && this.value === other.value);
            }
            return false;
        };
        KbNotEqualsExpression.prototype.evaluate = function (context) {
            /* tslint:disable:triple-equals */
            // Intentional !=
            return (context[this.key] != this.value);
            /* tslint:enable:triple-equals */
        };
        KbNotEqualsExpression.prototype.normalize = function () {
            if (typeof this.value === 'boolean') {
                if (this.value) {
                    return new KbNotExpression(this.key);
                }
                return new KbDefinedExpression(this.key);
            }
            return this;
        };
        KbNotEqualsExpression.prototype.serialize = function () {
            if (typeof this.value === 'boolean') {
                return this.normalize().serialize();
            }
            return this.key + ' != \'' + this.value + '\'';
        };
        return KbNotEqualsExpression;
    }());
    exports.KbNotEqualsExpression = KbNotEqualsExpression;
    var KbNotExpression = (function () {
        function KbNotExpression(key) {
            this.key = key;
        }
        KbNotExpression.prototype.equals = function (other) {
            if (other instanceof KbNotExpression) {
                return (this.key === other.key);
            }
            return false;
        };
        KbNotExpression.prototype.evaluate = function (context) {
            return (!context[this.key]);
        };
        KbNotExpression.prototype.normalize = function () {
            return this;
        };
        KbNotExpression.prototype.serialize = function () {
            return '!' + this.key;
        };
        return KbNotExpression;
    }());
    exports.KbNotExpression = KbNotExpression;
    var KbAndExpression = (function () {
        function KbAndExpression(expr) {
            this.expr = expr || [];
        }
        KbAndExpression.prototype.equals = function (other) {
            return this === other;
        };
        KbAndExpression.prototype.evaluate = function (context) {
            for (var i = 0, len = this.expr.length; i < len; i++) {
                if (!this.expr[i].evaluate(context)) {
                    return false;
                }
            }
            return true;
        };
        KbAndExpression.prototype.normalize = function () {
            var expr = [];
            for (var i = 0, len = this.expr.length; i < len; i++) {
                var e = this.expr[i];
                if (!e) {
                    continue;
                }
                e = e.normalize();
                if (!e) {
                    continue;
                }
                if (e instanceof KbAndExpression) {
                    expr = expr.concat(e.expr);
                    continue;
                }
                expr.push(e);
            }
            if (expr.length === 0) {
                return null;
            }
            if (expr.length === 1) {
                return expr[0];
            }
            return new KbAndExpression(expr);
        };
        KbAndExpression.prototype.serialize = function () {
            if (this.expr.length === 0) {
                return '';
            }
            if (this.expr.length === 1) {
                return this.normalize().serialize();
            }
            return this.expr.map(function (e) { return e.serialize(); }).join(' && ');
        };
        return KbAndExpression;
    }());
    exports.KbAndExpression = KbAndExpression;
    exports.KbExpr = {
        has: function (key) { return new KbDefinedExpression(key); },
        equals: function (key, value) { return new KbEqualsExpression(key, value); },
        notEquals: function (key, value) { return new KbNotEqualsExpression(key, value); },
        not: function (key) { return new KbNotExpression(key); },
        and: function () {
            var expr = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                expr[_i - 0] = arguments[_i];
            }
            return new KbAndExpression(expr);
        },
        deserialize: function (serialized) {
            if (!serialized) {
                return null;
            }
            var pieces = serialized.split('&&');
            var result = new KbAndExpression(pieces.map(function (p) { return exports.KbExpr._deserializeOne(p); }));
            return result.normalize();
        },
        _deserializeOne: function (serializedOne) {
            serializedOne = serializedOne.trim();
            if (serializedOne.indexOf('!=') >= 0) {
                var pieces = serializedOne.split('!=');
                return new KbNotEqualsExpression(pieces[0].trim(), exports.KbExpr._deserializeValue(pieces[1]));
            }
            if (serializedOne.indexOf('==') >= 0) {
                var pieces = serializedOne.split('==');
                return new KbEqualsExpression(pieces[0].trim(), exports.KbExpr._deserializeValue(pieces[1]));
            }
            if (/^\!\s*/.test(serializedOne)) {
                return new KbNotExpression(serializedOne.substr(1).trim());
            }
            return new KbDefinedExpression(serializedOne);
        },
        _deserializeValue: function (serializedValue) {
            serializedValue = serializedValue.trim();
            if (serializedValue === 'true') {
                return true;
            }
            if (serializedValue === 'false') {
                return false;
            }
            var m = /^'([^']*)'$/.exec(serializedValue);
            if (m) {
                return m[1].trim();
            }
            return serializedValue;
        }
    };
    exports.IKeybindingService = instantiation_1.createDecorator('keybindingService');
    exports.SET_CONTEXT_COMMAND_ID = 'setContext';
});

define("vs/platform/lifecycle/common/lifecycle", ["require", "exports", 'vs/platform/instantiation/common/instantiation'], function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.ILifecycleService = instantiation_1.createDecorator('lifecycleService');
});

define("vs/platform/markers/common/markers", ["require", "exports", 'vs/platform/instantiation/common/instantiation'], function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IMarkerService = instantiation_1.createDecorator('markerService');
    (function (MarkerType) {
        MarkerType[MarkerType["transient"] = 1] = "transient";
        MarkerType[MarkerType["permanent"] = 2] = "permanent";
    })(exports.MarkerType || (exports.MarkerType = {}));
    var MarkerType = exports.MarkerType;
});

define("vs/platform/message/common/message", ["require", "exports", 'vs/nls!vs/platform/message/common/message', 'vs/base/common/winjs.base', 'vs/base/common/severity', 'vs/platform/instantiation/common/instantiation', 'vs/base/common/actions'], function (require, exports, nls, winjs_base_1, severity_1, instantiation_1, actions_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.CloseAction = new actions_1.Action('close.message', nls.localize(0, null), null, true, function () { return winjs_base_1.TPromise.as(true); });
    exports.CancelAction = new actions_1.Action('close.message', nls.localize(1, null), null, true, function () { return winjs_base_1.TPromise.as(true); });
    exports.IMessageService = instantiation_1.createDecorator('messageService');
    exports.Severity = severity_1.default;
});

define("vs/platform/platform", ["require", "exports", 'vs/base/common/types', 'vs/base/common/assert'], function (require, exports, Types, Assert) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var RegistryImpl = (function () {
        function RegistryImpl() {
            this.data = {};
        }
        RegistryImpl.prototype.add = function (id, data) {
            Assert.ok(Types.isString(id));
            Assert.ok(Types.isObject(data));
            Assert.ok(!this.data.hasOwnProperty(id), 'There is already an extension with this id');
            this.data[id] = data;
        };
        RegistryImpl.prototype.knows = function (id) {
            return this.data.hasOwnProperty(id);
        };
        RegistryImpl.prototype.as = function (id) {
            return this.data[id] || null;
        };
        return RegistryImpl;
    }());
    exports.Registry = new RegistryImpl();
    /**
     * A base class for registries that leverage the instantiation service to create instances.
     */
    var BaseRegistry = (function () {
        function BaseRegistry() {
            this.toBeInstantiated = [];
            this.instances = [];
        }
        BaseRegistry.prototype.setInstantiationService = function (service) {
            this.instantiationService = service;
            while (this.toBeInstantiated.length > 0) {
                var entry = this.toBeInstantiated.shift();
                this.instantiate(entry);
            }
        };
        BaseRegistry.prototype.instantiate = function (ctor) {
            var instance = this.instantiationService.createInstance(ctor);
            this.instances.push(instance);
        };
        BaseRegistry.prototype._register = function (ctor) {
            if (this.instantiationService) {
                this.instantiate(ctor);
            }
            else {
                this.toBeInstantiated.push(ctor);
            }
        };
        BaseRegistry.prototype._getInstances = function () {
            return this.instances.slice(0);
        };
        BaseRegistry.prototype._setInstances = function (instances) {
            this.instances = instances;
        };
        return BaseRegistry;
    }());
    exports.BaseRegistry = BaseRegistry;
});

define("vs/editor/common/modes/modesRegistry", ["require", "exports", 'vs/nls!vs/editor/common/modes/modesRegistry', 'vs/base/common/event', 'vs/platform/platform'], function (require, exports, nls, event_1, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // Define extension point ids
    exports.Extensions = {
        ModesRegistry: 'editor.modesRegistry'
    };
    var EditorModesRegistry = (function () {
        function EditorModesRegistry() {
            this._onDidAddCompatModes = new event_1.Emitter();
            this.onDidAddCompatModes = this._onDidAddCompatModes.event;
            this._onDidAddLanguages = new event_1.Emitter();
            this.onDidAddLanguages = this._onDidAddLanguages.event;
            this._workerParticipants = [];
            this._compatModes = [];
            this._languages = [];
        }
        // --- worker participants
        EditorModesRegistry.prototype.registerWorkerParticipants = function (participants) {
            this._workerParticipants = participants;
        };
        EditorModesRegistry.prototype.registerWorkerParticipant = function (modeId, moduleId, ctorName) {
            if (typeof modeId !== 'string') {
                throw new Error('InvalidArgument: expected `modeId` to be a string');
            }
            if (typeof moduleId !== 'string') {
                throw new Error('InvalidArgument: expected `moduleId` to be a string');
            }
            this._workerParticipants.push({
                modeId: modeId,
                moduleId: moduleId,
                ctorName: ctorName
            });
        };
        EditorModesRegistry.prototype.getWorkerParticipantsForMode = function (modeId) {
            return this._workerParticipants.filter(function (p) { return p.modeId === modeId; });
        };
        EditorModesRegistry.prototype.getWorkerParticipants = function () {
            return this._workerParticipants;
        };
        // --- compat modes
        EditorModesRegistry.prototype.registerCompatModes = function (def) {
            this._compatModes = this._compatModes.concat(def);
            this._onDidAddCompatModes.fire(def);
        };
        EditorModesRegistry.prototype.registerCompatMode = function (def) {
            this._compatModes.push(def);
            this._onDidAddCompatModes.fire([def]);
        };
        EditorModesRegistry.prototype.getCompatModes = function () {
            return this._compatModes.slice(0);
        };
        // --- languages
        EditorModesRegistry.prototype.registerLanguage = function (def) {
            this._languages.push(def);
            this._onDidAddLanguages.fire([def]);
        };
        EditorModesRegistry.prototype.registerLanguages = function (def) {
            this._languages = this._languages.concat(def);
            this._onDidAddLanguages.fire(def);
        };
        EditorModesRegistry.prototype.getLanguages = function () {
            return this._languages.slice(0);
        };
        return EditorModesRegistry;
    }());
    exports.EditorModesRegistry = EditorModesRegistry;
    exports.ModesRegistry = new EditorModesRegistry();
    platform_1.Registry.add(exports.Extensions.ModesRegistry, exports.ModesRegistry);
    exports.ModesRegistry.registerLanguage({
        id: 'plaintext',
        extensions: ['.txt', '.gitignore'],
        aliases: [nls.localize(0, null), 'text'],
        mimetypes: ['text/plain']
    });
});

define("vs/editor/common/services/languagesRegistry", ["require", "exports", 'vs/base/common/errors', 'vs/base/common/event', 'vs/base/common/mime', 'vs/base/common/strings', 'vs/editor/common/modes/modesRegistry'], function (require, exports, errors_1, event_1, mime, strings, modesRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var LanguagesRegistry = (function () {
        function LanguagesRegistry(useModesRegistry) {
            var _this = this;
            if (useModesRegistry === void 0) { useModesRegistry = true; }
            this._onDidAddModes = new event_1.Emitter();
            this.onDidAddModes = this._onDidAddModes.event;
            this.knownModeIds = {};
            this.mime2LanguageId = {};
            this.name2LanguageId = {};
            this.id2Name = {};
            this.name2Extensions = {};
            this.compatModes = {};
            this.lowerName2Id = {};
            this.id2ConfigurationFiles = {};
            if (useModesRegistry) {
                this._registerCompatModes(modesRegistry_1.ModesRegistry.getCompatModes());
                modesRegistry_1.ModesRegistry.onDidAddCompatModes(function (m) { return _this._registerCompatModes(m); });
                this._registerLanguages(modesRegistry_1.ModesRegistry.getLanguages());
                modesRegistry_1.ModesRegistry.onDidAddLanguages(function (m) { return _this._registerLanguages(m); });
            }
        }
        LanguagesRegistry.prototype._registerCompatModes = function (defs) {
            var addedModes = [];
            for (var i = 0; i < defs.length; i++) {
                var def = defs[i];
                this._registerLanguage({
                    id: def.id,
                    extensions: def.extensions,
                    filenames: def.filenames,
                    firstLine: def.firstLine,
                    aliases: def.aliases,
                    mimetypes: def.mimetypes
                });
                this.compatModes[def.id] = {
                    moduleId: def.moduleId,
                    ctorName: def.ctorName
                };
                addedModes.push(def.id);
            }
            this._onDidAddModes.fire(addedModes);
        };
        LanguagesRegistry.prototype._registerLanguages = function (desc) {
            var addedModes = [];
            for (var i = 0; i < desc.length; i++) {
                this._registerLanguage(desc[i]);
                addedModes.push(desc[i].id);
            }
            this._onDidAddModes.fire(addedModes);
        };
        LanguagesRegistry.prototype._registerLanguage = function (lang) {
            this.knownModeIds[lang.id] = true;
            var primaryMime = null;
            if (typeof lang.mimetypes !== 'undefined' && Array.isArray(lang.mimetypes)) {
                for (var i = 0; i < lang.mimetypes.length; i++) {
                    if (!primaryMime) {
                        primaryMime = lang.mimetypes[i];
                    }
                    this.mime2LanguageId[lang.mimetypes[i]] = lang.id;
                }
            }
            if (!primaryMime) {
                primaryMime = 'text/x-' + lang.id;
                this.mime2LanguageId[primaryMime] = lang.id;
            }
            if (Array.isArray(lang.extensions)) {
                for (var _i = 0, _a = lang.extensions; _i < _a.length; _i++) {
                    var extension = _a[_i];
                    mime.registerTextMime({ mime: primaryMime, extension: extension });
                }
            }
            if (Array.isArray(lang.filenames)) {
                for (var _b = 0, _c = lang.filenames; _b < _c.length; _b++) {
                    var filename = _c[_b];
                    mime.registerTextMime({ mime: primaryMime, filename: filename });
                }
            }
            if (Array.isArray(lang.filenamePatterns)) {
                for (var _d = 0, _e = lang.filenamePatterns; _d < _e.length; _d++) {
                    var filenamePattern = _e[_d];
                    mime.registerTextMime({ mime: primaryMime, filepattern: filenamePattern });
                }
            }
            if (typeof lang.firstLine === 'string' && lang.firstLine.length > 0) {
                var firstLineRegexStr = lang.firstLine;
                if (firstLineRegexStr.charAt(0) !== '^') {
                    firstLineRegexStr = '^' + firstLineRegexStr;
                }
                try {
                    var firstLineRegex = new RegExp(firstLineRegexStr);
                    if (!strings.regExpLeadsToEndlessLoop(firstLineRegex)) {
                        mime.registerTextMime({ mime: primaryMime, firstline: firstLineRegex });
                    }
                }
                catch (err) {
                    // Most likely, the regex was bad
                    errors_1.onUnexpectedError(err);
                }
            }
            this.lowerName2Id[lang.id.toLowerCase()] = lang.id;
            if (typeof lang.aliases !== 'undefined' && Array.isArray(lang.aliases)) {
                for (var i = 0; i < lang.aliases.length; i++) {
                    if (!lang.aliases[i] || lang.aliases[i].length === 0) {
                        continue;
                    }
                    this.lowerName2Id[lang.aliases[i].toLowerCase()] = lang.id;
                }
            }
            if (!this.id2Name[lang.id]) {
                var bestName = null;
                if (typeof lang.aliases !== 'undefined' && Array.isArray(lang.aliases) && lang.aliases.length > 0) {
                    bestName = lang.aliases[0];
                }
                else {
                    bestName = lang.id;
                }
                if (bestName) {
                    this.name2LanguageId[bestName] = lang.id;
                    this.name2Extensions[bestName] = lang.extensions;
                    this.id2Name[lang.id] = bestName || '';
                }
            }
            if (typeof lang.configuration === 'string') {
                this.id2ConfigurationFiles[lang.id] = this.id2ConfigurationFiles[lang.id] || [];
                this.id2ConfigurationFiles[lang.id].push(lang.configuration);
            }
        };
        LanguagesRegistry.prototype.isRegisteredMode = function (mimetypeOrModeId) {
            // Is this a known mime type ?
            if (hasOwnProperty.call(this.mime2LanguageId, mimetypeOrModeId)) {
                return true;
            }
            // Is this a known mode id ?
            return hasOwnProperty.call(this.knownModeIds, mimetypeOrModeId);
        };
        LanguagesRegistry.prototype.getRegisteredModes = function () {
            return Object.keys(this.knownModeIds);
        };
        LanguagesRegistry.prototype.getRegisteredLanguageNames = function () {
            return Object.keys(this.name2LanguageId);
        };
        LanguagesRegistry.prototype.getLanguageName = function (modeId) {
            return this.id2Name[modeId] || null;
        };
        LanguagesRegistry.prototype.getModeIdForLanguageNameLowercase = function (languageNameLower) {
            return this.lowerName2Id[languageNameLower] || null;
        };
        LanguagesRegistry.prototype.getConfigurationFiles = function (modeId) {
            return this.id2ConfigurationFiles[modeId] || [];
        };
        LanguagesRegistry.prototype.getMimeForMode = function (theModeId) {
            for (var _mime in this.mime2LanguageId) {
                if (this.mime2LanguageId.hasOwnProperty(_mime)) {
                    var modeId = this.mime2LanguageId[_mime];
                    if (modeId === theModeId) {
                        return _mime;
                    }
                }
            }
            return null;
        };
        LanguagesRegistry.prototype.extractModeIds = function (commaSeparatedMimetypesOrCommaSeparatedIdsOrName) {
            var _this = this;
            if (!commaSeparatedMimetypesOrCommaSeparatedIdsOrName) {
                return [];
            }
            return (commaSeparatedMimetypesOrCommaSeparatedIdsOrName.
                split(',').
                map(function (mimeTypeOrIdOrName) { return mimeTypeOrIdOrName.trim(); }).
                map(function (mimeTypeOrIdOrName) {
                return _this.mime2LanguageId[mimeTypeOrIdOrName] || mimeTypeOrIdOrName;
            }).
                filter(function (modeId) {
                return _this.knownModeIds[modeId];
            }));
        };
        LanguagesRegistry.prototype.getModeIdsFromLanguageName = function (languageName) {
            if (!languageName) {
                return [];
            }
            if (hasOwnProperty.call(this.name2LanguageId, languageName)) {
                return [this.name2LanguageId[languageName]];
            }
            return [];
        };
        LanguagesRegistry.prototype.getModeIdsFromFilenameOrFirstLine = function (filename, firstLine) {
            if (!filename && !firstLine) {
                return [];
            }
            var mimeTypes = mime.guessMimeTypes(filename, firstLine);
            return this.extractModeIds(mimeTypes.join(','));
        };
        LanguagesRegistry.prototype.getCompatMode = function (modeId) {
            return this.compatModes[modeId] || null;
        };
        LanguagesRegistry.prototype.getExtensions = function (languageName) {
            return this.name2Extensions[languageName];
        };
        return LanguagesRegistry;
    }());
    exports.LanguagesRegistry = LanguagesRegistry;
});

define("vs/platform/jsonschemas/common/jsonContributionRegistry", ["require", "exports", 'vs/nls!vs/platform/jsonschemas/common/jsonContributionRegistry', 'vs/platform/platform', 'vs/base/common/eventEmitter'], function (require, exports, nls, platform, eventEmitter_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.Extensions = {
        JSONContribution: 'base.contributions.json'
    };
    function normalizeId(id) {
        if (id.length > 0 && id.charAt(id.length - 1) === '#') {
            return id.substring(0, id.length - 1);
        }
        return id;
    }
    var JSONContributionRegistry = (function () {
        function JSONContributionRegistry() {
            this.schemasById = {};
            this.schemaAssociations = {};
            this.eventEmitter = new eventEmitter_1.EventEmitter();
        }
        JSONContributionRegistry.prototype.addRegistryChangedListener = function (callback) {
            return this.eventEmitter.addListener2('registryChanged', callback);
        };
        JSONContributionRegistry.prototype.registerSchema = function (uri, unresolvedSchemaContent) {
            this.schemasById[normalizeId(uri)] = unresolvedSchemaContent;
            this.eventEmitter.emit('registryChanged', {});
        };
        JSONContributionRegistry.prototype.addSchemaFileAssociation = function (pattern, uri) {
            var uris = this.schemaAssociations[pattern];
            if (!uris) {
                uris = [];
                this.schemaAssociations[pattern] = uris;
            }
            uris.push(uri);
            this.eventEmitter.emit('registryChanged', {});
        };
        JSONContributionRegistry.prototype.getSchemaContributions = function () {
            return {
                schemas: this.schemasById,
                schemaAssociations: this.schemaAssociations
            };
        };
        return JSONContributionRegistry;
    }());
    var jsonContributionRegistry = new JSONContributionRegistry();
    platform.Registry.add(exports.Extensions.JSONContribution, jsonContributionRegistry);
    // preload the schema-schema with a version that contains descriptions.
    jsonContributionRegistry.registerSchema('http://json-schema.org/draft-04/schema#', {
        'id': 'http://json-schema.org/draft-04/schema#',
        'title': nls.localize(0, null),
        '$schema': 'http://json-schema.org/draft-04/schema#',
        'definitions': {
            'schemaArray': {
                'type': 'array',
                'minItems': 1,
                'items': { '$ref': '#' }
            },
            'positiveInteger': {
                'type': 'integer',
                'minimum': 0
            },
            'positiveIntegerDefault0': {
                'allOf': [{ '$ref': '#/definitions/positiveInteger' }, { 'default': 0 }]
            },
            'simpleTypes': {
                'type': 'string',
                'enum': ['array', 'boolean', 'integer', 'null', 'number', 'object', 'string']
            },
            'stringArray': {
                'type': 'array',
                'items': { 'type': 'string' },
                'minItems': 1,
                'uniqueItems': true
            }
        },
        'type': 'object',
        'properties': {
            'id': {
                'type': 'string',
                'format': 'uri',
                'description': nls.localize(1, null)
            },
            '$schema': {
                'type': 'string',
                'format': 'uri',
                'description': nls.localize(2, null)
            },
            'title': {
                'type': 'string',
                'description': nls.localize(3, null)
            },
            'description': {
                'type': 'string',
                'description': nls.localize(4, null)
            },
            'default': {
                'description': nls.localize(5, null)
            },
            'multipleOf': {
                'type': 'number',
                'minimum': 0,
                'exclusiveMinimum': true,
                'description': nls.localize(6, null)
            },
            'maximum': {
                'type': 'number',
                'description': nls.localize(7, null)
            },
            'exclusiveMaximum': {
                'type': 'boolean',
                'default': false,
                'description': nls.localize(8, null)
            },
            'minimum': {
                'type': 'number',
                'description': nls.localize(9, null)
            },
            'exclusiveMinimum': {
                'type': 'boolean',
                'default': false,
                'description': nls.localize(10, null)
            },
            'maxLength': {
                'allOf': [
                    { '$ref': '#/definitions/positiveInteger' }
                ],
                'description': nls.localize(11, null)
            },
            'minLength': {
                'allOf': [
                    { '$ref': '#/definitions/positiveIntegerDefault0' }
                ],
                'description': nls.localize(12, null)
            },
            'pattern': {
                'type': 'string',
                'format': 'regex',
                'description': nls.localize(13, null)
            },
            'additionalItems': {
                'anyOf': [
                    { 'type': 'boolean' },
                    { '$ref': '#' }
                ],
                'default': {},
                'description': nls.localize(14, null)
            },
            'items': {
                'anyOf': [
                    { '$ref': '#' },
                    { '$ref': '#/definitions/schemaArray' }
                ],
                'default': {},
                'description': nls.localize(15, null)
            },
            'maxItems': {
                'allOf': [
                    { '$ref': '#/definitions/positiveInteger' }
                ],
                'description': nls.localize(16, null)
            },
            'minItems': {
                'allOf': [
                    { '$ref': '#/definitions/positiveIntegerDefault0' }
                ],
                'description': nls.localize(17, null)
            },
            'uniqueItems': {
                'type': 'boolean',
                'default': false,
                'description': nls.localize(18, null)
            },
            'maxProperties': {
                'allOf': [
                    { '$ref': '#/definitions/positiveInteger' }
                ],
                'description': nls.localize(19, null)
            },
            'minProperties': {
                'allOf': [
                    { '$ref': '#/definitions/positiveIntegerDefault0' },
                ],
                'description': nls.localize(20, null)
            },
            'required': {
                'allOf': [
                    { '$ref': '#/definitions/stringArray' }
                ],
                'description': nls.localize(21, null)
            },
            'additionalProperties': {
                'anyOf': [
                    { 'type': 'boolean' },
                    { '$ref': '#' }
                ],
                'default': {},
                'description': nls.localize(22, null)
            },
            'definitions': {
                'type': 'object',
                'additionalProperties': { '$ref': '#' },
                'default': {},
                'description': nls.localize(23, null)
            },
            'properties': {
                'type': 'object',
                'additionalProperties': { '$ref': '#' },
                'default': {},
                'description': nls.localize(24, null)
            },
            'patternProperties': {
                'type': 'object',
                'additionalProperties': { '$ref': '#' },
                'default': {},
                'description': nls.localize(25, null)
            },
            'dependencies': {
                'type': 'object',
                'additionalProperties': {
                    'anyOf': [
                        { '$ref': '#' },
                        { '$ref': '#/definitions/stringArray' }
                    ]
                },
                'description': nls.localize(26, null)
            },
            'enum': {
                'type': 'array',
                'minItems': 1,
                'uniqueItems': true,
                'description': nls.localize(27, null)
            },
            'type': {
                'anyOf': [
                    { '$ref': '#/definitions/simpleTypes' },
                    {
                        'type': 'array',
                        'items': { '$ref': '#/definitions/simpleTypes' },
                        'minItems': 1,
                        'uniqueItems': true
                    }
                ],
                'description': nls.localize(28, null)
            },
            'format': {
                'anyOf': [
                    {
                        'type': 'string',
                        'description': nls.localize(29, null),
                        'enum': ['date-time', 'uri', 'email', 'hostname', 'ipv4', 'ipv6', 'regex']
                    }, {
                        'type': 'string'
                    }
                ]
            },
            'allOf': {
                'allOf': [
                    { '$ref': '#/definitions/schemaArray' }
                ],
                'description': nls.localize(30, null)
            },
            'anyOf': {
                'allOf': [
                    { '$ref': '#/definitions/schemaArray' }
                ],
                'description': nls.localize(31, null)
            },
            'oneOf': {
                'allOf': [
                    { '$ref': '#/definitions/schemaArray' }
                ],
                'description': nls.localize(32, null)
            },
            'not': {
                'allOf': [
                    { '$ref': '#' }
                ],
                'description': nls.localize(33, null)
            }
        },
        'dependencies': {
            'exclusiveMaximum': ['maximum'],
            'exclusiveMinimum': ['minimum']
        },
        'default': {}
    });
});

define("vs/platform/extensions/common/extensionsRegistry", ["require", "exports", 'vs/nls!vs/platform/extensions/common/extensionsRegistry', 'vs/base/common/errors', 'vs/base/common/paths', 'vs/base/common/severity', 'vs/platform/jsonschemas/common/jsonContributionRegistry', 'vs/platform/platform'], function (require, exports, nls, errors_1, paths, severity_1, jsonContributionRegistry_1, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ExtensionMessageCollector = (function () {
        function ExtensionMessageCollector(messageHandler, source) {
            this._messageHandler = messageHandler;
            this._source = source;
        }
        ExtensionMessageCollector.prototype._msg = function (type, message) {
            this._messageHandler({
                type: type,
                message: message,
                source: this._source
            });
        };
        ExtensionMessageCollector.prototype.error = function (message) {
            this._msg(severity_1.default.Error, message);
        };
        ExtensionMessageCollector.prototype.warn = function (message) {
            this._msg(severity_1.default.Warning, message);
        };
        ExtensionMessageCollector.prototype.info = function (message) {
            this._msg(severity_1.default.Info, message);
        };
        return ExtensionMessageCollector;
    }());
    function isValidExtensionDescription(extensionFolderPath, extensionDescription, notices) {
        if (!extensionDescription) {
            notices.push(nls.localize(0, null));
            return false;
        }
        if (typeof extensionDescription.publisher !== 'string') {
            notices.push(nls.localize(1, null, 'publisher'));
            return false;
        }
        if (typeof extensionDescription.name !== 'string') {
            notices.push(nls.localize(2, null, 'name'));
            return false;
        }
        if (typeof extensionDescription.version !== 'string') {
            notices.push(nls.localize(3, null, 'version'));
            return false;
        }
        if (!extensionDescription.engines) {
            notices.push(nls.localize(4, null, 'engines'));
            return false;
        }
        if (typeof extensionDescription.engines.vscode !== 'string') {
            notices.push(nls.localize(5, null, 'engines.vscode'));
            return false;
        }
        if (typeof extensionDescription.extensionDependencies !== 'undefined') {
            if (!_isStringArray(extensionDescription.extensionDependencies)) {
                notices.push(nls.localize(6, null, 'extensionDependencies'));
                return false;
            }
        }
        if (typeof extensionDescription.activationEvents !== 'undefined') {
            if (!_isStringArray(extensionDescription.activationEvents)) {
                notices.push(nls.localize(7, null, 'activationEvents'));
                return false;
            }
            if (typeof extensionDescription.main === 'undefined') {
                notices.push(nls.localize(8, null, 'activationEvents', 'main'));
                return false;
            }
        }
        if (typeof extensionDescription.main !== 'undefined') {
            if (typeof extensionDescription.main !== 'string') {
                notices.push(nls.localize(9, null, 'main'));
                return false;
            }
            else {
                var normalizedAbsolutePath = paths.normalize(paths.join(extensionFolderPath, extensionDescription.main));
                if (normalizedAbsolutePath.indexOf(extensionFolderPath)) {
                    notices.push(nls.localize(10, null, normalizedAbsolutePath, extensionFolderPath));
                }
            }
            if (typeof extensionDescription.activationEvents === 'undefined') {
                notices.push(nls.localize(11, null, 'activationEvents', 'main'));
                return false;
            }
        }
        return true;
    }
    exports.isValidExtensionDescription = isValidExtensionDescription;
    var hasOwnProperty = Object.hasOwnProperty;
    var schemaRegistry = platform_1.Registry.as(jsonContributionRegistry_1.Extensions.JSONContribution);
    var ExtensionPoint = (function () {
        function ExtensionPoint(name, registry) {
            this.name = name;
            this._registry = registry;
            this._handler = null;
            this._messageHandler = null;
        }
        ExtensionPoint.prototype.setHandler = function (handler) {
            if (this._handler) {
                throw new Error('Handler already set!');
            }
            this._handler = handler;
            this._handle();
        };
        ExtensionPoint.prototype.handle = function (messageHandler) {
            this._messageHandler = messageHandler;
            this._handle();
        };
        ExtensionPoint.prototype._handle = function () {
            var _this = this;
            if (!this._handler || !this._messageHandler) {
                return;
            }
            this._registry.registerPointListener(this.name, function (descriptions) {
                var users = descriptions.map(function (desc) {
                    return {
                        description: desc,
                        value: desc.contributes[_this.name],
                        collector: new ExtensionMessageCollector(_this._messageHandler, desc.extensionFolderPath)
                    };
                });
                _this._handler(users);
            });
        };
        return ExtensionPoint;
    }());
    var schemaId = 'vscode://schemas/vscode-extensions';
    var schema = {
        default: {
            'name': '{{name}}',
            'description': '{{description}}',
            'author': '{{author}}',
            'version': '{{1.0.0}}',
            'main': '{{pathToMain}}',
            'dependencies': {}
        },
        properties: {
            // engines: {
            // 	required: [ 'vscode' ],
            // 	properties: {
            // 		'vscode': {
            // 			type: 'string',
            // 			description: nls.localize('vscode.extension.engines.vscode', 'Specifies that this package only runs inside VSCode of the given version.'),
            // 		}
            // 	}
            // },
            displayName: {
                description: nls.localize(12, null),
                type: 'string'
            },
            categories: {
                description: nls.localize(13, null),
                type: 'array',
                items: {
                    type: 'string',
                    enum: ['Languages', 'Snippets', 'Linters', 'Themes', 'Debuggers', 'Other']
                }
            },
            galleryBanner: {
                type: 'object',
                description: nls.localize(14, null),
                properties: {
                    color: {
                        description: nls.localize(15, null),
                        type: 'string'
                    },
                    theme: {
                        description: nls.localize(16, null),
                        type: 'string',
                        enum: ['dark', 'light']
                    }
                }
            },
            publisher: {
                description: nls.localize(17, null),
                type: 'string'
            },
            activationEvents: {
                description: nls.localize(18, null),
                type: 'array',
                items: {
                    type: 'string'
                }
            },
            extensionDependencies: {
                description: nls.localize(19, null),
                type: 'array',
                items: {
                    type: 'string'
                }
            },
            scripts: {
                type: 'object',
                properties: {
                    'vscode:prepublish': {
                        description: nls.localize(20, null),
                        type: 'string'
                    }
                }
            },
            contributes: {
                description: nls.localize(21, null),
                type: 'object',
                properties: {},
                default: {}
            }
        }
    };
    var ExtensionsRegistryImpl = (function () {
        function ExtensionsRegistryImpl() {
            this._extensionsMap = {};
            this._extensionsArr = [];
            this._activationMap = {};
            this._pointListeners = [];
            this._extensionPoints = {};
            this._oneTimeActivationEventListeners = {};
        }
        ExtensionsRegistryImpl.prototype.registerPointListener = function (point, handler) {
            var entry = {
                extensionPoint: point,
                listener: handler
            };
            this._pointListeners.push(entry);
            this._triggerPointListener(entry, ExtensionsRegistryImpl._filterWithExtPoint(this.getAllExtensionDescriptions(), point));
        };
        ExtensionsRegistryImpl.prototype.registerExtensionPoint = function (extensionPoint, jsonSchema) {
            if (hasOwnProperty.call(this._extensionPoints, extensionPoint)) {
                throw new Error('Duplicate extension point: ' + extensionPoint);
            }
            var result = new ExtensionPoint(extensionPoint, this);
            this._extensionPoints[extensionPoint] = result;
            schema.properties['contributes'].properties[extensionPoint] = jsonSchema;
            schemaRegistry.registerSchema(schemaId, schema);
            return result;
        };
        ExtensionsRegistryImpl.prototype.handleExtensionPoints = function (messageHandler) {
            var _this = this;
            Object.keys(this._extensionPoints).forEach(function (extensionPointName) {
                _this._extensionPoints[extensionPointName].handle(messageHandler);
            });
        };
        ExtensionsRegistryImpl.prototype._triggerPointListener = function (handler, desc) {
            // console.log('_triggerPointListeners: ' + desc.length + ' OF ' + handler.extensionPoint);
            if (!desc || desc.length === 0) {
                return;
            }
            try {
                handler.listener(desc);
            }
            catch (e) {
                errors_1.onUnexpectedError(e);
            }
        };
        ExtensionsRegistryImpl.prototype.registerExtensions = function (extensionDescriptions) {
            for (var i = 0, len = extensionDescriptions.length; i < len; i++) {
                var extensionDescription = extensionDescriptions[i];
                if (hasOwnProperty.call(this._extensionsMap, extensionDescription.id)) {
                    // No overwriting allowed!
                    console.error('Extension `' + extensionDescription.id + '` is already registered');
                    continue;
                }
                this._extensionsMap[extensionDescription.id] = extensionDescription;
                this._extensionsArr.push(extensionDescription);
                if (Array.isArray(extensionDescription.activationEvents)) {
                    for (var j = 0, lenJ = extensionDescription.activationEvents.length; j < lenJ; j++) {
                        var activationEvent = extensionDescription.activationEvents[j];
                        this._activationMap[activationEvent] = this._activationMap[activationEvent] || [];
                        this._activationMap[activationEvent].push(extensionDescription);
                    }
                }
            }
            for (var i = 0, len = this._pointListeners.length; i < len; i++) {
                var listenerEntry = this._pointListeners[i];
                var descriptions = ExtensionsRegistryImpl._filterWithExtPoint(extensionDescriptions, listenerEntry.extensionPoint);
                this._triggerPointListener(listenerEntry, descriptions);
            }
        };
        ExtensionsRegistryImpl._filterWithExtPoint = function (input, point) {
            return input.filter(function (desc) {
                return (desc.contributes && hasOwnProperty.call(desc.contributes, point));
            });
        };
        ExtensionsRegistryImpl.prototype.getExtensionDescriptionsForActivationEvent = function (activationEvent) {
            if (!hasOwnProperty.call(this._activationMap, activationEvent)) {
                return [];
            }
            return this._activationMap[activationEvent].slice(0);
        };
        ExtensionsRegistryImpl.prototype.getAllExtensionDescriptions = function () {
            return this._extensionsArr.slice(0);
        };
        ExtensionsRegistryImpl.prototype.getExtensionDescription = function (extensionId) {
            if (!hasOwnProperty.call(this._extensionsMap, extensionId)) {
                return null;
            }
            return this._extensionsMap[extensionId];
        };
        ExtensionsRegistryImpl.prototype.registerOneTimeActivationEventListener = function (activationEvent, listener) {
            if (!hasOwnProperty.call(this._oneTimeActivationEventListeners, activationEvent)) {
                this._oneTimeActivationEventListeners[activationEvent] = [];
            }
            this._oneTimeActivationEventListeners[activationEvent].push(listener);
        };
        ExtensionsRegistryImpl.prototype.triggerActivationEventListeners = function (activationEvent) {
            if (hasOwnProperty.call(this._oneTimeActivationEventListeners, activationEvent)) {
                var listeners = this._oneTimeActivationEventListeners[activationEvent];
                delete this._oneTimeActivationEventListeners[activationEvent];
                for (var i = 0, len = listeners.length; i < len; i++) {
                    var listener = listeners[i];
                    try {
                        listener();
                    }
                    catch (e) {
                        errors_1.onUnexpectedError(e);
                    }
                }
            }
        };
        return ExtensionsRegistryImpl;
    }());
    function _isStringArray(arr) {
        if (!Array.isArray(arr)) {
            return false;
        }
        for (var i = 0, len = arr.length; i < len; i++) {
            if (typeof arr[i] !== 'string') {
                return false;
            }
        }
        return true;
    }
    var PRExtensions = {
        ExtensionsRegistry: 'ExtensionsRegistry'
    };
    platform_1.Registry.add(PRExtensions.ExtensionsRegistry, new ExtensionsRegistryImpl());
    exports.ExtensionsRegistry = platform_1.Registry.as(PRExtensions.ExtensionsRegistry);
    schemaRegistry.registerSchema(schemaId, schema);
    schemaRegistry.addSchemaFileAssociation('/package.json', schemaId);
});

define("vs/platform/extensions/common/abstractExtensionService", ["require", "exports", 'vs/nls!vs/platform/extensions/common/abstractExtensionService', 'vs/base/common/severity', 'vs/base/common/winjs.base', 'vs/platform/extensions/common/extensions', 'vs/platform/extensions/common/extensionsRegistry'], function (require, exports, nls, severity_1, winjs_base_1, extensions_1, extensionsRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var hasOwnProperty = Object.hasOwnProperty;
    var ActivatedExtension = (function () {
        function ActivatedExtension(activationFailed) {
            this.activationFailed = activationFailed;
        }
        return ActivatedExtension;
    }());
    exports.ActivatedExtension = ActivatedExtension;
    var AbstractExtensionService = (function () {
        function AbstractExtensionService(isReadyByDefault) {
            var _this = this;
            this.serviceId = extensions_1.IExtensionService;
            if (isReadyByDefault) {
                this._onReady = winjs_base_1.TPromise.as(true);
                this._onReadyC = function (v) { };
            }
            else {
                this._onReady = new winjs_base_1.TPromise(function (c, e, p) {
                    _this._onReadyC = c;
                }, function () {
                    console.warn('You should really not try to cancel this ready promise!');
                });
            }
            this._activatingExtensions = {};
            this._activatedExtensions = {};
        }
        AbstractExtensionService.prototype._triggerOnReady = function () {
            this._onReadyC(true);
        };
        AbstractExtensionService.prototype.onReady = function () {
            return this._onReady;
        };
        AbstractExtensionService.prototype.getExtensionsStatus = function () {
            return null;
        };
        AbstractExtensionService.prototype.isActivated = function (extensionId) {
            return hasOwnProperty.call(this._activatedExtensions, extensionId);
        };
        AbstractExtensionService.prototype.activateByEvent = function (activationEvent) {
            var _this = this;
            return this._onReady.then(function () {
                extensionsRegistry_1.ExtensionsRegistry.triggerActivationEventListeners(activationEvent);
                var activateExtensions = extensionsRegistry_1.ExtensionsRegistry.getExtensionDescriptionsForActivationEvent(activationEvent);
                return _this._activateExtensions(activateExtensions, 0);
            });
        };
        AbstractExtensionService.prototype.activateById = function (extensionId) {
            var _this = this;
            return this._onReady.then(function () {
                var desc = extensionsRegistry_1.ExtensionsRegistry.getExtensionDescription(extensionId);
                if (!desc) {
                    throw new Error('Extension `' + extensionId + '` is not known');
                }
                return _this._activateExtensions([desc], 0);
            });
        };
        /**
         * Handle semantics related to dependencies for `currentExtension`.
         * semantics: `redExtensions` must wait for `greenExtensions`.
         */
        AbstractExtensionService.prototype._handleActivateRequest = function (currentExtension, greenExtensions, redExtensions) {
            var depIds = (typeof currentExtension.extensionDependencies === 'undefined' ? [] : currentExtension.extensionDependencies);
            var currentExtensionGetsGreenLight = true;
            for (var j = 0, lenJ = depIds.length; j < lenJ; j++) {
                var depId = depIds[j];
                var depDesc = extensionsRegistry_1.ExtensionsRegistry.getExtensionDescription(depId);
                if (!depDesc) {
                    // Error condition 1: unknown dependency
                    this._showMessage(severity_1.default.Error, nls.localize(0, null, depId, currentExtension.id));
                    this._activatedExtensions[currentExtension.id] = this._createFailedExtension();
                    return;
                }
                if (hasOwnProperty.call(this._activatedExtensions, depId)) {
                    var dep = this._activatedExtensions[depId];
                    if (dep.activationFailed) {
                        // Error condition 2: a dependency has already failed activation
                        this._showMessage(severity_1.default.Error, nls.localize(1, null, depId, currentExtension.id));
                        this._activatedExtensions[currentExtension.id] = this._createFailedExtension();
                        return;
                    }
                }
                else {
                    // must first wait for the dependency to activate
                    currentExtensionGetsGreenLight = false;
                    greenExtensions[depId] = depDesc;
                }
            }
            if (currentExtensionGetsGreenLight) {
                greenExtensions[currentExtension.id] = currentExtension;
            }
            else {
                redExtensions.push(currentExtension);
            }
        };
        AbstractExtensionService.prototype._activateExtensions = function (extensionDescriptions, recursionLevel) {
            var _this = this;
            // console.log(recursionLevel, '_activateExtensions: ', extensionDescriptions.map(p => p.id));
            if (extensionDescriptions.length === 0) {
                return winjs_base_1.TPromise.as(void 0);
            }
            extensionDescriptions = extensionDescriptions.filter(function (p) { return !hasOwnProperty.call(_this._activatedExtensions, p.id); });
            if (extensionDescriptions.length === 0) {
                return winjs_base_1.TPromise.as(void 0);
            }
            if (recursionLevel > 10) {
                // More than 10 dependencies deep => most likely a dependency loop
                for (var i = 0, len = extensionDescriptions.length; i < len; i++) {
                    // Error condition 3: dependency loop
                    this._showMessage(severity_1.default.Error, nls.localize(2, null, extensionDescriptions[i].id));
                    this._activatedExtensions[extensionDescriptions[i].id] = this._createFailedExtension();
                }
                return winjs_base_1.TPromise.as(void 0);
            }
            var greenMap = Object.create(null), red = [];
            for (var i = 0, len = extensionDescriptions.length; i < len; i++) {
                this._handleActivateRequest(extensionDescriptions[i], greenMap, red);
            }
            // Make sure no red is also green
            for (var i = 0, len = red.length; i < len; i++) {
                if (greenMap[red[i].id]) {
                    delete greenMap[red[i].id];
                }
            }
            var green = Object.keys(greenMap).map(function (id) { return greenMap[id]; });
            // console.log('greenExtensions: ', green.map(p => p.id));
            // console.log('redExtensions: ', red.map(p => p.id));
            if (red.length === 0) {
                // Finally reached only leafs!
                return winjs_base_1.TPromise.join(green.map(function (p) { return _this._activateExtension(p); })).then(function (_) { return void 0; });
            }
            return this._activateExtensions(green, recursionLevel + 1).then(function (_) {
                return _this._activateExtensions(red, recursionLevel + 1);
            });
        };
        AbstractExtensionService.prototype._activateExtension = function (extensionDescription) {
            var _this = this;
            if (hasOwnProperty.call(this._activatedExtensions, extensionDescription.id)) {
                return winjs_base_1.TPromise.as(void 0);
            }
            if (hasOwnProperty.call(this._activatingExtensions, extensionDescription.id)) {
                return this._activatingExtensions[extensionDescription.id];
            }
            this._activatingExtensions[extensionDescription.id] = this._actualActivateExtension(extensionDescription).then(null, function (err) {
                _this._showMessage(severity_1.default.Error, nls.localize(3, null, extensionDescription.id, err.message));
                console.error('Activating extension `' + extensionDescription.id + '` failed: ', err.message);
                console.log('Here is the error stack: ', err.stack);
                // Treat the extension as being empty
                return _this._createFailedExtension();
            }).then(function (x) {
                _this._activatedExtensions[extensionDescription.id] = x;
                delete _this._activatingExtensions[extensionDescription.id];
            });
            return this._activatingExtensions[extensionDescription.id];
        };
        return AbstractExtensionService;
    }());
    exports.AbstractExtensionService = AbstractExtensionService;
});

define("vs/platform/extensions/node/extensionValidator", ["require", "exports", 'vs/nls!vs/platform/extensions/node/extensionValidator', 'vs/platform/extensions/common/extensionsRegistry', 'semver'], function (require, exports, nls, extensionsRegistry_1, semver_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var VERSION_REGEXP = /^(\^)?((\d+)|x)\.((\d+)|x)\.((\d+)|x)(\-.*)?$/;
    function isValidVersionStr(version) {
        version = version.trim();
        return (version === '*' || VERSION_REGEXP.test(version));
    }
    exports.isValidVersionStr = isValidVersionStr;
    function parseVersion(version) {
        if (!isValidVersionStr(version)) {
            return null;
        }
        version = version.trim();
        if (version === '*') {
            return {
                hasCaret: false,
                majorBase: 0,
                majorMustEqual: false,
                minorBase: 0,
                minorMustEqual: false,
                patchBase: 0,
                patchMustEqual: false,
                preRelease: null
            };
        }
        var m = version.match(VERSION_REGEXP);
        return {
            hasCaret: !!m[1],
            majorBase: m[2] === 'x' ? 0 : parseInt(m[2], 10),
            majorMustEqual: (m[2] === 'x' ? false : true),
            minorBase: m[4] === 'x' ? 0 : parseInt(m[4], 10),
            minorMustEqual: (m[4] === 'x' ? false : true),
            patchBase: m[6] === 'x' ? 0 : parseInt(m[6], 10),
            patchMustEqual: (m[6] === 'x' ? false : true),
            preRelease: m[8] || null
        };
    }
    exports.parseVersion = parseVersion;
    function normalizeVersion(version) {
        if (!version) {
            return null;
        }
        var majorBase = version.majorBase, majorMustEqual = version.majorMustEqual, minorBase = version.minorBase, minorMustEqual = version.minorMustEqual, patchBase = version.patchBase, patchMustEqual = version.patchMustEqual;
        if (version.hasCaret) {
            if (majorBase === 0) {
                patchMustEqual = false;
            }
            else {
                minorMustEqual = false;
                patchMustEqual = false;
            }
        }
        return {
            majorBase: majorBase,
            majorMustEqual: majorMustEqual,
            minorBase: minorBase,
            minorMustEqual: minorMustEqual,
            patchBase: patchBase,
            patchMustEqual: patchMustEqual
        };
    }
    exports.normalizeVersion = normalizeVersion;
    function isValidVersion(_version, _desiredVersion) {
        var version;
        if (typeof _version === 'string') {
            version = normalizeVersion(parseVersion(_version));
        }
        else {
            version = _version;
        }
        var desiredVersion;
        if (typeof _desiredVersion === 'string') {
            desiredVersion = normalizeVersion(parseVersion(_desiredVersion));
        }
        else {
            desiredVersion = _desiredVersion;
        }
        if (!version || !desiredVersion) {
            return false;
        }
        var majorBase = version.majorBase;
        var minorBase = version.minorBase;
        var patchBase = version.patchBase;
        var desiredMajorBase = desiredVersion.majorBase;
        var desiredMinorBase = desiredVersion.minorBase;
        var desiredPatchBase = desiredVersion.patchBase;
        var majorMustEqual = desiredVersion.majorMustEqual;
        var minorMustEqual = desiredVersion.minorMustEqual;
        var patchMustEqual = desiredVersion.patchMustEqual;
        // Anything < 1.0.0 is compatible with >= 1.0.0, except exact matches
        if (majorBase === 1 && desiredMajorBase === 0 && (!majorMustEqual || !minorMustEqual || !patchMustEqual)) {
            desiredMajorBase = 1;
            desiredMinorBase = 0;
            desiredPatchBase = 0;
            majorMustEqual = true;
            minorMustEqual = false;
            patchMustEqual = false;
        }
        if (majorBase < desiredMajorBase) {
            // smaller major version
            return false;
        }
        if (majorBase > desiredMajorBase) {
            // higher major version
            return (!majorMustEqual);
        }
        // at this point, majorBase are equal
        if (minorBase < desiredMinorBase) {
            // smaller minor version
            return false;
        }
        if (minorBase > desiredMinorBase) {
            // higher minor version
            return (!minorMustEqual);
        }
        // at this point, minorBase are equal
        if (patchBase < desiredPatchBase) {
            // smaller patch version
            return false;
        }
        if (patchBase > desiredPatchBase) {
            // higher patch version
            return (!patchMustEqual);
        }
        // at this point, patchBase are equal
        return true;
    }
    exports.isValidVersion = isValidVersion;
    function isValidExtensionVersion(version, extensionDesc, notices) {
        if (extensionDesc.isBuiltin || typeof extensionDesc.main === 'undefined') {
            // No version check for builtin or declarative extensions
            return true;
        }
        var desiredVersion = normalizeVersion(parseVersion(extensionDesc.engines.vscode));
        if (!desiredVersion) {
            notices.push(nls.localize(0, null, extensionDesc.engines.vscode));
            return false;
        }
        // enforce that a breaking API version is specified.
        // for 0.X.Y, that means up to 0.X must be specified
        // otherwise for Z.X.Y, that means Z must be specified
        if (desiredVersion.majorBase === 0) {
            // force that major and minor must be specific
            if (!desiredVersion.majorMustEqual || !desiredVersion.minorMustEqual) {
                notices.push(nls.localize(1, null, extensionDesc.engines.vscode));
                return false;
            }
        }
        else {
            // force that major must be specific
            if (!desiredVersion.majorMustEqual) {
                notices.push(nls.localize(2, null, extensionDesc.engines.vscode));
                return false;
            }
        }
        if (!isValidVersion(version, desiredVersion)) {
            notices.push(nls.localize(3, null, version, extensionDesc.engines.vscode));
            return false;
        }
        return true;
    }
    exports.isValidExtensionVersion = isValidExtensionVersion;
    function isValidExtensionDescription(version, extensionFolderPath, extensionDescription, notices) {
        if (!extensionsRegistry_1.isValidExtensionDescription(extensionFolderPath, extensionDescription, notices)) {
            return false;
        }
        if (!semver_1.valid(extensionDescription.version)) {
            notices.push(nls.localize(4, null));
            return false;
        }
        return isValidExtensionVersion(version, extensionDescription, notices);
    }
    exports.isValidExtensionDescription = isValidExtensionDescription;
});

define("vs/platform/keybinding/common/keybindingsRegistry", ["require", "exports", 'vs/base/common/keyCodes', 'vs/base/common/platform', 'vs/base/common/types', 'vs/platform/platform'], function (require, exports, keyCodes_1, platform, types_1, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var KeybindingsRegistryImpl = (function () {
        function KeybindingsRegistryImpl() {
            this.WEIGHT = {
                editorCore: function (importance) {
                    if (importance === void 0) { importance = 0; }
                    return 0 + importance;
                },
                editorContrib: function (importance) {
                    if (importance === void 0) { importance = 0; }
                    return 100 + importance;
                },
                workbenchContrib: function (importance) {
                    if (importance === void 0) { importance = 0; }
                    return 200 + importance;
                },
                builtinExtension: function (importance) {
                    if (importance === void 0) { importance = 0; }
                    return 300 + importance;
                },
                externalExtension: function (importance) {
                    if (importance === void 0) { importance = 0; }
                    return 400 + importance;
                }
            };
            this._keybindings = [];
            this._commands = Object.create(null);
        }
        /**
         * Take current platform into account and reduce to primary & secondary.
         */
        KeybindingsRegistryImpl.bindToCurrentPlatform = function (kb) {
            if (platform.isWindows) {
                if (kb && kb.win) {
                    return kb.win;
                }
            }
            else if (platform.isMacintosh) {
                if (kb && kb.mac) {
                    return kb.mac;
                }
            }
            else {
                if (kb && kb.linux) {
                    return kb.linux;
                }
            }
            return kb;
        };
        KeybindingsRegistryImpl.prototype.registerCommandRule = function (rule) {
            var _this = this;
            var actualKb = KeybindingsRegistryImpl.bindToCurrentPlatform(rule);
            if (actualKb && actualKb.primary) {
                this.registerDefaultKeybinding(actualKb.primary, rule.id, rule.weight, 0, rule.context);
            }
            if (actualKb && Array.isArray(actualKb.secondary)) {
                actualKb.secondary.forEach(function (k, i) { return _this.registerDefaultKeybinding(k, rule.id, rule.weight, -i - 1, rule.context); });
            }
        };
        KeybindingsRegistryImpl.prototype.registerCommandDesc = function (desc) {
            this.registerCommandRule(desc);
            // if (_commands[desc.id]) {
            // 	console.warn('Duplicate handler for command: ' + desc.id);
            // }
            // this._commands[desc.id] = desc.handler;
            var handler = desc.handler;
            var description = desc.description || handler.description;
            // add argument validation if rich command metadata is provided
            if (typeof description === 'object') {
                var constraints_1 = [];
                for (var _i = 0, _a = description.args; _i < _a.length; _i++) {
                    var arg = _a[_i];
                    constraints_1.push(arg.constraint);
                }
                handler = function (accesor, args) {
                    types_1.validateConstraints(args, constraints_1);
                    return desc.handler(accesor, args);
                };
            }
            // make sure description is there
            handler.description = description;
            // register handler
            this._commands[desc.id] = handler;
        };
        KeybindingsRegistryImpl.prototype.getCommands = function () {
            return this._commands;
        };
        KeybindingsRegistryImpl.prototype.registerDefaultKeybinding = function (keybinding, commandId, weight1, weight2, context) {
            if (platform.isWindows) {
                if (keyCodes_1.BinaryKeybindings.hasCtrlCmd(keybinding) && !keyCodes_1.BinaryKeybindings.hasShift(keybinding) && keyCodes_1.BinaryKeybindings.hasAlt(keybinding) && !keyCodes_1.BinaryKeybindings.hasWinCtrl(keybinding)) {
                    if (/^[A-Z0-9\[\]\|\;\'\,\.\/\`]$/.test(keyCodes_1.KeyCode.toString(keyCodes_1.BinaryKeybindings.extractKeyCode(keybinding)))) {
                        console.warn('Ctrl+Alt+ keybindings should not be used by default under Windows. Offender: ', keybinding, ' for ', commandId);
                    }
                }
            }
            this._keybindings.push({
                keybinding: keybinding,
                command: commandId,
                context: context,
                weight1: weight1,
                weight2: weight2
            });
        };
        KeybindingsRegistryImpl.prototype.getDefaultKeybindings = function () {
            return this._keybindings;
        };
        return KeybindingsRegistryImpl;
    }());
    exports.KeybindingsRegistry = new KeybindingsRegistryImpl();
    // Define extension point ids
    exports.Extensions = {
        EditorModes: 'platform.keybindingsRegistry'
    };
    platform_1.Registry.add(exports.Extensions.EditorModes, exports.KeybindingsRegistry);
});

define("vs/editor/common/config/config", ["require", "exports", 'vs/base/common/keyCodes', 'vs/platform/editor/common/editor', 'vs/platform/keybinding/common/keybindingService', 'vs/platform/keybinding/common/keybindingsRegistry', 'vs/editor/common/editorCommon', 'vs/editor/common/services/codeEditorService'], function (require, exports, keyCodes_1, editor_1, keybindingService_1, keybindingsRegistry_1, editorCommon, codeEditorService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var H = editorCommon.Handler;
    function findFocusedEditor(commandId, accessor, args, complain) {
        var codeEditorService = accessor.get(codeEditorService_1.ICodeEditorService);
        var editorId = args.context.editorId;
        if (!editorId) {
            if (complain) {
                console.warn('Cannot execute ' + commandId + ' because no editor is focused.');
            }
            return null;
        }
        var editor = codeEditorService.getCodeEditor(editorId);
        if (!editor) {
            if (complain) {
                console.warn('Cannot execute ' + commandId + ' because editor `' + editorId + '` could not be found.');
            }
            return null;
        }
        return editor;
    }
    exports.findFocusedEditor = findFocusedEditor;
    function withCodeEditorFromCommandHandler(commandId, accessor, args, callback) {
        var editor = findFocusedEditor(commandId, accessor, args, true);
        if (editor) {
            callback(editor);
        }
    }
    exports.withCodeEditorFromCommandHandler = withCodeEditorFromCommandHandler;
    function getActiveEditor(accessor) {
        var editorService = accessor.get(editor_1.IEditorService);
        var activeEditor = editorService.getActiveEditor && editorService.getActiveEditor();
        if (activeEditor) {
            var editor = activeEditor.getControl();
            // Substitute for (editor instanceof ICodeEditor)
            if (editor && typeof editor.getEditorType === 'function') {
                var codeEditor = editor;
                return codeEditor;
            }
        }
        return null;
    }
    exports.getActiveEditor = getActiveEditor;
    function triggerEditorHandler(handlerId, accessor, args) {
        withCodeEditorFromCommandHandler(handlerId, accessor, args, function (editor) {
            editor.trigger('keyboard', handlerId, args);
        });
    }
    function registerCoreCommand(handlerId, kb, weight, context) {
        if (weight === void 0) { weight = keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorCore(); }
        var desc = {
            id: handlerId,
            handler: triggerEditorHandler.bind(null, handlerId),
            weight: weight,
            context: (context ? context : keybindingService_1.KbExpr.has(editorCommon.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS)),
            primary: kb.primary,
            secondary: kb.secondary,
            win: kb.win,
            mac: kb.mac,
            linux: kb.linux
        };
        keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc(desc);
    }
    function registerCoreDispatchCommand2(handlerId) {
        var desc = {
            id: handlerId,
            handler: triggerEditorHandler.bind(null, handlerId),
            weight: keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorCore(),
            context: null,
            primary: 0
        };
        keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc(desc);
        var desc2 = {
            id: 'default:' + handlerId,
            handler: function (accessor, args) {
                withCodeEditorFromCommandHandler(handlerId, accessor, args, function (editor) {
                    editor.trigger('keyboard', handlerId, args[0]);
                });
            },
            weight: keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorCore(),
            context: null,
            primary: 0
        };
        keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc(desc2);
    }
    registerCoreDispatchCommand2(H.Type);
    registerCoreDispatchCommand2(H.ReplacePreviousChar);
    registerCoreDispatchCommand2(H.Paste);
    registerCoreDispatchCommand2(H.Cut);
    function getMacWordNavigationKB(shift, key) {
        // For macs, word navigation is based on the alt modifier
        if (shift) {
            return keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | key;
        }
        else {
            return keyCodes_1.KeyMod.Alt | key;
        }
    }
    function getWordNavigationKB(shift, key) {
        // Normally word navigation is based on the ctrl modifier
        if (shift) {
            return keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | key;
        }
        else {
            return keyCodes_1.KeyMod.CtrlCmd | key;
        }
    }
    // https://support.apple.com/en-gb/HT201236
    // [ADDED] Control-H					Delete the character to the left of the insertion point. Or use Delete.
    // [ADDED] Control-D					Delete the character to the right of the insertion point. Or use Fn-Delete.
    // [ADDED] Control-K					Delete the text between the insertion point and the end of the line or paragraph.
    // [ADDED] Command–Up Arrow				Move the insertion point to the beginning of the document.
    // [ADDED] Command–Down Arrow			Move the insertion point to the end of the document.
    // [ADDED] Command–Left Arrow			Move the insertion point to the beginning of the current line.
    // [ADDED] Command–Right Arrow			Move the insertion point to the end of the current line.
    // [ADDED] Option–Left Arrow			Move the insertion point to the beginning of the previous word.
    // [ADDED] Option–Right Arrow			Move the insertion point to the end of the next word.
    // [ADDED] Command–Shift–Up Arrow		Select the text between the insertion point and the beginning of the document.
    // [ADDED] Command–Shift–Down Arrow		Select the text between the insertion point and the end of the document.
    // [ADDED] Command–Shift–Left Arrow		Select the text between the insertion point and the beginning of the current line.
    // [ADDED] Command–Shift–Right Arrow	Select the text between the insertion point and the end of the current line.
    // [USED BY DUPLICATE LINES] Shift–Option–Up Arrow		Extend text selection to the beginning of the current paragraph, then to the beginning of the following paragraph if pressed again.
    // [USED BY DUPLICATE LINES] Shift–Option–Down Arrow	Extend text selection to the end of the current paragraph, then to the end of the following paragraph if pressed again.
    // [ADDED] Shift–Option–Left Arrow		Extend text selection to the beginning of the current word, then to the beginning of the following word if pressed again.
    // [ADDED] Shift–Option–Right Arrow		Extend text selection to the end of the current word, then to the end of the following word if pressed again.
    // [ADDED] Control-A					Move to the beginning of the line or paragraph.
    // [ADDED] Control-E					Move to the end of a line or paragraph.
    // [ADDED] Control-F					Move one character forward.
    // [ADDED] Control-B					Move one character backward.
    //Control-L								Center the cursor or selection in the visible area.
    // [ADDED] Control-P					Move up one line.
    // [ADDED] Control-N					Move down one line.
    // [ADDED] Control-O					Insert a new line after the insertion point.
    //Control-T								Swap the character behind the insertion point with the character in front of the insertion point.
    // Unconfirmed????
    //	Config.addKeyBinding(editorCommon.Handler.CursorPageDown,		KeyMod.WinCtrl | KeyCode.KEY_V);
    // OS X built in commands
    // Control+y => yank
    // [ADDED] Command+backspace => Delete to Hard BOL
    // [ADDED] Command+delete => Delete to Hard EOL
    // [ADDED] Control+k => Delete to Hard EOL
    // Control+l => show_at_center
    // Control+Command+d => noop
    // Control+Command+shift+d => noop
    registerCoreCommand(H.CursorLeft, {
        primary: keyCodes_1.KeyCode.LeftArrow,
        mac: { primary: keyCodes_1.KeyCode.LeftArrow, secondary: [keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_B] }
    });
    registerCoreCommand(H.CursorLeftSelect, {
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.LeftArrow
    });
    registerCoreCommand(H.CursorRight, {
        primary: keyCodes_1.KeyCode.RightArrow,
        mac: { primary: keyCodes_1.KeyCode.RightArrow, secondary: [keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_F] }
    });
    registerCoreCommand(H.CursorRightSelect, {
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.RightArrow
    });
    registerCoreCommand(H.CursorUp, {
        primary: keyCodes_1.KeyCode.UpArrow,
        mac: { primary: keyCodes_1.KeyCode.UpArrow, secondary: [keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_P] }
    });
    registerCoreCommand(H.CursorUpSelect, {
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.UpArrow,
        secondary: [getWordNavigationKB(true, keyCodes_1.KeyCode.UpArrow)],
        mac: { primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.UpArrow },
        linux: { primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.UpArrow }
    });
    registerCoreCommand(H.CursorDown, {
        primary: keyCodes_1.KeyCode.DownArrow,
        mac: { primary: keyCodes_1.KeyCode.DownArrow, secondary: [keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_N] }
    });
    registerCoreCommand(H.CursorDownSelect, {
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.DownArrow,
        secondary: [getWordNavigationKB(true, keyCodes_1.KeyCode.DownArrow)],
        mac: { primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.DownArrow },
        linux: { primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.DownArrow }
    });
    registerCoreCommand(H.CursorPageUp, {
        primary: keyCodes_1.KeyCode.PageUp
    });
    registerCoreCommand(H.CursorPageUpSelect, {
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.PageUp
    });
    registerCoreCommand(H.CursorPageDown, {
        primary: keyCodes_1.KeyCode.PageDown
    });
    registerCoreCommand(H.CursorPageDownSelect, {
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.PageDown
    });
    registerCoreCommand(H.CursorHome, {
        primary: keyCodes_1.KeyCode.Home,
        mac: { primary: keyCodes_1.KeyCode.Home, secondary: [keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.LeftArrow, keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_A] }
    });
    registerCoreCommand(H.CursorHomeSelect, {
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Home,
        mac: { primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Home, secondary: [keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.LeftArrow] }
    });
    registerCoreCommand(H.CursorEnd, {
        primary: keyCodes_1.KeyCode.End,
        mac: { primary: keyCodes_1.KeyCode.End, secondary: [keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.RightArrow, keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_E] }
    });
    registerCoreCommand(H.CursorEndSelect, {
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.End,
        mac: { primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.End, secondary: [keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.RightArrow] }
    });
    registerCoreCommand(H.ExpandLineSelection, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_I
    });
    registerCoreCommand(H.ScrollLineUp, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.UpArrow,
        mac: { primary: keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.PageUp }
    });
    registerCoreCommand(H.ScrollLineDown, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.DownArrow,
        mac: { primary: keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.PageDown }
    });
    registerCoreCommand(H.ScrollPageUp, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.PageUp
    });
    registerCoreCommand(H.ScrollPageDown, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.PageDown
    });
    registerCoreCommand(H.CursorColumnSelectLeft, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.LeftArrow,
        linux: { primary: 0 }
    });
    registerCoreCommand(H.CursorColumnSelectRight, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.RightArrow,
        linux: { primary: 0 }
    });
    registerCoreCommand(H.CursorColumnSelectUp, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.UpArrow,
        linux: { primary: 0 }
    });
    registerCoreCommand(H.CursorColumnSelectPageUp, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.PageUp,
        linux: { primary: 0 }
    });
    registerCoreCommand(H.CursorColumnSelectDown, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.DownArrow,
        linux: { primary: 0 }
    });
    registerCoreCommand(H.CursorColumnSelectPageDown, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.PageDown,
        linux: { primary: 0 }
    });
    registerCoreCommand(H.Tab, {
        primary: keyCodes_1.KeyCode.Tab
    }, keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorCore(), keybindingService_1.KbExpr.and(keybindingService_1.KbExpr.has(editorCommon.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS), keybindingService_1.KbExpr.not(editorCommon.KEYBINDING_CONTEXT_EDITOR_TAB_MOVES_FOCUS)));
    registerCoreCommand(H.Outdent, {
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Tab
    }, keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorCore(), keybindingService_1.KbExpr.and(keybindingService_1.KbExpr.has(editorCommon.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS), keybindingService_1.KbExpr.not(editorCommon.KEYBINDING_CONTEXT_EDITOR_TAB_MOVES_FOCUS)));
    registerCoreCommand(H.DeleteLeft, {
        primary: keyCodes_1.KeyCode.Backspace,
        secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Backspace],
        mac: { primary: keyCodes_1.KeyCode.Backspace, secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Backspace, keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_H, keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.Backspace] }
    });
    registerCoreCommand(H.DeleteRight, {
        primary: keyCodes_1.KeyCode.Delete,
        mac: { primary: keyCodes_1.KeyCode.Delete, secondary: [keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_D, keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.Delete] }
    });
    registerCoreCommand(H.DeleteAllLeft, {
        primary: null,
        mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.Backspace }
    });
    registerCoreCommand(H.DeleteAllRight, {
        primary: null,
        mac: { primary: keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_K, secondary: [keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.Delete] }
    });
    function registerWordCommand(handlerId, shift, key) {
        registerCoreCommand(handlerId, {
            primary: getWordNavigationKB(shift, key),
            mac: { primary: getMacWordNavigationKB(shift, key) }
        });
    }
    registerWordCommand(H.CursorWordStartLeft, false, keyCodes_1.KeyCode.LeftArrow);
    registerCoreCommand(H.CursorWordEndLeft, { primary: 0 });
    registerCoreCommand(H.CursorWordLeft, { primary: 0 });
    registerWordCommand(H.CursorWordStartLeftSelect, true, keyCodes_1.KeyCode.LeftArrow);
    registerCoreCommand(H.CursorWordEndLeftSelect, { primary: 0 });
    registerCoreCommand(H.CursorWordLeftSelect, { primary: 0 });
    registerWordCommand(H.CursorWordEndRight, false, keyCodes_1.KeyCode.RightArrow);
    registerCoreCommand(H.CursorWordStartRight, { primary: 0 });
    registerCoreCommand(H.CursorWordRight, { primary: 0 });
    registerWordCommand(H.CursorWordEndRightSelect, true, keyCodes_1.KeyCode.RightArrow);
    registerCoreCommand(H.CursorWordStartRightSelect, { primary: 0 });
    registerCoreCommand(H.CursorWordRightSelect, { primary: 0 });
    registerWordCommand(H.DeleteWordLeft, false, keyCodes_1.KeyCode.Backspace);
    registerCoreCommand(H.DeleteWordStartLeft, { primary: 0 });
    registerCoreCommand(H.DeleteWordEndLeft, { primary: 0 });
    registerWordCommand(H.DeleteWordRight, false, keyCodes_1.KeyCode.Delete);
    registerCoreCommand(H.DeleteWordStartRight, { primary: 0 });
    registerCoreCommand(H.DeleteWordEndRight, { primary: 0 });
    registerCoreCommand(H.CancelSelection, {
        primary: keyCodes_1.KeyCode.Escape,
        secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Escape]
    }, keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorCore(), keybindingService_1.KbExpr.and(keybindingService_1.KbExpr.has(editorCommon.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS), keybindingService_1.KbExpr.has(editorCommon.KEYBINDING_CONTEXT_EDITOR_HAS_NON_EMPTY_SELECTION)));
    registerCoreCommand(H.RemoveSecondaryCursors, {
        primary: keyCodes_1.KeyCode.Escape,
        secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Escape]
    }, keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorCore(1), keybindingService_1.KbExpr.and(keybindingService_1.KbExpr.has(editorCommon.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS), keybindingService_1.KbExpr.has(editorCommon.KEYBINDING_CONTEXT_EDITOR_HAS_MULTIPLE_SELECTIONS)));
    registerCoreCommand(H.CursorTop, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.Home,
        mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.UpArrow }
    });
    registerCoreCommand(H.CursorTopSelect, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Home,
        mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.UpArrow }
    });
    registerCoreCommand(H.CursorBottom, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.End,
        mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.DownArrow }
    });
    registerCoreCommand(H.CursorBottomSelect, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.End,
        mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.DownArrow }
    });
    registerCoreCommand(H.LineBreakInsert, {
        primary: null,
        mac: { primary: keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_O }
    });
    registerCoreCommand(H.Undo, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_Z
    });
    registerCoreCommand(H.CursorUndo, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_U
    });
    registerCoreCommand(H.Redo, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_Y,
        secondary: [keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.KEY_Z],
        mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.KEY_Z }
    });
    function selectAll(accessor, args) {
        var HANDLER = editorCommon.Handler.SelectAll;
        // If editor text focus
        if (args.context[editorCommon.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS]) {
            var focusedEditor = findFocusedEditor(HANDLER, accessor, args, false);
            if (focusedEditor) {
                focusedEditor.trigger('keyboard', HANDLER, args);
                return;
            }
        }
        // Ignore this action when user is focussed on an element that allows for entering text
        var activeElement = document.activeElement;
        if (activeElement && ['input', 'textarea'].indexOf(activeElement.tagName.toLowerCase()) >= 0) {
            activeElement.select();
            return;
        }
        // Redirecting to last active editor
        var activeEditor = getActiveEditor(accessor);
        if (activeEditor) {
            activeEditor.trigger('keyboard', HANDLER, args);
            return;
        }
    }
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc({
        id: 'editor.action.selectAll',
        handler: selectAll,
        weight: keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorCore(),
        context: null,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_A
    });
});

define("vs/platform/request/common/request", ["require", "exports", 'vs/platform/instantiation/common/instantiation'], function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IRequestService = instantiation_1.createDecorator('requestService');
});

define("vs/platform/request/common/baseRequestService", ["require", "exports", 'vs/base/common/uri', 'vs/base/common/strings', 'vs/base/common/timer', 'vs/base/common/async', 'vs/base/common/winjs.base', 'vs/base/common/objects', 'vs/platform/request/common/request'], function (require, exports, uri_1, strings, Timer, Async, winjs, objects, request_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Simple IRequestService implementation to allow sharing of this service implementation
     * between different layers of the platform.
     */
    var BaseRequestService = (function () {
        function BaseRequestService(contextService, telemetryService) {
            this.serviceId = request_1.IRequestService;
            var workspaceUri = null;
            var workspace = contextService.getWorkspace();
            this._serviceMap = workspace || Object.create(null);
            this._telemetryService = telemetryService;
            if (workspace) {
                workspaceUri = strings.rtrim(workspace.resource.toString(), '/') + '/';
            }
            this.computeOrigin(workspaceUri);
        }
        BaseRequestService.prototype.computeOrigin = function (workspaceUri) {
            if (workspaceUri) {
                // Find root server URL from configuration
                this._origin = workspaceUri;
                var urlPath = uri_1.default.parse(this._origin).path;
                if (urlPath && urlPath.length > 0) {
                    this._origin = this._origin.substring(0, this._origin.length - urlPath.length + 1);
                }
                if (!strings.endsWith(this._origin, '/')) {
                    this._origin += '/';
                }
            }
            else {
                this._origin = '/'; // Configuration not provided, fallback to default
            }
        };
        BaseRequestService.prototype.makeCrossOriginRequest = function (options) {
            return null;
        };
        BaseRequestService.prototype.makeRequest = function (options) {
            var timer = Timer.nullEvent;
            var isXhrRequestCORS = false;
            var url = options.url;
            if (!url) {
                throw new Error('IRequestService.makeRequest: Url is required');
            }
            if ((strings.startsWith(url, 'http://') || strings.startsWith(url, 'https://')) && this._origin && !strings.startsWith(url, this._origin)) {
                var coPromise = this.makeCrossOriginRequest(options);
                if (coPromise) {
                    return coPromise;
                }
                isXhrRequestCORS = true;
            }
            var xhrOptions = options;
            if (!isXhrRequestCORS) {
                var additionalHeaders = {};
                if (this._telemetryService) {
                    additionalHeaders['X-TelemetrySession'] = this._telemetryService.getSessionId();
                }
                additionalHeaders['X-Requested-With'] = 'XMLHttpRequest';
                xhrOptions.headers = objects.mixin(xhrOptions.headers, additionalHeaders);
            }
            if (options.timeout) {
                xhrOptions.customRequestInitializer = function (xhrRequest) {
                    xhrRequest.timeout = options.timeout;
                };
            }
            return Async.always(winjs.xhr(xhrOptions), (function (xhr) {
                if (timer.data) {
                    timer.data.status = xhr.status;
                }
                timer.stop();
            }));
        };
        return BaseRequestService;
    }());
    exports.BaseRequestService = BaseRequestService;
});

define("vs/platform/search/common/search", ["require", "exports", 'vs/platform/instantiation/common/instantiation'], function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.ID = 'searchService';
    exports.ISearchService = instantiation_1.createDecorator(exports.ID);
    (function (QueryType) {
        QueryType[QueryType["File"] = 1] = "File";
        QueryType[QueryType["Text"] = 2] = "Text";
    })(exports.QueryType || (exports.QueryType = {}));
    var QueryType = exports.QueryType;
    // ---- very simple implementation of the search model --------------------
    var FileMatch = (function () {
        function FileMatch(resource) {
            this.resource = resource;
            this.lineMatches = [];
            // empty
        }
        return FileMatch;
    }());
    exports.FileMatch = FileMatch;
    var LineMatch = (function () {
        function LineMatch(preview, lineNumber, offsetAndLengths) {
            this.preview = preview;
            this.lineNumber = lineNumber;
            this.offsetAndLengths = offsetAndLengths;
            // empty
        }
        return LineMatch;
    }());
    exports.LineMatch = LineMatch;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("vs/platform/storage/common/storage", ["require", "exports", 'vs/base/common/events', 'vs/platform/instantiation/common/instantiation'], function (require, exports, events_1, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.ID = 'storageService';
    exports.IStorageService = instantiation_1.createDecorator(exports.ID);
    var StorageEventType;
    (function (StorageEventType) {
        /**
         * Event type for when a storage value is changed.
         */
        StorageEventType.STORAGE = 'storage';
    })(StorageEventType = exports.StorageEventType || (exports.StorageEventType = {}));
    /**
     * Storage events are being emitted when user settings change which are persisted to local storage.
     */
    var StorageEvent = (function (_super) {
        __extends(StorageEvent, _super);
        function StorageEvent(key, before, after, originalEvent) {
            _super.call(this, key, before, after, originalEvent);
        }
        /**
         * Returns true if the storage change has occurred from this browser window and false if its coming from a different window.
         */
        StorageEvent.prototype.isLocal = function () {
            // By the spec a storage event is only ever emitted if it occurs from a different browser tab or window
            // so we can use the check for originalEvent being set or not as a way to find out if the event is local or not.
            return !this.originalEvent;
        };
        return StorageEvent;
    }(events_1.PropertyChangeEvent));
    exports.StorageEvent = StorageEvent;
    (function (StorageScope) {
        /**
         * The stored data will be scoped to all workspaces of this domain.
         */
        StorageScope[StorageScope["GLOBAL"] = 0] = "GLOBAL";
        /**
         * The stored data will be scoped to the current workspace.
         */
        StorageScope[StorageScope["WORKSPACE"] = 1] = "WORKSPACE";
    })(exports.StorageScope || (exports.StorageScope = {}));
    var StorageScope = exports.StorageScope;
});

define("vs/platform/telemetry/common/telemetry", ["require", "exports", 'vs/platform/instantiation/common/instantiation'], function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.ID = 'telemetryService';
    exports.ITelemetryService = instantiation_1.createDecorator(exports.ID);
    function anonymize(input) {
        if (!input) {
            return input;
        }
        var r = '';
        for (var i = 0; i < input.length; i++) {
            var ch = input[i];
            if (ch >= '0' && ch <= '9') {
                r += '0';
                continue;
            }
            if (ch >= 'a' && ch <= 'z') {
                r += 'a';
                continue;
            }
            if (ch >= 'A' && ch <= 'Z') {
                r += 'A';
                continue;
            }
            r += ch;
        }
        return r;
    }
    exports.anonymize = anonymize;
});

define("vs/editor/common/editorCommonExtensions", ["require", "exports", 'vs/base/common/errors', 'vs/base/common/uri', 'vs/platform/instantiation/common/descriptors', 'vs/platform/keybinding/common/keybindingService', 'vs/platform/keybinding/common/keybindingsRegistry', 'vs/platform/platform', 'vs/platform/telemetry/common/telemetry', 'vs/editor/common/config/config', 'vs/editor/common/core/position', 'vs/editor/common/editorCommon', 'vs/editor/common/services/modelService'], function (require, exports, errors_1, uri_1, descriptors_1, keybindingService_1, keybindingsRegistry_1, platform_1, telemetry_1, config_1, position_1, editorCommon, modelService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // --- Keybinding extensions to make it more concise to express keybindings conditions
    (function (ContextKey) {
        ContextKey[ContextKey["None"] = 0] = "None";
        ContextKey[ContextKey["EditorTextFocus"] = 1] = "EditorTextFocus";
        ContextKey[ContextKey["EditorFocus"] = 2] = "EditorFocus";
    })(exports.ContextKey || (exports.ContextKey = {}));
    var ContextKey = exports.ContextKey;
    // --- Editor Actions
    var EditorActionDescriptor = (function () {
        function EditorActionDescriptor(ctor, id, label, kbOpts) {
            if (kbOpts === void 0) { kbOpts = defaultEditorActionKeybindingOptions; }
            this.ctor = ctor;
            this.id = id;
            this.label = label;
            this.kbOpts = kbOpts;
        }
        return EditorActionDescriptor;
    }());
    exports.EditorActionDescriptor = EditorActionDescriptor;
    var CommonEditorRegistry;
    (function (CommonEditorRegistry) {
        function registerEditorAction(desc) {
            platform_1.Registry.as(Extensions.EditorCommonContributions).registerEditorAction(desc);
        }
        CommonEditorRegistry.registerEditorAction = registerEditorAction;
        // --- Editor Contributions
        function registerEditorContribution(ctor) {
            platform_1.Registry.as(Extensions.EditorCommonContributions).registerEditorContribution2(ctor);
        }
        CommonEditorRegistry.registerEditorContribution = registerEditorContribution;
        function getEditorContributions() {
            return platform_1.Registry.as(Extensions.EditorCommonContributions).getEditorContributions2();
        }
        CommonEditorRegistry.getEditorContributions = getEditorContributions;
        // --- Editor Commands
        function commandWeight(importance) {
            if (importance === void 0) { importance = 0; }
            return keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorContrib(importance);
        }
        CommonEditorRegistry.commandWeight = commandWeight;
        function registerEditorCommand(commandId, weight, keybinding, needsTextFocus, needsKey, handler) {
            var commandDesc = {
                id: commandId,
                handler: createCommandHandler(commandId, handler),
                weight: weight,
                context: contextRule(needsTextFocus, needsKey),
                primary: keybinding.primary,
                secondary: keybinding.secondary,
                win: keybinding.win,
                linux: keybinding.linux,
                mac: keybinding.mac,
            };
            keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc(commandDesc);
        }
        CommonEditorRegistry.registerEditorCommand = registerEditorCommand;
        function registerLanguageCommand(id, handler) {
            keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc({
                id: id,
                handler: function (accessor, args) {
                    if (args && args.length > 1 || typeof args[0] !== 'object') {
                        throw errors_1.illegalArgument();
                    }
                    return handler(accessor, args && args[0]);
                },
                weight: keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorContrib(),
                primary: undefined,
                context: undefined,
            });
        }
        CommonEditorRegistry.registerLanguageCommand = registerLanguageCommand;
        function registerDefaultLanguageCommand(id, handler) {
            registerLanguageCommand(id, function (accessor, args) {
                var resource = args.resource, position = args.position;
                if (!(resource instanceof uri_1.default) || !position_1.Position.isIPosition(position)) {
                    throw errors_1.illegalArgument();
                }
                var model = accessor.get(modelService_1.IModelService).getModel(resource);
                if (!model) {
                    throw errors_1.illegalArgument();
                }
                return handler(model, position, args);
            });
        }
        CommonEditorRegistry.registerDefaultLanguageCommand = registerDefaultLanguageCommand;
    })(CommonEditorRegistry = exports.CommonEditorRegistry || (exports.CommonEditorRegistry = {}));
    var SimpleEditorContributionDescriptor = (function () {
        function SimpleEditorContributionDescriptor(ctor) {
            this._ctor = ctor;
        }
        SimpleEditorContributionDescriptor.prototype.createInstance = function (instantiationService, editor) {
            return instantiationService.createInstance(this._ctor, editor);
        };
        return SimpleEditorContributionDescriptor;
    }());
    var InternalEditorActionDescriptor = (function () {
        function InternalEditorActionDescriptor(ctor, id, label) {
            this._descriptor = descriptors_1.createSyncDescriptor(ctor, {
                id: id,
                label: label
            });
        }
        InternalEditorActionDescriptor.prototype.createInstance = function (instService, editor) {
            return instService.createInstance(this._descriptor, editor);
        };
        return InternalEditorActionDescriptor;
    }());
    // Editor extension points
    var Extensions = {
        EditorCommonContributions: 'editor.commonContributions'
    };
    var EditorContributionRegistry = (function () {
        function EditorContributionRegistry() {
            this.editorContributions = [];
        }
        EditorContributionRegistry.prototype.registerEditorContribution2 = function (ctor) {
            this.editorContributions.push(new SimpleEditorContributionDescriptor(ctor));
        };
        EditorContributionRegistry.prototype.registerEditorAction = function (desc) {
            var handler = desc.kbOpts.handler;
            if (!handler) {
                if (desc.kbOpts.context === ContextKey.EditorTextFocus || desc.kbOpts.context === ContextKey.EditorFocus) {
                    handler = triggerEditorAction.bind(null, desc.id);
                }
                else {
                    handler = triggerEditorActionGlobal.bind(null, desc.id);
                }
            }
            var context = null;
            if (typeof desc.kbOpts.kbExpr === 'undefined') {
                if (desc.kbOpts.context === ContextKey.EditorTextFocus) {
                    context = keybindingService_1.KbExpr.has(editorCommon.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS);
                }
                else if (desc.kbOpts.context === ContextKey.EditorFocus) {
                    context = keybindingService_1.KbExpr.has(editorCommon.KEYBINDING_CONTEXT_EDITOR_FOCUS);
                }
            }
            else {
                context = desc.kbOpts.kbExpr;
            }
            var commandDesc = {
                id: desc.id,
                handler: handler,
                weight: keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorContrib(),
                context: context,
                primary: desc.kbOpts.primary,
                secondary: desc.kbOpts.secondary,
                win: desc.kbOpts.win,
                linux: desc.kbOpts.linux,
                mac: desc.kbOpts.mac,
            };
            keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc(commandDesc);
            this.editorContributions.push(new InternalEditorActionDescriptor(desc.ctor, desc.id, desc.label));
        };
        EditorContributionRegistry.prototype.getEditorContributions2 = function () {
            return this.editorContributions.slice(0);
        };
        return EditorContributionRegistry;
    }());
    platform_1.Registry.add(Extensions.EditorCommonContributions, new EditorContributionRegistry());
    function triggerEditorAction(actionId, accessor, args) {
        config_1.withCodeEditorFromCommandHandler(actionId, accessor, args, function (editor) {
            editor.trigger('keyboard', actionId, args);
        });
    }
    function triggerEditorActionGlobal(actionId, accessor, args) {
        // TODO: this is not necessarily keyboard
        var focusedEditor = config_1.findFocusedEditor(actionId, accessor, args, false);
        if (focusedEditor) {
            focusedEditor.trigger('keyboard', actionId, args);
            return;
        }
        var activeEditor = config_1.getActiveEditor(accessor);
        if (activeEditor) {
            var action = activeEditor.getAction(actionId);
            if (action) {
                accessor.get(telemetry_1.ITelemetryService).publicLog('editorActionInvoked', { name: action.label });
                action.run().done(null, errors_1.onUnexpectedError);
            }
            return;
        }
    }
    var defaultEditorActionKeybindingOptions = { primary: null, context: ContextKey.EditorTextFocus };
    function contextRule(needsTextFocus, needsKey) {
        var base = keybindingService_1.KbExpr.has(needsTextFocus ? editorCommon.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS : editorCommon.KEYBINDING_CONTEXT_EDITOR_FOCUS);
        if (needsKey) {
            return keybindingService_1.KbExpr.and(base, keybindingService_1.KbExpr.has(needsKey));
        }
        return base;
    }
    function createCommandHandler(commandId, handler) {
        return function (accessor, args) {
            config_1.withCodeEditorFromCommandHandler(commandId, accessor, args, function (editor) {
                handler(accessor, editor, args);
            });
        };
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/editor/contrib/codelens/common/codelens", ["require", "exports", 'vs/base/common/errors', 'vs/base/common/uri', 'vs/base/common/winjs.base', 'vs/editor/common/editorCommonExtensions', 'vs/editor/common/modes/languageFeatureRegistry', 'vs/editor/common/services/modelService'], function (require, exports, errors_1, uri_1, winjs_base_1, editorCommonExtensions_1, languageFeatureRegistry_1, modelService_1) {
    'use strict';
    exports.CodeLensRegistry = new languageFeatureRegistry_1.default('codeLensSupport');
    function getCodeLensData(model) {
        var symbols = [];
        var promises = exports.CodeLensRegistry.all(model).map(function (support) {
            return support.findCodeLensSymbols(model.getAssociatedResource()).then(function (result) {
                if (!Array.isArray(result)) {
                    return;
                }
                for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
                    var symbol = result_1[_i];
                    symbols.push({ symbol: symbol, support: support });
                }
            }, function (err) {
                if (!errors_1.isPromiseCanceledError(err)) {
                    errors_1.onUnexpectedError(err);
                }
            });
        });
        return winjs_base_1.TPromise.join(promises).then(function () { return symbols; });
    }
    exports.getCodeLensData = getCodeLensData;
    editorCommonExtensions_1.CommonEditorRegistry.registerLanguageCommand('_executeCodeLensProvider', function (accessor, args) {
        var resource = args.resource;
        if (!(resource instanceof uri_1.default)) {
            throw errors_1.illegalArgument();
        }
        var model = accessor.get(modelService_1.IModelService).getModel(resource);
        if (!model) {
            throw errors_1.illegalArgument();
        }
        return getCodeLensData(model);
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/editor/contrib/format/common/format", ["require", "exports", 'vs/base/common/errors', 'vs/base/common/uri', 'vs/base/common/winjs.base', 'vs/editor/common/core/range', 'vs/editor/common/editorCommonExtensions', 'vs/editor/common/modes/languageFeatureRegistry', 'vs/editor/common/services/modelService'], function (require, exports, errors_1, uri_1, winjs_base_1, range_1, editorCommonExtensions_1, languageFeatureRegistry_1, modelService_1) {
    'use strict';
    exports.FormatRegistry = new languageFeatureRegistry_1.default('formattingSupport');
    exports.FormatOnTypeRegistry = new languageFeatureRegistry_1.default('formattingSupport');
    function formatRange(model, range, options) {
        var support = exports.FormatRegistry.ordered(model)
            .filter(function (s) { return typeof s.formatRange === 'function'; })[0];
        if (!support) {
            return winjs_base_1.TPromise.as(undefined);
        }
        return support.formatRange(model.getAssociatedResource(), range, options);
    }
    exports.formatRange = formatRange;
    function formatDocument(model, options) {
        var support = exports.FormatRegistry.ordered(model)[0];
        if (!support) {
            return winjs_base_1.TPromise.as(undefined);
        }
        if (typeof support.formatDocument !== 'function') {
            if (typeof support.formatRange === 'function') {
                return formatRange(model, model.getFullModelRange(), options);
            }
            else {
                return winjs_base_1.TPromise.as(undefined);
            }
        }
        return support.formatDocument(model.getAssociatedResource(), options);
    }
    exports.formatDocument = formatDocument;
    function formatAfterKeystroke(model, position, ch, options) {
        var support = exports.FormatOnTypeRegistry.ordered(model)[0];
        if (!support) {
            return winjs_base_1.TPromise.as(undefined);
        }
        if (support.autoFormatTriggerCharacters.indexOf(ch) < 0) {
            return winjs_base_1.TPromise.as(undefined);
        }
        return support.formatAfterKeystroke(model.getAssociatedResource(), position, ch, options);
    }
    exports.formatAfterKeystroke = formatAfterKeystroke;
    editorCommonExtensions_1.CommonEditorRegistry.registerLanguageCommand('_executeFormatRangeProvider', function (accessor, args) {
        var resource = args.resource, range = args.range, options = args.options;
        if (!(resource instanceof uri_1.default) || !range_1.Range.isIRange(range)) {
            throw errors_1.illegalArgument();
        }
        var model = accessor.get(modelService_1.IModelService).getModel(resource);
        if (!model) {
            throw errors_1.illegalArgument('resource');
        }
        return formatRange(model, range, options);
    });
    editorCommonExtensions_1.CommonEditorRegistry.registerLanguageCommand('_executeFormatDocumentProvider', function (accessor, args) {
        var resource = args.resource, options = args.options;
        if (!(resource instanceof uri_1.default)) {
            throw errors_1.illegalArgument('resource');
        }
        var model = accessor.get(modelService_1.IModelService).getModel(resource);
        if (!model) {
            throw errors_1.illegalArgument('resource');
        }
        return formatDocument(model, options);
    });
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeFormatOnTypeProvider', function (model, position, args) {
        var ch = args.ch, options = args.options;
        if (typeof ch !== 'string') {
            throw errors_1.illegalArgument('ch');
        }
        return formatAfterKeystroke(model, position, ch, options);
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/editor/contrib/goToDeclaration/common/goToDeclaration", ["require", "exports", 'vs/base/common/errors', 'vs/base/common/winjs.base', 'vs/editor/common/editorCommonExtensions', 'vs/editor/common/modes/languageFeatureRegistry'], function (require, exports, errors_1, winjs_base_1, editorCommonExtensions_1, languageFeatureRegistry_1) {
    'use strict';
    exports.DeclarationRegistry = new languageFeatureRegistry_1.default('declarationSupport');
    function getDeclarationsAtPosition(model, position) {
        var resource = model.getAssociatedResource();
        var provider = exports.DeclarationRegistry.ordered(model);
        // get results
        var promises = provider.map(function (provider, idx) {
            return provider.findDeclaration(resource, position).then(function (result) {
                return result;
            }, function (err) {
                errors_1.onUnexpectedError(err);
            });
        });
        return winjs_base_1.TPromise.join(promises).then(function (allReferences) {
            var result = [];
            for (var _i = 0, allReferences_1 = allReferences; _i < allReferences_1.length; _i++) {
                var references = allReferences_1[_i];
                if (Array.isArray(references)) {
                    result.push.apply(result, references);
                }
                else if (references) {
                    result.push(references);
                }
            }
            return result;
        });
    }
    exports.getDeclarationsAtPosition = getDeclarationsAtPosition;
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeDefinitionProvider', getDeclarationsAtPosition);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/editor/contrib/hover/common/hover", ["require", "exports", 'vs/base/common/arrays', 'vs/base/common/errors', 'vs/base/common/winjs.base', 'vs/editor/common/editorCommonExtensions', 'vs/editor/common/modes/languageFeatureRegistry'], function (require, exports, arrays_1, errors_1, winjs_base_1, editorCommonExtensions_1, languageFeatureRegistry_1) {
    'use strict';
    exports.ExtraInfoRegistry = new languageFeatureRegistry_1.default('extraInfoSupport');
    function getExtraInfoAtPosition(model, position) {
        var resource = model.getAssociatedResource();
        var supports = exports.ExtraInfoRegistry.ordered(model);
        var values = [];
        var promises = supports.map(function (support, idx) {
            return support.computeInfo(resource, position).then(function (result) {
                if (result) {
                    var hasRange = (typeof result.range !== 'undefined');
                    var hasValue = (typeof result.value !== 'undefined');
                    var hasHtmlContent = (typeof result.htmlContent !== 'undefined' && result.htmlContent && result.htmlContent.length > 0);
                    if (hasRange && (hasValue || hasHtmlContent)) {
                        values[idx] = result;
                    }
                }
            }, function (err) {
                errors_1.onUnexpectedError(err);
            });
        });
        return winjs_base_1.TPromise.join(promises).then(function () { return arrays_1.coalesce(values); });
    }
    exports.getExtraInfoAtPosition = getExtraInfoAtPosition;
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeHoverProvider', getExtraInfoAtPosition);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/editor/contrib/parameterHints/common/parameterHints", ["require", "exports", 'vs/base/common/errors', 'vs/base/common/winjs.base', 'vs/editor/common/editorCommonExtensions', 'vs/editor/common/modes/languageFeatureRegistry'], function (require, exports, errors_1, winjs_base_1, editorCommonExtensions_1, languageFeatureRegistry_1) {
    'use strict';
    exports.ParameterHintsRegistry = new languageFeatureRegistry_1.default('parameterHintsSupport');
    function getParameterHints(model, position, triggerCharacter) {
        var support = exports.ParameterHintsRegistry.ordered(model)[0];
        if (!support) {
            return winjs_base_1.TPromise.as(undefined);
        }
        return support.getParameterHints(model.getAssociatedResource(), position, triggerCharacter);
    }
    exports.getParameterHints = getParameterHints;
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeSignatureHelpProvider', function (model, position, args) {
        var triggerCharacter = args.triggerCharacter;
        if (triggerCharacter && typeof triggerCharacter !== 'string') {
            throw errors_1.illegalArgument('triggerCharacter');
        }
        return getParameterHints(model, position, triggerCharacter);
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/editor/contrib/quickFix/common/quickFix", ["require", "exports", 'vs/base/common/errors', 'vs/base/common/uri', 'vs/base/common/winjs.base', 'vs/editor/common/core/range', 'vs/editor/common/editorCommonExtensions', 'vs/editor/common/modes/languageFeatureRegistry', 'vs/editor/common/services/modelService'], function (require, exports, errors_1, uri_1, winjs_base_1, range_1, editorCommonExtensions_1, languageFeatureRegistry_1, modelService_1) {
    'use strict';
    exports.QuickFixRegistry = new languageFeatureRegistry_1.default('quickFixSupport');
    function getQuickFixes(model, range) {
        var quickFixes = [];
        var idPool = 0;
        var promises = exports.QuickFixRegistry.all(model).map(function (support) {
            return support.getQuickFixes(model.getAssociatedResource(), range).then(function (result) {
                if (!Array.isArray(result)) {
                    return;
                }
                for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
                    var fix = result_1[_i];
                    quickFixes.push({
                        command: fix.command,
                        score: fix.score,
                        id: "quickfix_#" + idPool++,
                        support: support
                    });
                }
            }, function (err) {
                errors_1.onUnexpectedError(err);
            });
        });
        return winjs_base_1.TPromise.join(promises).then(function () { return quickFixes; });
    }
    exports.getQuickFixes = getQuickFixes;
    editorCommonExtensions_1.CommonEditorRegistry.registerLanguageCommand('_executeCodeActionProvider', function (accessor, args) {
        var resource = args.resource, range = args.range;
        if (!(resource instanceof uri_1.default) || !range_1.Range.isIRange(range)) {
            throw errors_1.illegalArgument();
        }
        var model = accessor.get(modelService_1.IModelService).getModel(resource);
        if (!model) {
            throw errors_1.illegalArgument();
        }
        return getQuickFixes(model, range);
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/editor/contrib/quickOpen/common/quickOpen", ["require", "exports", 'vs/base/common/errors', 'vs/base/common/uri', 'vs/base/common/winjs.base', 'vs/editor/common/core/range', 'vs/editor/common/editorCommonExtensions', 'vs/editor/common/modes/languageFeatureRegistry', 'vs/editor/common/services/modelService'], function (require, exports, errors_1, uri_1, winjs_base_1, range_1, editorCommonExtensions_1, languageFeatureRegistry_1, modelService_1) {
    'use strict';
    var OutlineRegistry = new languageFeatureRegistry_1.default('outlineSupport');
    exports.OutlineRegistry = OutlineRegistry;
    function getOutlineEntries(model) {
        var groupLabels = Object.create(null);
        var entries = [];
        var promises = OutlineRegistry.all(model).map(function (support) {
            if (support.outlineGroupLabel) {
                for (var key in support.outlineGroupLabel) {
                    if (Object.prototype.hasOwnProperty.call(support.outlineGroupLabel, key)) {
                        groupLabels[key] = support.outlineGroupLabel[key];
                    }
                }
            }
            return support.getOutline(model.getAssociatedResource()).then(function (result) {
                if (Array.isArray(result)) {
                    entries.push.apply(entries, result);
                }
            }, function (err) {
                errors_1.onUnexpectedError(err);
            });
        });
        return winjs_base_1.TPromise.join(promises).then(function () {
            var flatEntries = [];
            flatten(flatEntries, entries, '');
            flatEntries.sort(compareEntriesUsingStart);
            return {
                entries: flatEntries,
                outlineGroupLabel: groupLabels
            };
        });
    }
    exports.getOutlineEntries = getOutlineEntries;
    function compareEntriesUsingStart(a, b) {
        return range_1.Range.compareRangesUsingStarts(a.range, b.range);
    }
    function flatten(bucket, entries, overrideContainerLabel) {
        for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
            var entry = entries_1[_i];
            bucket.push({
                type: entry.type,
                range: entry.range,
                label: entry.label,
                icon: entry.icon,
                containerLabel: entry.containerLabel || overrideContainerLabel
            });
            if (entry.children) {
                flatten(bucket, entry.children, entry.label);
            }
        }
    }
    editorCommonExtensions_1.CommonEditorRegistry.registerLanguageCommand('_executeDocumentSymbolProvider', function (accessor, args) {
        var resource = args.resource;
        if (!(resource instanceof uri_1.default)) {
            throw errors_1.illegalArgument('resource');
        }
        var model = accessor.get(modelService_1.IModelService).getModel(resource);
        if (!model) {
            throw errors_1.illegalArgument('resource');
        }
        return getOutlineEntries(model);
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/editor/contrib/referenceSearch/common/referenceSearch", ["require", "exports", 'vs/base/common/errors', 'vs/base/common/winjs.base', 'vs/editor/common/editorCommonExtensions', 'vs/editor/common/modes/languageFeatureRegistry'], function (require, exports, errors_1, winjs_base_1, editorCommonExtensions_1, languageFeatureRegistry_1) {
    'use strict';
    exports.ReferenceRegistry = new languageFeatureRegistry_1.default('referenceSupport');
    function findReferences(model, position) {
        // collect references from all providers
        var promises = exports.ReferenceRegistry.ordered(model).map(function (provider) {
            return provider.findReferences(model.getAssociatedResource(), position, true).then(function (result) {
                if (Array.isArray(result)) {
                    return result;
                }
            }, function (err) {
                errors_1.onUnexpectedError(err);
            });
        });
        return winjs_base_1.TPromise.join(promises).then(function (references) {
            var result = [];
            for (var _i = 0, references_1 = references; _i < references_1.length; _i++) {
                var ref = references_1[_i];
                if (ref) {
                    result.push.apply(result, ref);
                }
            }
            return result;
        });
    }
    exports.findReferences = findReferences;
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeReferenceProvider', findReferences);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/editor/contrib/rename/common/rename", ["require", "exports", 'vs/nls!vs/editor/contrib/rename/common/rename', 'vs/base/common/async', 'vs/base/common/errors', 'vs/editor/common/editorCommonExtensions', 'vs/editor/common/modes/languageFeatureRegistry'], function (require, exports, nls_1, async_1, errors_1, editorCommonExtensions_1, languageFeatureRegistry_1) {
    'use strict';
    exports.RenameRegistry = new languageFeatureRegistry_1.default('renameSupport');
    function rename(model, position, newName) {
        var supports = exports.RenameRegistry.ordered(model);
        var resource = model.getAssociatedResource();
        var rejects = [];
        var hasResult = false;
        var factory = supports.map(function (support) {
            return function () {
                if (!hasResult) {
                    return support.rename(resource, position, newName).then(function (result) {
                        if (!result) {
                        }
                        else if (!result.rejectReason) {
                            hasResult = true;
                            return result;
                        }
                        else {
                            rejects.push(result.rejectReason);
                        }
                    });
                }
            };
        });
        return async_1.sequence(factory).then(function (values) {
            var result = values[0];
            if (rejects.length > 0) {
                return {
                    currentName: undefined,
                    edits: undefined,
                    rejectReason: rejects.join('\n')
                };
            }
            else if (!result) {
                return {
                    currentName: undefined,
                    edits: undefined,
                    rejectReason: nls_1.localize(0, null)
                };
            }
            else {
                return result;
            }
        });
    }
    exports.rename = rename;
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeDocumentRenameProvider', function (model, position, args) {
        var newName = args.newName;
        if (typeof newName !== 'string') {
            throw errors_1.illegalArgument('newName');
        }
        return rename(model, position, newName);
    });
});

define("vs/editor/contrib/suggest/common/suggest", ["require", "exports", 'vs/base/common/async', 'vs/base/common/errors', 'vs/base/common/winjs.base', 'vs/editor/common/editorCommonExtensions', 'vs/editor/common/modes/languageFeatureRegistry', 'vs/editor/common/modes/supports'], function (require, exports, async_1, errors_1, winjs_base_1, editorCommonExtensions_1, languageFeatureRegistry_1, supports_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.CONTEXT_SUGGEST_WIDGET_VISIBLE = 'suggestWidgetVisible';
    exports.CONTEXT_SUGGESTION_SUPPORTS_ACCEPT_ON_KEY = 'suggestionSupportsAcceptOnKey';
    exports.ACCEPT_SELECTED_SUGGESTION_CMD = 'acceptSelectedSuggestion';
    exports.SuggestRegistry = new languageFeatureRegistry_1.default('suggestSupport');
    function suggest(model, position, triggerCharacter, groups) {
        if (!groups) {
            groups = exports.SuggestRegistry.orderedGroups(model);
        }
        var resource = model.getAssociatedResource();
        var suggestions = [];
        var factory = groups.map(function (supports, index) {
            return function () {
                // stop as soon as a group produced a result
                if (suggestions.length > 0) {
                    return;
                }
                // for each support in the group ask for suggestions
                var promises = supports.map(function (support) {
                    return support.suggest(resource, position, triggerCharacter).then(function (values) {
                        var result = [];
                        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                            var suggestResult = values_1[_i];
                            if (!suggestResult
                                || !Array.isArray(suggestResult.suggestions)
                                || suggestResult.suggestions.length === 0) {
                                continue;
                            }
                            result.push({
                                support: support,
                                currentWord: suggestResult.currentWord,
                                incomplete: suggestResult.incomplete,
                                suggestions: suggestResult.suggestions
                            });
                        }
                        return result;
                    }, errors_1.onUnexpectedError);
                });
                return winjs_base_1.TPromise.join(promises).then(function (values) {
                    for (var _i = 0, values_2 = values; _i < values_2.length; _i++) {
                        var value = values_2[_i];
                        if (Array.isArray(value) && value.length > 0) {
                            suggestions.push(value);
                        }
                    }
                });
            };
        });
        return async_1.sequence(factory).then(function () {
            // add snippets to the first group
            var snippets = supports_1.SnippetsRegistry.getSnippets(model, position);
            if (suggestions.length === 0) {
                suggestions.push([snippets]);
            }
            else {
                suggestions[0].push(snippets);
            }
            return suggestions;
        });
    }
    exports.suggest = suggest;
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeCompletionItemProvider', function (model, position, args) {
        var triggerCharacter = args['triggerCharacter'];
        if (typeof triggerCharacter !== 'undefined' && typeof triggerCharacter !== 'string') {
            throw errors_1.illegalArgument('triggerCharacter');
        }
        return suggest(model, position, triggerCharacter);
    });
});

define("vs/editor/contrib/wordHighlighter/common/wordHighlighter", ["require", "exports", 'vs/base/common/async', 'vs/base/common/errors', 'vs/editor/common/core/range', 'vs/editor/common/editorCommon', 'vs/editor/common/editorCommonExtensions', 'vs/editor/common/modes/languageFeatureRegistry'], function (require, exports, async_1, errors_1, range_1, editorCommon, editorCommonExtensions_1, languageFeatureRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.OccurrencesRegistry = new languageFeatureRegistry_1.default('occurrencesSupport');
    function getOccurrencesAtPosition(model, position) {
        var resource = model.getAssociatedResource();
        var orderedByScore = exports.OccurrencesRegistry.ordered(model);
        var foundResult = false;
        // in order of score ask the occurrences provider
        // until someone response with a good result
        // (good = none empty array)
        return async_1.sequence(orderedByScore.map(function (provider) {
            return function () {
                if (!foundResult) {
                    return provider.findOccurrences(resource, position).then(function (data) {
                        if (Array.isArray(data) && data.length > 0) {
                            foundResult = true;
                            return data;
                        }
                    }, function (err) {
                        errors_1.onUnexpectedError(err);
                    });
                }
            };
        })).then(function (values) {
            return values[0];
        });
    }
    exports.getOccurrencesAtPosition = getOccurrencesAtPosition;
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeDocumentHighlights', getOccurrencesAtPosition);
    var WordHighlighter = (function () {
        function WordHighlighter(editor) {
            var _this = this;
            this.workerRequestTokenId = 0;
            this.workerRequest = null;
            this.workerRequestCompleted = false;
            this.workerRequestValue = [];
            this.lastCursorPositionChangeTime = 0;
            this.renderDecorationsTimer = -1;
            this.editor = editor;
            this.model = this.editor.getModel();
            this.toUnhook = [];
            this.toUnhook.push(editor.addListener(editorCommon.EventType.CursorPositionChanged, function (e) {
                _this._onPositionChanged(e);
            }));
            this.toUnhook.push(editor.addListener(editorCommon.EventType.ModelChanged, function (e) {
                _this._stopAll();
                _this.model = _this.editor.getModel();
            }));
            this.toUnhook.push(editor.addListener('change', function (e) {
                _this._stopAll();
            }));
            this._lastWordRange = null;
            this._decorationIds = [];
            this.workerRequestTokenId = 0;
            this.workerRequest = null;
            this.workerRequestCompleted = false;
            this.lastCursorPositionChangeTime = 0;
            this.renderDecorationsTimer = -1;
        }
        WordHighlighter.prototype._removeDecorations = function () {
            if (this._decorationIds.length > 0) {
                // remove decorations
                this._decorationIds = this.editor.deltaDecorations(this._decorationIds, []);
            }
        };
        WordHighlighter.prototype._stopAll = function () {
            this._lastWordRange = null;
            // Remove any existing decorations
            this._removeDecorations();
            // Cancel any renderDecorationsTimer
            if (this.renderDecorationsTimer !== -1) {
                window.clearTimeout(this.renderDecorationsTimer);
                this.renderDecorationsTimer = -1;
            }
            // Cancel any worker request
            if (this.workerRequest !== null) {
                this.workerRequest.cancel();
                this.workerRequest = null;
            }
            // Invalidate any worker request callback
            if (!this.workerRequestCompleted) {
                this.workerRequestTokenId++;
                this.workerRequestCompleted = true;
            }
        };
        WordHighlighter.prototype._onPositionChanged = function (e) {
            var _this = this;
            // ignore typing & other
            if (e.reason !== 'explicit') {
                this._stopAll();
                return;
            }
            // no providers for this model
            if (!exports.OccurrencesRegistry.has(this.model)) {
                this._stopAll();
                return;
            }
            var editorSelection = this.editor.getSelection();
            // ignore multiline selection
            if (editorSelection.startLineNumber !== editorSelection.endLineNumber) {
                this._stopAll();
                return;
            }
            var lineNumber = editorSelection.startLineNumber;
            var startColumn = editorSelection.startColumn;
            var endColumn = editorSelection.endColumn;
            var word = this.model.getWordAtPosition({
                lineNumber: lineNumber,
                column: startColumn
            });
            // The selection must be inside a word or surround one word at most
            if (!word || word.startColumn > startColumn || word.endColumn < endColumn) {
                this._stopAll();
                return;
            }
            // All the effort below is trying to achieve this:
            // - when cursor is moved to a word, trigger immediately a findOccurences request
            // - 250ms later after the last cursor move event, render the occurences
            // - no flickering!
            var currentWordRange = new range_1.Range(lineNumber, word.startColumn, lineNumber, word.endColumn);
            var workerRequestIsValid = this._lastWordRange && this._lastWordRange.equalsRange(currentWordRange);
            // Even if we are on a different word, if that word is in the decorations ranges, the request is still valid
            // (Same symbol)
            for (var i = 0, len = this._decorationIds.length; !workerRequestIsValid && i < len; i++) {
                var range = this.model.getDecorationRange(this._decorationIds[i]);
                if (range && range.startLineNumber === lineNumber) {
                    if (range.startColumn <= startColumn && range.endColumn >= endColumn) {
                        workerRequestIsValid = true;
                    }
                }
            }
            // There are 4 cases:
            // a) old workerRequest is valid & completed, renderDecorationsTimer fired
            // b) old workerRequest is valid & completed, renderDecorationsTimer not fired
            // c) old workerRequest is valid, but not completed
            // d) old workerRequest is not valid
            // For a) no action is needed
            // For c), member 'lastCursorPositionChangeTime' will be used when installing the timer so no action is needed
            this.lastCursorPositionChangeTime = (new Date()).getTime();
            if (workerRequestIsValid) {
                if (this.workerRequestCompleted && this.renderDecorationsTimer !== -1) {
                    // case b)
                    // Delay the firing of renderDecorationsTimer by an extra 250 ms
                    window.clearTimeout(this.renderDecorationsTimer);
                    this.renderDecorationsTimer = -1;
                    this._beginRenderDecorations();
                }
            }
            else {
                // case d)
                // Stop all previous actions and start fresh
                this._stopAll();
                var myRequestId = ++this.workerRequestTokenId;
                this.workerRequestCompleted = false;
                this.workerRequest = getOccurrencesAtPosition(this.model, this.editor.getPosition());
                this.workerRequest.then(function (data) {
                    if (myRequestId === _this.workerRequestTokenId) {
                        _this.workerRequestCompleted = true;
                        _this.workerRequestValue = data || [];
                        _this._beginRenderDecorations();
                    }
                }).done();
            }
            this._lastWordRange = currentWordRange;
        };
        WordHighlighter.prototype._beginRenderDecorations = function () {
            var _this = this;
            var currentTime = (new Date()).getTime();
            var minimumRenderTime = this.lastCursorPositionChangeTime + 250;
            if (currentTime >= minimumRenderTime) {
                // Synchronous
                this.renderDecorationsTimer = -1;
                this.renderDecorations();
            }
            else {
                // Asyncrhonous
                this.renderDecorationsTimer = window.setTimeout(function () {
                    _this.renderDecorations();
                }, (minimumRenderTime - currentTime));
            }
        };
        WordHighlighter.prototype.renderDecorations = function () {
            this.renderDecorationsTimer = -1;
            var decorations = [];
            for (var i = 0, len = this.workerRequestValue.length; i < len; i++) {
                var info = this.workerRequestValue[i];
                var className = 'wordHighlight';
                var color = '#A0A0A0';
                if (info.kind === 'write') {
                    className = className + 'Strong';
                }
                else if (info.kind === 'text') {
                    className = 'selectionHighlight';
                }
                decorations.push({
                    range: info.range,
                    options: {
                        stickiness: editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
                        className: className,
                        overviewRuler: {
                            color: color,
                            darkColor: color,
                            position: editorCommon.OverviewRulerLane.Center
                        }
                    }
                });
            }
            this._decorationIds = this.editor.deltaDecorations(this._decorationIds, decorations);
        };
        WordHighlighter.prototype.destroy = function () {
            this._stopAll();
            while (this.toUnhook.length > 0) {
                this.toUnhook.pop()();
            }
        };
        return WordHighlighter;
    }());
    var WordHighlighterContribution = (function () {
        function WordHighlighterContribution(editor) {
            this.wordHighligher = new WordHighlighter(editor);
        }
        WordHighlighterContribution.prototype.getId = function () {
            return WordHighlighterContribution.ID;
        };
        WordHighlighterContribution.prototype.dispose = function () {
            this.wordHighligher.destroy();
        };
        WordHighlighterContribution.ID = 'editor.contrib.wordHighlighter';
        return WordHighlighterContribution;
    }());
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorContribution(WordHighlighterContribution);
});

define("vs/platform/telemetry/common/abstractTelemetryService", ["require", "exports", 'vs/base/common/winjs.base', 'vs/base/common/errors', 'vs/base/common/types', 'vs/base/common/platform', 'vs/base/common/timer', 'vs/base/common/objects', 'vs/platform/platform', 'vs/platform/telemetry/common/telemetry'], function (require, exports, winjs_base_1, Errors, Types, Platform, timer_1, objects_1, platform_1, telemetry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var DefaultTelemetryServiceConfig = {
        enableTelemetry: true,
        enableHardIdle: true,
        enableSoftIdle: true,
        userOptIn: true,
        cleanupPatterns: []
    };
    /**
     * Base class for main process telemetry services
     */
    var AbstractTelemetryService = (function () {
        function AbstractTelemetryService(config) {
            var _this = this;
            this.serviceId = telemetry_1.ITelemetryService;
            this.sessionId = 'SESSION_ID_NOT_SET';
            this.timeKeeper = new timer_1.TimeKeeper();
            this.toUnbind = [];
            this.appenders = [];
            this.timeKeeperListener = function (events) { return _this.onTelemetryTimerEventStop(events); };
            this.timeKeeper.addListener(this.timeKeeperListener);
            this.toUnbind.push(Errors.errorHandler.addListener(this.onErrorEvent.bind(this)));
            this.errorBuffer = Object.create(null);
            this.enableGlobalErrorHandler();
            this.errorFlushTimeout = -1;
            this.config = objects_1.withDefaults(config, DefaultTelemetryServiceConfig);
        }
        AbstractTelemetryService.prototype._safeStringify = function (data) {
            return objects_1.safeStringify(data);
        };
        AbstractTelemetryService.prototype.onTelemetryTimerEventStop = function (events) {
            for (var i = 0; i < events.length; i++) {
                var event_1 = events[i];
                var data = event_1.data || {};
                data.duration = event_1.timeTaken();
                this.publicLog(event_1.name, data);
            }
        };
        AbstractTelemetryService.prototype.onErrorEvent = function (e) {
            if (!e) {
                return;
            }
            var error = Object.create(null);
            // unwrap nested errors from loader
            if (e.detail && e.detail.stack) {
                e = e.detail;
            }
            // work around behavior in workerServer.ts that breaks up Error.stack
            var stack = Array.isArray(e.stack) ? e.stack.join('\n') : e.stack;
            var message = e.message ? e.message : this._safeStringify(e);
            // errors without a stack are not useful telemetry
            if (!stack) {
                return;
            }
            error['message'] = this.cleanupInfo(message);
            error['stack'] = this.cleanupInfo(stack);
            this.addErrortoBuffer(error);
        };
        AbstractTelemetryService.prototype.addErrortoBuffer = function (e) {
            if (this.errorBuffer[e.stack]) {
                this.errorBuffer[e.stack].count++;
            }
            else {
                e.count = 1;
                this.errorBuffer[e.stack] = e;
            }
            this.tryScheduleErrorFlush();
        };
        AbstractTelemetryService.prototype.tryScheduleErrorFlush = function () {
            var _this = this;
            if (this.errorFlushTimeout === -1) {
                this.errorFlushTimeout = setTimeout(function () { return _this.flushErrorBuffer(); }, AbstractTelemetryService.ERROR_FLUSH_TIMEOUT);
            }
        };
        AbstractTelemetryService.prototype.flushErrorBuffer = function () {
            if (this.errorBuffer) {
                for (var stack in this.errorBuffer) {
                    this.publicLog('UnhandledError', this.errorBuffer[stack]);
                }
            }
            this.errorBuffer = Object.create(null);
            this.errorFlushTimeout = -1;
        };
        AbstractTelemetryService.prototype.cleanupInfo = function (stack) {
            // `file:///DANGEROUS/PATH/resources/app/Useful/Information`
            var reg = /file:\/\/\/.*?\/resources\/app\//gi;
            stack = stack.replace(reg, '');
            // Any other file path that doesn't match the approved form above should be cleaned.
            reg = /file:\/\/\/.*/gi;
            stack = stack.replace(reg, '');
            // "Error: ENOENT; no such file or directory" is often followed with PII, clean it
            reg = /ENOENT: no such file or directory.*?\'([^\']+)\'/gi;
            stack = stack.replace(reg, 'ENOENT: no such file or directory');
            // sanitize with configured cleanup patterns
            for (var _i = 0, _a = this.config.cleanupPatterns; _i < _a.length; _i++) {
                var pattern = _a[_i];
                stack = stack.replace(pattern, '');
            }
            return stack;
        };
        AbstractTelemetryService.prototype.enableGlobalErrorHandler = function () {
            if (Types.isFunction(Platform.globals.onerror)) {
                this.oldOnError = Platform.globals.onerror;
            }
            var that = this;
            var newHandler = function (message, filename, line, column, e) {
                that.onUncaughtError(message, filename, line, column, e);
                if (that.oldOnError) {
                    that.oldOnError.apply(this, arguments);
                }
            };
            Platform.globals.onerror = newHandler;
        };
        AbstractTelemetryService.prototype.onUncaughtError = function (message, filename, line, column, e) {
            filename = this.cleanupInfo(filename);
            message = this.cleanupInfo(message);
            var data = {
                message: message,
                filename: filename,
                line: line,
                column: column
            };
            if (e) {
                data.error = {
                    name: e.name,
                    message: e.message
                };
                if (e.stack) {
                    if (Array.isArray(e.stack)) {
                        e.stack = e.stack.join('\n');
                    }
                    data.stack = this.cleanupInfo(e.stack);
                }
            }
            if (!data.stack) {
                data.stack = data.message;
            }
            this.addErrortoBuffer(data);
        };
        AbstractTelemetryService.prototype.loadTelemetryAppendersFromRegistery = function () {
            var appendersRegistry = platform_1.Registry.as(exports.Extenstions.TelemetryAppenders).getTelemetryAppenderDescriptors();
            for (var i = 0; i < appendersRegistry.length; i++) {
                var descriptor = appendersRegistry[i];
                var appender = this.instantiationService.createInstance(descriptor);
                this.addTelemetryAppender(appender);
            }
        };
        AbstractTelemetryService.prototype.getSessionId = function () {
            return this.sessionId;
        };
        AbstractTelemetryService.prototype.getMachineId = function () {
            return this.machineId;
        };
        AbstractTelemetryService.prototype.getInstanceId = function () {
            return this.instanceId;
        };
        AbstractTelemetryService.prototype.getTelemetryInfo = function () {
            return winjs_base_1.TPromise.as({
                instanceId: this.instanceId,
                sessionId: this.sessionId,
                machineId: this.machineId
            });
        };
        AbstractTelemetryService.prototype.dispose = function () {
            if (this.errorFlushTimeout !== -1) {
                clearTimeout(this.errorFlushTimeout);
                this.flushErrorBuffer();
            }
            while (this.toUnbind.length) {
                this.toUnbind.pop()();
            }
            this.timeKeeper.removeListener(this.timeKeeperListener);
            this.timeKeeper.dispose();
            for (var i = 0; i < this.appenders.length; i++) {
                this.appenders[i].dispose();
            }
        };
        AbstractTelemetryService.prototype.start = function (name, data) {
            var topic = 'public';
            var event = this.timeKeeper.start(topic, name);
            if (data) {
                event.data = data;
            }
            return event;
        };
        AbstractTelemetryService.prototype.publicLog = function (eventName, data) {
            this.handleEvent(eventName, data);
        };
        AbstractTelemetryService.prototype.getAppendersCount = function () {
            return this.appenders.length;
        };
        AbstractTelemetryService.prototype.getAppenders = function () {
            return this.appenders;
        };
        AbstractTelemetryService.prototype.addTelemetryAppender = function (appender) {
            this.appenders.push(appender);
        };
        AbstractTelemetryService.prototype.removeTelemetryAppender = function (appender) {
            var index = this.appenders.indexOf(appender);
            if (index > -1) {
                this.appenders.splice(index, 1);
            }
        };
        AbstractTelemetryService.prototype.setInstantiationService = function (instantiationService) {
            this.instantiationService = instantiationService;
            if (this.instantiationService) {
                this.loadTelemetryAppendersFromRegistery();
            }
        };
        AbstractTelemetryService.prototype.handleEvent = function (eventName, data) {
            throw new Error('Not implemented!');
        };
        AbstractTelemetryService.ERROR_FLUSH_TIMEOUT = 5 * 1000;
        return AbstractTelemetryService;
    }());
    exports.AbstractTelemetryService = AbstractTelemetryService;
    exports.Extenstions = {
        TelemetryAppenders: 'telemetry.appenders'
    };
    var TelemetryAppendersRegistry = (function () {
        function TelemetryAppendersRegistry() {
            this.telemetryAppenderDescriptors = [];
        }
        TelemetryAppendersRegistry.prototype.registerTelemetryAppenderDescriptor = function (descriptor) {
            this.telemetryAppenderDescriptors.push(descriptor);
        };
        TelemetryAppendersRegistry.prototype.getTelemetryAppenderDescriptors = function () {
            return this.telemetryAppenderDescriptors;
        };
        return TelemetryAppendersRegistry;
    }());
    platform_1.Registry.add(exports.Extenstions.TelemetryAppenders, new TelemetryAppendersRegistry());
});

define("vs/platform/thread/common/thread", ["require", "exports", 'vs/platform/instantiation/common/instantiation'], function (require, exports, instantiation) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // --- thread service (web workers)
    exports.IThreadService = instantiation.createDecorator('threadService');
    var IRemotableCtorMap = (function () {
        function IRemotableCtorMap() {
        }
        return IRemotableCtorMap;
    }());
    exports.IRemotableCtorMap = IRemotableCtorMap;
    var IRemotableCtorAffinityMap = (function () {
        function IRemotableCtorAffinityMap() {
        }
        return IRemotableCtorAffinityMap;
    }());
    exports.IRemotableCtorAffinityMap = IRemotableCtorAffinityMap;
    var Remotable = (function () {
        function Remotable() {
        }
        Remotable.getId = function (ctor) {
            return (ctor[Remotable.PROP_NAME] || null);
        };
        Remotable.MainContext = function (identifier) {
            return function (target) {
                Remotable._ensureUnique(identifier);
                Remotable.Registry.MainContext[identifier] = target;
                target[Remotable.PROP_NAME] = identifier;
            };
        };
        Remotable.ExtHostContext = function (identifier) {
            return function (target) {
                Remotable._ensureUnique(identifier);
                Remotable.Registry.ExtHostContext[identifier] = target;
                target[Remotable.PROP_NAME] = identifier;
            };
        };
        Remotable.WorkerContext = function (identifier, whichWorker) {
            return function (target) {
                Remotable._ensureUnique(identifier);
                Remotable.Registry.WorkerContext[identifier] = {
                    ctor: target,
                    affinity: whichWorker
                };
                target[Remotable.PROP_NAME] = identifier;
            };
        };
        Remotable._ensureUnique = function (identifier) {
            if (Remotable.Registry.MainContext[identifier] || Remotable.Registry.ExtHostContext[identifier] || Remotable.Registry.WorkerContext[identifier]) {
                throw new Error('Duplicate Remotable identifier found');
            }
        };
        Remotable.PROP_NAME = '$__REMOTABLE_ID';
        Remotable.Registry = {
            MainContext: Object.create(null),
            ExtHostContext: Object.create(null),
            WorkerContext: Object.create(null),
        };
        return Remotable;
    }());
    exports.Remotable = Remotable;
    (function (ThreadAffinity) {
        ThreadAffinity[ThreadAffinity["None"] = 0] = "None";
        ThreadAffinity[ThreadAffinity["Group1"] = 1] = "Group1";
        ThreadAffinity[ThreadAffinity["Group2"] = 2] = "Group2";
        ThreadAffinity[ThreadAffinity["Group3"] = 3] = "Group3";
        ThreadAffinity[ThreadAffinity["Group4"] = 4] = "Group4";
        ThreadAffinity[ThreadAffinity["Group5"] = 5] = "Group5";
        ThreadAffinity[ThreadAffinity["Group6"] = 6] = "Group6";
        ThreadAffinity[ThreadAffinity["Group7"] = 7] = "Group7";
        ThreadAffinity[ThreadAffinity["Group8"] = 8] = "Group8";
        ThreadAffinity[ThreadAffinity["Group9"] = 9] = "Group9";
        ThreadAffinity[ThreadAffinity["All"] = 10] = "All";
    })(exports.ThreadAffinity || (exports.ThreadAffinity = {}));
    var ThreadAffinity = exports.ThreadAffinity;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/editor/common/services/modeServiceImpl", ["require", "exports", 'vs/nls!vs/editor/common/services/modeServiceImpl', 'vs/base/common/errors', 'vs/base/common/event', 'vs/base/common/lifecycle', 'vs/base/common/objects', 'vs/base/common/paths', 'vs/base/common/winjs.base', 'vs/base/common/mime', 'vs/platform/instantiation/common/descriptors', 'vs/platform/extensions/common/extensionsRegistry', 'vs/platform/thread/common/thread', 'vs/editor/common/modes/abstractMode', 'vs/editor/common/modes/modesRegistry', 'vs/editor/common/modes/monarch/monarchCompile', 'vs/editor/common/modes/monarch/monarchDefinition', 'vs/editor/common/modes/monarch/monarchLexer', 'vs/editor/common/modes/supports/declarationSupport', 'vs/editor/common/modes/supports/parameterHintsSupport', 'vs/editor/common/modes/supports/referenceSupport', 'vs/editor/common/modes/supports/richEditSupport', 'vs/editor/common/modes/supports/suggestSupport', 'vs/editor/common/services/languagesRegistry', 'vs/editor/common/services/modeService', 'vs/platform/configuration/common/configuration'], function (require, exports, nls, errors_1, event_1, lifecycle_1, objects, paths, winjs_base_1, mime, descriptors_1, extensionsRegistry_1, thread_1, abstractMode_1, modesRegistry_1, monarchCompile_1, monarchDefinition_1, monarchLexer_1, declarationSupport_1, parameterHintsSupport_1, referenceSupport_1, richEditSupport_1, suggestSupport_1, languagesRegistry_1, modeService_1, configuration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var languagesExtPoint = extensionsRegistry_1.ExtensionsRegistry.registerExtensionPoint('languages', {
        description: nls.localize(0, null),
        type: 'array',
        defaultSnippets: [{ body: [{ id: '', aliases: [], extensions: [] }] }],
        items: {
            type: 'object',
            defaultSnippets: [{ body: { id: '', extensions: [] } }],
            properties: {
                id: {
                    description: nls.localize(1, null),
                    type: 'string'
                },
                aliases: {
                    description: nls.localize(2, null),
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                extensions: {
                    description: nls.localize(3, null),
                    default: ['.foo'],
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                filenames: {
                    description: nls.localize(4, null),
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                filenamePatterns: {
                    description: nls.localize(5, null),
                    default: ['bar*foo.txt'],
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                mimetypes: {
                    description: nls.localize(6, null),
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                firstLine: {
                    description: nls.localize(7, null),
                    type: 'string'
                },
                configuration: {
                    description: nls.localize(8, null),
                    type: 'string'
                }
            }
        }
    });
    function isUndefinedOrStringArray(value) {
        if (typeof value === 'undefined') {
            return true;
        }
        if (!Array.isArray(value)) {
            return false;
        }
        return value.every(function (item) { return typeof item === 'string'; });
    }
    function isValidLanguageExtensionPoint(value, collector) {
        if (!value) {
            collector.error(nls.localize(9, null, languagesExtPoint.name));
            return false;
        }
        if (typeof value.id !== 'string') {
            collector.error(nls.localize(10, null, 'id'));
            return false;
        }
        if (!isUndefinedOrStringArray(value.extensions)) {
            collector.error(nls.localize(11, null, 'extensions'));
            return false;
        }
        if (!isUndefinedOrStringArray(value.filenames)) {
            collector.error(nls.localize(12, null, 'filenames'));
            return false;
        }
        if (typeof value.firstLine !== 'undefined' && typeof value.firstLine !== 'string') {
            collector.error(nls.localize(13, null, 'firstLine'));
            return false;
        }
        if (typeof value.configuration !== 'undefined' && typeof value.configuration !== 'string') {
            collector.error(nls.localize(14, null, 'configuration'));
            return false;
        }
        if (!isUndefinedOrStringArray(value.aliases)) {
            collector.error(nls.localize(15, null, 'aliases'));
            return false;
        }
        if (!isUndefinedOrStringArray(value.mimetypes)) {
            collector.error(nls.localize(16, null, 'mimetypes'));
            return false;
        }
        return true;
    }
    var ModeServiceImpl = (function () {
        function ModeServiceImpl(threadService, extensionService) {
            var _this = this;
            this.serviceId = modeService_1.IModeService;
            this._onDidAddModes = new event_1.Emitter();
            this.onDidAddModes = this._onDidAddModes.event;
            this._onDidCreateMode = new event_1.Emitter();
            this.onDidCreateMode = this._onDidCreateMode.event;
            this._threadService = threadService;
            this._extensionService = extensionService;
            this._activationPromises = {};
            this._instantiatedModes = {};
            this._config = {};
            this._registry = new languagesRegistry_1.LanguagesRegistry();
            this._registry.onDidAddModes(function (modes) { return _this._onDidAddModes.fire(modes); });
        }
        ModeServiceImpl.prototype.getConfigurationForMode = function (modeId) {
            return this._config[modeId] || {};
        };
        ModeServiceImpl.prototype.configureMode = function (mimetype, options) {
            var modeId = this.getModeId(mimetype);
            if (modeId) {
                this.configureModeById(modeId, options);
            }
        };
        ModeServiceImpl.prototype.configureModeById = function (modeId, options) {
            var previousOptions = this._config[modeId] || {};
            var newOptions = objects.mixin(objects.clone(previousOptions), options);
            if (objects.equals(previousOptions, newOptions)) {
                // This configure call is a no-op
                return;
            }
            this._config[modeId] = newOptions;
            var mode = this.getMode(modeId);
            if (mode && mode.configSupport) {
                mode.configSupport.configure(this.getConfigurationForMode(modeId));
            }
        };
        ModeServiceImpl.prototype.configureAllModes = function (config) {
            var _this = this;
            if (!config) {
                return;
            }
            var modes = this._registry.getRegisteredModes();
            modes.forEach(function (modeIdentifier) {
                var configuration = config[modeIdentifier];
                _this.configureModeById(modeIdentifier, configuration);
            });
        };
        ModeServiceImpl.prototype.isRegisteredMode = function (mimetypeOrModeId) {
            return this._registry.isRegisteredMode(mimetypeOrModeId);
        };
        ModeServiceImpl.prototype.isCompatMode = function (modeId) {
            var compatModeData = this._registry.getCompatMode(modeId);
            return (compatModeData ? true : false);
        };
        ModeServiceImpl.prototype.getRegisteredModes = function () {
            return this._registry.getRegisteredModes();
        };
        ModeServiceImpl.prototype.getRegisteredLanguageNames = function () {
            return this._registry.getRegisteredLanguageNames();
        };
        ModeServiceImpl.prototype.getExtensions = function (alias) {
            return this._registry.getExtensions(alias);
        };
        ModeServiceImpl.prototype.getMimeForMode = function (modeId) {
            return this._registry.getMimeForMode(modeId);
        };
        ModeServiceImpl.prototype.getLanguageName = function (modeId) {
            return this._registry.getLanguageName(modeId);
        };
        ModeServiceImpl.prototype.getModeIdForLanguageName = function (alias) {
            return this._registry.getModeIdForLanguageNameLowercase(alias);
        };
        ModeServiceImpl.prototype.getModeId = function (commaSeparatedMimetypesOrCommaSeparatedIds) {
            var modeIds = this._registry.extractModeIds(commaSeparatedMimetypesOrCommaSeparatedIds);
            if (modeIds.length > 0) {
                return modeIds[0];
            }
            return null;
        };
        ModeServiceImpl.prototype.getConfigurationFiles = function (modeId) {
            return this._registry.getConfigurationFiles(modeId);
        };
        // --- instantiation
        ModeServiceImpl.prototype.lookup = function (commaSeparatedMimetypesOrCommaSeparatedIds) {
            var r = [];
            var modeIds = this._registry.extractModeIds(commaSeparatedMimetypesOrCommaSeparatedIds);
            for (var i = 0; i < modeIds.length; i++) {
                var modeId = modeIds[i];
                r.push({
                    modeId: modeId,
                    isInstantiated: this._instantiatedModes.hasOwnProperty(modeId)
                });
            }
            return r;
        };
        ModeServiceImpl.prototype.getMode = function (commaSeparatedMimetypesOrCommaSeparatedIds) {
            var modeIds = this._registry.extractModeIds(commaSeparatedMimetypesOrCommaSeparatedIds);
            var isPlainText = false;
            for (var i = 0; i < modeIds.length; i++) {
                if (this._instantiatedModes.hasOwnProperty(modeIds[i])) {
                    return this._instantiatedModes[modeIds[i]];
                }
                isPlainText = isPlainText || (modeIds[i] === 'plaintext');
            }
            if (isPlainText) {
                // Try to do it synchronously
                var r = null;
                this.getOrCreateMode(commaSeparatedMimetypesOrCommaSeparatedIds).then(function (mode) {
                    r = mode;
                }).done(null, errors_1.onUnexpectedError);
                return r;
            }
        };
        ModeServiceImpl.prototype.getModeIdByLanguageName = function (languageName) {
            var modeIds = this._registry.getModeIdsFromLanguageName(languageName);
            if (modeIds.length > 0) {
                return modeIds[0];
            }
            return null;
        };
        ModeServiceImpl.prototype.getModeIdByFilenameOrFirstLine = function (filename, firstLine) {
            var modeIds = this._registry.getModeIdsFromFilenameOrFirstLine(filename, firstLine);
            if (modeIds.length > 0) {
                return modeIds[0];
            }
            return null;
        };
        ModeServiceImpl.prototype.onReady = function () {
            return this._extensionService.onReady();
        };
        ModeServiceImpl.prototype.getOrCreateMode = function (commaSeparatedMimetypesOrCommaSeparatedIds) {
            var _this = this;
            return this.onReady().then(function () {
                var modeId = _this.getModeId(commaSeparatedMimetypesOrCommaSeparatedIds);
                // Fall back to plain text if no mode was found
                return _this._getOrCreateMode(modeId || 'plaintext');
            });
        };
        ModeServiceImpl.prototype.getOrCreateModeByLanguageName = function (languageName) {
            var _this = this;
            return this.onReady().then(function () {
                var modeId = _this.getModeIdByLanguageName(languageName);
                // Fall back to plain text if no mode was found
                return _this._getOrCreateMode(modeId || 'plaintext');
            });
        };
        ModeServiceImpl.prototype.getOrCreateModeByFilenameOrFirstLine = function (filename, firstLine) {
            var _this = this;
            return this.onReady().then(function () {
                var modeId = _this.getModeIdByFilenameOrFirstLine(filename, firstLine);
                // Fall back to plain text if no mode was found
                return _this._getOrCreateMode(modeId || 'plaintext');
            });
        };
        ModeServiceImpl.prototype._getOrCreateMode = function (modeId) {
            var _this = this;
            if (this._instantiatedModes.hasOwnProperty(modeId)) {
                return winjs_base_1.TPromise.as(this._instantiatedModes[modeId]);
            }
            if (this._activationPromises.hasOwnProperty(modeId)) {
                return this._activationPromises[modeId];
            }
            var c, e;
            var promise = new winjs_base_1.TPromise(function (cc, ee, pp) { c = cc; e = ee; });
            this._activationPromises[modeId] = promise;
            this._createMode(modeId).then(function (mode) {
                _this._instantiatedModes[modeId] = mode;
                delete _this._activationPromises[modeId];
                _this._onDidCreateMode.fire(mode);
                _this._extensionService.activateByEvent("onLanguage:" + modeId).done(null, errors_1.onUnexpectedError);
                return _this._instantiatedModes[modeId];
            }).then(c, e);
            return promise;
        };
        ModeServiceImpl.prototype._createMode = function (modeId) {
            var _this = this;
            var modeDescriptor = this._createModeDescriptor(modeId);
            var compatModeData = this._registry.getCompatMode(modeId);
            if (compatModeData) {
                // This is a compatibility mode
                var compatModeAsyncDescriptor = descriptors_1.createAsyncDescriptor1(compatModeData.moduleId, compatModeData.ctorName);
                return this._threadService.createInstance(compatModeAsyncDescriptor, modeDescriptor).then(function (compatMode) {
                    if (compatMode.configSupport) {
                        compatMode.configSupport.configure(_this.getConfigurationForMode(modeId));
                    }
                    return compatMode;
                });
            }
            return winjs_base_1.TPromise.as(this._threadService.createInstance(abstractMode_1.FrankensteinMode, modeDescriptor));
        };
        ModeServiceImpl.prototype._createModeDescriptor = function (modeId) {
            var workerParticipants = modesRegistry_1.ModesRegistry.getWorkerParticipantsForMode(modeId);
            return {
                id: modeId,
                workerParticipants: workerParticipants.map(function (p) { return descriptors_1.createAsyncDescriptor0(p.moduleId, p.ctorName); })
            };
        };
        ModeServiceImpl.prototype._registerModeSupport = function (mode, support, callback) {
            if (mode.registerSupport) {
                return mode.registerSupport(support, callback);
            }
            else {
                console.warn('Cannot register support ' + support + ' on mode ' + mode.getId() + ' because it does not support it.');
                return lifecycle_1.empty;
            }
        };
        ModeServiceImpl.prototype.registerModeSupport = function (modeId, support, callback) {
            var _this = this;
            if (this._instantiatedModes.hasOwnProperty(modeId)) {
                return this._registerModeSupport(this._instantiatedModes[modeId], support, callback);
            }
            var cc;
            var promise = new winjs_base_1.TPromise(function (c, e) { cc = c; });
            var disposable = this.onDidCreateMode(function (mode) {
                if (mode.getId() !== modeId) {
                    return;
                }
                cc(_this._registerModeSupport(mode, support, callback));
                disposable.dispose();
            });
            return {
                dispose: function () {
                    promise.done(function (disposable) { return disposable.dispose(); }, null);
                }
            };
        };
        ModeServiceImpl.prototype.doRegisterMonarchDefinition = function (modeId, lexer) {
            var _this = this;
            return lifecycle_1.combinedDispose(this.registerTokenizationSupport(modeId, function (mode) {
                return monarchLexer_1.createTokenizationSupport(_this, mode, lexer);
            }), this.registerRichEditSupport(modeId, monarchDefinition_1.createRichEditSupport(lexer)));
        };
        ModeServiceImpl.prototype.registerMonarchDefinition = function (modelService, editorWorkerService, modeId, language) {
            var lexer = monarchCompile_1.compile(objects.clone(language));
            return this.doRegisterMonarchDefinition(modeId, lexer);
        };
        ModeServiceImpl.prototype.registerCodeLensSupport = function (modeId, support) {
            return this.registerModeSupport(modeId, 'codeLensSupport', function (mode) { return support; });
        };
        ModeServiceImpl.prototype.registerRichEditSupport = function (modeId, support) {
            return this.registerModeSupport(modeId, 'richEditSupport', function (mode) { return new richEditSupport_1.RichEditSupport(modeId, mode.richEditSupport, support); });
        };
        ModeServiceImpl.prototype.registerDeclarativeDeclarationSupport = function (modeId, contribution) {
            return this.registerModeSupport(modeId, 'declarationSupport', function (mode) { return new declarationSupport_1.DeclarationSupport(modeId, contribution); });
        };
        ModeServiceImpl.prototype.registerExtraInfoSupport = function (modeId, support) {
            return this.registerModeSupport(modeId, 'extraInfoSupport', function (mode) { return support; });
        };
        ModeServiceImpl.prototype.registerFormattingSupport = function (modeId, support) {
            return this.registerModeSupport(modeId, 'formattingSupport', function (mode) { return support; });
        };
        ModeServiceImpl.prototype.registerInplaceReplaceSupport = function (modeId, support) {
            return this.registerModeSupport(modeId, 'inplaceReplaceSupport', function (mode) { return support; });
        };
        ModeServiceImpl.prototype.registerOccurrencesSupport = function (modeId, support) {
            return this.registerModeSupport(modeId, 'occurrencesSupport', function (mode) { return support; });
        };
        ModeServiceImpl.prototype.registerOutlineSupport = function (modeId, support) {
            return this.registerModeSupport(modeId, 'outlineSupport', function (mode) { return support; });
        };
        ModeServiceImpl.prototype.registerDeclarativeParameterHintsSupport = function (modeId, support) {
            return this.registerModeSupport(modeId, 'parameterHintsSupport', function (mode) { return new parameterHintsSupport_1.ParameterHintsSupport(modeId, support); });
        };
        ModeServiceImpl.prototype.registerQuickFixSupport = function (modeId, support) {
            return this.registerModeSupport(modeId, 'quickFixSupport', function (mode) { return support; });
        };
        ModeServiceImpl.prototype.registerDeclarativeReferenceSupport = function (modeId, contribution) {
            return this.registerModeSupport(modeId, 'referenceSupport', function (mode) { return new referenceSupport_1.ReferenceSupport(modeId, contribution); });
        };
        ModeServiceImpl.prototype.registerRenameSupport = function (modeId, support) {
            return this.registerModeSupport(modeId, 'renameSupport', function (mode) { return support; });
        };
        ModeServiceImpl.prototype.registerDeclarativeSuggestSupport = function (modeId, declaration) {
            return this.registerModeSupport(modeId, 'suggestSupport', function (mode) { return new suggestSupport_1.SuggestSupport(modeId, declaration); });
        };
        ModeServiceImpl.prototype.registerTokenizationSupport = function (modeId, callback) {
            return this.registerModeSupport(modeId, 'tokenizationSupport', callback);
        };
        return ModeServiceImpl;
    }());
    exports.ModeServiceImpl = ModeServiceImpl;
    var MainThreadModeServiceImpl = (function (_super) {
        __extends(MainThreadModeServiceImpl, _super);
        function MainThreadModeServiceImpl(threadService, extensionService, configurationService) {
            var _this = this;
            _super.call(this, threadService, extensionService);
            this._configurationService = configurationService;
            this._hasInitialized = false;
            languagesExtPoint.setHandler(function (extensions) {
                var allValidLanguages = [];
                for (var i = 0, len = extensions.length; i < len; i++) {
                    var extension = extensions[i];
                    if (!Array.isArray(extension.value)) {
                        extension.collector.error(nls.localize(17, null, languagesExtPoint.name));
                        continue;
                    }
                    for (var j = 0, lenJ = extension.value.length; j < lenJ; j++) {
                        var ext = extension.value[j];
                        if (isValidLanguageExtensionPoint(ext, extension.collector)) {
                            var configuration = (ext.configuration ? paths.join(extension.description.extensionFolderPath, ext.configuration) : ext.configuration);
                            allValidLanguages.push({
                                id: ext.id,
                                extensions: ext.extensions,
                                filenames: ext.filenames,
                                filenamePatterns: ext.filenamePatterns,
                                firstLine: ext.firstLine,
                                aliases: ext.aliases,
                                mimetypes: ext.mimetypes,
                                configuration: configuration
                            });
                        }
                    }
                }
                modesRegistry_1.ModesRegistry.registerLanguages(allValidLanguages);
            });
            this._configurationService.addListener(configuration_1.ConfigurationServiceEventTypes.UPDATED, function (e) { return _this.onConfigurationChange(e.config); });
        }
        MainThreadModeServiceImpl.prototype.onReady = function () {
            var _this = this;
            if (!this._onReadyPromise) {
                this._onReadyPromise = this._configurationService.loadConfiguration().then(function (configuration) {
                    return _this._extensionService.onReady().then(function () {
                        _this.onConfigurationChange(configuration);
                        return true;
                    });
                });
            }
            return this._onReadyPromise;
        };
        MainThreadModeServiceImpl.prototype.onConfigurationChange = function (configuration) {
            var _this = this;
            // Clear user configured mime associations
            mime.clearTextMimes(true /* user configured */);
            // Register based on settings
            if (configuration.files && configuration.files.associations) {
                Object.keys(configuration.files.associations).forEach(function (pattern) {
                    mime.registerTextMime({ mime: _this.getMimeForMode(configuration.files.associations[pattern]), filepattern: pattern, userConfigured: true });
                });
            }
        };
        MainThreadModeServiceImpl.prototype._getModeServiceWorkerHelper = function () {
            var r = this._threadService.getRemotable(ModeServiceWorkerHelper);
            if (!this._hasInitialized) {
                this._hasInitialized = true;
                var initData = {
                    compatModes: modesRegistry_1.ModesRegistry.getCompatModes(),
                    languages: modesRegistry_1.ModesRegistry.getLanguages(),
                    workerParticipants: modesRegistry_1.ModesRegistry.getWorkerParticipants()
                };
                r._initialize(initData);
                modesRegistry_1.ModesRegistry.onDidAddCompatModes(function (m) { return r._acceptCompatModes(m); });
                modesRegistry_1.ModesRegistry.onDidAddLanguages(function (m) { return r._acceptLanguages(m); });
            }
            return r;
        };
        MainThreadModeServiceImpl.prototype.configureModeById = function (modeId, options) {
            this._getModeServiceWorkerHelper().configureModeById(modeId, options);
            _super.prototype.configureModeById.call(this, modeId, options);
        };
        MainThreadModeServiceImpl.prototype._createMode = function (modeId) {
            // Instantiate mode also in worker
            this._getModeServiceWorkerHelper().instantiateMode(modeId);
            return _super.prototype._createMode.call(this, modeId);
        };
        MainThreadModeServiceImpl.prototype.registerMonarchDefinition = function (modelService, editorWorkerService, modeId, language) {
            this._getModeServiceWorkerHelper().registerMonarchDefinition(modeId, language);
            var lexer = monarchCompile_1.compile(objects.clone(language));
            return lifecycle_1.combinedDispose(_super.prototype.doRegisterMonarchDefinition.call(this, modeId, lexer), this.registerModeSupport(modeId, 'suggestSupport', function (mode) {
                return monarchDefinition_1.createSuggestSupport(modelService, editorWorkerService, modeId, lexer);
            }));
        };
        return MainThreadModeServiceImpl;
    }(ModeServiceImpl));
    exports.MainThreadModeServiceImpl = MainThreadModeServiceImpl;
    var ModeServiceWorkerHelper = (function () {
        function ModeServiceWorkerHelper(modeService) {
            this._modeService = modeService;
        }
        ModeServiceWorkerHelper.prototype._initialize = function (initData) {
            modesRegistry_1.ModesRegistry.registerCompatModes(initData.compatModes);
            modesRegistry_1.ModesRegistry.registerLanguages(initData.languages);
            modesRegistry_1.ModesRegistry.registerWorkerParticipants(initData.workerParticipants);
        };
        ModeServiceWorkerHelper.prototype._acceptCompatModes = function (modes) {
            modesRegistry_1.ModesRegistry.registerCompatModes(modes);
        };
        ModeServiceWorkerHelper.prototype._acceptLanguages = function (languages) {
            modesRegistry_1.ModesRegistry.registerLanguages(languages);
        };
        ModeServiceWorkerHelper.prototype.instantiateMode = function (modeId) {
            this._modeService.getOrCreateMode(modeId).done(null, errors_1.onUnexpectedError);
        };
        ModeServiceWorkerHelper.prototype.configureModeById = function (modeId, options) {
            this._modeService.configureMode(modeId, options);
        };
        ModeServiceWorkerHelper.prototype.registerMonarchDefinition = function (modeId, language) {
            this._modeService.registerMonarchDefinition(null, null, modeId, language);
        };
        ModeServiceWorkerHelper = __decorate([
            thread_1.Remotable.WorkerContext('ModeServiceWorkerHelper', thread_1.ThreadAffinity.All),
            __param(0, modeService_1.IModeService)
        ], ModeServiceWorkerHelper);
        return ModeServiceWorkerHelper;
    }());
    exports.ModeServiceWorkerHelper = ModeServiceWorkerHelper;
});

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/platform/storage/common/remotable.storage", ["require", "exports", 'vs/base/common/winjs.base', 'vs/platform/thread/common/thread', 'vs/platform/storage/common/storage'], function (require, exports, winjs_base_1, thread_1, storage_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var MainThreadStorage = (function () {
        function MainThreadStorage(storageService) {
            this._storageService = storageService;
        }
        MainThreadStorage.prototype.getValue = function (shared, key) {
            var jsonValue = this._storageService.get(key, shared ? storage_1.StorageScope.GLOBAL : storage_1.StorageScope.WORKSPACE);
            if (!jsonValue) {
                return winjs_base_1.TPromise.as(undefined);
            }
            var value;
            try {
                value = JSON.parse(jsonValue);
                return winjs_base_1.TPromise.as(value);
            }
            catch (err) {
                return winjs_base_1.TPromise.wrapError(err);
            }
        };
        MainThreadStorage.prototype.setValue = function (shared, key, value) {
            var jsonValue;
            try {
                jsonValue = JSON.stringify(value);
                this._storageService.store(key, jsonValue, shared ? storage_1.StorageScope.GLOBAL : storage_1.StorageScope.WORKSPACE);
            }
            catch (err) {
                return winjs_base_1.TPromise.wrapError(err);
            }
        };
        MainThreadStorage = __decorate([
            thread_1.Remotable.MainContext('MainThreadStorage'),
            __param(0, storage_1.IStorageService)
        ], MainThreadStorage);
        return MainThreadStorage;
    }());
    exports.MainThreadStorage = MainThreadStorage;
    var ExtHostStorage = (function () {
        function ExtHostStorage(threadService) {
            this._proxy = threadService.getRemotable(MainThreadStorage);
        }
        ExtHostStorage.prototype.getValue = function (shared, key, defaultValue) {
            return this._proxy.getValue(shared, key).then(function (value) { return value || defaultValue; });
        };
        ExtHostStorage.prototype.setValue = function (shared, key, value) {
            return this._proxy.setValue(shared, key, value);
        };
        return ExtHostStorage;
    }());
    exports.ExtHostStorage = ExtHostStorage;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("vs/platform/extensions/common/nativeExtensionService", ["require", "exports", 'vs/base/common/lifecycle', 'vs/base/common/paths', 'vs/base/common/severity', 'vs/base/common/winjs.base', 'vs/platform/extensions/common/abstractExtensionService', 'vs/platform/extensions/common/extensionsRegistry', 'vs/platform/storage/common/remotable.storage', 'vs/platform/thread/common/thread'], function (require, exports, lifecycle_1, paths, severity_1, winjs_base_1, abstractExtensionService_1, extensionsRegistry_1, remotable_storage_1, thread_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var hasOwnProperty = Object.hasOwnProperty;
    /**
     * Represents a failed extension in the ext host.
     */
    var MainProcessFailedExtension = (function (_super) {
        __extends(MainProcessFailedExtension, _super);
        function MainProcessFailedExtension() {
            _super.call(this, true);
        }
        return MainProcessFailedExtension;
    }(abstractExtensionService_1.ActivatedExtension));
    /**
     * Represents an extension that was successfully loaded or an
     * empty extension in the ext host.
     */
    var MainProcessSuccessExtension = (function (_super) {
        __extends(MainProcessSuccessExtension, _super);
        function MainProcessSuccessExtension() {
            _super.call(this, false);
        }
        return MainProcessSuccessExtension;
    }(abstractExtensionService_1.ActivatedExtension));
    function messageWithSource(msg) {
        return (msg.source ? '[' + msg.source + ']: ' : '') + msg.message;
    }
    var MainProcessExtensionService = (function (_super) {
        __extends(MainProcessExtensionService, _super);
        /**
         * This class is constructed manually because it is a service, so it doesn't use any ctor injection
         */
        function MainProcessExtensionService(contextService, threadService, messageService, telemetryService) {
            var _this = this;
            _super.call(this, false);
            var config = contextService.getConfiguration();
            this._isDev = !config.env.isBuilt || !!config.env.extensionDevelopmentPath;
            this._messageService = messageService;
            threadService.registerRemotableInstance(MainProcessExtensionService, this);
            this._threadService = threadService;
            this._telemetryService = telemetryService;
            this._proxy = this._threadService.getRemotable(ExtHostExtensionService);
            this._extensionsStatus = {};
            extensionsRegistry_1.ExtensionsRegistry.handleExtensionPoints(function (msg) { return _this._handleMessage(msg); });
        }
        MainProcessExtensionService.prototype._handleMessage = function (msg) {
            this._showMessage(msg.type, messageWithSource(msg));
            if (!this._extensionsStatus[msg.source]) {
                this._extensionsStatus[msg.source] = { messages: [] };
            }
            this._extensionsStatus[msg.source].messages.push(msg);
        };
        MainProcessExtensionService.prototype.$localShowMessage = function (severity, msg) {
            var messageShown = false;
            if (severity === severity_1.default.Error || severity === severity_1.default.Warning) {
                if (this._isDev) {
                    // Only show nasty intrusive messages if doing extension development.
                    this._messageService.show(severity, msg);
                    messageShown = true;
                }
            }
            if (!messageShown) {
                switch (severity) {
                    case severity_1.default.Error:
                        console.error(msg);
                        break;
                    case severity_1.default.Warning:
                        console.warn(msg);
                        break;
                    default:
                        console.log(msg);
                }
            }
        };
        // -- overwriting AbstractExtensionService
        MainProcessExtensionService.prototype.getExtensionsStatus = function () {
            return this._extensionsStatus;
        };
        MainProcessExtensionService.prototype._showMessage = function (severity, msg) {
            this._proxy.$localShowMessage(severity, msg);
            this.$localShowMessage(severity, msg);
        };
        MainProcessExtensionService.prototype._createFailedExtension = function () {
            return new MainProcessFailedExtension();
        };
        MainProcessExtensionService.prototype._actualActivateExtension = function (extensionDescription) {
            var _this = this;
            // redirect extension activation to the extension host
            return this._proxy.$activateExtension(extensionDescription).then(function (_) {
                // the extension host calls $onExtensionActivated, where we write to `_activatedExtensions`
                return _this._activatedExtensions[extensionDescription.id];
            });
        };
        // -- called by extension host
        MainProcessExtensionService.prototype.$onExtensionHostReady = function (extensionDescriptions, messages) {
            var _this = this;
            extensionsRegistry_1.ExtensionsRegistry.registerExtensions(extensionDescriptions);
            messages.forEach(function (entry) { return _this._handleMessage(entry); });
            this._triggerOnReady();
        };
        MainProcessExtensionService.prototype.$onExtensionActivated = function (extensionId) {
            this._activatedExtensions[extensionId] = new MainProcessSuccessExtension();
        };
        MainProcessExtensionService.prototype.$onExtensionActivationFailed = function (extensionId) {
            this._activatedExtensions[extensionId] = new MainProcessFailedExtension();
        };
        MainProcessExtensionService = __decorate([
            thread_1.Remotable.MainContext('MainProcessExtensionService')
        ], MainProcessExtensionService);
        return MainProcessExtensionService;
    }(abstractExtensionService_1.AbstractExtensionService));
    exports.MainProcessExtensionService = MainProcessExtensionService;
    var ExtHostExtension = (function (_super) {
        __extends(ExtHostExtension, _super);
        function ExtHostExtension(activationFailed, module, exports, subscriptions) {
            _super.call(this, activationFailed);
            this.module = module;
            this.exports = exports;
            this.subscriptions = subscriptions;
        }
        return ExtHostExtension;
    }(abstractExtensionService_1.ActivatedExtension));
    exports.ExtHostExtension = ExtHostExtension;
    var ExtHostEmptyExtension = (function (_super) {
        __extends(ExtHostEmptyExtension, _super);
        function ExtHostEmptyExtension() {
            _super.call(this, false, { activate: undefined, deactivate: undefined }, undefined, []);
        }
        return ExtHostEmptyExtension;
    }(ExtHostExtension));
    exports.ExtHostEmptyExtension = ExtHostEmptyExtension;
    var ExtensionMemento = (function () {
        function ExtensionMemento(id, global, storage) {
            var _this = this;
            this._id = id;
            this._shared = global;
            this._storage = storage;
            this._init = this._storage.getValue(this._shared, this._id, Object.create(null)).then(function (value) {
                _this._value = value;
                return _this;
            });
        }
        Object.defineProperty(ExtensionMemento.prototype, "whenReady", {
            get: function () {
                return this._init;
            },
            enumerable: true,
            configurable: true
        });
        ExtensionMemento.prototype.get = function (key, defaultValue) {
            var value = this._value[key];
            if (typeof value === 'undefined') {
                value = defaultValue;
            }
            return value;
        };
        ExtensionMemento.prototype.update = function (key, value) {
            this._value[key] = value;
            return this._storage
                .setValue(this._shared, this._id, this._value)
                .then(function () { return true; });
        };
        return ExtensionMemento;
    }());
    var ExtHostExtensionService = (function (_super) {
        __extends(ExtHostExtensionService, _super);
        /**
         * This class is constructed manually because it is a service, so it doesn't use any ctor injection
         */
        function ExtHostExtensionService(threadService, telemetryService) {
            _super.call(this, true);
            threadService.registerRemotableInstance(ExtHostExtensionService, this);
            this._threadService = threadService;
            this._storage = new remotable_storage_1.ExtHostStorage(threadService);
            this._proxy = this._threadService.getRemotable(MainProcessExtensionService);
            this._telemetryService = telemetryService;
        }
        ExtHostExtensionService.prototype.$localShowMessage = function (severity, msg) {
            switch (severity) {
                case severity_1.default.Error:
                    console.error(msg);
                    break;
                case severity_1.default.Warning:
                    console.warn(msg);
                    break;
                default:
                    console.log(msg);
            }
        };
        ExtHostExtensionService.prototype.get = function (extensionId) {
            if (!hasOwnProperty.call(this._activatedExtensions, extensionId)) {
                throw new Error('Extension `' + extensionId + '` is not known or not activated');
            }
            return this._activatedExtensions[extensionId].exports;
        };
        ExtHostExtensionService.prototype.deactivate = function (extensionId) {
            var extension = this._activatedExtensions[extensionId];
            if (!extension) {
                return;
            }
            // call deactivate if available
            try {
                if (typeof extension.module.deactivate === 'function') {
                    extension.module.deactivate();
                }
            }
            catch (err) {
            }
            // clean up subscriptions
            try {
                lifecycle_1.disposeAll(extension.subscriptions);
            }
            catch (err) {
            }
        };
        ExtHostExtensionService.prototype.registrationDone = function (messages) {
            this._triggerOnReady();
            this._proxy.$onExtensionHostReady(extensionsRegistry_1.ExtensionsRegistry.getAllExtensionDescriptions(), messages);
        };
        // -- overwriting AbstractExtensionService
        ExtHostExtensionService.prototype._showMessage = function (severity, msg) {
            this._proxy.$localShowMessage(severity, msg);
            this.$localShowMessage(severity, msg);
        };
        ExtHostExtensionService.prototype._createFailedExtension = function () {
            return new ExtHostExtension(true, { activate: undefined, deactivate: undefined }, undefined, []);
        };
        ExtHostExtensionService.prototype._loadExtensionContext = function (extensionDescription) {
            var globalState = new ExtensionMemento(extensionDescription.id, true, this._storage);
            var workspaceState = new ExtensionMemento(extensionDescription.id, false, this._storage);
            return winjs_base_1.TPromise.join([globalState.whenReady, workspaceState.whenReady]).then(function () {
                return Object.freeze({
                    globalState: globalState,
                    workspaceState: workspaceState,
                    subscriptions: [],
                    get extensionPath() { return extensionDescription.extensionFolderPath; },
                    asAbsolutePath: function (relativePath) { return paths.normalize(paths.join(extensionDescription.extensionFolderPath, relativePath), true); }
                });
            });
        };
        ExtHostExtensionService.prototype._actualActivateExtension = function (extensionDescription) {
            var _this = this;
            return this._doActualActivateExtension(extensionDescription).then(function (activatedExtension) {
                _this._proxy.$onExtensionActivated(extensionDescription.id);
                return activatedExtension;
            }, function (err) {
                _this._proxy.$onExtensionActivationFailed(extensionDescription.id);
                throw err;
            });
        };
        ExtHostExtensionService.prototype._doActualActivateExtension = function (extensionDescription) {
            var _this = this;
            var event = getTelemetryActivationEvent(extensionDescription);
            this._telemetryService.publicLog('activatePlugin', event);
            if (!extensionDescription.main) {
                // Treat the extension as being empty => NOT AN ERROR CASE
                return winjs_base_1.TPromise.as(new ExtHostEmptyExtension());
            }
            return loadCommonJSModule(extensionDescription.main).then(function (extensionModule) {
                return _this._loadExtensionContext(extensionDescription).then(function (context) {
                    return ExtHostExtensionService._callActivate(extensionModule, context);
                });
            });
        };
        ExtHostExtensionService._callActivate = function (extensionModule, context) {
            // Make sure the extension's surface is not undefined
            extensionModule = extensionModule || {
                activate: undefined,
                deactivate: undefined
            };
            return this._callActivateOptional(extensionModule, context).then(function (extensionExports) {
                return new ExtHostExtension(false, extensionModule, extensionExports, context.subscriptions);
            });
        };
        ExtHostExtensionService._callActivateOptional = function (extensionModule, context) {
            if (typeof extensionModule.activate === 'function') {
                try {
                    return winjs_base_1.TPromise.as(extensionModule.activate.apply(global, [context]));
                }
                catch (err) {
                    return winjs_base_1.TPromise.wrapError(err);
                }
            }
            else {
                // No activate found => the module is the extension's exports
                return winjs_base_1.TPromise.as(extensionModule);
            }
        };
        // -- called by main thread
        ExtHostExtensionService.prototype.$activateExtension = function (extensionDescription) {
            return this._activateExtension(extensionDescription);
        };
        ExtHostExtensionService = __decorate([
            thread_1.Remotable.ExtHostContext('ExtHostExtensionService')
        ], ExtHostExtensionService);
        return ExtHostExtensionService;
    }(abstractExtensionService_1.AbstractExtensionService));
    exports.ExtHostExtensionService = ExtHostExtensionService;
    function loadCommonJSModule(modulePath) {
        var r = null;
        try {
            r = require.__$__nodeRequire(modulePath);
        }
        catch (e) {
            return winjs_base_1.TPromise.wrapError(e);
        }
        return winjs_base_1.TPromise.as(r);
    }
    function getTelemetryActivationEvent(extensionDescription) {
        var event = {
            id: extensionDescription.id,
            name: extensionDescription.name,
            publisherDisplayName: extensionDescription.publisher,
            activationEvents: extensionDescription.activationEvents ? extensionDescription.activationEvents.join(',') : null
        };
        for (var contribution in extensionDescription.contributes) {
            var contributionDetails = extensionDescription.contributes[contribution];
            if (!contributionDetails) {
                continue;
            }
            switch (contribution) {
                case 'debuggers':
                    var types = contributionDetails.reduce(function (p, c) { return p ? p + ',' + c['type'] : c['type']; }, '');
                    event['contribution.debuggers'] = types;
                    break;
                case 'grammars':
                    var grammers = contributionDetails.reduce(function (p, c) { return p ? p + ',' + c['language'] : c['language']; }, '');
                    event['contribution.grammars'] = grammers;
                    break;
                case 'languages':
                    var languages = contributionDetails.reduce(function (p, c) { return p ? p + ',' + c['id'] : c['id']; }, '');
                    event['contribution.languages'] = languages;
                    break;
                case 'tmSnippets':
                    var tmSnippets = contributionDetails.reduce(function (p, c) { return p ? p + ',' + c['languageId'] : c['languageId']; }, '');
                    event['contribution.tmSnippets'] = tmSnippets;
                    break;
                default:
                    event[("contribution." + contribution)] = true;
            }
        }
        return event;
    }
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/platform/telemetry/common/abstractRemoteTelemetryService", ["require", "exports", 'vs/platform/telemetry/common/abstractTelemetryService', 'vs/platform/telemetry/common/telemetry', 'vs/platform/thread/common/thread'], function (require, exports, AbstractTelemetryService, telemetry_1, thread_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Helper always instantiated in the main process to receive telemetry events from remote telemetry services
     */
    var RemoteTelemetryServiceHelper = (function () {
        function RemoteTelemetryServiceHelper(telemetryService) {
            this._telemetryService = telemetryService;
        }
        RemoteTelemetryServiceHelper.prototype._handleRemoteTelemetryEvent = function (eventName, data) {
            this._telemetryService.publicLog(eventName, data);
        };
        RemoteTelemetryServiceHelper.prototype.getTelemetryInfo = function () {
            return this._telemetryService.getTelemetryInfo();
        };
        RemoteTelemetryServiceHelper = __decorate([
            thread_1.Remotable.MainContext('RemoteTelemetryServiceHelper'),
            __param(0, telemetry_1.ITelemetryService)
        ], RemoteTelemetryServiceHelper);
        return RemoteTelemetryServiceHelper;
    }());
    exports.RemoteTelemetryServiceHelper = RemoteTelemetryServiceHelper;
    /**
     * Base class for remote telemetry services (instantiated in extension host or in web workers)
     */
    var AbstractRemoteTelemetryService = (function (_super) {
        __extends(AbstractRemoteTelemetryService, _super);
        function AbstractRemoteTelemetryService(threadService) {
            // Log all events including public, since they will be forwarded to the main which will do the real filtering
            _super.call(this);
            this._proxy = threadService.getRemotable(RemoteTelemetryServiceHelper);
        }
        AbstractRemoteTelemetryService.prototype.getTelemetryInfo = function () {
            return this._proxy.getTelemetryInfo();
        };
        AbstractRemoteTelemetryService.prototype.addTelemetryAppender = function (appender) {
            throw new Error('Telemetry appenders are not supported in this execution envirnoment');
        };
        AbstractRemoteTelemetryService.prototype.handleEvent = function (eventName, data) {
            this._proxy._handleRemoteTelemetryEvent(eventName, data);
        };
        return AbstractRemoteTelemetryService;
    }(AbstractTelemetryService.AbstractTelemetryService));
    exports.AbstractRemoteTelemetryService = AbstractRemoteTelemetryService;
});

define("vs/platform/thread/common/threadService", ["require", "exports", 'vs/base/common/winjs.base', './thread'], function (require, exports, winjs_base_1, thread) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.THREAD_SERVICE_PROPERTY_NAME = '__$$__threadService';
    function findMember(proto, target) {
        for (var i in proto) {
            if (proto[i] === target) {
                return i;
            }
        }
        throw new Error('Member not found in prototype');
    }
    function findThreadService(obj) {
        var threadService = obj[exports.THREAD_SERVICE_PROPERTY_NAME];
        if (!threadService) {
            throw new Error('Objects that use thread attributes must be instantiated with the thread service');
        }
        return threadService;
    }
    function OneWorkerFn(type, target, conditionOrAffinity, affinity) {
        if (affinity === void 0) { affinity = thread.ThreadAffinity.None; }
        var methodName = findMember(type.prototype, target), condition;
        if (typeof conditionOrAffinity === 'function') {
            condition = conditionOrAffinity;
        }
        else if (typeof conditionOrAffinity !== 'undefined') {
            affinity = conditionOrAffinity;
        }
        type.prototype[methodName] = function () {
            var param = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                param[_i - 0] = arguments[_i];
            }
            if (!condition) {
                return findThreadService(this).OneWorker(this, methodName, target, param, affinity);
            }
            else {
                var that_1 = this, promise = condition.call(that_1);
                if (!winjs_base_1.TPromise.is(promise)) {
                    promise = winjs_base_1.TPromise.as(promise);
                }
                return promise.then(function () {
                    return findThreadService(that_1).OneWorker(that_1, methodName, target, param, affinity);
                });
            }
        };
    }
    exports.OneWorkerAttr = OneWorkerFn;
    function AllWorkersAttr(type, target) {
        var methodName = findMember(type.prototype, target);
        type.prototype[methodName] = function () {
            var param = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                param[_i - 0] = arguments[_i];
            }
            return findThreadService(this).AllWorkers(this, methodName, target, param);
        };
    }
    exports.AllWorkersAttr = AllWorkersAttr;
});

define("vs/platform/thread/common/abstractThreadService", ["require", "exports", 'vs/base/common/winjs.base', 'vs/platform/thread/common/thread', 'vs/platform/thread/common/threadService', 'vs/platform/instantiation/common/descriptors'], function (require, exports, winjs_base_1, thread_1, threadService_1, descriptors_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var AbstractThreadService = (function () {
        function AbstractThreadService(isInMainThread) {
            this.isInMainThread = isInMainThread;
            this._boundObjects = {};
            this._pendingObjects = [];
            this._localObjMap = Object.create(null);
            this._proxyObjMap = Object.create(null);
        }
        AbstractThreadService.prototype.setInstantiationService = function (service) {
            this._instantiationService = service;
        };
        AbstractThreadService.prototype.createInstance = function () {
            var params = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                params[_i - 0] = arguments[_i];
            }
            return this._doCreateInstance(params);
        };
        AbstractThreadService.prototype._doCreateInstance = function (params) {
            var _this = this;
            var instanceOrPromise = this._instantiationService.createInstance.apply(this._instantiationService, params);
            if (winjs_base_1.TPromise.is(instanceOrPromise)) {
                var objInstantiated_1;
                objInstantiated_1 = instanceOrPromise.then(function (instance) {
                    if (instance.asyncCtor) {
                        var initPromise = instance.asyncCtor();
                        if (winjs_base_1.TPromise.is(initPromise)) {
                            return initPromise.then(function () {
                                return instance;
                            });
                        }
                    }
                    return instance;
                });
                this._pendingObjects.push(objInstantiated_1);
                return objInstantiated_1.then(function (instance) {
                    var r = _this._finishInstance(instance);
                    for (var i = 0; i < _this._pendingObjects.length; i++) {
                        if (_this._pendingObjects[i] === objInstantiated_1) {
                            _this._pendingObjects.splice(i, 1);
                            break;
                        }
                    }
                    return r;
                });
            }
            return this._finishInstance(instanceOrPromise);
        };
        AbstractThreadService.prototype._finishInstance = function (instance) {
            instance[threadService_1.THREAD_SERVICE_PROPERTY_NAME] = this;
            this._boundObjects[instance.getId()] = instance;
            if (instance.creationDone) {
                instance.creationDone();
            }
            return instance;
        };
        AbstractThreadService.prototype.handle = function (rpcId, methodName, args) {
            if (!this._localObjMap[rpcId]) {
                throw new Error('Unknown actor ' + rpcId);
            }
            var actor = this._localObjMap[rpcId];
            var method = actor[methodName];
            if (typeof method !== 'function') {
                throw new Error('Unknown method ' + methodName + ' on actor ' + rpcId);
            }
            return method.apply(actor, args);
        };
        AbstractThreadService.prototype._getOrCreateProxyInstance = function (remoteCom, id, descriptor) {
            if (this._proxyObjMap[id]) {
                return this._proxyObjMap[id];
            }
            var result = createProxyFromCtor(remoteCom, id, descriptor.ctor);
            this._proxyObjMap[id] = result;
            return result;
        };
        AbstractThreadService.prototype._registerLocalInstance = function (id, obj) {
            this._localObjMap[id] = obj;
        };
        AbstractThreadService.prototype._getOrCreateLocalInstance = function (id, descriptor) {
            if (this._localObjMap[id]) {
                return this._localObjMap[id];
            }
            var result = this._instantiationService.createInstance(descriptor);
            this._registerLocalInstance(id, result);
            return result;
        };
        AbstractThreadService.prototype.getRemotable = function (ctor) {
            var id = thread_1.Remotable.getId(ctor);
            if (!id) {
                throw new Error('Unknown Remotable: <<' + id + '>>');
            }
            var desc = descriptors_1.createSyncDescriptor(ctor);
            if (thread_1.Remotable.Registry.MainContext[id]) {
                return this._registerAndInstantiateMainProcessActor(id, desc);
            }
            if (thread_1.Remotable.Registry.ExtHostContext[id]) {
                return this._registerAndInstantiateExtHostActor(id, desc);
            }
            if (thread_1.Remotable.Registry.WorkerContext[id]) {
                return this._registerAndInstantiateWorkerActor(id, desc, thread_1.Remotable.Registry.WorkerContext[id].affinity);
            }
            throw new Error('Unknown Remotable: <<' + id + '>>');
        };
        AbstractThreadService.prototype.registerRemotableInstance = function (ctor, instance) {
            var id = thread_1.Remotable.getId(ctor);
            if (!id) {
                throw new Error('Unknown Remotable: <<' + id + '>>');
            }
            if (thread_1.Remotable.Registry.MainContext[id]) {
                return this._registerMainProcessActor(id, instance);
            }
            if (thread_1.Remotable.Registry.ExtHostContext[id]) {
                return this._registerExtHostActor(id, instance);
            }
            if (thread_1.Remotable.Registry.WorkerContext[id]) {
                return this._registerWorkerActor(id, instance);
            }
            throw new Error('Unknown Remotable: <<' + id + '>>');
        };
        return AbstractThreadService;
    }());
    exports.AbstractThreadService = AbstractThreadService;
    function createProxyFromCtor(remote, id, ctor) {
        var result = {
            $__IS_REMOTE_OBJ: true
        };
        for (var prop in ctor.prototype) {
            if (typeof ctor.prototype[prop] === 'function') {
                result[prop] = createMethodProxy(remote, id, prop);
            }
        }
        return result;
    }
    function createMethodProxy(remote, proxyId, path) {
        return function () {
            var myArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                myArgs[_i - 0] = arguments[_i];
            }
            return remote.callOnRemote(proxyId, path, myArgs);
        };
    }
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("vs/platform/thread/common/extHostThreadService", ["require", "exports", 'vs/base/common/winjs.base', './abstractThreadService', 'vs/platform/thread/common/thread'], function (require, exports, winjs_base_1, abstractThreadService, thread_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ExtHostThreadService = (function (_super) {
        __extends(ExtHostThreadService, _super);
        function ExtHostThreadService(remoteCom) {
            _super.call(this, false);
            this.serviceId = thread_1.IThreadService;
            this._remoteCom = remoteCom;
            this._remoteCom.setManyHandler(this);
        }
        ExtHostThreadService.prototype.OneWorker = function (obj, methodName, target, params, affinity) {
            return winjs_base_1.TPromise.as(null);
        };
        ExtHostThreadService.prototype.AllWorkers = function (obj, methodName, target, params) {
            return winjs_base_1.TPromise.as(null);
        };
        ExtHostThreadService.prototype.addStatusListener = function (listener) {
            // Nothing to do
        };
        ExtHostThreadService.prototype.removeStatusListener = function (listener) {
            // Nothing to do
        };
        ExtHostThreadService.prototype._registerAndInstantiateMainProcessActor = function (id, descriptor) {
            return this._getOrCreateProxyInstance(this._remoteCom, id, descriptor);
        };
        ExtHostThreadService.prototype._registerMainProcessActor = function (id, actor) {
            throw new Error('Not supported in this runtime context!');
        };
        ExtHostThreadService.prototype._registerAndInstantiateExtHostActor = function (id, descriptor) {
            return this._getOrCreateLocalInstance(id, descriptor);
        };
        ExtHostThreadService.prototype._registerExtHostActor = function (id, actor) {
            this._registerLocalInstance(id, actor);
        };
        ExtHostThreadService.prototype._registerAndInstantiateWorkerActor = function (id, descriptor, whichWorker) {
            throw new Error('Not supported in this runtime context! Cannot communicate directly from Extension Host to Worker!');
        };
        ExtHostThreadService.prototype._registerWorkerActor = function (id, actor) {
            throw new Error('Not supported in this runtime context!');
        };
        return ExtHostThreadService;
    }(abstractThreadService.AbstractThreadService));
    exports.ExtHostThreadService = ExtHostThreadService;
});

define("vs/platform/workspace/common/workspace", ["require", "exports", 'vs/platform/instantiation/common/instantiation'], function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IWorkspaceContextService = instantiation_1.createDecorator('contextService');
});

define("vs/platform/workspace/common/baseWorkspaceContextService", ["require", "exports", 'vs/base/common/uri', 'vs/base/common/paths', './workspace'], function (require, exports, uri_1, paths, workspace_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Simple IWorkspaceContextService implementation to allow sharing of this service implementation
     * between different layers of the platform.
     */
    var BaseWorkspaceContextService = (function () {
        function BaseWorkspaceContextService(workspace, configuration, options) {
            if (options === void 0) { options = {}; }
            this.serviceId = workspace_1.IWorkspaceContextService;
            this.workspace = workspace;
            this.configuration = configuration;
            this.options = options;
        }
        BaseWorkspaceContextService.prototype.getWorkspace = function () {
            return this.workspace;
        };
        BaseWorkspaceContextService.prototype.getConfiguration = function () {
            return this.configuration;
        };
        BaseWorkspaceContextService.prototype.getOptions = function () {
            return this.options;
        };
        BaseWorkspaceContextService.prototype.isInsideWorkspace = function (resource) {
            if (resource && this.workspace) {
                return paths.isEqualOrParent(resource.fsPath, this.workspace.resource.fsPath);
            }
            return false;
        };
        BaseWorkspaceContextService.prototype.toWorkspaceRelativePath = function (resource) {
            if (this.isInsideWorkspace(resource)) {
                return paths.normalize(paths.relative(this.workspace.resource.fsPath, resource.fsPath));
            }
            return null;
        };
        BaseWorkspaceContextService.prototype.toResource = function (workspaceRelativePath) {
            if (typeof workspaceRelativePath === 'string' && this.workspace) {
                return uri_1.default.file(paths.join(this.workspace.resource.fsPath, workspaceRelativePath));
            }
            return null;
        };
        return BaseWorkspaceContextService;
    }());
    exports.BaseWorkspaceContextService = BaseWorkspaceContextService;
});

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/workbench/api/node/extHostConfiguration", ["require", "exports", 'vs/base/common/objects', 'vs/base/common/lifecycle', 'vs/platform/thread/common/thread', 'vs/platform/configuration/common/configuration', 'vs/base/common/event'], function (require, exports, objects_1, lifecycle_1, thread_1, configuration_1, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ExtHostConfiguration = (function () {
        function ExtHostConfiguration() {
            this._onDidChangeConfiguration = new event_1.Emitter();
        }
        Object.defineProperty(ExtHostConfiguration.prototype, "onDidChangeConfiguration", {
            get: function () {
                return this._onDidChangeConfiguration && this._onDidChangeConfiguration.event;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostConfiguration.prototype._acceptConfigurationChanged = function (config) {
            this._config = config;
            this._hasConfig = true;
            this._onDidChangeConfiguration.fire(undefined);
        };
        ExtHostConfiguration.prototype.getConfiguration = function (section) {
            if (!this._hasConfig) {
                return;
            }
            var config = section
                ? ExtHostConfiguration._lookUp(section, this._config)
                : this._config;
            var result = config ? objects_1.clone(config) : {};
            // result = Object.freeze(result);
            result.has = function (key) {
                return typeof ExtHostConfiguration._lookUp(key, config) !== 'undefined';
            };
            result.get = function (key, defaultValue) {
                var result = ExtHostConfiguration._lookUp(key, config);
                if (typeof result === 'undefined') {
                    result = defaultValue;
                }
                return result;
            };
            return result;
        };
        ExtHostConfiguration._lookUp = function (section, config) {
            if (!section) {
                return;
            }
            var parts = section.split('.');
            var node = config;
            while (node && parts.length) {
                node = node[parts.shift()];
            }
            return node;
        };
        ExtHostConfiguration = __decorate([
            thread_1.Remotable.ExtHostContext('ExtHostConfiguration')
        ], ExtHostConfiguration);
        return ExtHostConfiguration;
    }());
    exports.ExtHostConfiguration = ExtHostConfiguration;
    var MainThreadConfiguration = (function () {
        function MainThreadConfiguration(configurationService, threadService) {
            var _this = this;
            this._configurationService = configurationService;
            this._proxy = threadService.getRemotable(ExtHostConfiguration);
            this._toDispose = [];
            this._toDispose.push(this._configurationService.addListener2(configuration_1.ConfigurationServiceEventTypes.UPDATED, function (e) {
                _this._proxy._acceptConfigurationChanged(e.config);
            }));
            this._configurationService.loadConfiguration().then(function (config) {
                _this._proxy._acceptConfigurationChanged(config);
            });
        }
        MainThreadConfiguration.prototype.dispose = function () {
            this._toDispose = lifecycle_1.disposeAll(this._toDispose);
        };
        MainThreadConfiguration = __decorate([
            thread_1.Remotable.MainContext('MainProcessConfigurationServiceHelper'),
            __param(0, configuration_1.IConfigurationService),
            __param(1, thread_1.IThreadService)
        ], MainThreadConfiguration);
        return MainThreadConfiguration;
    }());
    exports.MainThreadConfiguration = MainThreadConfiguration;
});

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/workbench/api/node/extHostDiagnostics", ["require", "exports", 'vs/platform/thread/common/thread', 'vs/platform/markers/common/markers', 'vs/base/common/uri', 'vs/base/common/severity'], function (require, exports, thread_1, markers_1, uri_1, severity_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var DiagnosticCollection = (function () {
        function DiagnosticCollection(name, proxy) {
            this._name = name;
            this._proxy = proxy;
        }
        DiagnosticCollection.prototype.dispose = function () {
            var _this = this;
            if (!this._isDisposed) {
                this._proxy._changeAll(this.name, undefined).then(function () {
                    _this._proxy = undefined;
                    _this._isDisposed = true;
                });
            }
        };
        Object.defineProperty(DiagnosticCollection.prototype, "name", {
            get: function () {
                this._checkDisposed();
                return this._name;
            },
            enumerable: true,
            configurable: true
        });
        DiagnosticCollection.prototype.set = function (first, diagnostics) {
            this._checkDisposed();
            if (first instanceof uri_1.default) {
                // change markers of resource only (max 500)
                var data = void 0;
                if (diagnostics) {
                    data = [];
                    var len = diagnostics.length;
                    if (len > DiagnosticCollection._maxDiagnosticsPerFile) {
                        console.warn('diagnostics for %s will be capped to %d (actually is %d)', first.toString(), DiagnosticCollection._maxDiagnosticsPerFile, len);
                        len = DiagnosticCollection._maxDiagnosticsPerFile;
                    }
                    for (var i = 0; i < len; i++) {
                        data.push(DiagnosticCollection._toMarkerData(diagnostics[i]));
                    }
                }
                // set or reset for this resource
                return this._proxy._changeOne(this.name, first, data);
            }
            else {
                // change all marker of owner
                var entries = first;
                var data = void 0;
                if (entries) {
                    var total = 0;
                    data = [];
                    for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                        var entry = entries_1[_i];
                        var uri = entry[0], diagnostics_1 = entry[1];
                        if (diagnostics_1) {
                            var len = diagnostics_1.length;
                            if (len > DiagnosticCollection._maxDiagnosticsPerFile) {
                                console.warn('diagnostics for %s will be capped to %d (actually is %d)', uri.toString(), DiagnosticCollection._maxDiagnosticsPerFile, len);
                                len = DiagnosticCollection._maxDiagnosticsPerFile;
                            }
                            for (var i = 0; i < len; i++) {
                                data.push({
                                    resource: uri,
                                    marker: DiagnosticCollection._toMarkerData(diagnostics_1[i])
                                });
                            }
                            total += len;
                            if (total > 10 * DiagnosticCollection._maxDiagnosticsPerFile) {
                                console.warn('too many diagnostics will cap to %d', 10 * DiagnosticCollection._maxDiagnosticsPerFile);
                                break;
                            }
                        }
                    }
                }
                // set or reset all
                this._proxy._changeAll(this.name, data);
            }
        };
        DiagnosticCollection.prototype.delete = function (uri) {
            return this.set(uri, undefined);
        };
        DiagnosticCollection.prototype.clear = function () {
            return this.set(undefined);
        };
        DiagnosticCollection.prototype._checkDisposed = function () {
            if (this._isDisposed) {
                throw new Error('illegal state - object is disposed');
            }
        };
        DiagnosticCollection._toMarkerData = function (diagnostic) {
            var range = diagnostic.range;
            return {
                startLineNumber: range.start.line + 1,
                startColumn: range.start.character + 1,
                endLineNumber: range.end.line + 1,
                endColumn: range.end.character + 1,
                message: diagnostic.message,
                source: diagnostic.source,
                severity: DiagnosticCollection._convertDiagnosticsSeverity(diagnostic.severity),
                code: String(diagnostic.code)
            };
        };
        DiagnosticCollection._convertDiagnosticsSeverity = function (severity) {
            switch (severity) {
                case 0: return severity_1.default.Error;
                case 1: return severity_1.default.Warning;
                case 2: return severity_1.default.Info;
                case 3: return severity_1.default.Ignore;
                default: return severity_1.default.Error;
            }
        };
        DiagnosticCollection._maxDiagnosticsPerFile = 250;
        return DiagnosticCollection;
    }());
    var ExtHostDiagnostics = (function () {
        function ExtHostDiagnostics(threadService) {
            this._proxy = threadService.getRemotable(MainThreadDiagnostics);
        }
        ExtHostDiagnostics.prototype.createDiagnosticCollection = function (name) {
            if (!name) {
                name = '_generated_diagnostic_collection_name_#' + ExtHostDiagnostics._idPool++;
            }
            return new DiagnosticCollection(name, this._proxy);
        };
        ExtHostDiagnostics._idPool = 0;
        return ExtHostDiagnostics;
    }());
    exports.ExtHostDiagnostics = ExtHostDiagnostics;
    var MainThreadDiagnostics = (function () {
        function MainThreadDiagnostics(markerService) {
            this._markerService = markerService;
        }
        MainThreadDiagnostics.prototype._changeOne = function (owner, resource, markers) {
            this._markerService.changeOne(owner, resource, markers);
            return undefined;
        };
        MainThreadDiagnostics.prototype._changeAll = function (owner, data) {
            this._markerService.changeAll(owner, data);
            return undefined;
        };
        MainThreadDiagnostics = __decorate([
            thread_1.Remotable.MainContext('MainThreadDiagnostics'),
            __param(0, markers_1.IMarkerService)
        ], MainThreadDiagnostics);
        return MainThreadDiagnostics;
    }());
    exports.MainThreadDiagnostics = MainThreadDiagnostics;
});

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/workbench/api/node/extHostLanguages", ["require", "exports", 'vs/base/common/winjs.base', 'vs/platform/thread/common/thread', 'vs/editor/common/services/modeService'], function (require, exports, winjs_base_1, thread_1, modeService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ExtHostLanguages = (function () {
        function ExtHostLanguages(threadService) {
            this._proxy = threadService.getRemotable(MainThreadLanguages);
        }
        ExtHostLanguages.prototype.getLanguages = function () {
            return this._proxy._getLanguages();
        };
        ExtHostLanguages = __decorate([
            __param(0, thread_1.IThreadService)
        ], ExtHostLanguages);
        return ExtHostLanguages;
    }());
    exports.ExtHostLanguages = ExtHostLanguages;
    var MainThreadLanguages = (function () {
        function MainThreadLanguages(modeService) {
            this._modeService = modeService;
        }
        MainThreadLanguages.prototype._getLanguages = function () {
            return winjs_base_1.TPromise.as(this._modeService.getRegisteredModes());
        };
        MainThreadLanguages = __decorate([
            thread_1.Remotable.MainContext('MainThreadLanguages'),
            __param(0, modeService_1.IModeService)
        ], MainThreadLanguages);
        return MainThreadLanguages;
    }());
    exports.MainThreadLanguages = MainThreadLanguages;
});

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/workbench/api/node/extHostMessageService", ["require", "exports", 'vs/nls!vs/workbench/api/node/extHostMessageService', 'vs/platform/thread/common/thread', 'vs/platform/message/common/message', 'vs/base/common/actions', 'vs/base/common/winjs.base'], function (require, exports, nls, thread_1, message_1, actions_1, winjs_base_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ExtHostMessageService = (function () {
        function ExtHostMessageService(threadService, commands) {
            this._proxy = threadService.getRemotable(MainThreadMessageService);
            this._commands = commands;
        }
        ExtHostMessageService.prototype.showMessage = function (severity, message, commands) {
            var items = [];
            for (var handle = 0; handle < commands.length; handle++) {
                var command = commands[handle];
                if (typeof command === 'string') {
                    items.push({ title: command, handle: handle });
                }
                else {
                    items.push({ title: command.title, handle: handle });
                }
            }
            return this._proxy.showMessage(severity, message, items).then(function (handle) {
                if (typeof handle === 'number') {
                    return commands[handle];
                }
            });
        };
        ExtHostMessageService = __decorate([
            __param(0, thread_1.IThreadService)
        ], ExtHostMessageService);
        return ExtHostMessageService;
    }());
    exports.ExtHostMessageService = ExtHostMessageService;
    var MainThreadMessageService = (function () {
        function MainThreadMessageService(messageService) {
            this._messageService = messageService;
        }
        MainThreadMessageService.prototype.showMessage = function (severity, message, commands) {
            var _this = this;
            var hide;
            var actions = [];
            actions.push(new actions_1.Action('__close', nls.localize(0, null), undefined, true, function () {
                hide();
                return winjs_base_1.TPromise.as(undefined);
            }));
            commands.forEach(function (command) {
                actions.push(new actions_1.Action('_extension_message_handle_' + command.handle, command.title, undefined, true, function () {
                    hide(command.handle);
                    return winjs_base_1.TPromise.as(undefined);
                }));
            });
            return new winjs_base_1.TPromise(function (c) {
                var messageHide;
                hide = function (handle) {
                    messageHide();
                    c(handle);
                };
                messageHide = _this._messageService.show(severity, {
                    message: message,
                    actions: actions
                });
            });
        };
        MainThreadMessageService = __decorate([
            thread_1.Remotable.MainContext('MainThreadMessageService'),
            __param(0, message_1.IMessageService)
        ], MainThreadMessageService);
        return MainThreadMessageService;
    }());
    exports.MainThreadMessageService = MainThreadMessageService;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("vs/workbench/api/node/extHostTelemetry", ["require", "exports", 'vs/platform/telemetry/common/abstractRemoteTelemetryService'], function (require, exports, abstractRemoteTelemetryService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ExtHostTelemetryService = (function (_super) {
        __extends(ExtHostTelemetryService, _super);
        function ExtHostTelemetryService() {
            _super.apply(this, arguments);
        }
        ExtHostTelemetryService.prototype.handleEvent = function (eventName, data) {
            data = data || {};
            data['pluginHostTelemetry'] = true;
            _super.prototype.handleEvent.call(this, eventName, data);
        };
        return ExtHostTelemetryService;
    }(abstractRemoteTelemetryService_1.AbstractRemoteTelemetryService));
    exports.ExtHostTelemetryService = ExtHostTelemetryService;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("vs/workbench/api/node/extHostTypes", ["require", "exports", 'vs/base/common/uri', 'vs/base/common/errors'], function (require, exports, uri_1, errors_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Disposable = (function () {
        function Disposable(callOnDispose) {
            this._callOnDispose = callOnDispose;
        }
        Disposable.from = function () {
            var disposables = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                disposables[_i - 0] = arguments[_i];
            }
            return new Disposable(function () {
                if (disposables) {
                    for (var _i = 0, disposables_1 = disposables; _i < disposables_1.length; _i++) {
                        var disposable = disposables_1[_i];
                        if (disposable && typeof disposable.dispose === 'function') {
                            disposable.dispose();
                        }
                    }
                    disposables = undefined;
                }
            });
        };
        Disposable.prototype.dispose = function () {
            if (typeof this._callOnDispose === 'function') {
                this._callOnDispose();
                this._callOnDispose = undefined;
            }
        };
        return Disposable;
    }());
    exports.Disposable = Disposable;
    var Position = (function () {
        function Position(line, character) {
            if (line < 0) {
                throw errors_1.illegalArgument('line must be positive');
            }
            if (character < 0) {
                throw errors_1.illegalArgument('character must be positive');
            }
            this._line = line;
            this._character = character;
        }
        Position.Min = function () {
            var positions = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                positions[_i - 0] = arguments[_i];
            }
            var result = positions.pop();
            for (var _a = 0, positions_1 = positions; _a < positions_1.length; _a++) {
                var p = positions_1[_a];
                if (p.isBefore(result)) {
                    result = p;
                }
            }
            return result;
        };
        Position.Max = function () {
            var positions = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                positions[_i - 0] = arguments[_i];
            }
            var result = positions.pop();
            for (var _a = 0, positions_2 = positions; _a < positions_2.length; _a++) {
                var p = positions_2[_a];
                if (p.isAfter(result)) {
                    result = p;
                }
            }
            return result;
        };
        Object.defineProperty(Position.prototype, "line", {
            get: function () {
                return this._line;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Position.prototype, "character", {
            get: function () {
                return this._character;
            },
            enumerable: true,
            configurable: true
        });
        Position.prototype.isBefore = function (other) {
            if (this._line < other._line) {
                return true;
            }
            if (other._line < this._line) {
                return false;
            }
            return this._character < other._character;
        };
        Position.prototype.isBeforeOrEqual = function (other) {
            if (this._line < other._line) {
                return true;
            }
            if (other._line < this._line) {
                return false;
            }
            return this._character <= other._character;
        };
        Position.prototype.isAfter = function (other) {
            return !this.isBeforeOrEqual(other);
        };
        Position.prototype.isAfterOrEqual = function (other) {
            return !this.isBefore(other);
        };
        Position.prototype.isEqual = function (other) {
            return this._line === other._line && this._character === other._character;
        };
        Position.prototype.compareTo = function (other) {
            if (this._line < other._line) {
                return -1;
            }
            else if (this._line > other.line) {
                return 1;
            }
            else {
                // equal line
                if (this._character < other._character) {
                    return -1;
                }
                else if (this._character > other._character) {
                    return 1;
                }
                else {
                    // equal line and character
                    return 0;
                }
            }
        };
        Position.prototype.translate = function (lineDelta, characterDelta) {
            if (lineDelta === void 0) { lineDelta = 0; }
            if (characterDelta === void 0) { characterDelta = 0; }
            if (lineDelta === 0 && characterDelta === 0) {
                return this;
            }
            return new Position(this.line + lineDelta, this.character + characterDelta);
        };
        Position.prototype.with = function (line, character) {
            if (line === void 0) { line = this.line; }
            if (character === void 0) { character = this.character; }
            if (line === this.line && character === this.character) {
                return this;
            }
            return new Position(line, character);
        };
        Position.prototype.toJSON = function () {
            return { line: this.line, character: this.character };
        };
        return Position;
    }());
    exports.Position = Position;
    var Range = (function () {
        function Range(startLineOrStart, startColumnOrEnd, endLine, endColumn) {
            var start;
            var end;
            if (typeof startLineOrStart === 'number' && typeof startColumnOrEnd === 'number' && typeof endLine === 'number' && typeof endColumn === 'number') {
                start = new Position(startLineOrStart, startColumnOrEnd);
                end = new Position(endLine, endColumn);
            }
            else if (startLineOrStart instanceof Position && startColumnOrEnd instanceof Position) {
                start = startLineOrStart;
                end = startColumnOrEnd;
            }
            if (!start || !end) {
                throw new Error('Invalid arguments');
            }
            if (start.isBefore(end)) {
                this._start = start;
                this._end = end;
            }
            else {
                this._start = end;
                this._end = start;
            }
        }
        Object.defineProperty(Range.prototype, "start", {
            get: function () {
                return this._start;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Range.prototype, "end", {
            get: function () {
                return this._end;
            },
            enumerable: true,
            configurable: true
        });
        Range.prototype.contains = function (positionOrRange) {
            if (positionOrRange instanceof Range) {
                return this.contains(positionOrRange._start)
                    && this.contains(positionOrRange._end);
            }
            else if (positionOrRange instanceof Position) {
                if (positionOrRange.isBefore(this._start)) {
                    return false;
                }
                if (this._end.isBefore(positionOrRange)) {
                    return false;
                }
                return true;
            }
            return false;
        };
        Range.prototype.isEqual = function (other) {
            return this._start.isEqual(other._start) && this._end.isEqual(other._end);
        };
        Range.prototype.intersection = function (other) {
            var start = Position.Max(other.start, this._start);
            var end = Position.Min(other.end, this._end);
            if (start.isAfter(end)) {
                // this happens when there is no overlap:
                // |-----|
                //          |----|
                return;
            }
            return new Range(start, end);
        };
        Range.prototype.union = function (other) {
            if (this.contains(other)) {
                return this;
            }
            else if (other.contains(this)) {
                return other;
            }
            var start = Position.Min(other.start, this._start);
            var end = Position.Max(other.end, this.end);
            return new Range(start, end);
        };
        Object.defineProperty(Range.prototype, "isEmpty", {
            get: function () {
                return this._start.isEqual(this._end);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Range.prototype, "isSingleLine", {
            get: function () {
                return this._start.line === this._end.line;
            },
            enumerable: true,
            configurable: true
        });
        Range.prototype.with = function (start, end) {
            if (start === void 0) { start = this.start; }
            if (end === void 0) { end = this.end; }
            if (start.isEqual(this._start) && end.isEqual(this.end)) {
                return this;
            }
            return new Range(start, end);
        };
        Range.prototype.toJSON = function () {
            return [this.start, this.end];
        };
        return Range;
    }());
    exports.Range = Range;
    var Selection = (function (_super) {
        __extends(Selection, _super);
        function Selection(anchorLineOrAnchor, anchorColumnOrActive, activeLine, activeColumn) {
            var anchor;
            var active;
            if (typeof anchorLineOrAnchor === 'number' && typeof anchorColumnOrActive === 'number' && typeof activeLine === 'number' && typeof activeColumn === 'number') {
                anchor = new Position(anchorLineOrAnchor, anchorColumnOrActive);
                active = new Position(activeLine, activeColumn);
            }
            else if (anchorLineOrAnchor instanceof Position && anchorColumnOrActive instanceof Position) {
                anchor = anchorLineOrAnchor;
                active = anchorColumnOrActive;
            }
            if (!anchor || !active) {
                throw new Error('Invalid arguments');
            }
            _super.call(this, anchor, active);
            this._anchor = anchor;
            this._active = active;
        }
        Object.defineProperty(Selection.prototype, "anchor", {
            get: function () {
                return this._anchor;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Selection.prototype, "active", {
            get: function () {
                return this._active;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Selection.prototype, "isReversed", {
            get: function () {
                return this._anchor === this._end;
            },
            enumerable: true,
            configurable: true
        });
        Selection.prototype.toJSON = function () {
            return {
                start: this.start,
                end: this.end,
                active: this.active,
                anchor: this.anchor
            };
        };
        return Selection;
    }(Range));
    exports.Selection = Selection;
    var TextEdit = (function () {
        function TextEdit(range, newText) {
            this.range = range;
            this.newText = newText;
        }
        TextEdit.replace = function (range, newText) {
            return new TextEdit(range, newText);
        };
        TextEdit.insert = function (position, newText) {
            return TextEdit.replace(new Range(position, position), newText);
        };
        TextEdit.delete = function (range) {
            return TextEdit.replace(range, '');
        };
        Object.defineProperty(TextEdit.prototype, "range", {
            get: function () {
                return this._range;
            },
            set: function (value) {
                if (!value) {
                    throw errors_1.illegalArgument('range');
                }
                this._range = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextEdit.prototype, "newText", {
            get: function () {
                return this._newText || '';
            },
            set: function (value) {
                this._newText = value;
            },
            enumerable: true,
            configurable: true
        });
        TextEdit.prototype.toJSON = function () {
            return {
                range: this.range,
                newText: this.newText
            };
        };
        return TextEdit;
    }());
    exports.TextEdit = TextEdit;
    var Uri = (function (_super) {
        __extends(Uri, _super);
        function Uri() {
            _super.apply(this, arguments);
        }
        return Uri;
    }(uri_1.default));
    exports.Uri = Uri;
    var WorkspaceEdit = (function () {
        function WorkspaceEdit() {
            this._values = [];
            this._index = Object.create(null);
        }
        WorkspaceEdit.prototype.replace = function (uri, range, newText) {
            var edit = new TextEdit(range, newText);
            var array = this.get(uri);
            if (array) {
                array.push(edit);
            }
            else {
                this.set(uri, [edit]);
            }
        };
        WorkspaceEdit.prototype.insert = function (resource, position, newText) {
            this.replace(resource, new Range(position, position), newText);
        };
        WorkspaceEdit.prototype.delete = function (resource, range) {
            this.replace(resource, range, '');
        };
        WorkspaceEdit.prototype.has = function (uri) {
            return typeof this._index[uri.toString()] !== 'undefined';
        };
        WorkspaceEdit.prototype.set = function (uri, edits) {
            var idx = this._index[uri.toString()];
            if (typeof idx === 'undefined') {
                var newLen = this._values.push([uri, edits]);
                this._index[uri.toString()] = newLen - 1;
            }
            else {
                this._values[idx][1] = edits;
            }
        };
        WorkspaceEdit.prototype.get = function (uri) {
            var idx = this._index[uri.toString()];
            return typeof idx !== 'undefined' && this._values[idx][1];
        };
        WorkspaceEdit.prototype.entries = function () {
            return this._values;
        };
        Object.defineProperty(WorkspaceEdit.prototype, "size", {
            get: function () {
                return this._values.length;
            },
            enumerable: true,
            configurable: true
        });
        WorkspaceEdit.prototype.toJSON = function () {
            return this._values;
        };
        return WorkspaceEdit;
    }());
    exports.WorkspaceEdit = WorkspaceEdit;
    (function (DiagnosticSeverity) {
        DiagnosticSeverity[DiagnosticSeverity["Hint"] = 3] = "Hint";
        DiagnosticSeverity[DiagnosticSeverity["Information"] = 2] = "Information";
        DiagnosticSeverity[DiagnosticSeverity["Warning"] = 1] = "Warning";
        DiagnosticSeverity[DiagnosticSeverity["Error"] = 0] = "Error";
    })(exports.DiagnosticSeverity || (exports.DiagnosticSeverity = {}));
    var DiagnosticSeverity = exports.DiagnosticSeverity;
    var Location = (function () {
        function Location(uri, range) {
            this.uri = uri;
            if (range instanceof Range) {
                this.range = range;
            }
            else if (range instanceof Position) {
                this.range = new Range(range, range);
            }
            else {
                throw new Error('Illegal argument');
            }
        }
        Location.prototype.toJSON = function () {
            return {
                uri: this.uri,
                range: this.range
            };
        };
        return Location;
    }());
    exports.Location = Location;
    var Diagnostic = (function () {
        function Diagnostic(range, message, severity) {
            if (severity === void 0) { severity = DiagnosticSeverity.Error; }
            this.range = range;
            this.message = message;
            this.severity = severity;
        }
        Diagnostic.prototype.toJSON = function () {
            return {
                severity: DiagnosticSeverity[this.severity],
                message: this.message,
                range: this.range,
                source: this.source,
                code: this.code,
            };
        };
        return Diagnostic;
    }());
    exports.Diagnostic = Diagnostic;
    var Hover = (function () {
        function Hover(contents, range) {
            if (!contents) {
                throw new Error('Illegal argument');
            }
            if (Array.isArray(contents)) {
                this.contents = contents;
            }
            else {
                this.contents = [contents];
            }
            this.range = range;
        }
        return Hover;
    }());
    exports.Hover = Hover;
    (function (DocumentHighlightKind) {
        DocumentHighlightKind[DocumentHighlightKind["Text"] = 0] = "Text";
        DocumentHighlightKind[DocumentHighlightKind["Read"] = 1] = "Read";
        DocumentHighlightKind[DocumentHighlightKind["Write"] = 2] = "Write";
    })(exports.DocumentHighlightKind || (exports.DocumentHighlightKind = {}));
    var DocumentHighlightKind = exports.DocumentHighlightKind;
    var DocumentHighlight = (function () {
        function DocumentHighlight(range, kind) {
            if (kind === void 0) { kind = DocumentHighlightKind.Text; }
            this.range = range;
            this.kind = kind;
        }
        DocumentHighlight.prototype.toJSON = function () {
            return {
                range: this.range,
                kind: DocumentHighlightKind[this.kind]
            };
        };
        return DocumentHighlight;
    }());
    exports.DocumentHighlight = DocumentHighlight;
    (function (SymbolKind) {
        SymbolKind[SymbolKind["File"] = 0] = "File";
        SymbolKind[SymbolKind["Module"] = 1] = "Module";
        SymbolKind[SymbolKind["Namespace"] = 2] = "Namespace";
        SymbolKind[SymbolKind["Package"] = 3] = "Package";
        SymbolKind[SymbolKind["Class"] = 4] = "Class";
        SymbolKind[SymbolKind["Method"] = 5] = "Method";
        SymbolKind[SymbolKind["Property"] = 6] = "Property";
        SymbolKind[SymbolKind["Field"] = 7] = "Field";
        SymbolKind[SymbolKind["Constructor"] = 8] = "Constructor";
        SymbolKind[SymbolKind["Enum"] = 9] = "Enum";
        SymbolKind[SymbolKind["Interface"] = 10] = "Interface";
        SymbolKind[SymbolKind["Function"] = 11] = "Function";
        SymbolKind[SymbolKind["Variable"] = 12] = "Variable";
        SymbolKind[SymbolKind["Constant"] = 13] = "Constant";
        SymbolKind[SymbolKind["String"] = 14] = "String";
        SymbolKind[SymbolKind["Number"] = 15] = "Number";
        SymbolKind[SymbolKind["Boolean"] = 16] = "Boolean";
        SymbolKind[SymbolKind["Array"] = 17] = "Array";
        SymbolKind[SymbolKind["Object"] = 18] = "Object";
        SymbolKind[SymbolKind["Key"] = 19] = "Key";
        SymbolKind[SymbolKind["Null"] = 20] = "Null";
    })(exports.SymbolKind || (exports.SymbolKind = {}));
    var SymbolKind = exports.SymbolKind;
    var SymbolInformation = (function () {
        function SymbolInformation(name, kind, range, uri, containerName) {
            this.name = name;
            this.kind = kind;
            this.location = new Location(uri, range);
            this.containerName = containerName;
        }
        SymbolInformation.prototype.toJSON = function () {
            return {
                name: this.name,
                kind: SymbolKind[this.kind],
                location: this.location,
                containerName: this.containerName
            };
        };
        return SymbolInformation;
    }());
    exports.SymbolInformation = SymbolInformation;
    var CodeLens = (function () {
        function CodeLens(range, command) {
            this.range = range;
            this.command = command;
        }
        Object.defineProperty(CodeLens.prototype, "isResolved", {
            get: function () {
                return !!this.command;
            },
            enumerable: true,
            configurable: true
        });
        return CodeLens;
    }());
    exports.CodeLens = CodeLens;
    var ParameterInformation = (function () {
        function ParameterInformation(label, documentation) {
            this.label = label;
            this.documentation = documentation;
        }
        return ParameterInformation;
    }());
    exports.ParameterInformation = ParameterInformation;
    var SignatureInformation = (function () {
        function SignatureInformation(label, documentation) {
            this.label = label;
            this.documentation = documentation;
            this.parameters = [];
        }
        return SignatureInformation;
    }());
    exports.SignatureInformation = SignatureInformation;
    var SignatureHelp = (function () {
        function SignatureHelp() {
            this.signatures = [];
        }
        return SignatureHelp;
    }());
    exports.SignatureHelp = SignatureHelp;
    (function (CompletionItemKind) {
        CompletionItemKind[CompletionItemKind["Text"] = 0] = "Text";
        CompletionItemKind[CompletionItemKind["Method"] = 1] = "Method";
        CompletionItemKind[CompletionItemKind["Function"] = 2] = "Function";
        CompletionItemKind[CompletionItemKind["Constructor"] = 3] = "Constructor";
        CompletionItemKind[CompletionItemKind["Field"] = 4] = "Field";
        CompletionItemKind[CompletionItemKind["Variable"] = 5] = "Variable";
        CompletionItemKind[CompletionItemKind["Class"] = 6] = "Class";
        CompletionItemKind[CompletionItemKind["Interface"] = 7] = "Interface";
        CompletionItemKind[CompletionItemKind["Module"] = 8] = "Module";
        CompletionItemKind[CompletionItemKind["Property"] = 9] = "Property";
        CompletionItemKind[CompletionItemKind["Unit"] = 10] = "Unit";
        CompletionItemKind[CompletionItemKind["Value"] = 11] = "Value";
        CompletionItemKind[CompletionItemKind["Enum"] = 12] = "Enum";
        CompletionItemKind[CompletionItemKind["Keyword"] = 13] = "Keyword";
        CompletionItemKind[CompletionItemKind["Snippet"] = 14] = "Snippet";
        CompletionItemKind[CompletionItemKind["Color"] = 15] = "Color";
        CompletionItemKind[CompletionItemKind["File"] = 16] = "File";
        CompletionItemKind[CompletionItemKind["Reference"] = 17] = "Reference";
    })(exports.CompletionItemKind || (exports.CompletionItemKind = {}));
    var CompletionItemKind = exports.CompletionItemKind;
    var CompletionItem = (function () {
        function CompletionItem(label) {
            this.label = label;
        }
        CompletionItem.prototype.toJSON = function () {
            return {
                label: this.label,
                kind: CompletionItemKind[this.kind],
                detail: this.detail,
                documentation: this.documentation,
                sortText: this.sortText,
                filterText: this.filterText,
                insertText: this.insertText,
                textEdit: this.textEdit
            };
        };
        return CompletionItem;
    }());
    exports.CompletionItem = CompletionItem;
    var CompletionList = (function () {
        function CompletionList(items, isIncomplete) {
            if (items === void 0) { items = []; }
            if (isIncomplete === void 0) { isIncomplete = false; }
            this.items = items;
            this.isIncomplete = isIncomplete;
        }
        return CompletionList;
    }());
    exports.CompletionList = CompletionList;
    (function (ViewColumn) {
        ViewColumn[ViewColumn["One"] = 1] = "One";
        ViewColumn[ViewColumn["Two"] = 2] = "Two";
        ViewColumn[ViewColumn["Three"] = 3] = "Three";
    })(exports.ViewColumn || (exports.ViewColumn = {}));
    var ViewColumn = exports.ViewColumn;
    (function (StatusBarAlignment) {
        StatusBarAlignment[StatusBarAlignment["Left"] = 1] = "Left";
        StatusBarAlignment[StatusBarAlignment["Right"] = 2] = "Right";
    })(exports.StatusBarAlignment || (exports.StatusBarAlignment = {}));
    var StatusBarAlignment = exports.StatusBarAlignment;
    (function (EndOfLine) {
        EndOfLine[EndOfLine["LF"] = 1] = "LF";
        EndOfLine[EndOfLine["CRLF"] = 2] = "CRLF";
    })(exports.EndOfLine || (exports.EndOfLine = {}));
    var EndOfLine = exports.EndOfLine;
});

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/workbench/api/node/extHostFileSystemEventService", ["require", "exports", 'vs/platform/files/common/files', 'vs/platform/thread/common/thread', 'vs/base/common/event', './extHostTypes', 'vs/platform/event/common/event', 'vs/base/common/async', 'vs/base/common/glob'], function (require, exports, files_1, thread_1, event_1, extHostTypes_1, event_2, async_1, glob_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var FileSystemWatcher = (function () {
        function FileSystemWatcher(dispatcher, globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
            var _this = this;
            this._onDidCreate = new event_1.Emitter();
            this._onDidChange = new event_1.Emitter();
            this._onDidDelete = new event_1.Emitter();
            this._config = 0;
            if (!ignoreCreateEvents) {
                this._config += 1;
            }
            if (!ignoreChangeEvents) {
                this._config += 2;
            }
            if (!ignoreDeleteEvents) {
                this._config += 4;
            }
            var subscription = dispatcher(function (events) {
                if (!ignoreCreateEvents) {
                    for (var _i = 0, _a = events.created; _i < _a.length; _i++) {
                        var created = _a[_i];
                        if (glob_1.match(globPattern, created.fsPath)) {
                            _this._onDidCreate.fire(created);
                        }
                    }
                }
                if (!ignoreChangeEvents) {
                    for (var _b = 0, _c = events.changed; _b < _c.length; _b++) {
                        var changed = _c[_b];
                        if (glob_1.match(globPattern, changed.fsPath)) {
                            _this._onDidChange.fire(changed);
                        }
                    }
                }
                if (!ignoreDeleteEvents) {
                    for (var _d = 0, _e = events.deleted; _d < _e.length; _d++) {
                        var deleted = _e[_d];
                        if (glob_1.match(globPattern, deleted.fsPath)) {
                            _this._onDidDelete.fire(deleted);
                        }
                    }
                }
            });
            this._disposable = extHostTypes_1.Disposable.from(this._onDidCreate, this._onDidChange, this._onDidDelete, subscription);
        }
        Object.defineProperty(FileSystemWatcher.prototype, "ignoreCreateEvents", {
            get: function () {
                return Boolean(this._config & 1);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileSystemWatcher.prototype, "ignoreChangeEvents", {
            get: function () {
                return Boolean(this._config & 2);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileSystemWatcher.prototype, "ignoreDeleteEvents", {
            get: function () {
                return Boolean(this._config & 4);
            },
            enumerable: true,
            configurable: true
        });
        FileSystemWatcher.prototype.dispose = function () {
            this._disposable.dispose();
        };
        Object.defineProperty(FileSystemWatcher.prototype, "onDidCreate", {
            get: function () {
                return this._onDidCreate.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileSystemWatcher.prototype, "onDidChange", {
            get: function () {
                return this._onDidChange.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileSystemWatcher.prototype, "onDidDelete", {
            get: function () {
                return this._onDidDelete.event;
            },
            enumerable: true,
            configurable: true
        });
        return FileSystemWatcher;
    }());
    exports.FileSystemWatcher = FileSystemWatcher;
    var ExtHostFileSystemEventService = (function () {
        function ExtHostFileSystemEventService() {
            this._emitter = new event_1.Emitter();
        }
        ExtHostFileSystemEventService.prototype.createFileSystemWatcher = function (globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
            return new FileSystemWatcher(this._emitter.event, globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents);
        };
        ExtHostFileSystemEventService.prototype._onFileEvent = function (events) {
            this._emitter.fire(events);
        };
        ExtHostFileSystemEventService = __decorate([
            thread_1.Remotable.ExtHostContext('ExtHostFileSystemEventService')
        ], ExtHostFileSystemEventService);
        return ExtHostFileSystemEventService;
    }());
    exports.ExtHostFileSystemEventService = ExtHostFileSystemEventService;
    var MainThreadFileSystemEventService = (function () {
        function MainThreadFileSystemEventService(eventService, threadService) {
            var proxy = threadService.getRemotable(ExtHostFileSystemEventService);
            var events = {
                created: [],
                changed: [],
                deleted: []
            };
            var scheduler = new async_1.RunOnceScheduler(function () {
                proxy._onFileEvent(events);
                events.created.length = 0;
                events.changed.length = 0;
                events.deleted.length = 0;
            }, 100);
            eventService.addListener('files:fileChanges', function (event) {
                for (var _i = 0, _a = event.changes; _i < _a.length; _i++) {
                    var change = _a[_i];
                    switch (change.type) {
                        case files_1.FileChangeType.ADDED:
                            events.created.push(change.resource);
                            break;
                        case files_1.FileChangeType.UPDATED:
                            events.changed.push(change.resource);
                            break;
                        case files_1.FileChangeType.DELETED:
                            events.deleted.push(change.resource);
                            break;
                    }
                }
                scheduler.schedule();
            });
        }
        MainThreadFileSystemEventService = __decorate([
            __param(0, event_2.IEventService),
            __param(1, thread_1.IThreadService)
        ], MainThreadFileSystemEventService);
        return MainThreadFileSystemEventService;
    }());
    exports.MainThreadFileSystemEventService = MainThreadFileSystemEventService;
});

define("vs/workbench/api/node/extHostTypeConverters", ["require", "exports", 'vs/base/common/severity', 'vs/base/common/arrays', './extHostTypes', 'vs/platform/editor/common/editor'], function (require, exports, severity_1, arrays_1, types, editor_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function toSelection(selection) {
        var selectionStartLineNumber = selection.selectionStartLineNumber, selectionStartColumn = selection.selectionStartColumn, positionLineNumber = selection.positionLineNumber, positionColumn = selection.positionColumn;
        var start = new types.Position(selectionStartLineNumber - 1, selectionStartColumn - 1);
        var end = new types.Position(positionLineNumber - 1, positionColumn - 1);
        return new types.Selection(start, end);
    }
    exports.toSelection = toSelection;
    function fromSelection(selection) {
        var anchor = selection.anchor, active = selection.active;
        return {
            selectionStartLineNumber: anchor.line + 1,
            selectionStartColumn: anchor.character + 1,
            positionLineNumber: active.line + 1,
            positionColumn: active.character + 1
        };
    }
    exports.fromSelection = fromSelection;
    function fromRange(range) {
        var start = range.start, end = range.end;
        return {
            startLineNumber: start.line + 1,
            startColumn: start.character + 1,
            endLineNumber: end.line + 1,
            endColumn: end.character + 1
        };
    }
    exports.fromRange = fromRange;
    function toRange(range) {
        var startLineNumber = range.startLineNumber, startColumn = range.startColumn, endLineNumber = range.endLineNumber, endColumn = range.endColumn;
        return new types.Range(startLineNumber - 1, startColumn - 1, endLineNumber - 1, endColumn - 1);
    }
    exports.toRange = toRange;
    function toPosition(position) {
        return new types.Position(position.lineNumber - 1, position.column - 1);
    }
    exports.toPosition = toPosition;
    function fromPosition(position) {
        return { lineNumber: position.line + 1, column: position.character + 1 };
    }
    exports.fromPosition = fromPosition;
    function fromDiagnosticSeverity(value) {
        switch (value) {
            case types.DiagnosticSeverity.Error:
                return severity_1.default.Error;
            case types.DiagnosticSeverity.Warning:
                return severity_1.default.Warning;
            case types.DiagnosticSeverity.Information:
                return severity_1.default.Info;
            case types.DiagnosticSeverity.Hint:
                return severity_1.default.Ignore;
        }
        return severity_1.default.Error;
    }
    exports.fromDiagnosticSeverity = fromDiagnosticSeverity;
    function toDiagnosticSeverty(value) {
        switch (value) {
            case severity_1.default.Info:
                return types.DiagnosticSeverity.Information;
            case severity_1.default.Warning:
                return types.DiagnosticSeverity.Warning;
            case severity_1.default.Error:
                return types.DiagnosticSeverity.Error;
            case severity_1.default.Ignore:
                return types.DiagnosticSeverity.Hint;
        }
        return types.DiagnosticSeverity.Error;
    }
    exports.toDiagnosticSeverty = toDiagnosticSeverty;
    function fromViewColumn(column) {
        var editorColumn = editor_1.Position.LEFT;
        if (typeof column !== 'number') {
        }
        else if (column === types.ViewColumn.Two) {
            editorColumn = editor_1.Position.CENTER;
        }
        else if (column === types.ViewColumn.Three) {
            editorColumn = editor_1.Position.RIGHT;
        }
        return editorColumn;
    }
    exports.fromViewColumn = fromViewColumn;
    function toViewColumn(position) {
        if (typeof position !== 'number') {
            return;
        }
        if (position === editor_1.Position.LEFT) {
            return types.ViewColumn.One;
        }
        else if (position === editor_1.Position.CENTER) {
            return types.ViewColumn.Two;
        }
        else if (position === editor_1.Position.RIGHT) {
            return types.ViewColumn.Three;
        }
    }
    exports.toViewColumn = toViewColumn;
    function fromFormattedString(value) {
        if (typeof value === 'string') {
            return { markdown: value };
        }
        else if (typeof value === 'object') {
            return { code: value };
        }
    }
    exports.fromFormattedString = fromFormattedString;
    function toFormattedString(value) {
        if (typeof value.code === 'string') {
            return value.code;
        }
        var markdown = value.markdown, text = value.text;
        return markdown || text || '<???>';
    }
    exports.toFormattedString = toFormattedString;
    function isMarkedStringArr(something) {
        return Array.isArray(something);
    }
    function fromMarkedStringOrMarkedStringArr(something) {
        if (isMarkedStringArr(something)) {
            return something.map(function (msg) { return fromFormattedString(msg); });
        }
        else if (something) {
            return [fromFormattedString(something)];
        }
        else {
            return [];
        }
    }
    function isRangeWithMessage(something) {
        return (typeof something.range !== 'undefined');
    }
    function isRangeWithMessageArr(something) {
        if (something.length === 0) {
            return true;
        }
        return isRangeWithMessage(something[0]) ? true : false;
    }
    function fromRangeOrRangeWithMessage(ranges) {
        if (isRangeWithMessageArr(ranges)) {
            return ranges.map(function (r) {
                return {
                    range: fromRange(r.range),
                    hoverMessage: fromMarkedStringOrMarkedStringArr(r.hoverMessage)
                };
            });
        }
        else {
            return ranges.map(function (r) {
                return {
                    range: fromRange(r)
                };
            });
        }
    }
    exports.fromRangeOrRangeWithMessage = fromRangeOrRangeWithMessage;
    exports.TextEdit = {
        from: function (edit) {
            return {
                text: edit.newText,
                range: fromRange(edit.range)
            };
        },
        to: function (edit) {
            return new types.TextEdit(toRange(edit.range), edit.text);
        }
    };
    var SymbolKind;
    (function (SymbolKind) {
        function from(kind) {
            switch (kind) {
                case types.SymbolKind.Method:
                    return 'method';
                case types.SymbolKind.Function:
                    return 'function';
                case types.SymbolKind.Constructor:
                    return 'constructor';
                case types.SymbolKind.Variable:
                    return 'variable';
                case types.SymbolKind.Class:
                    return 'class';
                case types.SymbolKind.Interface:
                    return 'interface';
                case types.SymbolKind.Namespace:
                    return 'namespace';
                case types.SymbolKind.Package:
                    return 'package';
                case types.SymbolKind.Module:
                    return 'module';
                case types.SymbolKind.Property:
                    return 'property';
                case types.SymbolKind.Enum:
                    return 'enum';
                case types.SymbolKind.String:
                    return 'string';
                case types.SymbolKind.File:
                    return 'file';
                case types.SymbolKind.Array:
                    return 'array';
                case types.SymbolKind.Number:
                    return 'number';
                case types.SymbolKind.Boolean:
                    return 'boolean';
                case types.SymbolKind.Object:
                    return 'object';
                case types.SymbolKind.Key:
                    return 'key';
                case types.SymbolKind.Null:
                    return 'null';
            }
            return 'property';
        }
        SymbolKind.from = from;
        function to(type) {
            switch (type) {
                case 'method':
                    return types.SymbolKind.Method;
                case 'function':
                    return types.SymbolKind.Function;
                case 'constructor':
                    return types.SymbolKind.Constructor;
                case 'variable':
                    return types.SymbolKind.Variable;
                case 'class':
                    return types.SymbolKind.Class;
                case 'interface':
                    return types.SymbolKind.Interface;
                case 'namespace':
                    return types.SymbolKind.Namespace;
                case 'package':
                    return types.SymbolKind.Package;
                case 'module':
                    return types.SymbolKind.Module;
                case 'property':
                    return types.SymbolKind.Property;
                case 'enum':
                    return types.SymbolKind.Enum;
                case 'string':
                    return types.SymbolKind.String;
                case 'file':
                    return types.SymbolKind.File;
                case 'array':
                    return types.SymbolKind.Array;
                case 'number':
                    return types.SymbolKind.Number;
                case 'boolean':
                    return types.SymbolKind.Boolean;
                case 'object':
                    return types.SymbolKind.Object;
                case 'key':
                    return types.SymbolKind.Key;
                case 'null':
                    return types.SymbolKind.Null;
            }
            return types.SymbolKind.Property;
        }
        SymbolKind.to = to;
    })(SymbolKind = exports.SymbolKind || (exports.SymbolKind = {}));
    var SymbolInformation;
    (function (SymbolInformation) {
        function fromOutlineEntry(entry) {
            return new types.SymbolInformation(entry.label, SymbolKind.to(entry.type), toRange(entry.range), undefined, entry.containerLabel);
        }
        SymbolInformation.fromOutlineEntry = fromOutlineEntry;
        function toOutlineEntry(symbol) {
            return {
                type: SymbolKind.from(symbol.kind),
                range: fromRange(symbol.location.range),
                containerLabel: symbol.containerName,
                label: symbol.name,
                icon: undefined,
            };
        }
        SymbolInformation.toOutlineEntry = toOutlineEntry;
    })(SymbolInformation = exports.SymbolInformation || (exports.SymbolInformation = {}));
    function fromSymbolInformation(info) {
        return {
            name: info.name,
            type: types.SymbolKind[info.kind || types.SymbolKind.Property].toLowerCase(),
            range: fromRange(info.location.range),
            resourceUri: info.location.uri,
            containerName: info.containerName,
            parameters: '',
        };
    }
    exports.fromSymbolInformation = fromSymbolInformation;
    function toSymbolInformation(bearing) {
        return new types.SymbolInformation(bearing.name, types.SymbolKind[bearing.type.charAt(0).toUpperCase() + bearing.type.substr(1)], toRange(bearing.range), bearing.resourceUri, bearing.containerName);
    }
    exports.toSymbolInformation = toSymbolInformation;
    exports.location = {
        from: function (value) {
            return {
                range: fromRange(value.range),
                resource: value.uri
            };
        },
        to: function (value) {
            return new types.Location(value.resource, toRange(value.range));
        }
    };
    function fromHover(hover) {
        return {
            range: fromRange(hover.range),
            htmlContent: hover.contents.map(fromFormattedString)
        };
    }
    exports.fromHover = fromHover;
    function toHover(info) {
        return new types.Hover(info.htmlContent.map(toFormattedString), toRange(info.range));
    }
    exports.toHover = toHover;
    function toDocumentHighlight(occurrence) {
        return new types.DocumentHighlight(toRange(occurrence.range), types.DocumentHighlightKind[occurrence.kind.charAt(0).toUpperCase() + occurrence.kind.substr(1)]);
    }
    exports.toDocumentHighlight = toDocumentHighlight;
    exports.Suggest = {
        from: function (item) {
            var suggestion = {
                label: item.label,
                codeSnippet: item.insertText || item.label,
                type: types.CompletionItemKind[item.kind || types.CompletionItemKind.Text].toString().toLowerCase(),
                typeLabel: item.detail,
                documentationLabel: item.documentation,
                sortText: item.sortText,
                filterText: item.filterText
            };
            return suggestion;
        },
        to: function (container, position, suggestion) {
            var result = new types.CompletionItem(suggestion.label);
            result.insertText = suggestion.codeSnippet;
            result.kind = types.CompletionItemKind[suggestion.type.charAt(0).toUpperCase() + suggestion.type.substr(1)];
            result.detail = suggestion.typeLabel;
            result.documentation = suggestion.documentationLabel;
            result.sortText = suggestion.sortText;
            result.filterText = suggestion.filterText;
            var overwriteBefore = (typeof suggestion.overwriteBefore === 'number') ? suggestion.overwriteBefore : container.currentWord.length;
            var startPosition = new types.Position(position.line, Math.max(0, position.character - overwriteBefore));
            var endPosition = position;
            if (typeof suggestion.overwriteAfter === 'number') {
                endPosition = new types.Position(position.line, position.character + suggestion.overwriteAfter);
            }
            result.textEdit = types.TextEdit.replace(new types.Range(startPosition, endPosition), suggestion.codeSnippet);
            return result;
        }
    };
    var SignatureHelp;
    (function (SignatureHelp) {
        function from(signatureHelp) {
            var result = {
                currentSignature: signatureHelp.activeSignature,
                currentParameter: signatureHelp.activeParameter,
                signatures: []
            };
            for (var _i = 0, _a = signatureHelp.signatures; _i < _a.length; _i++) {
                var signature = _a[_i];
                var signatureItem = {
                    label: signature.label,
                    documentation: signature.documentation,
                    parameters: []
                };
                var idx = 0;
                for (var _b = 0, _c = signature.parameters; _b < _c.length; _b++) {
                    var parameter = _c[_b];
                    var parameterItem = {
                        label: parameter.label,
                        documentation: parameter.documentation,
                    };
                    signatureItem.parameters.push(parameterItem);
                    idx = signature.label.indexOf(parameter.label, idx);
                    if (idx >= 0) {
                        parameterItem.signatureLabelOffset = idx;
                        idx += parameter.label.length;
                        parameterItem.signatureLabelEnd = idx;
                    }
                    else {
                        parameterItem.signatureLabelOffset = 0;
                        parameterItem.signatureLabelEnd = 0;
                    }
                }
                result.signatures.push(signatureItem);
            }
            return result;
        }
        SignatureHelp.from = from;
        function to(hints) {
            var result = new types.SignatureHelp();
            result.activeSignature = hints.currentSignature;
            result.activeParameter = hints.currentParameter;
            for (var _i = 0, _a = hints.signatures; _i < _a.length; _i++) {
                var signature = _a[_i];
                var signatureItem = new types.SignatureInformation(signature.label, signature.documentation);
                result.signatures.push(signatureItem);
                for (var _b = 0, _c = signature.parameters; _b < _c.length; _b++) {
                    var parameter = _c[_b];
                    var parameterItem = new types.ParameterInformation(parameter.label, parameter.documentation);
                    signatureItem.parameters.push(parameterItem);
                }
            }
            return result;
        }
        SignatureHelp.to = to;
    })(SignatureHelp = exports.SignatureHelp || (exports.SignatureHelp = {}));
    var Command;
    (function (Command) {
        var _cache = Object.create(null);
        var _idPool = 1;
        function from(command, context) {
            if (!command) {
                return;
            }
            var result = {
                id: command.command,
                title: command.title
            };
            if (!arrays_1.isFalsyOrEmpty(command.arguments)) {
                // keep command around
                var id_1 = command.command + "-no-args-wrapper-" + _idPool++;
                result.id = id_1;
                _cache[id_1] = command;
                var disposable1 = context.commands.registerCommand(id_1, function () { return (_a = context.commands).executeCommand.apply(_a, [command.command].concat(_cache[id_1].arguments)); var _a; });
                var disposable2 = { dispose: function () { delete _cache[id_1]; } };
                context.disposables.push(disposable1, disposable2);
            }
            return result;
        }
        Command.from = from;
        function to(command) {
            var result = _cache[command.id];
            if (!result) {
                result = {
                    command: command.id,
                    title: command.title
                };
            }
            return result;
        }
        Command.to = to;
    })(Command = exports.Command || (exports.Command = {}));
});

define("vs/workbench/api/node/mainThreadEditors", ["require", "exports", 'vs/editor/common/editorCommon', 'vs/base/common/event', 'vs/base/common/lifecycle', 'vs/base/common/async', 'vs/editor/common/core/range', 'vs/editor/common/core/selection', 'vs/workbench/api/node/extHostTypes'], function (require, exports, EditorCommon, event_1, lifecycle_1, async_1, range_1, selection_1, extHostTypes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function configurationsEqual(a, b) {
        if (a && !b || !a && b) {
            return false;
        }
        if (!a && !b) {
            return true;
        }
        return (a.tabSize === b.tabSize
            && a.insertSpaces === b.insertSpaces);
    }
    (function (TextEditorRevealType) {
        TextEditorRevealType[TextEditorRevealType["Default"] = 0] = "Default";
        TextEditorRevealType[TextEditorRevealType["InCenter"] = 1] = "InCenter";
        TextEditorRevealType[TextEditorRevealType["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
    })(exports.TextEditorRevealType || (exports.TextEditorRevealType = {}));
    var TextEditorRevealType = exports.TextEditorRevealType;
    /**
     * Text Editor that is permanently bound to the same model.
     * It can be bound or not to a CodeEditor.
     */
    var MainThreadTextEditor = (function () {
        function MainThreadTextEditor(id, model, codeEditor, focusTracker, modelService) {
            var _this = this;
            this._id = id;
            this._model = model;
            this._codeEditor = null;
            this._focusTracker = focusTracker;
            this._modelService = modelService;
            this._codeEditorListeners = [];
            this._onSelectionChanged = new event_1.Emitter();
            this._onConfigurationChanged = new event_1.Emitter();
            this._lastSelection = [new selection_1.Selection(1, 1, 1, 1)];
            this._setConfiguration(this._readConfiguration(this._model, this._codeEditor));
            this._modelListeners = [];
            this._modelListeners.push(this._model.addListener2(EditorCommon.EventType.ModelOptionsChanged, function (e) {
                _this._setConfiguration(_this._readConfiguration(_this._model, _this._codeEditor));
            }));
            this.setCodeEditor(codeEditor);
        }
        MainThreadTextEditor.prototype.dispose = function () {
            this._model = null;
            this._modelListeners = lifecycle_1.disposeAll(this._modelListeners);
            this._codeEditor = null;
            this._codeEditorListeners = lifecycle_1.disposeAll(this._codeEditorListeners);
        };
        MainThreadTextEditor.prototype.getId = function () {
            return this._id;
        };
        MainThreadTextEditor.prototype.getModel = function () {
            return this._model;
        };
        MainThreadTextEditor.prototype.hasCodeEditor = function (codeEditor) {
            return (this._codeEditor === codeEditor);
        };
        MainThreadTextEditor.prototype.setCodeEditor = function (codeEditor) {
            var _this = this;
            if (this.hasCodeEditor(codeEditor)) {
                // Nothing to do...
                return;
            }
            this._codeEditorListeners = lifecycle_1.disposeAll(this._codeEditorListeners);
            this._codeEditor = codeEditor;
            if (this._codeEditor) {
                var forwardSelection = function () {
                    _this._lastSelection = _this._codeEditor.getSelections();
                    _this._onSelectionChanged.fire(_this._lastSelection);
                };
                this._codeEditorListeners.push(this._codeEditor.addListener2(EditorCommon.EventType.CursorSelectionChanged, forwardSelection));
                if (!selection_1.Selection.selectionsArrEqual(this._lastSelection, this._codeEditor.getSelections())) {
                    forwardSelection();
                }
                this._codeEditorListeners.push(this._codeEditor.addListener2(EditorCommon.EventType.EditorFocus, function () {
                    _this._focusTracker.onGainedFocus();
                }));
                this._codeEditorListeners.push(this._codeEditor.addListener2(EditorCommon.EventType.EditorBlur, function () {
                    _this._focusTracker.onLostFocus();
                }));
                this._codeEditorListeners.push(this._codeEditor.addListener2(EditorCommon.EventType.ConfigurationChanged, function () {
                    _this._setConfiguration(_this._readConfiguration(_this._model, _this._codeEditor));
                }));
                this._setConfiguration(this._readConfiguration(this._model, this._codeEditor));
            }
        };
        MainThreadTextEditor.prototype.isVisible = function () {
            return !!this._codeEditor;
        };
        Object.defineProperty(MainThreadTextEditor.prototype, "onSelectionChanged", {
            get: function () {
                return this._onSelectionChanged.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MainThreadTextEditor.prototype, "onConfigurationChanged", {
            get: function () {
                return this._onConfigurationChanged.event;
            },
            enumerable: true,
            configurable: true
        });
        MainThreadTextEditor.prototype.getSelections = function () {
            if (this._codeEditor) {
                return this._codeEditor.getSelections();
            }
            return this._lastSelection;
        };
        MainThreadTextEditor.prototype.setSelections = function (selections) {
            if (this._codeEditor) {
                this._codeEditor.setSelections(selections);
                return;
            }
            this._lastSelection = selections.map(selection_1.Selection.liftSelection);
            console.warn('setSelections on invisble editor');
        };
        MainThreadTextEditor.prototype.getConfiguration = function () {
            return this._configuration;
        };
        MainThreadTextEditor.prototype._setIndentConfiguration = function (newConfiguration) {
            if (newConfiguration.tabSize === 'auto' || newConfiguration.insertSpaces === 'auto') {
                // one of the options was set to 'auto' => detect indentation
                var creationOpts = this._modelService.getCreationOptions();
                var insertSpaces = creationOpts.insertSpaces;
                var tabSize = creationOpts.tabSize;
                if (newConfiguration.insertSpaces !== 'auto') {
                    if (typeof newConfiguration.insertSpaces !== 'undefined') {
                        insertSpaces = (newConfiguration.insertSpaces === 'false' ? false : Boolean(newConfiguration.insertSpaces));
                    }
                }
                if (newConfiguration.tabSize !== 'auto') {
                    if (typeof newConfiguration.tabSize !== 'undefined') {
                        var parsedTabSize = parseInt(newConfiguration.tabSize, 10);
                        if (!isNaN(parsedTabSize)) {
                            tabSize = parsedTabSize;
                        }
                    }
                }
                this._model.detectIndentation(insertSpaces, tabSize);
                return;
            }
            var newOpts = {};
            if (typeof newConfiguration.insertSpaces !== 'undefined') {
                newOpts.insertSpaces = (newConfiguration.insertSpaces === 'false' ? false : Boolean(newConfiguration.insertSpaces));
            }
            if (typeof newConfiguration.tabSize !== 'undefined') {
                var parsedTabSize = parseInt(newConfiguration.tabSize, 10);
                if (!isNaN(parsedTabSize)) {
                    newOpts.tabSize = parsedTabSize;
                }
            }
            this._model.updateOptions(newOpts);
        };
        MainThreadTextEditor.prototype.setConfiguration = function (newConfiguration) {
            this._setIndentConfiguration(newConfiguration);
            if (newConfiguration.cursorStyle) {
                var newCursorStyle = EditorCommon.cursorStyleToString(newConfiguration.cursorStyle);
                if (!this._codeEditor) {
                    console.warn('setConfiguration on invisible editor');
                    return;
                }
                this._codeEditor.updateOptions({
                    cursorStyle: newCursorStyle
                });
            }
        };
        MainThreadTextEditor.prototype.setDecorations = function (key, ranges) {
            if (!this._codeEditor) {
                console.warn('setDecorations on invisible editor');
                return;
            }
            this._codeEditor.setDecorations(key, ranges);
        };
        MainThreadTextEditor.prototype.revealRange = function (range, revealType) {
            if (!this._codeEditor) {
                console.warn('revealRange on invisible editor');
                return;
            }
            if (revealType === TextEditorRevealType.Default) {
                this._codeEditor.revealRange(range);
            }
            else if (revealType === TextEditorRevealType.InCenter) {
                this._codeEditor.revealRangeInCenter(range);
            }
            else if (revealType === TextEditorRevealType.InCenterIfOutsideViewport) {
                this._codeEditor.revealRangeInCenterIfOutsideViewport(range);
            }
            else {
                console.warn('Unknown revealType');
            }
        };
        MainThreadTextEditor.prototype._readConfiguration = function (model, codeEditor) {
            if (model.isDisposed()) {
                // shutdown time
                return this._configuration;
            }
            var cursorStyle = this._configuration ? this._configuration.cursorStyle : EditorCommon.TextEditorCursorStyle.Line;
            if (codeEditor) {
                var codeEditorOpts = codeEditor.getConfiguration();
                cursorStyle = codeEditorOpts.cursorStyle;
            }
            var indent = model.getOptions();
            return {
                insertSpaces: indent.insertSpaces,
                tabSize: indent.tabSize,
                cursorStyle: cursorStyle
            };
        };
        MainThreadTextEditor.prototype._setConfiguration = function (newConfiguration) {
            if (configurationsEqual(this._configuration, newConfiguration)) {
                return;
            }
            this._configuration = newConfiguration;
            this._onConfigurationChanged.fire(this._configuration);
        };
        MainThreadTextEditor.prototype.isFocused = function () {
            if (this._codeEditor) {
                return this._codeEditor.isFocused();
            }
            return false;
        };
        MainThreadTextEditor.prototype.matches = function (editor) {
            return editor.getControl() === this._codeEditor;
        };
        MainThreadTextEditor.prototype.applyEdits = function (versionIdCheck, edits, setEndOfLine) {
            if (this._model.getVersionId() !== versionIdCheck) {
                console.warn('Model has changed in the meantime!');
                // throw new Error('Model has changed in the meantime!');
                // model changed in the meantime
                return false;
            }
            if (this._codeEditor) {
                if (setEndOfLine === extHostTypes_1.EndOfLine.CRLF) {
                    this._model.setEOL(EditorCommon.EndOfLineSequence.CRLF);
                }
                else if (setEndOfLine === extHostTypes_1.EndOfLine.LF) {
                    this._model.setEOL(EditorCommon.EndOfLineSequence.LF);
                }
                var transformedEdits = edits.map(function (edit) {
                    return {
                        identifier: null,
                        range: range_1.Range.lift(edit.range),
                        text: edit.text,
                        forceMoveMarkers: edit.forceMoveMarkers
                    };
                });
                return this._codeEditor.executeEdits('MainThreadTextEditor', transformedEdits) || true;
            }
            console.warn('applyEdits on invisible editor');
            return false;
        };
        return MainThreadTextEditor;
    }());
    exports.MainThreadTextEditor = MainThreadTextEditor;
    /**
     * Keeps track of what goes on in the main thread and maps models => text editors
     */
    var MainThreadEditorsTracker = (function () {
        function MainThreadEditorsTracker(editorService, modelService) {
            var _this = this;
            this._codeEditorService = editorService;
            this._modelService = modelService;
            this._toDispose = [];
            this._focusedTextEditorId = null;
            this._visibleTextEditorIds = [];
            this._editorModelChangeListeners = Object.create(null);
            this._model2TextEditors = Object.create(null);
            this._onTextEditorAdd = new event_1.Emitter();
            this._onTextEditorRemove = new event_1.Emitter();
            this._onDidUpdateTextEditors = new event_1.Emitter();
            this._onDidChangeFocusedTextEditor = new event_1.Emitter();
            this._focusTracker = {
                onGainedFocus: function () { return _this._updateFocusedTextEditor(); },
                onLostFocus: function () { return _this._updateFocusedTextEditor(); }
            };
            this._modelService.onModelAdded(this._onModelAdded, this, this._toDispose);
            this._modelService.onModelRemoved(this._onModelRemoved, this, this._toDispose);
            this._codeEditorService.onCodeEditorAdd(this._onCodeEditorAdd, this, this._toDispose);
            this._codeEditorService.onCodeEditorRemove(this._onCodeEditorRemove, this, this._toDispose);
            this._updateMapping = new async_1.RunOnceScheduler(function () { return _this._doUpdateMapping(); }, 0);
            this._toDispose.push(this._updateMapping);
        }
        MainThreadEditorsTracker.prototype._nextId = function () {
            return String(++MainThreadEditorsTracker._LAST_TEXT_EDITOR_ID);
        };
        MainThreadEditorsTracker.prototype.dispose = function () {
            this._toDispose = lifecycle_1.disposeAll(this._toDispose);
        };
        MainThreadEditorsTracker.prototype._onModelAdded = function (model) {
            this._updateMapping.schedule();
        };
        MainThreadEditorsTracker.prototype._onModelRemoved = function (model) {
            this._updateMapping.schedule();
        };
        MainThreadEditorsTracker.prototype._onCodeEditorAdd = function (codeEditor) {
            var _this = this;
            this._editorModelChangeListeners[codeEditor.getId()] = codeEditor.addListener2(EditorCommon.EventType.ModelChanged, function (_) { return _this._updateMapping.schedule(); });
            this._updateMapping.schedule();
        };
        MainThreadEditorsTracker.prototype._onCodeEditorRemove = function (codeEditor) {
            this._editorModelChangeListeners[codeEditor.getId()].dispose();
            delete this._editorModelChangeListeners[codeEditor.getId()];
            this._updateMapping.schedule();
        };
        MainThreadEditorsTracker.prototype._doUpdateMapping = function () {
            var _this = this;
            var allModels = this._modelService.getModels();
            // Same filter as in extHostDocuments
            allModels = allModels.filter(function (model) { return !model.isTooLargeForHavingARichMode(); });
            var allModelsMap = Object.create(null);
            allModels.forEach(function (model) {
                allModelsMap[model.getAssociatedResource().toString()] = model;
            });
            // Remove text editors for models that no longer exist
            Object.keys(this._model2TextEditors).forEach(function (modelUri) {
                if (allModelsMap[modelUri]) {
                    // model still exists, will be updated below
                    return;
                }
                var textEditorsToRemove = _this._model2TextEditors[modelUri];
                delete _this._model2TextEditors[modelUri];
                for (var i = 0; i < textEditorsToRemove.length; i++) {
                    _this._onTextEditorRemove.fire(textEditorsToRemove[i]);
                    textEditorsToRemove[i].dispose();
                }
            });
            // Handle all visible models
            var visibleModels = this._getVisibleModels();
            Object.keys(visibleModels).forEach(function (modelUri) {
                var model = visibleModels[modelUri].model;
                var codeEditors = visibleModels[modelUri].codeEditors;
                if (!_this._model2TextEditors[modelUri]) {
                    _this._model2TextEditors[modelUri] = [];
                }
                var existingTextEditors = _this._model2TextEditors[modelUri];
                // Remove text editors if more exist
                while (existingTextEditors.length > codeEditors.length) {
                    var removedTextEditor = existingTextEditors.pop();
                    _this._onTextEditorRemove.fire(removedTextEditor);
                    removedTextEditor.dispose();
                }
                // Adjust remaining text editors
                for (var i = 0; i < existingTextEditors.length; i++) {
                    existingTextEditors[i].setCodeEditor(codeEditors[i]);
                }
                // Create new editors as needed
                for (var i = existingTextEditors.length; i < codeEditors.length; i++) {
                    var newTextEditor = new MainThreadTextEditor(_this._nextId(), model, codeEditors[i], _this._focusTracker, _this._modelService);
                    existingTextEditors.push(newTextEditor);
                    _this._onTextEditorAdd.fire(newTextEditor);
                }
            });
            // Handle all not visible models
            allModels.forEach(function (model) {
                var modelUri = model.getAssociatedResource().toString();
                if (visibleModels[modelUri]) {
                    // model is visible, already handled above
                    return;
                }
                if (!_this._model2TextEditors[modelUri]) {
                    _this._model2TextEditors[modelUri] = [];
                }
                var existingTextEditors = _this._model2TextEditors[modelUri];
                // Remove extra text editors
                while (existingTextEditors.length > 1) {
                    var removedTextEditor = existingTextEditors.pop();
                    _this._onTextEditorRemove.fire(removedTextEditor);
                    removedTextEditor.dispose();
                }
                // Create new editor if needed or adjust it
                if (existingTextEditors.length === 0) {
                    var newTextEditor = new MainThreadTextEditor(_this._nextId(), model, null, _this._focusTracker, _this._modelService);
                    existingTextEditors.push(newTextEditor);
                    _this._onTextEditorAdd.fire(newTextEditor);
                }
                else {
                    existingTextEditors[0].setCodeEditor(null);
                }
            });
            this._printState();
            this._visibleTextEditorIds = this._findVisibleTextEditorIds();
            this._updateFocusedTextEditor();
            // this is a sync event
            this._onDidUpdateTextEditors.fire(undefined);
        };
        MainThreadEditorsTracker.prototype._updateFocusedTextEditor = function () {
            this._setFocusedTextEditorId(this._findFocusedTextEditorId());
        };
        MainThreadEditorsTracker.prototype._findFocusedTextEditorId = function () {
            var modelUris = Object.keys(this._model2TextEditors);
            for (var i = 0, len = modelUris.length; i < len; i++) {
                var editors = this._model2TextEditors[modelUris[i]];
                for (var j = 0, lenJ = editors.length; j < lenJ; j++) {
                    if (editors[j].isFocused()) {
                        return editors[j].getId();
                    }
                }
            }
            return null;
        };
        MainThreadEditorsTracker.prototype._findVisibleTextEditorIds = function () {
            var result = [];
            var modelUris = Object.keys(this._model2TextEditors);
            for (var i = 0, len = modelUris.length; i < len; i++) {
                var editors = this._model2TextEditors[modelUris[i]];
                for (var j = 0, lenJ = editors.length; j < lenJ; j++) {
                    if (editors[j].isVisible()) {
                        result.push(editors[j].getId());
                    }
                }
            }
            result.sort();
            return result;
        };
        MainThreadEditorsTracker.prototype._setFocusedTextEditorId = function (focusedTextEditorId) {
            if (this._focusedTextEditorId === focusedTextEditorId) {
                // no change
                return;
            }
            this._focusedTextEditorId = focusedTextEditorId;
            this._printState();
            this._onDidChangeFocusedTextEditor.fire(this._focusedTextEditorId);
        };
        MainThreadEditorsTracker.prototype._printState = function () {
            // console.log('----------------------');
            // Object.keys(this._model2TextEditors).forEach((modelUri) => {
            // 	let editors = this._model2TextEditors[modelUri];
            // 	console.log(editors.map((e) => {
            // 		return e.getId() + " (" + (e.getId() === this._focusedTextEditorId ? 'FOCUSED, ': '') + modelUri + ")";
            // 	}).join('\n'));
            // });
        };
        MainThreadEditorsTracker.prototype._getVisibleModels = function () {
            var r = {};
            var allCodeEditors = this._codeEditorService.listCodeEditors();
            // Maintain a certain sorting such that the mapping doesn't change too much all the time
            allCodeEditors.sort(function (a, b) { return strcmp(a.getId(), b.getId()); });
            allCodeEditors.forEach(function (codeEditor) {
                var model = codeEditor.getModel();
                if (!model || model.isTooLargeForHavingARichMode()) {
                    return;
                }
                var modelUri = model.getAssociatedResource().toString();
                r[modelUri] = r[modelUri] || {
                    model: model,
                    codeEditors: []
                };
                r[modelUri].codeEditors.push(codeEditor);
            });
            return r;
        };
        MainThreadEditorsTracker.prototype.getFocusedTextEditorId = function () {
            return this._focusedTextEditorId;
        };
        MainThreadEditorsTracker.prototype.getVisibleTextEditorIds = function () {
            return this._visibleTextEditorIds;
        };
        Object.defineProperty(MainThreadEditorsTracker.prototype, "onTextEditorAdd", {
            get: function () {
                return this._onTextEditorAdd.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MainThreadEditorsTracker.prototype, "onTextEditorRemove", {
            get: function () {
                return this._onTextEditorRemove.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MainThreadEditorsTracker.prototype, "onDidUpdateTextEditors", {
            get: function () {
                return this._onDidUpdateTextEditors.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MainThreadEditorsTracker.prototype, "onChangedFocusedTextEditor", {
            get: function () {
                return this._onDidChangeFocusedTextEditor.event;
            },
            enumerable: true,
            configurable: true
        });
        MainThreadEditorsTracker.prototype.findTextEditorIdFor = function (codeEditor) {
            var modelUris = Object.keys(this._model2TextEditors);
            for (var i = 0, len = modelUris.length; i < len; i++) {
                var editors = this._model2TextEditors[modelUris[i]];
                for (var j = 0, lenJ = editors.length; j < lenJ; j++) {
                    if (editors[j].hasCodeEditor(codeEditor)) {
                        return editors[j].getId();
                    }
                }
            }
            return null;
        };
        MainThreadEditorsTracker.prototype.registerTextEditorDecorationType = function (key, options) {
            this._codeEditorService.registerDecorationType(key, options);
        };
        MainThreadEditorsTracker.prototype.removeTextEditorDecorationType = function (key) {
            this._codeEditorService.removeDecorationType(key);
        };
        MainThreadEditorsTracker._LAST_TEXT_EDITOR_ID = 0;
        return MainThreadEditorsTracker;
    }());
    exports.MainThreadEditorsTracker = MainThreadEditorsTracker;
    function strcmp(a, b) {
        if (a < b) {
            return -1;
        }
        if (a > b) {
            return 1;
        }
        return 0;
    }
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("vs/workbench/common/editor", ["require", "exports", 'vs/base/common/winjs.base', 'vs/base/common/eventEmitter', 'vs/base/common/types', 'vs/base/common/objects'], function (require, exports, winjs_base_1, eventEmitter_1, types, objects) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Editor inputs are lightweight objects that can be passed to the workbench API to open inside the editor part.
     * Each editor input is mapped to an editor that is capable of opening it through the Platform facade.
     */
    var EditorInput = (function (_super) {
        __extends(EditorInput, _super);
        function EditorInput() {
            _super.apply(this, arguments);
        }
        /**
         * Returns the name of this input that can be shown to the user. Examples include showing the name of the input
         * above the editor area when the input is shown.
         */
        EditorInput.prototype.getName = function () {
            return null;
        };
        /**
         * Returns the description of this input that can be shown to the user. Examples include showing the description of
         * the input above the editor area to the side of the name of the input.
         *
         * @param verbose controls if the description should be short or can contain additional details.
         */
        EditorInput.prototype.getDescription = function (verbose) {
            return null;
        };
        /**
         * Returns status information about this input that can be shown to the user. Examples include showing the status
         * of the input when hovering over the name of the input.
         */
        EditorInput.prototype.getStatus = function () {
            return null;
        };
        /**
         * Returns the preferred editor for this input. A list of candidate editors is passed in that whee registered
         * for the input. This allows subclasses to decide late which editor to use for the input on a case by case basis.
         */
        EditorInput.prototype.getPreferredEditorId = function (candidates) {
            if (candidates && candidates.length > 0) {
                return candidates[0];
            }
            return null;
        };
        /**
         * Returns true if this input is identical to the otherInput.
         */
        EditorInput.prototype.matches = function (otherInput) {
            return this === otherInput;
        };
        /**
         * Called when an editor input is no longer needed. Allows to free up any resources taken by
         * resolving the editor input.
         */
        EditorInput.prototype.dispose = function () {
            this.disposed = true;
            this.emit('dispose');
            _super.prototype.dispose.call(this);
        };
        /**
         * Returns whether this input was disposed or not.
         */
        EditorInput.prototype.isDisposed = function () {
            return this.disposed;
        };
        return EditorInput;
    }(eventEmitter_1.EventEmitter));
    exports.EditorInput = EditorInput;
    (function (EncodingMode) {
        /**
         * Instructs the encoding support to encode the current input with the provided encoding
         */
        EncodingMode[EncodingMode["Encode"] = 0] = "Encode";
        /**
         * Instructs the encoding support to decode the current input with the provided encoding
         */
        EncodingMode[EncodingMode["Decode"] = 1] = "Decode";
    })(exports.EncodingMode || (exports.EncodingMode = {}));
    var EncodingMode = exports.EncodingMode;
    /**
     * The base class of untitled editor inputs in the workbench.
     */
    var UntitledEditorInput = (function (_super) {
        __extends(UntitledEditorInput, _super);
        function UntitledEditorInput() {
            _super.apply(this, arguments);
        }
        return UntitledEditorInput;
    }(EditorInput));
    exports.UntitledEditorInput = UntitledEditorInput;
    /**
     * The base class of editor inputs that have an original and modified side.
     */
    var BaseDiffEditorInput = (function (_super) {
        __extends(BaseDiffEditorInput, _super);
        function BaseDiffEditorInput(originalInput, modifiedInput) {
            _super.call(this);
            this._originalInput = originalInput;
            this._modifiedInput = modifiedInput;
        }
        Object.defineProperty(BaseDiffEditorInput.prototype, "originalInput", {
            get: function () {
                return this._originalInput;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseDiffEditorInput.prototype, "modifiedInput", {
            get: function () {
                return this._modifiedInput;
            },
            enumerable: true,
            configurable: true
        });
        BaseDiffEditorInput.prototype.getOriginalInput = function () {
            return this.originalInput;
        };
        BaseDiffEditorInput.prototype.getModifiedInput = function () {
            return this.modifiedInput;
        };
        return BaseDiffEditorInput;
    }(EditorInput));
    exports.BaseDiffEditorInput = BaseDiffEditorInput;
    /**
     * The editor model is the heavyweight counterpart of editor input. Depending on the editor input, it
     * connects to the disk to retrieve content and may allow for saving it back or reverting it. Editor models
     * are typically cached for some while because they are expensive to construct.
     */
    var EditorModel = (function (_super) {
        __extends(EditorModel, _super);
        function EditorModel() {
            _super.apply(this, arguments);
        }
        /**
         * Causes this model to load returning a promise when loading is completed.
         */
        EditorModel.prototype.load = function () {
            return winjs_base_1.TPromise.as(this);
        };
        /**
         * Returns whether this model was loaded or not.
         */
        EditorModel.prototype.isResolved = function () {
            return true;
        };
        /**
         * Subclasses should implement to free resources that have been claimed through loading.
         */
        EditorModel.prototype.dispose = function () {
            this.emit('dispose');
            _super.prototype.dispose.call(this);
        };
        return EditorModel;
    }(eventEmitter_1.EventEmitter));
    exports.EditorModel = EditorModel;
    /**
     * The editor options is the base class of options that can be passed in when opening an editor.
     */
    var EditorOptions = (function () {
        function EditorOptions() {
        }
        /**
         * Helper to create EditorOptions inline.
         */
        EditorOptions.create = function (settings) {
            var options = new EditorOptions();
            options.preserveFocus = settings.preserveFocus;
            options.forceOpen = settings.forceOpen;
            return options;
        };
        /**
         * Returns true if this options is identical to the otherOptions.
         */
        EditorOptions.prototype.matches = function (otherOptions) {
            return this === otherOptions;
        };
        return EditorOptions;
    }());
    exports.EditorOptions = EditorOptions;
    /**
     * Base Text Editor Options.
     */
    var TextEditorOptions = (function (_super) {
        __extends(TextEditorOptions, _super);
        function TextEditorOptions() {
            _super.apply(this, arguments);
        }
        TextEditorOptions.from = function (input) {
            var options = null;
            if (input && input.options) {
                if (input.options.selection || input.options.forceOpen || input.options.preserveFocus) {
                    options = new TextEditorOptions();
                }
                if (input.options.selection) {
                    var selection = input.options.selection;
                    options.selection(selection.startLineNumber, selection.startColumn, selection.endLineNumber, selection.endColumn);
                }
                if (input.options.forceOpen) {
                    options.forceOpen = true;
                }
                if (input.options.preserveFocus) {
                    options.preserveFocus = true;
                }
            }
            return options;
        };
        /**
         * Helper to create TextEditorOptions inline.
         */
        TextEditorOptions.create = function (settings) {
            var options = new TextEditorOptions();
            options.preserveFocus = settings.preserveFocus;
            options.forceActive = settings.forceActive;
            options.forceOpen = settings.forceOpen;
            if (settings.selection) {
                options.startLineNumber = settings.selection.startLineNumber;
                options.startColumn = settings.selection.startColumn;
                options.endLineNumber = settings.selection.endLineNumber || settings.selection.startLineNumber;
                options.endColumn = settings.selection.endColumn || settings.selection.startColumn;
            }
            return options;
        };
        /**
         * Returns if this options object has objects defined for the editor.
         */
        TextEditorOptions.prototype.hasOptionsDefined = function () {
            return !!this.editorViewState || (!types.isUndefinedOrNull(this.startLineNumber) && !types.isUndefinedOrNull(this.startColumn));
        };
        /**
         * Tells the editor to set show the given selection when the editor is being opened.
         */
        TextEditorOptions.prototype.selection = function (startLineNumber, startColumn, endLineNumber, endColumn) {
            if (endLineNumber === void 0) { endLineNumber = startLineNumber; }
            if (endColumn === void 0) { endColumn = startColumn; }
            this.startLineNumber = startLineNumber;
            this.startColumn = startColumn;
            this.endLineNumber = endLineNumber;
            this.endColumn = endColumn;
            return this;
        };
        /**
         * Sets the view state to be used when the editor is opening.
         */
        TextEditorOptions.prototype.viewState = function (viewState) {
            this.editorViewState = viewState;
        };
        /**
         * Apply the view state or selection to the given editor.
         *
         * @return if something was applied
         */
        TextEditorOptions.prototype.apply = function (textEditor) {
            var gotApplied = false;
            // First try viewstate
            if (this.editorViewState) {
                textEditor.restoreViewState(this.editorViewState);
                gotApplied = true;
            }
            else if (!types.isUndefinedOrNull(this.startLineNumber) && !types.isUndefinedOrNull(this.startColumn)) {
                // Select
                if (!types.isUndefinedOrNull(this.endLineNumber) && !types.isUndefinedOrNull(this.endColumn)) {
                    var range = {
                        startLineNumber: this.startLineNumber,
                        startColumn: this.startColumn,
                        endLineNumber: this.endLineNumber,
                        endColumn: this.endColumn
                    };
                    textEditor.setSelection(range);
                    textEditor.revealRangeInCenter(range);
                }
                else {
                    var pos = {
                        lineNumber: this.startLineNumber,
                        column: this.startColumn
                    };
                    textEditor.setPosition(pos);
                    textEditor.revealPositionInCenter(pos);
                }
                gotApplied = true;
            }
            return gotApplied;
        };
        TextEditorOptions.prototype.matches = function (otherOptions) {
            if (_super.prototype.matches.call(this, otherOptions) === true) {
                return true;
            }
            if (otherOptions) {
                return otherOptions instanceof TextEditorOptions &&
                    otherOptions.startLineNumber === this.startLineNumber &&
                    otherOptions.startColumn === this.startColumn &&
                    otherOptions.endLineNumber === this.endLineNumber &&
                    otherOptions.endColumn === this.endColumn &&
                    otherOptions.preserveFocus === this.preserveFocus &&
                    otherOptions.forceOpen === this.forceOpen &&
                    objects.equals(otherOptions.editorViewState, this.editorViewState);
            }
            return false;
        };
        return TextEditorOptions;
    }(EditorOptions));
    exports.TextEditorOptions = TextEditorOptions;
    /**
     * Base Text Diff Editor Options.
     */
    var TextDiffEditorOptions = (function (_super) {
        __extends(TextDiffEditorOptions, _super);
        function TextDiffEditorOptions() {
            _super.apply(this, arguments);
        }
        /**
         * Helper to create TextDiffEditorOptions inline.
         */
        TextDiffEditorOptions.create = function (settings) {
            var options = new TextDiffEditorOptions();
            options.autoRevealFirstChange = settings.autoRevealFirstChange;
            options.preserveFocus = settings.preserveFocus;
            options.forceOpen = settings.forceOpen;
            return options;
        };
        return TextDiffEditorOptions;
    }(TextEditorOptions));
    exports.TextDiffEditorOptions = TextDiffEditorOptions;
    /**
     * Given an input, tries to get the associated URI for it (either file or untitled scheme).
     */
    function getUntitledOrFileResource(input, supportDiff) {
        if (!input) {
            return null;
        }
        // Untitled
        if (input instanceof UntitledEditorInput) {
            return input.getResource();
        }
        // File
        var fileInput = asFileEditorInput(input, supportDiff);
        return fileInput && fileInput.getResource();
    }
    exports.getUntitledOrFileResource = getUntitledOrFileResource;
    /**
     * Returns the object as IFileEditorInput only if it matches the signature.
     */
    function asFileEditorInput(obj, supportDiff) {
        if (!obj) {
            return null;
        }
        // Check for diff if we are asked to
        if (supportDiff && types.isFunction(obj.getModifiedInput)) {
            obj = obj.getModifiedInput();
        }
        var i = obj;
        return i instanceof EditorInput && types.areFunctions(i.setResource, i.setMime, i.setEncoding, i.getEncoding, i.getResource, i.getMime) ? i : null;
    }
    exports.asFileEditorInput = asFileEditorInput;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/workbench/common/editor/textEditorModel", ["require", "exports", 'vs/base/common/winjs.base', 'vs/editor/common/editorCommon', 'vs/workbench/common/editor', 'vs/editor/common/services/modeService', 'vs/editor/common/services/modelService', 'vs/editor/common/model/textModel'], function (require, exports, winjs_base_1, editorCommon_1, editor_1, modeService_1, modelService_1, textModel_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * The base text editor model leverages the monaco code editor model. This class is only intended to be subclassed and not instantiated.
     */
    var BaseTextEditorModel = (function (_super) {
        __extends(BaseTextEditorModel, _super);
        function BaseTextEditorModel(modelService, modeService, textEditorModelHandle) {
            var _this = this;
            _super.call(this);
            this.modelService = modelService;
            this.modeService = modeService;
            this.textEditorModelHandle = textEditorModelHandle;
            if (textEditorModelHandle) {
                // We need the resource to point to an existing model
                var model = modelService.getModel(textEditorModelHandle);
                if (!model) {
                    throw new Error("Document with resource " + textEditorModelHandle.toString() + " does not exist");
                }
                // Since we did not create the model, we need to listen to it disposing
                // and properly trigger our dispose function so that events get emitted
                var unbind_1 = model.addListener(editorCommon_1.EventType.ModelDispose, function () {
                    _this.textEditorModelHandle = null; // make sure we do not dispose code editor model again
                    unbind_1();
                    _this.dispose();
                });
            }
        }
        Object.defineProperty(BaseTextEditorModel.prototype, "textEditorModel", {
            get: function () {
                return this.textEditorModelHandle ? this.modelService.getModel(this.textEditorModelHandle) : null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates the text editor model with the provided value, mime (can be comma separated for multiple values) and optional resource URL.
         */
        BaseTextEditorModel.prototype.createTextEditorModel = function (value, resource, mime) {
            var _this = this;
            var firstLineText = this.getFirstLineText(value);
            // To avoid flickering, give the mode at most 50ms to load. If the mode doesn't load in 50ms, proceed creating the model with a mode promise
            return winjs_base_1.TPromise.any([winjs_base_1.TPromise.timeout(50), this.getOrCreateMode(this.modeService, mime, firstLineText)]).then(function () {
                var model = _this.modelService.createModel(value, _this.getOrCreateMode(_this.modeService, mime, firstLineText), resource);
                _this.createdEditorModel = true;
                _this.textEditorModelHandle = model.getAssociatedResource();
                return _this;
            });
        };
        BaseTextEditorModel.prototype.getFirstLineText = function (value) {
            var firstLineText = value.substr(0, 100);
            var crIndex = firstLineText.indexOf('\r');
            if (crIndex < 0) {
                crIndex = firstLineText.length;
            }
            var lfIndex = firstLineText.indexOf('\n');
            if (lfIndex < 0) {
                lfIndex = firstLineText.length;
            }
            firstLineText = firstLineText.substr(0, Math.min(crIndex, lfIndex));
            return firstLineText;
        };
        /**
         * Gets the mode for the given identifier. Subclasses can override to provide their own implementation of this lookup.
         *
         * @param firstLineText optional first line of the text buffer to set the mode on. This can be used to guess a mode from content.
         */
        BaseTextEditorModel.prototype.getOrCreateMode = function (modeService, mime, firstLineText) {
            return modeService.getOrCreateMode(mime);
        };
        /**
         * Updates the text editor model with the provided value. If the value is the same as the model has, this is a no-op.
         */
        BaseTextEditorModel.prototype.updateTextEditorModel = function (newValue) {
            if (!this.textEditorModel) {
                return;
            }
            var rawText = textModel_1.RawText.fromStringWithModelOptions(newValue, this.textEditorModel);
            // Return early if the text is already set in that form
            if (this.textEditorModel.equals(rawText)) {
                return;
            }
            // Otherwise update model
            this.textEditorModel.setValueFromRawText(rawText);
        };
        /**
         * Returns the textual value of this editor model or null if it has not yet been created.
         */
        BaseTextEditorModel.prototype.getValue = function () {
            var model = this.textEditorModel;
            if (model) {
                return model.getValue(editorCommon_1.EndOfLinePreference.TextDefined, true /* Preserve BOM */);
            }
            return null;
        };
        BaseTextEditorModel.prototype.dispose = function () {
            if (this.textEditorModelHandle && this.createdEditorModel) {
                this.modelService.destroyModel(this.textEditorModelHandle);
            }
            this.textEditorModelHandle = null;
            this.createdEditorModel = false;
            _super.prototype.dispose.call(this);
        };
        BaseTextEditorModel.prototype.isResolved = function () {
            return !!this.textEditorModelHandle;
        };
        BaseTextEditorModel = __decorate([
            __param(0, modelService_1.IModelService),
            __param(1, modeService_1.IModeService)
        ], BaseTextEditorModel);
        return BaseTextEditorModel;
    }(editor_1.EditorModel));
    exports.BaseTextEditorModel = BaseTextEditorModel;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/workbench/common/editor/resourceEditorModel", ["require", "exports", 'vs/workbench/common/editor/textEditorModel', 'vs/editor/common/services/modeService', 'vs/editor/common/services/modelService'], function (require, exports, textEditorModel_1, modeService_1, modelService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * An editor model whith an in-memory, readonly content that is backed by an existing editor model.
     */
    var ResourceEditorModel = (function (_super) {
        __extends(ResourceEditorModel, _super);
        function ResourceEditorModel(resource, modeService, modelService) {
            _super.call(this, modelService, modeService, resource);
        }
        ResourceEditorModel = __decorate([
            __param(1, modeService_1.IModeService),
            __param(2, modelService_1.IModelService)
        ], ResourceEditorModel);
        return ResourceEditorModel;
    }(textEditorModel_1.BaseTextEditorModel));
    exports.ResourceEditorModel = ResourceEditorModel;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/workbench/common/editor/resourceEditorInput", ["require", "exports", 'vs/base/common/winjs.base', 'vs/base/common/async', 'vs/workbench/common/editor', 'vs/workbench/common/editor/resourceEditorModel', 'vs/base/common/events', 'vs/platform/instantiation/common/instantiation', 'vs/editor/common/services/modelService'], function (require, exports, winjs_base_1, async_1, editor_1, resourceEditorModel_1, events_1, instantiation_1, modelService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * A read-only text editor input whos contents are made of the provided resource that points to an existing
     * code editor model.
     */
    var ResourceEditorInput = (function (_super) {
        __extends(ResourceEditorInput, _super);
        function ResourceEditorInput(name, description, resource, modelService, instantiationService) {
            _super.call(this);
            this.modelService = modelService;
            this.instantiationService = instantiationService;
            this.name = name;
            this.description = description;
            this.resource = resource;
        }
        ResourceEditorInput.registerResourceContentProvider = function (scheme, provider) {
            var array = ResourceEditorInput.registry[scheme];
            if (!array) {
                array = [provider];
                ResourceEditorInput.registry[scheme] = array;
            }
            else {
                array.unshift(provider);
            }
            return {
                dispose: function () {
                    var array = ResourceEditorInput.registry[scheme];
                    var idx = array.indexOf(provider);
                    if (idx >= 0) {
                        array.splice(idx, 1);
                        if (array.length === 0) {
                            delete ResourceEditorInput.registry[scheme];
                        }
                    }
                }
            };
        };
        ResourceEditorInput.getOrCreateModel = function (modelService, resource) {
            var model = modelService.getModel(resource);
            if (model) {
                return winjs_base_1.TPromise.as(model);
            }
            var loadingModel = ResourceEditorInput.loadingModels[resource.toString()];
            if (!loadingModel) {
                // make sure we have a provider this scheme
                // the resource uses
                var array_1 = ResourceEditorInput.registry[resource.scheme];
                if (!array_1) {
                    return winjs_base_1.TPromise.wrapError("No model with uri '" + resource + "' nor a resolver for the scheme '" + resource.scheme + "'.");
                }
                // load the model-content from the provider and cache
                // the loading such that we don't create the same model
                // twice
                ResourceEditorInput.loadingModels[resource.toString()] = loadingModel = new winjs_base_1.TPromise(function (resolve, reject) {
                    var result;
                    var lastError;
                    async_1.sequence(array_1.map(function (provider) {
                        return function () {
                            if (!result) {
                                return provider.provideTextContent(resource).then(function (value) {
                                    result = value;
                                }, function (err) {
                                    lastError = err;
                                });
                            }
                        };
                    })).then(function () {
                        if (!result && lastError) {
                            reject(lastError);
                        }
                        else {
                            resolve(result);
                        }
                    }, reject);
                }, function () {
                    // no cancellation when caching promises
                });
                // remove the cached promise 'cos the model is now
                // known to the model service (see above)
                loadingModel.then(function () { return delete ResourceEditorInput.loadingModels[resource.toString()]; }, function () { return delete ResourceEditorInput.loadingModels[resource.toString()]; });
            }
            return loadingModel;
        };
        ResourceEditorInput.prototype.getId = function () {
            return ResourceEditorInput.ID;
        };
        ResourceEditorInput.prototype.getName = function () {
            return this.name;
        };
        ResourceEditorInput.prototype.getDescription = function () {
            return this.description;
        };
        ResourceEditorInput.prototype.resolve = function (refresh) {
            var _this = this;
            // Use Cached Model
            if (this.cachedModel) {
                return winjs_base_1.TPromise.as(this.cachedModel);
            }
            // Otherwise Create Model and handle dispose event
            return ResourceEditorInput.getOrCreateModel(this.modelService, this.resource).then(function () {
                var model = _this.instantiationService.createInstance(resourceEditorModel_1.ResourceEditorModel, _this.resource);
                var unbind = model.addListener(events_1.EventType.DISPOSE, function () {
                    _this.cachedModel = null; // make sure we do not dispose model again
                    unbind();
                    _this.dispose();
                });
                // Load it
                return model.load().then(function (resolvedModel) {
                    _this.cachedModel = resolvedModel;
                    return _this.cachedModel;
                });
            });
        };
        ResourceEditorInput.prototype.matches = function (otherInput) {
            if (_super.prototype.matches.call(this, otherInput) === true) {
                return true;
            }
            if (otherInput instanceof ResourceEditorInput) {
                var otherResourceEditorInput = otherInput;
                // Compare by properties
                return otherResourceEditorInput.resource.toString() === this.resource.toString();
            }
            return false;
        };
        ResourceEditorInput.prototype.dispose = function () {
            if (this.cachedModel) {
                this.cachedModel.dispose();
                this.cachedModel = null;
            }
            _super.prototype.dispose.call(this);
        };
        // --- registry logic
        // todo@joh,ben this should maybe be a service that is in charge of loading/resolving a uri from a scheme
        ResourceEditorInput.loadingModels = Object.create(null);
        ResourceEditorInput.registry = Object.create(null);
        ResourceEditorInput.ID = 'workbench.editors.resourceEditorInput';
        ResourceEditorInput = __decorate([
            __param(3, modelService_1.IModelService),
            __param(4, instantiation_1.IInstantiationService)
        ], ResourceEditorInput);
        return ResourceEditorInput;
    }(editor_1.EditorInput));
    exports.ResourceEditorInput = ResourceEditorInput;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/workbench/common/editor/stringEditorModel", ["require", "exports", 'vs/base/common/winjs.base', 'vs/workbench/common/editor/textEditorModel', 'vs/editor/common/core/position', 'vs/editor/common/core/range', 'vs/editor/common/services/modeService', 'vs/editor/common/services/modelService', 'vs/editor/common/core/editOperation'], function (require, exports, winjs_base_1, textEditorModel_1, position_1, range_1, modeService_1, modelService_1, editOperation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * An editor model whith an in-memory, readonly content that is not backed by any particular resource.
     */
    var StringEditorModel = (function (_super) {
        __extends(StringEditorModel, _super);
        function StringEditorModel(value, mime, resource, modeService, modelService) {
            _super.call(this, modelService, modeService);
            this.value = value;
            this.mime = mime;
            this.resource = resource;
        }
        /**
         * The value of this string editor model.
         */
        StringEditorModel.prototype.getValue = function () {
            return this.value;
        };
        /**
         * Sets the value of this string editor model.
         */
        StringEditorModel.prototype.setValue = function (value) {
            this.value = value;
            if (this.textEditorModel) {
                this.textEditorModel.setValue(value);
            }
        };
        /**
         * Appends value to this string editor model.
         */
        StringEditorModel.prototype.append = function (value) {
            this.value += value;
            if (this.textEditorModel) {
                var model = this.textEditorModel;
                var lastLine = model.getLineCount();
                var lastLineMaxColumn = model.getLineMaxColumn(lastLine);
                model.applyEdits([editOperation_1.EditOperation.insert(new position_1.Position(lastLine, lastLineMaxColumn), value)]);
            }
        };
        /**
         * Clears the value of this string editor model
         */
        StringEditorModel.prototype.clearValue = function () {
            this.value = '';
            if (this.textEditorModel) {
                var model = this.textEditorModel;
                var lastLine = model.getLineCount();
                model.applyEdits([editOperation_1.EditOperation.delete(new range_1.Range(1, 1, lastLine, model.getLineMaxColumn(lastLine)))]);
            }
        };
        /**
         * Removes all lines from the top if the line number exceeds the given line count. Returns the new value if lines got trimmed.
         */
        StringEditorModel.prototype.trim = function (linecount) {
            if (this.textEditorModel) {
                var model = this.textEditorModel;
                var lastLine = model.getLineCount();
                if (lastLine > linecount) {
                    model.applyEdits([editOperation_1.EditOperation.delete(new range_1.Range(1, 1, lastLine - linecount + 1, 1))]);
                    var newValue = model.getValue();
                    this.value = newValue;
                    return this.value;
                }
            }
            return null;
        };
        StringEditorModel.prototype.getMime = function () {
            return this.mime;
        };
        StringEditorModel.prototype.load = function () {
            // Create text editor model if not yet done
            if (!this.textEditorModel) {
                return this.createTextEditorModel(this.value, this.resource, this.mime);
            }
            else {
                this.updateTextEditorModel(this.value);
            }
            return winjs_base_1.TPromise.as(this);
        };
        StringEditorModel = __decorate([
            __param(3, modeService_1.IModeService),
            __param(4, modelService_1.IModelService)
        ], StringEditorModel);
        return StringEditorModel;
    }(textEditorModel_1.BaseTextEditorModel));
    exports.StringEditorModel = StringEditorModel;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("vs/workbench/common/events", ["require", "exports", 'vs/base/common/events'], function (require, exports, events_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * All workbench events are listed here. For DOM events, see Monaco.Base.DomUtils.EventType.
     */
    var EventType = (function () {
        function EventType() {
        }
        /**
         * Event type for when an editor is opened. This event is only sent once for a specific editor type until another
         * editor type gets opened. For example, when the user opens a file, the editorOpened event will be sent. If another
         * file is opened, this event will not be fired again. If the user opens, e.g. the diff editor, editorOpened will be
         * fired, since another editor type opened.
         */
        EventType.EDITOR_OPENED = 'editorOpened';
        /**
         * Event type for when an editor is closed because another editor type is opened.
         */
        EventType.EDITOR_CLOSED = 'editorClosed';
        /**
         * Event to indciate that an editor input is about to open. This event can be prevented to do something else instead.
         */
        EventType.EDITOR_INPUT_OPENING = 'editorInputOpening';
        /**
         * Event type for when the editor input is about to change. This event is being sent before (!) the input is being set
         * to the active editor. Use EDITOR_INPUT_CHANGED to react after the input has been set and displayed by the editor.
         *
         * Note: This event will also be emitted when multiple editors are open and the user sets focus from the active editor
         * to another one. This allows to detect a focus change of the active editor.
         */
        EventType.EDITOR_INPUT_CHANGING = 'editorInputChanging';
        /**
         * Event type to indicate that the editor options of the current active editor are changing.
         */
        EventType.EDITOR_OPTIONS_CHANGING = 'editorOptionsChanging';
        /**
         * Event type for when the editor input has been changed in the currently active editor. This event is being sent after
         * the input has been set and displayed by the editor.
         *
         * Note: This event will also be emitted when multiple editors are open and the user sets focus from the active editor
         * to another one. This allows to detect a focus change of the active editor.
         */
        EventType.EDITOR_INPUT_CHANGED = 'editorInputChanged';
        /**
         * Event type for when the editor input state changed.
         */
        EventType.EDITOR_INPUT_STATE_CHANGED = 'editorInputStateChanged';
        /**
         * Event type for when the editor input failed to be set to the editor.
         */
        EventType.EDITOR_SET_INPUT_ERROR = 'editorSetInputError';
        /**
         * Event type for when the editor position has been changed
         */
        EventType.EDITOR_POSITION_CHANGED = 'editorPositionChanged';
        /**
         * An event type that fires when a text editor changes its selection.
         */
        EventType.TEXT_EDITOR_SELECTION_CHANGED = 'textEditorSelectionChanged';
        /**
         * An event type that fires when a text editor mode changes.
         */
        EventType.TEXT_EDITOR_MODE_CHANGED = 'textEditorModeChanged';
        /**
         * An event type that fires when a text editor content changes.
         */
        EventType.TEXT_EDITOR_CONTENT_CHANGED = 'textEditorContentChanged';
        /**
         * An event type that fires when a text editor content options changed.
         */
        EventType.TEXT_EDITOR_CONTENT_OPTIONS_CHANGED = 'textEditorContentOptionsChanged';
        /**
         * An event type that fires when a text editor's configuration changes.
         */
        EventType.TEXT_EDITOR_CONFIGURATION_CHANGED = 'textEditorOptionsChanged';
        /**
         * Event type for when a composite is about to open.
         */
        EventType.COMPOSITE_OPENING = 'compositeOpening';
        /**
         * Event type for when a composite is opened.
         */
        EventType.COMPOSITE_OPENED = 'compositeOpened';
        /**
         * Event type for when a composite is closed.
         */
        EventType.COMPOSITE_CLOSED = 'compositeClosed';
        /**
         * Event type for when the workbench has been fully created.
         */
        EventType.WORKBENCH_CREATED = 'workbenchCreated';
        /**
         * Event type for when the workbench is about to being disposed.
         */
        EventType.WORKBENCH_DISPOSING = 'workbenchDisposing';
        /**
         * Event type for when the workbench is fully disposed.
         */
        EventType.WORKBENCH_DISPOSED = 'workbenchDisposed';
        /**
         * Event type for when an untitled file is becoming dirty.
         */
        EventType.UNTITLED_FILE_DIRTY = 'untitledFileDirty';
        /**
         * Event type for when an untitled file is deleted.
         */
        EventType.UNTITLED_FILE_DELETED = 'untitledFileDeleted';
        /**
         * Event type for when a resources encoding changes.
         */
        EventType.RESOURCE_ENCODING_CHANGED = 'resourceEncodingChanged';
        /**
         * Event type for when the workbench options change. Listeners should refresh their
         * assumption on workbench options after this event is emitted.
         */
        EventType.WORKBENCH_OPTIONS_CHANGED = 'workbenchOptionsChanged';
        return EventType;
    }());
    exports.EventType = EventType;
    /**
     * Editor events are being emitted when the editor input changes, shows, is being saved or when the editor content changes.
     */
    var EditorEvent = (function (_super) {
        __extends(EditorEvent, _super);
        function EditorEvent(editor, editorId, editorInput, editorOptions, position, originalEvent) {
            _super.call(this, originalEvent);
            this.editor = editor;
            this.editorId = editorId;
            this.editorInput = editorInput;
            this.editorOptions = editorOptions;
            this.position = position;
        }
        EditorEvent.prototype.prevent = function () {
            this.prevented = true;
        };
        EditorEvent.prototype.isPrevented = function () {
            return this.prevented;
        };
        return EditorEvent;
    }(events_1.Event));
    exports.EditorEvent = EditorEvent;
    /**
     * Editor input events are being emitted when the editor input state changes.
     */
    var EditorInputEvent = (function (_super) {
        __extends(EditorInputEvent, _super);
        function EditorInputEvent(editorInput, originalEvent) {
            _super.call(this, originalEvent);
            this.editorInput = editorInput;
        }
        return EditorInputEvent;
    }(events_1.Event));
    exports.EditorInputEvent = EditorInputEvent;
    /**
     * A subclass of EditorEvent for text editor selection changes.
     */
    var TextEditorSelectionEvent = (function (_super) {
        __extends(TextEditorSelectionEvent, _super);
        function TextEditorSelectionEvent(selection, editor, editorId, editorInput, editorOptions, position, originalEvent) {
            _super.call(this, editor, editorId, editorInput, editorOptions, position, originalEvent);
            this.selection = selection;
        }
        return TextEditorSelectionEvent;
    }(EditorEvent));
    exports.TextEditorSelectionEvent = TextEditorSelectionEvent;
    /**
     * Option change events are send when the options in the running instance change.
     */
    var OptionsChangeEvent = (function (_super) {
        __extends(OptionsChangeEvent, _super);
        function OptionsChangeEvent(key, before, after, originalEvent) {
            _super.call(this, originalEvent);
            this.key = key;
            this.before = before;
            this.after = after;
        }
        return OptionsChangeEvent;
    }(events_1.Event));
    exports.OptionsChangeEvent = OptionsChangeEvent;
    /**
     * Command events are emitted when an action is being executed through a command handler (Keybinding).
     */
    var CommandEvent = (function (_super) {
        __extends(CommandEvent, _super);
        function CommandEvent(actionId, originalEvent) {
            _super.call(this, originalEvent);
            this.actionId = actionId;
        }
        return CommandEvent;
    }(events_1.Event));
    exports.CommandEvent = CommandEvent;
    /**
     * Composite events are emitted when a composite opens or closes in the sidebar or panel.
     */
    var CompositeEvent = (function (_super) {
        __extends(CompositeEvent, _super);
        function CompositeEvent(compositeId, originalEvent) {
            _super.call(this, originalEvent);
            this.compositeId = compositeId;
        }
        return CompositeEvent;
    }(events_1.Event));
    exports.CompositeEvent = CompositeEvent;
    var ResourceEvent = (function (_super) {
        __extends(ResourceEvent, _super);
        function ResourceEvent(resource, originalEvent) {
            _super.call(this, originalEvent);
            this.resource = resource;
        }
        return ResourceEvent;
    }(events_1.Event));
    exports.ResourceEvent = ResourceEvent;
    var UntitledEditorEvent = (function (_super) {
        __extends(UntitledEditorEvent, _super);
        function UntitledEditorEvent() {
            _super.apply(this, arguments);
        }
        return UntitledEditorEvent;
    }(ResourceEvent));
    exports.UntitledEditorEvent = UntitledEditorEvent;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/workbench/common/editor/untitledEditorModel", ["require", "exports", 'vs/workbench/common/editor/stringEditorModel', 'vs/editor/common/editorCommon', 'vs/workbench/common/events', 'vs/platform/configuration/common/configuration', 'vs/platform/event/common/event', 'vs/editor/common/services/modeService', 'vs/editor/common/services/modelService'], function (require, exports, stringEditorModel_1, editorCommon_1, events_1, configuration_1, event_1, modeService_1, modelService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var UntitledEditorModel = (function (_super) {
        __extends(UntitledEditorModel, _super);
        function UntitledEditorModel(value, modeId, resource, hasAssociatedFilePath, modeService, modelService, eventService, configurationService) {
            _super.call(this, value, modeId, resource, modeService, modelService);
            this.eventService = eventService;
            this.configurationService = configurationService;
            this.dirty = hasAssociatedFilePath; // untitled associated to file path are dirty right away
            this.registerListeners();
        }
        UntitledEditorModel.prototype.registerListeners = function () {
            var _this = this;
            // Config Changes
            this.configurationChangeListenerUnbind = this.configurationService.addListener(configuration_1.ConfigurationServiceEventTypes.UPDATED, function (e) { return _this.onConfigurationChange(e.config); });
        };
        UntitledEditorModel.prototype.onConfigurationChange = function (configuration) {
            this.configuredEncoding = configuration && configuration.files && configuration.files.encoding;
        };
        UntitledEditorModel.prototype.getValue = function () {
            if (this.textEditorModel) {
                return this.textEditorModel.getValue(editorCommon_1.EndOfLinePreference.TextDefined, true /* Preserve BOM */);
            }
            return null;
        };
        UntitledEditorModel.prototype.getModeId = function () {
            if (this.textEditorModel) {
                return this.textEditorModel.getModeId();
            }
            return null;
        };
        UntitledEditorModel.prototype.getEncoding = function () {
            return this.preferredEncoding || this.configuredEncoding;
        };
        UntitledEditorModel.prototype.setEncoding = function (encoding) {
            var oldEncoding = this.getEncoding();
            this.preferredEncoding = encoding;
            // Emit if it changed
            if (oldEncoding !== this.preferredEncoding) {
                this.eventService.emit(events_1.EventType.RESOURCE_ENCODING_CHANGED, new events_1.ResourceEvent(this.resource));
            }
        };
        UntitledEditorModel.prototype.isDirty = function () {
            return this.dirty;
        };
        UntitledEditorModel.prototype.load = function () {
            var _this = this;
            return _super.prototype.load.call(this).then(function (model) {
                return _this.configurationService.loadConfiguration().then(function (configuration) {
                    // Encoding
                    _this.configuredEncoding = configuration && configuration.files && configuration.files.encoding;
                    // Listen to content changes
                    _this.textModelChangeListener = _this.textEditorModel.addListener(editorCommon_1.EventType.ModelContentChanged, function (e) { return _this.onModelContentChanged(e); });
                    // Emit initial dirty event if we are
                    if (_this.dirty) {
                        setTimeout(function () {
                            _this.eventService.emit(events_1.EventType.UNTITLED_FILE_DIRTY, new events_1.UntitledEditorEvent(_this.resource));
                        }, 0 /* prevent race condition between creating model and emitting dirty event */);
                    }
                    return model;
                });
            });
        };
        UntitledEditorModel.prototype.onModelContentChanged = function (e) {
            if (!this.dirty) {
                this.dirty = true;
                this.eventService.emit(events_1.EventType.UNTITLED_FILE_DIRTY, new events_1.UntitledEditorEvent(this.resource));
            }
        };
        UntitledEditorModel.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            if (this.textModelChangeListener) {
                this.textModelChangeListener();
                this.textModelChangeListener = null;
            }
            if (this.configurationChangeListenerUnbind) {
                this.configurationChangeListenerUnbind();
                this.configurationChangeListenerUnbind = null;
            }
            this.eventService.emit(events_1.EventType.UNTITLED_FILE_DELETED, new events_1.UntitledEditorEvent(this.resource));
        };
        UntitledEditorModel = __decorate([
            __param(4, modeService_1.IModeService),
            __param(5, modelService_1.IModelService),
            __param(6, event_1.IEventService),
            __param(7, configuration_1.IConfigurationService)
        ], UntitledEditorModel);
        return UntitledEditorModel;
    }(stringEditorModel_1.StringEditorModel));
    exports.UntitledEditorModel = UntitledEditorModel;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/workbench/common/editor/untitledEditorInput", ["require", "exports", 'vs/base/common/winjs.base', 'vs/base/common/mime', 'vs/base/common/labels', 'vs/base/common/paths', 'vs/workbench/common/editor', 'vs/workbench/common/editor/untitledEditorModel', 'vs/platform/instantiation/common/instantiation', 'vs/platform/lifecycle/common/lifecycle', 'vs/platform/workspace/common/workspace', 'vs/editor/common/services/modeService'], function (require, exports, winjs_base_1, mime_1, labels, paths, editor_1, untitledEditorModel_1, instantiation_1, lifecycle_1, workspace_1, modeService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * An editor input to be used for untitled text buffers.
     */
    var UntitledEditorInput = (function (_super) {
        __extends(UntitledEditorInput, _super);
        function UntitledEditorInput(resource, hasAssociatedFilePath, modeId, instantiationService, lifecycleService, contextService, modeService) {
            _super.call(this);
            this.instantiationService = instantiationService;
            this.lifecycleService = lifecycleService;
            this.contextService = contextService;
            this.modeService = modeService;
            this.resource = resource;
            this.hasAssociatedFilePath = hasAssociatedFilePath;
            this.modeId = modeId;
        }
        UntitledEditorInput.prototype.getId = function () {
            return UntitledEditorInput.ID;
        };
        UntitledEditorInput.prototype.getResource = function () {
            return this.resource;
        };
        UntitledEditorInput.prototype.getName = function () {
            return this.hasAssociatedFilePath ? paths.basename(this.resource.fsPath) : this.resource.fsPath;
        };
        UntitledEditorInput.prototype.getDescription = function () {
            return this.hasAssociatedFilePath ? labels.getPathLabel(paths.dirname(this.resource.fsPath), this.contextService) : null;
        };
        UntitledEditorInput.prototype.isDirty = function () {
            return this.cachedModel && this.cachedModel.isDirty();
        };
        UntitledEditorInput.prototype.getStatus = function () {
            var isDirty = this.isDirty();
            if (isDirty) {
                return { state: 'dirty', decoration: '\u25cf' };
            }
            return null;
        };
        UntitledEditorInput.prototype.suggestFileName = function () {
            if (!this.hasAssociatedFilePath) {
                var mime = this.getMime();
                if (mime && mime !== mime_1.MIME_TEXT /* do not suggest when the mime type is simple plain text */) {
                    return mime_1.suggestFilename(mime, this.getName());
                }
            }
            return this.getName();
        };
        UntitledEditorInput.prototype.getMime = function () {
            if (this.cachedModel) {
                return this.modeService.getMimeForMode(this.cachedModel.getModeId());
            }
            return null;
        };
        UntitledEditorInput.prototype.getEncoding = function () {
            if (this.cachedModel) {
                return this.cachedModel.getEncoding();
            }
            return null;
        };
        UntitledEditorInput.prototype.setEncoding = function (encoding, mode /* ignored, we only have Encode */) {
            if (this.cachedModel) {
                this.cachedModel.setEncoding(encoding);
            }
        };
        UntitledEditorInput.prototype.resolve = function (refresh) {
            var _this = this;
            // Use Cached Model
            if (this.cachedModel) {
                return winjs_base_1.TPromise.as(this.cachedModel);
            }
            // Otherwise Create Model and load
            var model = this.createModel();
            return model.load().then(function (resolvedModel) {
                _this.cachedModel = resolvedModel;
                return _this.cachedModel;
            });
        };
        UntitledEditorInput.prototype.createModel = function () {
            var content = '';
            var mime = this.modeId;
            if (!mime && this.hasAssociatedFilePath) {
                var mimeFromPath = mime_1.guessMimeTypes(this.resource.fsPath)[0];
                if (!mime_1.isUnspecific(mimeFromPath)) {
                    mime = mimeFromPath; // take most specific mime type if file path is associated and mime is specific
                }
            }
            return this.instantiationService.createInstance(untitledEditorModel_1.UntitledEditorModel, content, mime || mime_1.MIME_TEXT, this.resource, this.hasAssociatedFilePath);
        };
        UntitledEditorInput.prototype.matches = function (otherInput) {
            if (_super.prototype.matches.call(this, otherInput) === true) {
                return true;
            }
            if (otherInput instanceof UntitledEditorInput) {
                var otherUntitledEditorInput = otherInput;
                // Otherwise compare by properties
                return otherUntitledEditorInput.resource.toString() === this.resource.toString();
            }
            return false;
        };
        UntitledEditorInput.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            if (this.cachedModel) {
                this.cachedModel.dispose();
                this.cachedModel = null;
            }
        };
        UntitledEditorInput.ID = 'workbench.editors.untitledEditorInput';
        UntitledEditorInput.SCHEMA = 'untitled';
        UntitledEditorInput = __decorate([
            __param(3, instantiation_1.IInstantiationService),
            __param(4, lifecycle_1.ILifecycleService),
            __param(5, workspace_1.IWorkspaceContextService),
            __param(6, modeService_1.IModeService)
        ], UntitledEditorInput);
        return UntitledEditorInput;
    }(editor_1.UntitledEditorInput));
    exports.UntitledEditorInput = UntitledEditorInput;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("vs/workbench/node/extensionPoints", ["require", "exports", 'vs/nls!vs/workbench/node/extensionPoints', 'vs/base/common/platform', 'vs/base/node/pfs', 'vs/base/common/severity', 'vs/base/common/winjs.base', 'vs/base/common/collections', 'vs/base/common/paths', 'vs/base/common/json', 'vs/base/common/types', 'vs/platform/extensions/node/extensionValidator', 'semver'], function (require, exports, nls, Platform, pfs, severity_1, winjs_base_1, collections_1, paths, json, Types, extensionValidator_1, semver) {
    'use strict';
    var MANIFEST_FILE = 'package.json';
    var devMode = !!process.env['VSCODE_DEV'];
    var nlsConfig = {
        locale: Platform.locale,
        pseudo: Platform.locale === 'pseudo'
    };
    var MessagesCollector = (function () {
        function MessagesCollector() {
            this._messages = [];
        }
        MessagesCollector.prototype.getMessages = function () {
            return this._messages;
        };
        MessagesCollector.prototype._msg = function (source, type, message) {
            this._messages.push({
                type: type,
                message: message,
                source: source
            });
        };
        MessagesCollector.prototype.error = function (source, message) {
            this._msg(source, severity_1.default.Error, message);
        };
        MessagesCollector.prototype.warn = function (source, message) {
            this._msg(source, severity_1.default.Warning, message);
        };
        MessagesCollector.prototype.info = function (source, message) {
            this._msg(source, severity_1.default.Info, message);
        };
        return MessagesCollector;
    }());
    exports.MessagesCollector = MessagesCollector;
    var ExtensionManifestHandler = (function () {
        function ExtensionManifestHandler(ourVersion, collector, absoluteFolderPath, isBuiltin) {
            this._ourVersion = ourVersion;
            this._collector = collector;
            this._absoluteFolderPath = absoluteFolderPath;
            this._isBuiltin = isBuiltin;
            this._absoluteManifestPath = paths.join(absoluteFolderPath, MANIFEST_FILE);
        }
        return ExtensionManifestHandler;
    }());
    var ExtensionManifestParser = (function (_super) {
        __extends(ExtensionManifestParser, _super);
        function ExtensionManifestParser() {
            _super.apply(this, arguments);
        }
        ExtensionManifestParser.prototype.parse = function () {
            var _this = this;
            return pfs.readFile(this._absoluteManifestPath).then(function (manifestContents) {
                var errors = [];
                var extensionDescription = json.parse(manifestContents.toString(), errors);
                if (errors.length > 0) {
                    errors.forEach(function (error) {
                        _this._collector.error(_this._absoluteFolderPath, nls.localize(0, null, _this._absoluteManifestPath, error));
                    });
                    return null;
                }
                return extensionDescription;
            }, function (err) {
                _this._collector.error(_this._absoluteFolderPath, nls.localize(1, null, _this._absoluteManifestPath, err.message));
                return null;
            });
        };
        return ExtensionManifestParser;
    }(ExtensionManifestHandler));
    var ExtensionManifestNLSReplacer = (function (_super) {
        __extends(ExtensionManifestNLSReplacer, _super);
        function ExtensionManifestNLSReplacer() {
            _super.apply(this, arguments);
        }
        ExtensionManifestNLSReplacer.prototype.replaceNLS = function (extensionDescription) {
            var _this = this;
            var extension = paths.extname(this._absoluteManifestPath);
            var basename = this._absoluteManifestPath.substr(0, this._absoluteManifestPath.length - extension.length);
            return pfs.fileExists(basename + '.nls' + extension).then(function (exists) {
                if (!exists) {
                    return extensionDescription;
                }
                return ExtensionManifestNLSReplacer.findMessageBundle(basename).then(function (messageBundle) {
                    if (!messageBundle) {
                        return extensionDescription;
                    }
                    return pfs.readFile(messageBundle).then(function (messageBundleContent) {
                        var errors = [];
                        var messages = json.parse(messageBundleContent.toString(), errors);
                        if (errors.length > 0) {
                            errors.forEach(function (error) {
                                _this._collector.error(_this._absoluteFolderPath, nls.localize(2, null, messageBundle, error));
                            });
                            return extensionDescription;
                        }
                        ExtensionManifestNLSReplacer._replaceNLStrings(extensionDescription, messages, _this._collector, _this._absoluteFolderPath);
                        return extensionDescription;
                    }, function (err) {
                        _this._collector.error(_this._absoluteFolderPath, nls.localize(3, null, messageBundle, err.message));
                        return null;
                    });
                });
            });
        };
        ExtensionManifestNLSReplacer.findMessageBundle = function (basename) {
            return new winjs_base_1.TPromise(function (c, e, p) {
                function loop(basename, locale) {
                    var toCheck = basename + ".nls." + locale + ".json";
                    pfs.fileExists(toCheck).then(function (exists) {
                        if (exists) {
                            c(toCheck);
                        }
                        var index = locale.lastIndexOf('-');
                        if (index === -1) {
                            c(basename + ".nls.json");
                        }
                        else {
                            locale = locale.substring(0, index);
                            loop(basename, locale);
                        }
                    });
                }
                if (devMode || nlsConfig.pseudo || !nlsConfig.locale) {
                    return c(basename + '.nls.json');
                }
                loop(basename, nlsConfig.locale);
            });
        };
        /**
         * This routine make the following assumptions:
         * The root element is a object literal
         * Strings to replace are one values of a key. So for example string[] are ignored.
         * This is done to speed things up.
         */
        ExtensionManifestNLSReplacer._replaceNLStrings = function (literal, messages, collector, messageScope) {
            Object.keys(literal).forEach(function (key) {
                if (literal.hasOwnProperty(key)) {
                    var value = literal[key];
                    if (Types.isString(value)) {
                        var str = value;
                        var length_1 = str.length;
                        if (length_1 > 1 && str[0] === '%' && str[length_1 - 1] === '%') {
                            var messageKey = str.substr(1, length_1 - 2);
                            var message = messages[messageKey];
                            if (message) {
                                if (nlsConfig.pseudo) {
                                    // FF3B and FF3D is the Unicode zenkaku representation for [ and ]
                                    message = '\uFF3B' + message.replace(/[aouei]/g, '$&$&') + '\uFF3D';
                                }
                                literal[key] = message;
                            }
                            else {
                                collector.warn(messageScope, nls.localize(4, null, messageKey));
                            }
                        }
                    }
                    else if (Types.isObject(value)) {
                        ExtensionManifestNLSReplacer._replaceNLStrings(value, messages, collector, messageScope);
                    }
                    else if (Types.isArray(value)) {
                        value.forEach(function (element) {
                            if (Types.isObject(element)) {
                                ExtensionManifestNLSReplacer._replaceNLStrings(element, messages, collector, messageScope);
                            }
                        });
                    }
                }
            });
        };
        return ExtensionManifestNLSReplacer;
    }(ExtensionManifestHandler));
    var ExtensionManifestValidator = (function (_super) {
        __extends(ExtensionManifestValidator, _super);
        function ExtensionManifestValidator() {
            _super.apply(this, arguments);
        }
        ExtensionManifestValidator.prototype.validate = function (extensionDescription) {
            var _this = this;
            extensionDescription.isBuiltin = this._isBuiltin;
            var notices = [];
            if (!extensionValidator_1.isValidExtensionDescription(this._ourVersion, this._absoluteFolderPath, extensionDescription, notices)) {
                notices.forEach(function (error) {
                    _this._collector.error(_this._absoluteFolderPath, error);
                });
                return null;
            }
            // in this case the notices are warnings
            notices.forEach(function (error) {
                _this._collector.warn(_this._absoluteFolderPath, error);
            });
            // id := `publisher.name`
            extensionDescription.id = extensionDescription.publisher + "." + extensionDescription.name;
            // main := absolutePath(`main`)
            if (extensionDescription.main) {
                extensionDescription.main = paths.normalize(paths.join(this._absoluteFolderPath, extensionDescription.main));
            }
            extensionDescription.extensionFolderPath = this._absoluteFolderPath;
            return extensionDescription;
        };
        return ExtensionManifestValidator;
    }(ExtensionManifestHandler));
    var ExtensionScanner = (function () {
        function ExtensionScanner() {
        }
        /**
         * Read the extension defined in `absoluteFolderPath`
         */
        ExtensionScanner.scanExtension = function (version, collector, absoluteFolderPath, isBuiltin) {
            absoluteFolderPath = paths.normalize(absoluteFolderPath);
            var parser = new ExtensionManifestParser(version, collector, absoluteFolderPath, isBuiltin);
            return parser.parse().then(function (extensionDescription) {
                if (extensionDescription === null) {
                    return null;
                }
                var nlsReplacer = new ExtensionManifestNLSReplacer(version, collector, absoluteFolderPath, isBuiltin);
                return nlsReplacer.replaceNLS(extensionDescription);
            }).then(function (extensionDescription) {
                if (extensionDescription === null) {
                    return null;
                }
                var validator = new ExtensionManifestValidator(version, collector, absoluteFolderPath, isBuiltin);
                return validator.validate(extensionDescription);
            });
        };
        /**
         * Scan a list of extensions defined in `absoluteFolderPath`
         */
        ExtensionScanner.scanExtensions = function (version, collector, absoluteFolderPath, isBuiltin) {
            var _this = this;
            var obsolete = winjs_base_1.TPromise.as({});
            if (!isBuiltin) {
                obsolete = pfs.readFile(paths.join(absoluteFolderPath, '.obsolete'), 'utf8')
                    .then(function (raw) { return JSON.parse(raw); })
                    .then(null, function (err) { return ({}); });
            }
            return obsolete.then(function (obsolete) {
                return pfs.readDirsInDir(absoluteFolderPath)
                    .then(function (folders) { return winjs_base_1.TPromise.join(folders.map(function (f) { return _this.scanExtension(version, collector, paths.join(absoluteFolderPath, f), isBuiltin); })); })
                    .then(function (extensionDescriptions) { return extensionDescriptions.filter(function (item) { return item !== null; }); })
                    .then(function (extensionDescriptions) { return extensionDescriptions.filter(function (p) { return !obsolete[(p.publisher + "." + p.name + "-" + p.version)]; }); })
                    .then(function (extensionDescriptions) {
                    var extensionDescriptionsById = collections_1.values(collections_1.groupBy(extensionDescriptions, function (p) { return p.id; }));
                    return extensionDescriptionsById.map(function (p) { return p.sort(function (a, b) { return semver.rcompare(a.version, b.version); })[0]; });
                })
                    .then(null, function (err) {
                    collector.error(absoluteFolderPath, err);
                    return [];
                });
            });
        };
        /**
         * Combination of scanExtension and scanExtensions: If an extension manifest is found at root, we load just this extension,
         * otherwise we assume the folder contains multiple extensions.
         */
        ExtensionScanner.scanOneOrMultipleExtensions = function (version, collector, absoluteFolderPath, isBuiltin) {
            var _this = this;
            return pfs.fileExists(paths.join(absoluteFolderPath, MANIFEST_FILE)).then(function (exists) {
                if (exists) {
                    return _this.scanExtension(version, collector, absoluteFolderPath, isBuiltin).then(function (extensionDescription) {
                        if (extensionDescription === null) {
                            return [];
                        }
                        return [extensionDescription];
                    });
                }
                return _this.scanExtensions(version, collector, absoluteFolderPath, isBuiltin);
            }, function (err) {
                collector.error(absoluteFolderPath, err);
                return [];
            });
        };
        return ExtensionScanner;
    }());
    exports.ExtensionScanner = ExtensionScanner;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/workbench/node/userSettings", ["require", "exports", 'fs', 'path', 'vs/base/common/json', 'vs/base/common/objects', 'vs/base/common/winjs.base', 'vs/base/common/event'], function (require, exports, fs, path, json, objects, winjs_base_1, event_1) {
    'use strict';
    var UserSettings = (function () {
        function UserSettings(appSettingsPath, appKeybindingsPath) {
            this.appSettingsPath = appSettingsPath;
            this.appKeybindingsPath = appKeybindingsPath;
            this._onChange = new event_1.Emitter();
            this.registerWatchers();
        }
        UserSettings.getValue = function (contextService, key, fallback) {
            return new winjs_base_1.TPromise(function (c, e) {
                var appSettingsPath = contextService.getConfiguration().env.appSettingsPath;
                fs.readFile(appSettingsPath, function (error /* ignore */, fileContents) {
                    var root = Object.create(null);
                    var content = fileContents ? fileContents.toString() : '{}';
                    var contents = Object.create(null);
                    try {
                        contents = json.parse(content);
                    }
                    catch (error) {
                    }
                    for (var key_1 in contents) {
                        UserSettings.setNode(root, key_1, contents[key_1]);
                    }
                    return c(UserSettings.doGetValue(root, key, fallback));
                });
            });
        };
        Object.defineProperty(UserSettings.prototype, "onChange", {
            get: function () {
                return this._onChange.event;
            },
            enumerable: true,
            configurable: true
        });
        UserSettings.prototype.getValue = function (key, fallback) {
            return UserSettings.doGetValue(this.globalSettings.settings, key, fallback);
        };
        UserSettings.doGetValue = function (globalSettings, key, fallback) {
            if (!key) {
                return fallback;
            }
            var value = globalSettings;
            var parts = key.split('\.');
            while (parts.length && value) {
                var part = parts.shift();
                value = value[part];
            }
            return typeof value !== 'undefined' ? value : fallback;
        };
        UserSettings.prototype.registerWatchers = function () {
            var _this = this;
            this.watcher = fs.watch(path.dirname(this.appSettingsPath));
            this.watcher.on('change', function (eventType, fileName) { return _this.onSettingsFileChange(eventType, fileName); });
        };
        UserSettings.prototype.onSettingsFileChange = function (eventType, fileName) {
            var _this = this;
            // we can get multiple change events for one change, so we buffer through a timeout
            if (this.timeoutHandle) {
                global.clearTimeout(this.timeoutHandle);
                this.timeoutHandle = null;
            }
            this.timeoutHandle = global.setTimeout(function () {
                // Reload
                var didChange = _this.loadSync();
                // Emit event
                if (didChange) {
                    _this._onChange.fire(_this.globalSettings);
                }
            }, UserSettings.CHANGE_BUFFER_DELAY);
        };
        UserSettings.prototype.loadSync = function () {
            var loadedSettings = this.doLoadSync();
            if (!objects.equals(loadedSettings, this.globalSettings)) {
                // Keep in class
                this.globalSettings = loadedSettings;
                return true; // changed value
            }
            return false; // no changed value
        };
        UserSettings.prototype.doLoadSync = function () {
            var settings = this.doLoadSettingsSync();
            return {
                settings: settings.contents,
                settingsParseErrors: settings.parseErrors,
                keybindings: this.doLoadKeybindingsSync()
            };
        };
        UserSettings.prototype.doLoadSettingsSync = function () {
            var root = Object.create(null);
            var content = '{}';
            try {
                content = fs.readFileSync(this.appSettingsPath).toString();
            }
            catch (error) {
            }
            var contents = Object.create(null);
            try {
                contents = json.parse(content);
            }
            catch (error) {
                // parse problem
                return {
                    contents: Object.create(null),
                    parseErrors: [this.appSettingsPath]
                };
            }
            for (var key in contents) {
                UserSettings.setNode(root, key, contents[key]);
            }
            return {
                contents: root
            };
        };
        UserSettings.setNode = function (root, key, value) {
            var segments = key.split('.');
            var last = segments.pop();
            var curr = root;
            segments.forEach(function (s) {
                var obj = curr[s];
                switch (typeof obj) {
                    case 'undefined':
                        obj = curr[s] = {};
                        break;
                    case 'object':
                        break;
                    default:
                        console.log('Conflicting user settings: ' + key + ' at ' + s + ' with ' + JSON.stringify(obj));
                }
                curr = obj;
            });
            curr[last] = value;
        };
        UserSettings.prototype.doLoadKeybindingsSync = function () {
            try {
                return json.parse(fs.readFileSync(this.appKeybindingsPath).toString());
            }
            catch (error) {
            }
            return [];
        };
        UserSettings.prototype.dispose = function () {
            if (this.watcher) {
                this.watcher.close();
                this.watcher = null;
            }
        };
        UserSettings.CHANGE_BUFFER_DELAY = 300;
        return UserSettings;
    }());
    exports.UserSettings = UserSettings;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/workbench/parts/extensions/common/extensions", ["require", "exports", 'vs/nls!vs/workbench/parts/extensions/common/extensions', 'vs/platform/instantiation/common/instantiation'], function (require, exports, nls, instantiation_1) {
    'use strict';
    exports.IExtensionsService = instantiation_1.createDecorator('extensionsService');
    exports.IGalleryService = instantiation_1.createDecorator('galleryService');
    exports.IExtensionTipsService = instantiation_1.createDecorator('extensionTipsService');
    exports.ExtensionsLabel = nls.localize(0, null);
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("vs/workbench/parts/files/common/explorerViewModel", ["require", "exports", 'vs/base/common/assert', 'vs/base/common/types', 'vs/base/common/uri', 'vs/base/common/platform', 'vs/base/common/paths', 'vs/base/common/mime'], function (require, exports, assert, types, uri_1, platform_1, paths, mime_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    (function (StatType) {
        StatType[StatType["FILE"] = 0] = "FILE";
        StatType[StatType["FOLDER"] = 1] = "FOLDER";
        StatType[StatType["ANY"] = 2] = "ANY";
    })(exports.StatType || (exports.StatType = {}));
    var StatType = exports.StatType;
    var FileStat = (function () {
        function FileStat(resource, isDirectory, hasChildren, name, mtime, etag) {
            if (name === void 0) { name = paths.basename(resource.fsPath); }
            this.resource = resource;
            this.name = name;
            this.isDirectory = !!isDirectory;
            this.hasChildren = isDirectory && hasChildren;
            this.mime = !isDirectory ? mime_1.guessMimeTypes(this.resource.fsPath).join(', ') : void (0);
            this.etag = etag;
            this.mtime = mtime;
            // Prepare child stat array
            if (this.isDirectory) {
                this.children = [];
            }
            this.isDirectoryResolved = false;
        }
        FileStat.prototype.getId = function () {
            return this.resource.toString();
        };
        FileStat.create = function (raw, resolveTo) {
            var stat = new FileStat(raw.resource, raw.isDirectory, raw.hasChildren, raw.name, raw.mtime, raw.etag);
            // Recursively add children if present
            if (stat.isDirectory) {
                // isDirectoryResolved is a very important indicator in the stat model that tells if the folder was fully resolved
                // the folder is fully resolved if either it has a list of children or the client requested this by using the resolveTo
                // array of resource path to resolve.
                stat.isDirectoryResolved = !!raw.children || (!!resolveTo && resolveTo.some(function (r) {
                    return paths.isEqualOrParent(r.fsPath, stat.resource.fsPath);
                }));
                // Recurse into children
                if (raw.children) {
                    for (var i = 0, len = raw.children.length; i < len; i++) {
                        var child = FileStat.create(raw.children[i], resolveTo);
                        child.parent = stat;
                        stat.children.push(child);
                        stat.hasChildren = stat.children.length > 0;
                    }
                }
            }
            return stat;
        };
        /**
         * Merges the stat which was resolved from the disk with the local stat by copying over properties
         * and children. The merge will only consider resolved stat elements to avoid overwriting data which
         * exists locally.
         */
        FileStat.mergeLocalWithDisk = function (disk, local) {
            assert.ok(disk.resource.toString() === local.resource.toString(), 'Merging only supported for stats with the same resource');
            // Stop merging when a folder is not resolved to avoid loosing local data
            var mergingDirectories = disk.isDirectory || local.isDirectory;
            if (mergingDirectories && local.isDirectoryResolved && !disk.isDirectoryResolved) {
                return;
            }
            // Properties
            local.resource = disk.resource;
            local.name = disk.name;
            local.isDirectory = disk.isDirectory;
            local.hasChildren = disk.isDirectory && disk.hasChildren;
            local.mtime = disk.mtime;
            local.mime = disk.mime;
            local.isDirectoryResolved = disk.isDirectoryResolved;
            // Merge Children if resolved
            if (mergingDirectories && disk.isDirectoryResolved) {
                // Map resource => stat
                var oldLocalChildren_1 = Object.create(null);
                local.children.forEach(function (localChild) {
                    oldLocalChildren_1[localChild.resource.toString()] = localChild;
                });
                // Clear current children
                local.children = [];
                // Merge received children
                disk.children.forEach(function (diskChild) {
                    var formerLocalChild = oldLocalChildren_1[diskChild.resource.toString()];
                    // Existing child: merge
                    if (formerLocalChild) {
                        FileStat.mergeLocalWithDisk(diskChild, formerLocalChild);
                        formerLocalChild.parent = local;
                        local.children.push(formerLocalChild);
                    }
                    else {
                        diskChild.parent = local;
                        local.children.push(diskChild);
                    }
                });
            }
        };
        /**
         * Returns a deep copy of this model object.
         */
        FileStat.prototype.clone = function () {
            var stat = new FileStat(uri_1.default.parse(this.resource.toString()), this.isDirectory, this.hasChildren, this.name, this.mtime, this.etag);
            stat.isDirectoryResolved = this.isDirectoryResolved;
            if (this.parent) {
                stat.parent = this.parent;
            }
            if (this.isDirectory) {
                this.children.forEach(function (child) {
                    stat.addChild(child.clone());
                });
            }
            return stat;
        };
        /**
         * Adds a child element to this folder.
         */
        FileStat.prototype.addChild = function (child) {
            assert.ok(this.isDirectory, 'Can only add a child to a folder');
            // Overwrite a previous child with the same name
            this.removeChild(child);
            // Inherit some parent properties to child
            child.parent = this;
            child.updateResource(false);
            this.children.push(child);
            this.hasChildren = this.children.length > 0;
        };
        /**
         * Returns true if this stat is a directory that contains a child with the given name.
         *
         * @param ignoreCase if true, will check for the name ignoring case.
         * @param type the type of stat to check for.
         */
        FileStat.prototype.hasChild = function (name, ignoreCase, type) {
            if (type === void 0) { type = StatType.ANY; }
            assert.ok(this.isDirectory, 'Can only call hasChild on a directory');
            assert.ok(types.isString(name), 'Expected parameter of type String');
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                if ((type === StatType.FILE && child.isDirectory) || (type === StatType.FOLDER && !child.isDirectory)) {
                    continue;
                }
                // Check for Identity
                if (child.name === name) {
                    return true;
                }
                // Also consider comparing without case
                if (ignoreCase && child.name.toLowerCase() === name.toLowerCase()) {
                    return true;
                }
            }
            return false;
        };
        /**
         * Removes a child element from this folder.
         */
        FileStat.prototype.removeChild = function (child) {
            assert.ok(this.isDirectory, 'Can only remove a child from a directory');
            assert.ok(!!this.children, 'Expected children for directory but found none: ' + this.resource.fsPath);
            for (var i = 0; i < this.children.length; i++) {
                if (this.children[i].resource.toString() === child.resource.toString()) {
                    this.children.splice(i, 1);
                    break;
                }
            }
            this.hasChildren = this.children.length > 0;
        };
        /**
         * Moves this element under a new parent element.
         */
        FileStat.prototype.move = function (newParent, fnBetweenStates, fnDone) {
            var _this = this;
            assert.ok(newParent.isDirectory, 'Can only move an element into a directory');
            if (!fnBetweenStates) {
                fnBetweenStates = function (cb) { cb(); };
            }
            this.parent.removeChild(this);
            fnBetweenStates(function () {
                newParent.addChild(_this);
                _this.updateResource(true);
                if (fnDone) {
                    fnDone();
                }
            });
        };
        FileStat.prototype.updateResource = function (recursive) {
            this.resource = uri_1.default.file(paths.join(this.parent.resource.fsPath, this.name));
            if (recursive) {
                if (this.isDirectory && this.hasChildren && this.children) {
                    this.children.forEach(function (child) {
                        child.updateResource(true);
                    });
                }
            }
        };
        /**
         * Tells this stat that it was renamed. This requires changes to all children of this stat (if any)
         * so that the path property can be updated properly.
         */
        FileStat.prototype.rename = function (renamedStat) {
            // Merge a subset of Properties that can change on rename
            this.name = renamedStat.name;
            this.mime = renamedStat.mime;
            this.mtime = renamedStat.mtime;
            // Update Paths including children
            this.updateResource(true);
        };
        /**
         * Returns a child stat from this stat that matches with the provided path.
         * Will return "null" in case the child does not exist.
         */
        FileStat.prototype.find = function (resource) {
            // Return if path found
            if (this.fileResourceEquals(resource, this.resource)) {
                return this;
            }
            // Return if not having any children
            if (!this.hasChildren) {
                return null;
            }
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                if (this.fileResourceEquals(resource, child.resource)) {
                    return child;
                }
                if (child.isDirectory && paths.isEqualOrParent(resource.fsPath, child.resource.fsPath)) {
                    return child.find(resource);
                }
            }
            return null; //Unable to find
        };
        FileStat.prototype.fileResourceEquals = function (r1, r2) {
            var identityEquals = (r1.toString() === r2.toString());
            if (platform_1.isLinux || identityEquals) {
                return identityEquals;
            }
            return r1.toString().toLowerCase() === r2.toString().toLowerCase();
        };
        return FileStat;
    }());
    exports.FileStat = FileStat;
    /* A helper that can be used to show a placeholder when creating a new stat */
    var NewStatPlaceholder = (function (_super) {
        __extends(NewStatPlaceholder, _super);
        function NewStatPlaceholder(isDirectory) {
            _super.call(this, uri_1.default.file(''));
            this.id = NewStatPlaceholder.ID++;
            this.isDirectoryResolved = isDirectory;
        }
        NewStatPlaceholder.prototype.destroy = function () {
            this.parent.removeChild(this);
            this.isDirectoryResolved = void 0;
            this.name = void 0;
            this.isDirectory = void 0;
            this.hasChildren = void 0;
            this.mtime = void 0;
            this.mime = void 0;
        };
        NewStatPlaceholder.prototype.getId = function () {
            return 'new-stat-placeholder:' + this.id + ':' + this.parent.resource.toString();
        };
        /**
         * Returns a deep copy of this model object.
         */
        NewStatPlaceholder.prototype.clone = function () {
            var stat = new NewStatPlaceholder(this.isDirectory);
            stat.parent = this.parent;
            return stat;
        };
        NewStatPlaceholder.prototype.addChild = function (child) {
            throw new Error('Can\'t perform operations in NewStatPlaceholder.');
        };
        NewStatPlaceholder.prototype.hasChild = function (name, ignoreCase) {
            return false;
        };
        NewStatPlaceholder.prototype.removeChild = function (child) {
            throw new Error('Can\'t perform operations in NewStatPlaceholder.');
        };
        NewStatPlaceholder.prototype.move = function (newParent) {
            throw new Error('Can\'t perform operations in NewStatPlaceholder.');
        };
        NewStatPlaceholder.prototype.rename = function (renamedStat) {
            throw new Error('Can\'t perform operations in NewStatPlaceholder.');
        };
        NewStatPlaceholder.prototype.find = function (resource) {
            return null;
        };
        NewStatPlaceholder.addNewStatPlaceholder = function (parent, isDirectory) {
            assert.ok(parent.isDirectory, 'Can only add a child to a folder');
            var child = new NewStatPlaceholder(isDirectory);
            // Inherit some parent properties to child
            child.parent = parent;
            parent.children.push(child);
            parent.hasChildren = parent.children.length > 0;
            return child;
        };
        NewStatPlaceholder.ID = 0;
        return NewStatPlaceholder;
    }(FileStat));
    exports.NewStatPlaceholder = NewStatPlaceholder;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("vs/workbench/parts/files/common/files", ["require", "exports", 'vs/base/common/events', 'vs/base/common/mime', 'vs/workbench/common/editor', 'vs/platform/instantiation/common/instantiation', 'vs/workbench/parts/files/common/explorerViewModel'], function (require, exports, events_1, mime_1, editor_1, instantiation_1, explorerViewModel_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Explorer viewlet id.
     */
    exports.VIEWLET_ID = 'workbench.view.explorer';
    /**
     * File editor input id.
     */
    exports.FILE_EDITOR_INPUT_ID = 'workbench.editors.files.fileEditorInput';
    /**
     * Text file editor id.
     */
    exports.TEXT_FILE_EDITOR_ID = 'workbench.editors.files.textFileEditor';
    /**
     * Binary file editor id.
     */
    exports.BINARY_FILE_EDITOR_ID = 'workbench.editors.files.binaryFileEditor';
    /**
     * Marker ID for model entries.
     */
    exports.WORKING_FILES_MODEL_ENTRY_CLASS_ID = 'workbench.workingFiles.model.entry.class';
    /**
     * API class to denote file editor inputs. Internal implementation is provided.
     *
     * Note: This class is not intended to be instantiated.
     */
    var FileEditorInput = (function (_super) {
        __extends(FileEditorInput, _super);
        function FileEditorInput() {
            _super.apply(this, arguments);
        }
        return FileEditorInput;
    }(editor_1.EditorInput));
    exports.FileEditorInput = FileEditorInput;
    /**
     * Helper to get a file resource from an object.
     */
    function asFileResource(obj) {
        if (obj instanceof explorerViewModel_1.FileStat) {
            var stat = obj;
            return {
                resource: stat.resource,
                mimes: stat.mime ? stat.mime.split(', ') : [],
                isDirectory: stat.isDirectory
            };
        }
        if (obj && obj.CLASS_ID === exports.WORKING_FILES_MODEL_ENTRY_CLASS_ID) {
            var entry = obj;
            if (entry.isFile) {
                return {
                    resource: entry.resource,
                    mimes: mime_1.guessMimeTypes(entry.resource.fsPath),
                    isDirectory: false
                };
            }
        }
        return null;
    }
    exports.asFileResource = asFileResource;
    /**
     * List of event types from files.
     */
    exports.EventType = {
        /**
         * Indicates that a file content has changed but not yet saved.
         */
        FILE_DIRTY: 'files:fileDirty',
        /**
         * Indicates that a file is being saved.
         */
        FILE_SAVING: 'files:fileSaving',
        /**
         * Indicates that a file save resulted in an error.
         */
        FILE_SAVE_ERROR: 'files:fileSaveError',
        /**
         * Indicates that a file content has been saved to the disk.
         */
        FILE_SAVED: 'files:fileSaved',
        /**
         * Indicates that a file content has been reverted to the state
         * on disk.
         */
        FILE_REVERTED: 'files:fileReverted'
    };
    /**
     * Local file change events are being emitted when a file is added, removed, moved or its contents got updated. These events
     * are being emitted from within the workbench and are not reflecting the truth on the disk file system. For that, please
     * use FileChangesEvent instead.
     */
    var LocalFileChangeEvent = (function (_super) {
        __extends(LocalFileChangeEvent, _super);
        function LocalFileChangeEvent(before, after, originalEvent) {
            _super.call(this, null, before, after, originalEvent);
        }
        /**
         * Returns the meta information of the file before the event occurred or null if the file is new.
         */
        LocalFileChangeEvent.prototype.getBefore = function () {
            return this.oldValue;
        };
        /**
         * Returns the meta information of the file after the event occurred or null if the file got deleted.
         */
        LocalFileChangeEvent.prototype.getAfter = function () {
            return this.newValue;
        };
        /**
         * Indicates if the file was added as a new file.
         */
        LocalFileChangeEvent.prototype.gotAdded = function () {
            return !this.oldValue && !!this.newValue;
        };
        /**
         * Indicates if the file was moved to a different path.
         */
        LocalFileChangeEvent.prototype.gotMoved = function () {
            return !!this.oldValue && !!this.newValue && this.oldValue.resource.toString() !== this.newValue.resource.toString();
        };
        /**
         * Indicates if the files metadata was updated.
         */
        LocalFileChangeEvent.prototype.gotUpdated = function () {
            return !!this.oldValue && !!this.newValue && !this.gotMoved() && this.oldValue !== this.newValue;
        };
        /**
         * Indicates if the file was deleted.
         */
        LocalFileChangeEvent.prototype.gotDeleted = function () {
            return !!this.oldValue && !this.newValue;
        };
        return LocalFileChangeEvent;
    }(events_1.PropertyChangeEvent));
    exports.LocalFileChangeEvent = LocalFileChangeEvent;
    /**
     * Text file change events are emitted when files are saved or reverted.
     */
    var TextFileChangeEvent = (function (_super) {
        __extends(TextFileChangeEvent, _super);
        function TextFileChangeEvent(model, before, after, originalEvent) {
            if (after === void 0) { after = before; }
            _super.call(this, before, after, originalEvent);
            this._model = model;
        }
        Object.defineProperty(TextFileChangeEvent.prototype, "model", {
            get: function () {
                return this._model;
            },
            enumerable: true,
            configurable: true
        });
        TextFileChangeEvent.prototype.setAutoSaved = function (autoSaved) {
            this._isAutoSaved = autoSaved;
        };
        Object.defineProperty(TextFileChangeEvent.prototype, "isAutoSaved", {
            get: function () {
                return this._isAutoSaved;
            },
            enumerable: true,
            configurable: true
        });
        return TextFileChangeEvent;
    }(LocalFileChangeEvent));
    exports.TextFileChangeEvent = TextFileChangeEvent;
    exports.TEXT_FILE_SERVICE_ID = 'textFileService';
    (function (ConfirmResult) {
        ConfirmResult[ConfirmResult["SAVE"] = 0] = "SAVE";
        ConfirmResult[ConfirmResult["DONT_SAVE"] = 1] = "DONT_SAVE";
        ConfirmResult[ConfirmResult["CANCEL"] = 2] = "CANCEL";
    })(exports.ConfirmResult || (exports.ConfirmResult = {}));
    var ConfirmResult = exports.ConfirmResult;
    (function (AutoSaveMode) {
        AutoSaveMode[AutoSaveMode["OFF"] = 0] = "OFF";
        AutoSaveMode[AutoSaveMode["AFTER_SHORT_DELAY"] = 1] = "AFTER_SHORT_DELAY";
        AutoSaveMode[AutoSaveMode["AFTER_LONG_DELAY"] = 2] = "AFTER_LONG_DELAY";
        AutoSaveMode[AutoSaveMode["ON_FOCUS_CHANGE"] = 3] = "ON_FOCUS_CHANGE";
    })(exports.AutoSaveMode || (exports.AutoSaveMode = {}));
    var AutoSaveMode = exports.AutoSaveMode;
    exports.ITextFileService = instantiation_1.createDecorator(exports.TEXT_FILE_SERVICE_ID);
});

define("vs/workbench/parts/output/common/output", ["require", "exports", 'vs/platform/platform', 'vs/platform/instantiation/common/instantiation'], function (require, exports, platform_1, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Mime type used by the output editor.
     */
    exports.OUTPUT_MIME = 'text/x-monaco-output';
    /**
     * Id used by the output editor.
     */
    exports.OUTPUT_MODE_ID = 'Log';
    /**
     * Output editor input id.
     */
    exports.OUTPUT_EDITOR_INPUT_ID = 'vs.output';
    /**
     * Output panel id
     */
    exports.OUTPUT_PANEL_ID = 'workbench.panel.output';
    exports.Extensions = {
        OutputChannels: 'workbench.contributions.outputChannels'
    };
    exports.OUTPUT_SERVICE_ID = 'outputService';
    exports.MAX_OUTPUT_LENGTH = 10000 /* Max. number of output lines to show in output */ * 100;
    exports.IOutputService = instantiation_1.createDecorator(exports.OUTPUT_SERVICE_ID);
    var OutputChannelRegistry = (function () {
        function OutputChannelRegistry() {
            this.channels = [];
        }
        OutputChannelRegistry.prototype.registerChannel = function (name) {
            if (this.channels.indexOf(name) === -1) {
                this.channels.push(name);
            }
        };
        OutputChannelRegistry.prototype.getChannels = function () {
            return this.channels.slice(0);
        };
        return OutputChannelRegistry;
    }());
    platform_1.Registry.add(exports.Extensions.OutputChannels, new OutputChannelRegistry());
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/workbench/parts/search/common/search", ["require", "exports", 'vs/base/common/winjs.base', 'vs/base/common/errors', 'vs/editor/common/editorCommonExtensions'], function (require, exports, winjs_base_1, errors_1, editorCommonExtensions_1) {
    'use strict';
    var NavigateTypesSupportRegistry;
    (function (NavigateTypesSupportRegistry) {
        var _supports = [];
        function register(support) {
            if (support) {
                _supports.push(support);
            }
            return {
                dispose: function () {
                    if (support) {
                        var idx = _supports.indexOf(support);
                        if (idx >= 0) {
                            _supports.splice(idx, 1);
                            support = undefined;
                        }
                    }
                }
            };
        }
        NavigateTypesSupportRegistry.register = register;
        function all() {
            return _supports.slice(0);
        }
        NavigateTypesSupportRegistry.all = all;
    })(NavigateTypesSupportRegistry = exports.NavigateTypesSupportRegistry || (exports.NavigateTypesSupportRegistry = {}));
    function getNavigateToItems(query) {
        var promises = NavigateTypesSupportRegistry.all().map(function (support) {
            return support.getNavigateToItems(query).then(function (value) { return value; }, errors_1.onUnexpectedError);
        });
        return winjs_base_1.TPromise.join(promises).then(function (all) {
            var result = [];
            for (var _i = 0, all_1 = all; _i < all_1.length; _i++) {
                var bearings = all_1[_i];
                if (Array.isArray(bearings)) {
                    result.push.apply(result, bearings);
                }
            }
            return result;
        });
    }
    exports.getNavigateToItems = getNavigateToItems;
    editorCommonExtensions_1.CommonEditorRegistry.registerLanguageCommand('_executeWorkspaceSymbolProvider', function (accessor, args) {
        var query = args.query;
        if (typeof query !== 'string') {
            throw errors_1.illegalArgument();
        }
        return getNavigateToItems(query);
    });
});

define("vs/workbench/services/editor/common/editorService", ["require", "exports", 'vs/platform/instantiation/common/instantiation'], function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    (function (EditorArrangement) {
        EditorArrangement[EditorArrangement["MINIMIZE_OTHERS"] = 0] = "MINIMIZE_OTHERS";
        EditorArrangement[EditorArrangement["EVEN_WIDTH"] = 1] = "EVEN_WIDTH";
    })(exports.EditorArrangement || (exports.EditorArrangement = {}));
    var EditorArrangement = exports.EditorArrangement;
    exports.IWorkbenchEditorService = instantiation_1.createDecorator('editorService');
});

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/workbench/api/node/extHostOutputService", ["require", "exports", 'vs/base/common/errors', 'vs/platform/thread/common/thread', 'vs/workbench/parts/output/common/output', 'vs/workbench/services/editor/common/editorService'], function (require, exports, errors_1, thread_1, output_1, editorService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ExtHostOutputChannel = (function () {
        function ExtHostOutputChannel(name, proxy) {
            this._name = name;
            this._proxy = proxy;
        }
        Object.defineProperty(ExtHostOutputChannel.prototype, "name", {
            get: function () {
                return this._name;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostOutputChannel.prototype.dispose = function () {
            var _this = this;
            if (!this._disposed) {
                this._proxy.clear(this._name).then(function () {
                    _this._disposed = true;
                });
            }
        };
        ExtHostOutputChannel.prototype.append = function (value) {
            this._proxy.append(this._name, value);
        };
        ExtHostOutputChannel.prototype.appendLine = function (value) {
            this.append(value + '\n');
        };
        ExtHostOutputChannel.prototype.clear = function () {
            this._proxy.clear(this._name);
        };
        ExtHostOutputChannel.prototype.show = function (columnOrPreserveFocus, preserveFocus) {
            if (typeof columnOrPreserveFocus === 'boolean') {
                preserveFocus = columnOrPreserveFocus;
            }
            this._proxy.reveal(this._name, preserveFocus);
        };
        ExtHostOutputChannel.prototype.hide = function () {
            this._proxy.close(this._name);
        };
        return ExtHostOutputChannel;
    }());
    exports.ExtHostOutputChannel = ExtHostOutputChannel;
    var ExtHostOutputService = (function () {
        function ExtHostOutputService(threadService) {
            this._proxy = threadService.getRemotable(MainThreadOutputService);
        }
        ExtHostOutputService.prototype.createOutputChannel = function (name) {
            name = name.trim();
            if (!name) {
                throw new Error('illegal argument `name`. must not be falsy');
            }
            else {
                return new ExtHostOutputChannel(name, this._proxy);
            }
        };
        return ExtHostOutputService;
    }());
    exports.ExtHostOutputService = ExtHostOutputService;
    var MainThreadOutputService = (function () {
        function MainThreadOutputService(outputService, editorService) {
            this._outputService = outputService;
            this._editorService = editorService;
        }
        MainThreadOutputService.prototype.append = function (channel, value) {
            this._outputService.append(channel, value);
            return undefined;
        };
        MainThreadOutputService.prototype.clear = function (channel) {
            this._outputService.clearOutput(channel);
            return undefined;
        };
        MainThreadOutputService.prototype.reveal = function (channel, preserveFocus) {
            this._outputService.showOutput(channel, preserveFocus);
            return undefined;
        };
        MainThreadOutputService.prototype.close = function (channel) {
            var editors = this._editorService.getVisibleEditors();
            for (var _i = 0, editors_1 = editors; _i < editors_1.length; _i++) {
                var editor = editors_1[_i];
                if (editor.input.getId() === output_1.OUTPUT_EDITOR_INPUT_ID) {
                    this._editorService.closeEditor(editor).done(null, errors_1.onUnexpectedError);
                    return undefined;
                }
            }
        };
        MainThreadOutputService = __decorate([
            thread_1.Remotable.MainContext('MainThreadOutputService'),
            __param(0, output_1.IOutputService),
            __param(1, editorService_1.IWorkbenchEditorService)
        ], MainThreadOutputService);
        return MainThreadOutputService;
    }());
    exports.MainThreadOutputService = MainThreadOutputService;
});

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/workbench/api/node/extHostWorkspace", ["require", "exports", 'vs/base/common/errors', 'vs/platform/search/common/search', 'vs/platform/workspace/common/workspace', 'vs/platform/thread/common/thread', 'vs/platform/event/common/event', 'vs/workbench/services/editor/common/editorService', 'vs/workbench/parts/files/common/files', 'vs/editor/common/services/bulkEdit', 'vs/base/common/winjs.base', 'vs/workbench/api/node/extHostTypeConverters'], function (require, exports, errors_1, search_1, workspace_1, thread_1, event_1, editorService_1, files_1, bulkEdit_1, winjs_base_1, extHostTypeConverters_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ExtHostWorkspace = (function () {
        function ExtHostWorkspace(threadService, workspacePath) {
            this._proxy = threadService.getRemotable(MainThreadWorkspace);
            this._workspacePath = workspacePath;
        }
        ExtHostWorkspace.prototype.getPath = function () {
            return this._workspacePath;
        };
        ExtHostWorkspace.prototype.getRelativePath = function (pathOrUri) {
            var path;
            if (typeof pathOrUri === 'string') {
                path = pathOrUri;
            }
            else {
                path = pathOrUri.fsPath;
            }
            if (this._workspacePath && this._workspacePath.length < path.length) {
                // return relative(workspacePath, path);
                return path.substring(this._workspacePath.length);
            }
            return path;
        };
        ExtHostWorkspace.prototype.findFiles = function (include, exclude, maxResults, token) {
            var _this = this;
            var requestId = ExtHostWorkspace._requestIdPool++;
            var result = this._proxy.$startSearch(include, exclude, maxResults, requestId);
            if (token) {
                token.onCancellationRequested(function () { return _this._proxy.$cancelSearch(requestId); });
            }
            return result;
        };
        ExtHostWorkspace.prototype.saveAll = function (includeUntitled) {
            return this._proxy.$saveAll(includeUntitled);
        };
        ExtHostWorkspace.prototype.appyEdit = function (edit) {
            var resourceEdits = [];
            var entries = edit.entries();
            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                var entry = entries_1[_i];
                var uri = entry[0], edits = entry[1];
                for (var _a = 0, edits_1 = edits; _a < edits_1.length; _a++) {
                    var edit_1 = edits_1[_a];
                    resourceEdits.push({
                        resource: uri,
                        newText: edit_1.newText,
                        range: extHostTypeConverters_1.fromRange(edit_1.range)
                    });
                }
            }
            return this._proxy.$applyWorkspaceEdit(resourceEdits);
        };
        ExtHostWorkspace._requestIdPool = 0;
        ExtHostWorkspace = __decorate([
            __param(0, thread_1.IThreadService)
        ], ExtHostWorkspace);
        return ExtHostWorkspace;
    }());
    exports.ExtHostWorkspace = ExtHostWorkspace;
    var MainThreadWorkspace = (function () {
        function MainThreadWorkspace(searchService, contextService, textFileService, editorService, eventService) {
            this._activeSearches = Object.create(null);
            this._searchService = searchService;
            this._workspace = contextService.getWorkspace();
            this._textFileService = textFileService;
            this._editorService = editorService;
            this._eventService = eventService;
        }
        MainThreadWorkspace.prototype.$startSearch = function (include, exclude, maxResults, requestId) {
            var _this = this;
            if (!this._workspace) {
                return;
            }
            var search = this._searchService.search({
                folderResources: [this._workspace.resource],
                type: search_1.QueryType.File,
                maxResults: maxResults,
                includePattern: (_a = {}, _a[include] = true, _a),
                excludePattern: (_b = {}, _b[exclude] = true, _b),
            }).then(function (result) {
                return result.results.map(function (m) { return m.resource; });
            }, function (err) {
                if (!errors_1.isPromiseCanceledError(err)) {
                    return winjs_base_1.TPromise.wrapError(err);
                }
            });
            this._activeSearches[requestId] = search;
            var onDone = function () { return delete _this._activeSearches[requestId]; };
            search.done(onDone, onDone);
            return search;
            var _a, _b;
        };
        MainThreadWorkspace.prototype.$cancelSearch = function (requestId) {
            var search = this._activeSearches[requestId];
            if (search) {
                delete this._activeSearches[requestId];
                search.cancel();
                return winjs_base_1.TPromise.as(true);
            }
        };
        MainThreadWorkspace.prototype.$saveAll = function (includeUntitled) {
            return this._textFileService.saveAll(includeUntitled).then(function (result) {
                return result.results.every(function (each) { return each.success === true; });
            });
        };
        MainThreadWorkspace.prototype.$applyWorkspaceEdit = function (edits) {
            var codeEditor;
            var editor = this._editorService.getActiveEditor();
            if (editor) {
                var candidate = editor.getControl();
                if (typeof candidate.getEditorType === 'function') {
                    // enough proof
                    codeEditor = candidate;
                }
            }
            return bulkEdit_1.bulkEdit(this._eventService, this._editorService, codeEditor, edits)
                .then(function () { return true; });
        };
        MainThreadWorkspace = __decorate([
            thread_1.Remotable.MainContext('MainThreadWorkspace'),
            __param(0, search_1.ISearchService),
            __param(1, workspace_1.IWorkspaceContextService),
            __param(2, files_1.ITextFileService),
            __param(3, editorService_1.IWorkbenchEditorService),
            __param(4, event_1.IEventService)
        ], MainThreadWorkspace);
        return MainThreadWorkspace;
    }());
    exports.MainThreadWorkspace = MainThreadWorkspace;
});

define("vs/workbench/services/quickopen/common/quickOpenService", ["require", "exports", 'vs/platform/instantiation/common/instantiation'], function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IQuickOpenService = instantiation_1.createDecorator('quickOpenService');
});

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/workbench/api/node/extHostQuickOpen", ["require", "exports", 'vs/base/common/winjs.base', 'vs/platform/thread/common/thread', 'vs/workbench/services/quickopen/common/quickOpenService'], function (require, exports, winjs_base_1, thread_1, quickOpenService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ExtHostQuickOpen = (function () {
        function ExtHostQuickOpen(threadService) {
            this._proxy = threadService.getRemotable(MainThreadQuickOpen);
        }
        ExtHostQuickOpen.prototype.show = function (itemsOrItemsPromise, options) {
            var _this = this;
            // clear state from last invocation
            this._onDidSelectItem = undefined;
            var itemsPromise;
            if (!Array.isArray(itemsOrItemsPromise)) {
                itemsPromise = itemsOrItemsPromise;
            }
            else {
                itemsPromise = winjs_base_1.TPromise.as(itemsOrItemsPromise);
            }
            var quickPickWidget = this._proxy.$show({
                autoFocus: { autoFocusFirstEntry: true },
                placeHolder: options && options.placeHolder,
                matchOnDescription: options && options.matchOnDescription,
                matchOnDetail: options && options.matchOnDetail
            });
            return itemsPromise.then(function (items) {
                var pickItems = [];
                for (var handle = 0; handle < items.length; handle++) {
                    var item = items[handle];
                    var label = void 0;
                    var description = void 0;
                    var detail = void 0;
                    if (typeof item === 'string') {
                        label = item;
                    }
                    else {
                        label = item.label;
                        description = item.description;
                        detail = item.detail;
                    }
                    pickItems.push({
                        label: label,
                        description: description,
                        handle: handle,
                        detail: detail
                    });
                }
                // handle selection changes
                if (options && typeof options.onDidSelectItem === 'function') {
                    _this._onDidSelectItem = function (handle) {
                        options.onDidSelectItem(items[handle]);
                    };
                }
                // show items
                _this._proxy.$setItems(pickItems);
                return quickPickWidget.then(function (handle) {
                    if (typeof handle === 'number') {
                        return items[handle];
                    }
                });
            }, function (err) {
                _this._proxy.$setError(err);
                return winjs_base_1.TPromise.wrapError(err);
            });
        };
        ExtHostQuickOpen.prototype.$onItemSelected = function (handle) {
            if (this._onDidSelectItem) {
                this._onDidSelectItem(handle);
            }
        };
        // ---- input
        ExtHostQuickOpen.prototype.input = function (options) {
            this._validateInput = options.validateInput;
            return this._proxy.$input(options, typeof options.validateInput === 'function');
        };
        ExtHostQuickOpen.prototype.$validateInput = function (input) {
            if (this._validateInput) {
                return winjs_base_1.TPromise.as(this._validateInput(input));
            }
        };
        ExtHostQuickOpen = __decorate([
            thread_1.Remotable.ExtHostContext('ExtHostQuickOpen'),
            __param(0, thread_1.IThreadService)
        ], ExtHostQuickOpen);
        return ExtHostQuickOpen;
    }());
    exports.ExtHostQuickOpen = ExtHostQuickOpen;
    var MainThreadQuickOpen = (function () {
        function MainThreadQuickOpen(threadService, quickOpenService) {
            this._token = 0;
            this._proxy = threadService.getRemotable(ExtHostQuickOpen);
            this._quickOpenService = quickOpenService;
        }
        MainThreadQuickOpen.prototype.$show = function (options) {
            var _this = this;
            var myToken = ++this._token;
            this._contents = new winjs_base_1.TPromise(function (c, e) {
                _this._doSetItems = function (items) {
                    if (myToken === _this._token) {
                        c(items);
                    }
                };
                _this._doSetError = function (error) {
                    if (myToken === _this._token) {
                        e(error);
                    }
                };
            });
            return this._quickOpenService.pick(this._contents, options).then(function (item) {
                if (item) {
                    return item.handle;
                }
            }, undefined, function (progress) {
                if (progress) {
                    _this._proxy.$onItemSelected(progress.handle);
                }
            });
        };
        MainThreadQuickOpen.prototype.$setItems = function (items) {
            if (this._doSetItems) {
                this._doSetItems(items);
                return;
            }
        };
        MainThreadQuickOpen.prototype.$setError = function (error) {
            if (this._doSetError) {
                this._doSetError(error);
                return;
            }
        };
        // ---- input
        MainThreadQuickOpen.prototype.$input = function (options, validateInput) {
            var _this = this;
            var inputOptions = Object.create(null);
            if (options) {
                inputOptions.password = options.password;
                inputOptions.placeHolder = options.placeHolder;
                inputOptions.prompt = options.prompt;
                inputOptions.value = options.value;
            }
            if (validateInput) {
                inputOptions.validateInput = function (value) {
                    return _this._proxy.$validateInput(value);
                };
            }
            return this._quickOpenService.input(inputOptions);
        };
        MainThreadQuickOpen = __decorate([
            thread_1.Remotable.MainContext('MainThreadQuickOpen'),
            __param(0, thread_1.IThreadService),
            __param(1, quickOpenService_1.IQuickOpenService)
        ], MainThreadQuickOpen);
        return MainThreadQuickOpen;
    }());
    exports.MainThreadQuickOpen = MainThreadQuickOpen;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/workbench/services/statusbar/common/statusbarService", ["require", "exports", 'vs/platform/instantiation/common/instantiation'], function (require, exports, instantiation_1) {
    'use strict';
    exports.IStatusbarService = instantiation_1.createDecorator('statusbarService');
    (function (StatusbarAlignment) {
        StatusbarAlignment[StatusbarAlignment["LEFT"] = 0] = "LEFT";
        StatusbarAlignment[StatusbarAlignment["RIGHT"] = 1] = "RIGHT";
    })(exports.StatusbarAlignment || (exports.StatusbarAlignment = {}));
    var StatusbarAlignment = exports.StatusbarAlignment;
});

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/workbench/api/node/extHostStatusBar", ["require", "exports", 'vs/platform/thread/common/thread', 'vs/workbench/services/statusbar/common/statusbarService', './extHostTypes'], function (require, exports, thread_1, statusbarService_1, extHostTypes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ExtHostStatusBarEntry = (function () {
        function ExtHostStatusBarEntry(proxy, alignment, priority) {
            if (alignment === void 0) { alignment = extHostTypes_1.StatusBarAlignment.Left; }
            this._id = ExtHostStatusBarEntry.ID_GEN++;
            this._proxy = proxy;
            this._alignment = alignment;
            this._priority = priority;
        }
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "alignment", {
            get: function () {
                return this._alignment;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "priority", {
            get: function () {
                return this._priority;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "text", {
            get: function () {
                return this._text;
            },
            set: function (text) {
                this._text = text;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "tooltip", {
            get: function () {
                return this._tooltip;
            },
            set: function (tooltip) {
                this._tooltip = tooltip;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                this._color = color;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "command", {
            get: function () {
                return this._command;
            },
            set: function (command) {
                this._command = command;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        ExtHostStatusBarEntry.prototype.show = function () {
            this._visible = true;
            this.update();
        };
        ExtHostStatusBarEntry.prototype.hide = function () {
            this._visible = false;
            this._proxy.dispose(this.id);
        };
        ExtHostStatusBarEntry.prototype.update = function () {
            var _this = this;
            if (this._disposed || !this._visible) {
                return;
            }
            if (this._timeoutHandle) {
                clearTimeout(this._timeoutHandle);
            }
            // Defer the update so that multiple changes to setters dont cause a redraw each
            this._timeoutHandle = setTimeout(function () {
                _this._timeoutHandle = null;
                // Set to status bar
                _this._proxy.setEntry(_this.id, _this.text, _this.tooltip, _this.command, _this.color, _this._alignment === extHostTypes_1.StatusBarAlignment.Left ? statusbarService_1.StatusbarAlignment.LEFT : statusbarService_1.StatusbarAlignment.RIGHT, _this._priority);
            }, 0);
        };
        ExtHostStatusBarEntry.prototype.dispose = function () {
            this.hide();
            this._disposed = true;
        };
        ExtHostStatusBarEntry.ID_GEN = 0;
        return ExtHostStatusBarEntry;
    }());
    exports.ExtHostStatusBarEntry = ExtHostStatusBarEntry;
    var StatusBarMessage = (function () {
        function StatusBarMessage(statusBar) {
            this._messages = [];
            this._item = statusBar.createStatusBarEntry(extHostTypes_1.StatusBarAlignment.Left, Number.MIN_VALUE);
        }
        StatusBarMessage.prototype.dispose = function () {
            this._messages.length = 0;
            this._item.dispose();
        };
        StatusBarMessage.prototype.setMessage = function (message) {
            var _this = this;
            var data = { message: message }; // use object to not confuse equal strings
            this._messages.unshift(data);
            this._update();
            return new extHostTypes_1.Disposable(function () {
                var idx = _this._messages.indexOf(data);
                if (idx >= 0) {
                    _this._messages.splice(idx, 1);
                    _this._update();
                }
            });
        };
        StatusBarMessage.prototype._update = function () {
            if (this._messages.length > 0) {
                this._item.text = this._messages[0].message;
                this._item.show();
            }
            else {
                this._item.hide();
            }
        };
        return StatusBarMessage;
    }());
    var ExtHostStatusBar = (function () {
        function ExtHostStatusBar(threadService) {
            this._proxy = threadService.getRemotable(MainThreadStatusBar);
            this._statusMessage = new StatusBarMessage(this);
        }
        ExtHostStatusBar.prototype.createStatusBarEntry = function (alignment, priority) {
            return new ExtHostStatusBarEntry(this._proxy, alignment, priority);
        };
        ExtHostStatusBar.prototype.setStatusBarMessage = function (text, timeoutOrThenable) {
            var d = this._statusMessage.setMessage(text);
            var handle;
            if (typeof timeoutOrThenable === 'number') {
                handle = setTimeout(function () { return d.dispose(); }, timeoutOrThenable);
            }
            else if (typeof timeoutOrThenable !== 'undefined') {
                timeoutOrThenable.then(function () { return d.dispose(); }, function () { return d.dispose(); });
            }
            return new extHostTypes_1.Disposable(function () {
                d.dispose();
                clearTimeout(handle);
            });
        };
        ExtHostStatusBar = __decorate([
            __param(0, thread_1.IThreadService)
        ], ExtHostStatusBar);
        return ExtHostStatusBar;
    }());
    exports.ExtHostStatusBar = ExtHostStatusBar;
    var MainThreadStatusBar = (function () {
        function MainThreadStatusBar(statusbarService) {
            this.statusbarService = statusbarService;
            this.mapIdToDisposable = Object.create(null);
        }
        MainThreadStatusBar.prototype.setEntry = function (id, text, tooltip, command, color, alignment, priority) {
            // Dispose any old
            this.dispose(id);
            // Add new
            var disposeable = this.statusbarService.addEntry({ text: text, tooltip: tooltip, command: command, color: color }, alignment, priority);
            this.mapIdToDisposable[id] = disposeable;
        };
        MainThreadStatusBar.prototype.dispose = function (id) {
            var disposeable = this.mapIdToDisposable[id];
            if (disposeable) {
                disposeable.dispose();
            }
            delete this.mapIdToDisposable[id];
        };
        MainThreadStatusBar = __decorate([
            thread_1.Remotable.MainContext('MainThreadStatusBar'),
            __param(0, statusbarService_1.IStatusbarService)
        ], MainThreadStatusBar);
        return MainThreadStatusBar;
    }());
    exports.MainThreadStatusBar = MainThreadStatusBar;
});

define("vs/workbench/services/untitled/common/untitledEditorService", ["require", "exports", 'vs/base/common/uri', 'vs/platform/instantiation/common/instantiation', 'vs/base/common/events', 'vs/base/common/arrays', 'vs/workbench/common/editor/untitledEditorInput'], function (require, exports, uri_1, instantiation_1, events_1, arrays, untitledEditorInput_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IUntitledEditorService = instantiation_1.createDecorator('untitledEditorService');
    var UntitledEditorService = (function () {
        function UntitledEditorService() {
            this.serviceId = exports.IUntitledEditorService;
        }
        UntitledEditorService.prototype.setInstantiationService = function (service) {
            this.instantiationService = service;
        };
        UntitledEditorService.prototype.get = function (resource) {
            return UntitledEditorService.CACHE[resource.toString()];
        };
        UntitledEditorService.prototype.getAll = function (resources) {
            var _this = this;
            if (resources) {
                return arrays.coalesce(resources.map(function (r) { return _this.get(r); }));
            }
            return Object.keys(UntitledEditorService.CACHE).map(function (key) { return UntitledEditorService.CACHE[key]; });
        };
        UntitledEditorService.prototype.isDirty = function (resource) {
            var input = this.get(resource);
            return input && input.isDirty();
        };
        UntitledEditorService.prototype.getDirty = function () {
            return Object.keys(UntitledEditorService.CACHE)
                .map(function (key) { return UntitledEditorService.CACHE[key]; })
                .filter(function (i) { return i.isDirty(); })
                .map(function (i) { return i.getResource(); });
        };
        UntitledEditorService.prototype.createOrGet = function (resource, modeId) {
            var hasAssociatedFilePath = false;
            if (resource) {
                hasAssociatedFilePath = (resource.scheme === 'file');
                resource = this.resourceToUntitled(resource); // ensure we have the right scheme
                if (hasAssociatedFilePath) {
                    UntitledEditorService.KNOWN_ASSOCIATED_FILE_PATHS[resource.toString()] = true; // remember for future lookups
                }
            }
            // Return existing instance if asked for it
            if (resource && UntitledEditorService.CACHE[resource.toString()]) {
                return UntitledEditorService.CACHE[resource.toString()];
            }
            // Create new otherwise
            return this.doCreate(resource, hasAssociatedFilePath, modeId);
        };
        UntitledEditorService.prototype.doCreate = function (resource, hasAssociatedFilePath, modeId) {
            if (!resource) {
                // Create new taking a resource URI that is not already taken
                var counter = Object.keys(UntitledEditorService.CACHE).length + 1;
                do {
                    resource = uri_1.default.create(untitledEditorInput_1.UntitledEditorInput.SCHEMA, null, 'Untitled-' + counter);
                    counter++;
                } while (Object.keys(UntitledEditorService.CACHE).indexOf(resource.toString()) >= 0);
            }
            var input = this.instantiationService.createInstance(untitledEditorInput_1.UntitledEditorInput, resource, hasAssociatedFilePath, modeId);
            // Remove from cache on dispose
            input.addOneTimeListener(events_1.EventType.DISPOSE, function () {
                delete UntitledEditorService.CACHE[input.getResource().toString()];
                delete UntitledEditorService.KNOWN_ASSOCIATED_FILE_PATHS[input.getResource().toString()];
            });
            // Add to cache
            UntitledEditorService.CACHE[resource.toString()] = input;
            return input;
        };
        UntitledEditorService.prototype.resourceToUntitled = function (resource) {
            if (resource.scheme === untitledEditorInput_1.UntitledEditorInput.SCHEMA) {
                return resource;
            }
            return uri_1.default.create(untitledEditorInput_1.UntitledEditorInput.SCHEMA, null, resource.fsPath);
        };
        UntitledEditorService.prototype.hasAssociatedFilePath = function (resource) {
            return !!UntitledEditorService.KNOWN_ASSOCIATED_FILE_PATHS[resource.toString()];
        };
        UntitledEditorService.CACHE = Object.create(null);
        UntitledEditorService.KNOWN_ASSOCIATED_FILE_PATHS = Object.create(null);
        return UntitledEditorService;
    }());
    exports.UntitledEditorService = UntitledEditorService;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("vs/workbench/services/workspace/common/contextService", ["require", "exports", 'vs/workbench/common/events', 'vs/platform/instantiation/common/instantiation', 'vs/platform/workspace/common/baseWorkspaceContextService'], function (require, exports, events_1, instantiation_1, baseWorkspaceContextService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IWorkspaceContextService = instantiation_1.createDecorator('contextService');
    var WorkspaceContextService = (function (_super) {
        __extends(WorkspaceContextService, _super);
        function WorkspaceContextService(eventService, workspace, configuration, options) {
            if (options === void 0) { options = {}; }
            _super.call(this, workspace, configuration, options);
            this.eventService = eventService;
            this.serviceId = exports.IWorkspaceContextService;
        }
        WorkspaceContextService.prototype.updateOptions = function (key, value) {
            var oldValue = this.options[key];
            this.options[key] = value;
            this.eventService.emit(events_1.EventType.WORKBENCH_OPTIONS_CHANGED, new events_1.OptionsChangeEvent(key, oldValue, value));
        };
        return WorkspaceContextService;
    }(baseWorkspaceContextService_1.BaseWorkspaceContextService));
    exports.WorkspaceContextService = WorkspaceContextService;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/workbench/api/node/extHostDocuments", ["require", "exports", 'vs/base/common/errors', 'vs/editor/common/services/modelService', 'vs/editor/common/editorCommon', 'vs/editor/common/model/mirrorModel2', 'vs/platform/thread/common/thread', 'vs/base/common/event', 'vs/base/common/uri', 'vs/base/common/lifecycle', 'vs/workbench/api/node/extHostTypes', 'vs/platform/event/common/event', 'vs/workbench/services/editor/common/editorService', 'vs/workbench/parts/files/common/files', './extHostTypeConverters', 'vs/base/common/winjs.base', 'vs/editor/common/model/textModelWithTokensHelpers', 'vs/platform/files/common/files', 'vs/editor/common/services/modeService', 'vs/workbench/services/untitled/common/untitledEditorService', 'vs/workbench/common/editor/resourceEditorInput', 'vs/base/common/async', 'weak'], function (require, exports, errors_1, modelService_1, EditorCommon, mirrorModel2_1, thread_1, event_1, uri_1, lifecycle_1, extHostTypes_1, event_2, editorService_1, files_1, TypeConverters, winjs_base_1, textModelWithTokensHelpers_1, files_2, modeService_1, untitledEditorService_1, resourceEditorInput_1, async_1, weak) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var _modeId2WordDefinition = Object.create(null);
    function setWordDefinitionFor(modeId, wordDefinition) {
        _modeId2WordDefinition[modeId] = wordDefinition;
    }
    exports.setWordDefinitionFor = setWordDefinitionFor;
    function getWordDefinitionFor(modeId) {
        return _modeId2WordDefinition[modeId];
    }
    exports.getWordDefinitionFor = getWordDefinitionFor;
    var ExtHostModelService = (function () {
        function ExtHostModelService(threadService) {
            this._proxy = threadService.getRemotable(MainThreadDocuments);
            this._onDidAddDocumentEventEmitter = new event_1.Emitter();
            this.onDidAddDocument = this._onDidAddDocumentEventEmitter.event;
            this._onDidRemoveDocumentEventEmitter = new event_1.Emitter();
            this.onDidRemoveDocument = this._onDidRemoveDocumentEventEmitter.event;
            this._onDidChangeDocumentEventEmitter = new event_1.Emitter();
            this.onDidChangeDocument = this._onDidChangeDocumentEventEmitter.event;
            this._onDidSaveDocumentEventEmitter = new event_1.Emitter();
            this.onDidSaveDocument = this._onDidSaveDocumentEventEmitter.event;
            this._documentData = Object.create(null);
            this._documentLoader = Object.create(null);
            this._documentContentProviders = Object.create(null);
        }
        ExtHostModelService.prototype.getAllDocumentData = function () {
            var result = [];
            for (var key in this._documentData) {
                result.push(this._documentData[key]);
            }
            return result;
        };
        ExtHostModelService.prototype.getDocumentData = function (resource) {
            if (!resource) {
                return;
            }
            var data = this._documentData[resource.toString()];
            if (data) {
                return data;
            }
        };
        ExtHostModelService.prototype.ensureDocumentData = function (uri) {
            var _this = this;
            var cached = this._documentData[uri.toString()];
            if (cached) {
                return winjs_base_1.TPromise.as(cached);
            }
            var promise = this._documentLoader[uri.toString()];
            if (!promise) {
                promise = this._proxy._tryOpenDocument(uri).then(function () {
                    delete _this._documentLoader[uri.toString()];
                    return _this._documentData[uri.toString()];
                }, function (err) {
                    delete _this._documentLoader[uri.toString()];
                    return winjs_base_1.TPromise.wrapError(err);
                });
                this._documentLoader[uri.toString()] = promise;
            }
            return promise;
        };
        ExtHostModelService.prototype.registerTextDocumentContentProvider = function (scheme, provider) {
            var _this = this;
            if (scheme === 'file' || scheme === 'untitled') {
                throw new Error("scheme '" + scheme + "' already registered");
            }
            var handle = ExtHostModelService._handlePool++;
            this._documentContentProviders[handle] = provider;
            this._proxy.$registerTextContentProvider(handle, scheme);
            var subscription;
            if (typeof provider.onDidChange === 'function') {
                subscription = provider.onDidChange(function (uri) {
                    if (_this._documentData[uri.toString()]) {
                        _this.$provideTextDocumentContent(handle, uri).then(function (value) {
                            return _this._proxy.$onVirtualDocumentChange(uri, value);
                        }, errors_1.onUnexpectedError);
                    }
                });
            }
            return new extHostTypes_1.Disposable(function () {
                if (delete _this._documentContentProviders[handle]) {
                    _this._proxy.$unregisterTextContentProvider(handle);
                }
                if (subscription) {
                    subscription.dispose();
                    subscription = undefined;
                }
            });
        };
        ExtHostModelService.prototype.$provideTextDocumentContent = function (handle, uri) {
            var provider = this._documentContentProviders[handle];
            if (!provider) {
                return winjs_base_1.TPromise.wrapError("unsupported uri-scheme: " + uri.scheme);
            }
            return async_1.asWinJsPromise(function (token) { return provider.provideTextDocumentContent(uri, token); });
        };
        ExtHostModelService.prototype.$isDocumentReferenced = function (uri) {
            var key = uri.toString();
            var document = this._documentData[key];
            if (document) {
                return winjs_base_1.TPromise.as(document.isDocumentReferenced);
            }
        };
        ExtHostModelService.prototype._acceptModelAdd = function (initData) {
            var data = new ExtHostDocumentData(this._proxy, initData.url, initData.value.lines, initData.value.EOL, initData.modeId, initData.versionId, initData.isDirty);
            var key = data.document.uri.toString();
            if (this._documentData[key]) {
                throw new Error('Document `' + key + '` already exists.');
            }
            this._documentData[key] = data;
            this._onDidAddDocumentEventEmitter.fire(data.document);
        };
        ExtHostModelService.prototype._acceptModelModeChanged = function (strURL, oldModeId, newModeId) {
            var data = this._documentData[strURL];
            // Treat a mode change as a remove + add
            this._onDidRemoveDocumentEventEmitter.fire(data.document);
            data._acceptLanguageId(newModeId);
            this._onDidAddDocumentEventEmitter.fire(data.document);
        };
        ExtHostModelService.prototype._acceptModelSaved = function (strURL) {
            var data = this._documentData[strURL];
            data._acceptIsDirty(false);
            this._onDidSaveDocumentEventEmitter.fire(data.document);
        };
        ExtHostModelService.prototype._acceptModelDirty = function (strURL) {
            var document = this._documentData[strURL];
            document._acceptIsDirty(true);
        };
        ExtHostModelService.prototype._acceptModelReverted = function (strURL) {
            var document = this._documentData[strURL];
            document._acceptIsDirty(false);
        };
        ExtHostModelService.prototype._acceptModelRemoved = function (strURL) {
            if (!this._documentData[strURL]) {
                throw new Error('Document `' + strURL + '` does not exist.');
            }
            var data = this._documentData[strURL];
            delete this._documentData[strURL];
            this._onDidRemoveDocumentEventEmitter.fire(data.document);
            data.dispose();
        };
        ExtHostModelService.prototype._acceptModelChanged = function (strURL, events) {
            var data = this._documentData[strURL];
            data.onEvents(events);
            this._onDidChangeDocumentEventEmitter.fire({
                document: data.document,
                contentChanges: events.map(function (e) {
                    return {
                        range: TypeConverters.toRange(e.range),
                        rangeLength: e.rangeLength,
                        text: e.text
                    };
                })
            });
        };
        ExtHostModelService._handlePool = 0;
        ExtHostModelService = __decorate([
            thread_1.Remotable.ExtHostContext('ExtHostModelService'),
            __param(0, thread_1.IThreadService)
        ], ExtHostModelService);
        return ExtHostModelService;
    }());
    exports.ExtHostModelService = ExtHostModelService;
    var ExtHostDocumentData = (function (_super) {
        __extends(ExtHostDocumentData, _super);
        function ExtHostDocumentData(proxy, uri, lines, eol, languageId, versionId, isDirty) {
            _super.call(this, uri, lines, eol, versionId);
            this._proxy = proxy;
            this._languageId = languageId;
            this._isDirty = isDirty;
            this._textLines = [];
        }
        ExtHostDocumentData.prototype.dispose = function () {
            this._textLines.length = 0;
            this._isDirty = false;
            _super.prototype.dispose.call(this);
        };
        Object.defineProperty(ExtHostDocumentData.prototype, "document", {
            get: function () {
                // dereferences or creates the actual document for this
                // document data. keeps a weak reference only such that
                // we later when a document isn't needed anymore
                if (!this.isDocumentReferenced) {
                    var data_1 = this;
                    var doc = {
                        get uri() { return data_1._uri; },
                        get fileName() { return data_1._uri.fsPath; },
                        get isUntitled() { return data_1._uri.scheme !== 'file'; },
                        get languageId() { return data_1._languageId; },
                        get version() { return data_1._versionId; },
                        get isDirty() { return data_1._isDirty; },
                        save: function () { return data_1._proxy._trySaveDocument(data_1._uri); },
                        getText: function (range) { return range ? data_1._getTextInRange(range) : data_1.getText(); },
                        get lineCount() { return data_1._lines.length; },
                        lineAt: function (lineOrPos) { return data_1.lineAt(lineOrPos); },
                        offsetAt: function (pos) { return data_1.offsetAt(pos); },
                        positionAt: function (offset) { return data_1.positionAt(offset); },
                        validateRange: function (ran) { return data_1.validateRange(ran); },
                        validatePosition: function (pos) { return data_1.validatePosition(pos); },
                        getWordRangeAtPosition: function (pos) { return data_1.getWordRangeAtPosition(pos); }
                    };
                    this._documentRef = weak(doc);
                }
                return weak.get(this._documentRef);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostDocumentData.prototype, "isDocumentReferenced", {
            get: function () {
                return this._documentRef && !weak.isDead(this._documentRef);
            },
            enumerable: true,
            configurable: true
        });
        ExtHostDocumentData.prototype._acceptLanguageId = function (newLanguageId) {
            this._languageId = newLanguageId;
        };
        ExtHostDocumentData.prototype._acceptIsDirty = function (isDirty) {
            this._isDirty = isDirty;
        };
        ExtHostDocumentData.prototype._getTextInRange = function (_range) {
            var range = this.validateRange(_range);
            if (range.isEmpty) {
                return '';
            }
            if (range.isSingleLine) {
                return this._lines[range.start.line].substring(range.start.character, range.end.character);
            }
            var lineEnding = this._eol, startLineIndex = range.start.line, endLineIndex = range.end.line, resultLines = [];
            resultLines.push(this._lines[startLineIndex].substring(range.start.character));
            for (var i = startLineIndex + 1; i < endLineIndex; i++) {
                resultLines.push(this._lines[i]);
            }
            resultLines.push(this._lines[endLineIndex].substring(0, range.end.character));
            return resultLines.join(lineEnding);
        };
        ExtHostDocumentData.prototype.lineAt = function (lineOrPosition) {
            var line;
            if (lineOrPosition instanceof extHostTypes_1.Position) {
                line = lineOrPosition.line;
            }
            else if (typeof lineOrPosition === 'number') {
                line = lineOrPosition;
            }
            if (line < 0 || line >= this._lines.length) {
                throw new Error('Illegal value ' + line + ' for `line`');
            }
            var result = this._textLines[line];
            if (!result || result.lineNumber !== line || result.text !== this._lines[line]) {
                var text = this._lines[line];
                var firstNonWhitespaceCharacterIndex = /^(\s*)/.exec(text)[1].length;
                var range = new extHostTypes_1.Range(line, 0, line, text.length);
                var rangeIncludingLineBreak = new extHostTypes_1.Range(line, 0, line + 1, 0);
                result = Object.freeze({
                    lineNumber: line,
                    range: range,
                    rangeIncludingLineBreak: rangeIncludingLineBreak,
                    text: text,
                    firstNonWhitespaceCharacterIndex: firstNonWhitespaceCharacterIndex,
                    isEmptyOrWhitespace: firstNonWhitespaceCharacterIndex === text.length
                });
                this._textLines[line] = result;
            }
            return result;
        };
        ExtHostDocumentData.prototype.offsetAt = function (position) {
            position = this.validatePosition(position);
            this._ensureLineStarts();
            return this._lineStarts.getAccumulatedValue(position.line - 1) + position.character;
        };
        ExtHostDocumentData.prototype.positionAt = function (offset) {
            offset = Math.floor(offset);
            offset = Math.max(0, offset);
            this._ensureLineStarts();
            var out = { index: 0, remainder: 0 };
            this._lineStarts.getIndexOf(offset, out);
            var lineLength = this._lines[out.index].length;
            // Ensure we return a valid position
            return new extHostTypes_1.Position(out.index, Math.min(out.remainder, lineLength));
        };
        // ---- range math
        ExtHostDocumentData.prototype.validateRange = function (range) {
            if (!(range instanceof extHostTypes_1.Range)) {
                throw new Error('Invalid argument');
            }
            var start = this.validatePosition(range.start);
            var end = this.validatePosition(range.end);
            if (start === range.start && end === range.end) {
                return range;
            }
            return new extHostTypes_1.Range(start.line, start.character, end.line, end.character);
        };
        ExtHostDocumentData.prototype.validatePosition = function (position) {
            if (!(position instanceof extHostTypes_1.Position)) {
                throw new Error('Invalid argument');
            }
            var line = position.line, character = position.character;
            var hasChanged = false;
            if (line < 0) {
                line = 0;
                hasChanged = true;
            }
            if (line >= this._lines.length) {
                line = this._lines.length - 1;
                hasChanged = true;
            }
            if (character < 0) {
                character = 0;
                hasChanged = true;
            }
            var maxCharacter = this._lines[line].length;
            if (character > maxCharacter) {
                character = maxCharacter;
                hasChanged = true;
            }
            if (!hasChanged) {
                return position;
            }
            return new extHostTypes_1.Position(line, character);
        };
        ExtHostDocumentData.prototype.getWordRangeAtPosition = function (_position) {
            var position = this.validatePosition(_position);
            var wordAtText = textModelWithTokensHelpers_1.WordHelper._getWordAtText(position.character + 1, textModelWithTokensHelpers_1.WordHelper.ensureValidWordDefinition(getWordDefinitionFor(this._languageId)), this._lines[position.line], 0);
            if (wordAtText) {
                return new extHostTypes_1.Range(position.line, wordAtText.startColumn - 1, position.line, wordAtText.endColumn - 1);
            }
        };
        return ExtHostDocumentData;
    }(mirrorModel2_1.MirrorModel2));
    exports.ExtHostDocumentData = ExtHostDocumentData;
    var MainThreadDocuments = (function () {
        function MainThreadDocuments(threadService, modelService, modeService, eventService, textFileService, editorService, fileService, untitledEditorService) {
            var _this = this;
            this._modelService = modelService;
            this._modeService = modeService;
            this._textFileService = textFileService;
            this._editorService = editorService;
            this._fileService = fileService;
            this._untitledEditorService = untitledEditorService;
            this._proxy = threadService.getRemotable(ExtHostModelService);
            this._modelIsSynced = {};
            this._toDispose = [];
            modelService.onModelAdded(this._onModelAdded, this, this._toDispose);
            modelService.onModelRemoved(this._onModelRemoved, this, this._toDispose);
            modelService.onModelModeChanged(this._onModelModeChanged, this, this._toDispose);
            this._toDispose.push(eventService.addListener2(files_1.EventType.FILE_SAVED, function (e) {
                _this._proxy._acceptModelSaved(e.getAfter().resource.toString());
            }));
            this._toDispose.push(eventService.addListener2(files_1.EventType.FILE_REVERTED, function (e) {
                _this._proxy._acceptModelReverted(e.getAfter().resource.toString());
            }));
            this._toDispose.push(eventService.addListener2(files_1.EventType.FILE_DIRTY, function (e) {
                _this._proxy._acceptModelDirty(e.getAfter().resource.toString());
            }));
            var handle = setInterval(function () { return _this._runDocumentCleanup(); }, 30 * 1000);
            this._toDispose.push({ dispose: function () { clearInterval(handle); } });
            this._modelToDisposeMap = Object.create(null);
            this._resourceContentProvider = Object.create(null);
            this._virtualDocumentSet = Object.create(null);
        }
        MainThreadDocuments.prototype.dispose = function () {
            var _this = this;
            Object.keys(this._modelToDisposeMap).forEach(function (modelUrl) {
                _this._modelToDisposeMap[modelUrl].dispose();
            });
            this._modelToDisposeMap = Object.create(null);
            this._toDispose = lifecycle_1.disposeAll(this._toDispose);
        };
        MainThreadDocuments.prototype._onModelAdded = function (model) {
            var _this = this;
            // Same filter as in mainThreadEditors
            if (model.isTooLargeForHavingARichMode()) {
                // don't synchronize too large models
                return null;
            }
            var modelUrl = model.getAssociatedResource();
            this._modelIsSynced[modelUrl.toString()] = true;
            this._modelToDisposeMap[modelUrl.toString()] = model.addBulkListener2(function (events) { return _this._onModelEvents(modelUrl, events); });
            this._proxy._acceptModelAdd({
                url: model.getAssociatedResource(),
                versionId: model.getVersionId(),
                value: model.toRawText(),
                modeId: model.getMode().getId(),
                isDirty: this._textFileService.isDirty(modelUrl)
            });
        };
        MainThreadDocuments.prototype._onModelModeChanged = function (event) {
            var model = event.model, oldModeId = event.oldModeId;
            var modelUrl = model.getAssociatedResource();
            if (!this._modelIsSynced[modelUrl.toString()]) {
                return;
            }
            this._proxy._acceptModelModeChanged(model.getAssociatedResource().toString(), oldModeId, model.getMode().getId());
        };
        MainThreadDocuments.prototype._onModelRemoved = function (model) {
            var modelUrl = model.getAssociatedResource();
            if (!this._modelIsSynced[modelUrl.toString()]) {
                return;
            }
            delete this._modelIsSynced[modelUrl.toString()];
            this._modelToDisposeMap[modelUrl.toString()].dispose();
            delete this._modelToDisposeMap[modelUrl.toString()];
            this._proxy._acceptModelRemoved(modelUrl.toString());
        };
        MainThreadDocuments.prototype._onModelEvents = function (modelUrl, events) {
            var changedEvents = [];
            for (var i = 0, len = events.length; i < len; i++) {
                var e = events[i];
                switch (e.getType()) {
                    case EditorCommon.EventType.ModelContentChanged2:
                        changedEvents.push(e.getData());
                        break;
                }
            }
            if (changedEvents.length > 0) {
                this._proxy._acceptModelChanged(modelUrl.toString(), changedEvents);
            }
        };
        // --- from extension host process
        MainThreadDocuments.prototype._trySaveDocument = function (uri) {
            return this._textFileService.save(uri);
        };
        MainThreadDocuments.prototype._tryOpenDocument = function (uri) {
            if (!uri.scheme || !(uri.fsPath || uri.authority)) {
                return winjs_base_1.TPromise.wrapError("Invalid uri. Scheme and authority or path must be set.");
            }
            var promise;
            switch (uri.scheme) {
                case 'untitled':
                    promise = this._handleUnititledScheme(uri);
                    break;
                case 'file':
                default:
                    promise = this._handleAsResourceInput(uri);
                    break;
            }
            return promise.then(function (success) {
                if (!success) {
                    return winjs_base_1.TPromise.wrapError('cannot open ' + uri.toString());
                }
            }, function (err) {
                return winjs_base_1.TPromise.wrapError('cannot open ' + uri.toString() + '. Detail: ' + errors_1.toErrorMessage(err));
            });
        };
        MainThreadDocuments.prototype._handleAsResourceInput = function (uri) {
            return this._editorService.resolveEditorModel({ resource: uri }).then(function (model) {
                return !!model;
            });
        };
        MainThreadDocuments.prototype._handleUnititledScheme = function (uri) {
            var _this = this;
            var asFileUri = uri_1.default.file(uri.fsPath);
            return this._fileService.resolveFile(asFileUri).then(function (stats) {
                // don't create a new file ontop of an existing file
                return winjs_base_1.TPromise.wrapError('file already exists on disk');
            }, function (err) {
                var input = _this._untitledEditorService.createOrGet(asFileUri); // using file-uri makes it show in 'Working Files' section
                return input.resolve(true).then(function (model) {
                    if (input.getResource().toString() !== uri.toString()) {
                        throw new Error("expected URI " + uri.toString() + " BUT GOT " + input.getResource().toString());
                    }
                    return _this._proxy._acceptModelDirty(uri.toString()); // mark as dirty
                }).then(function () {
                    return true;
                });
            });
        };
        // --- virtual document logic
        MainThreadDocuments.prototype.$registerTextContentProvider = function (handle, scheme) {
            var _this = this;
            this._resourceContentProvider[handle] = resourceEditorInput_1.ResourceEditorInput.registerResourceContentProvider(scheme, {
                provideTextContent: function (uri) {
                    return _this._proxy.$provideTextDocumentContent(handle, uri).then(function (value) {
                        if (value) {
                            _this._virtualDocumentSet[uri.toString()] = true;
                            var firstLineText = value.substr(0, 1 + value.search(/\r?\n/));
                            var mode = _this._modeService.getOrCreateModeByFilenameOrFirstLine(uri.fsPath, firstLineText);
                            return _this._modelService.createModel(value, mode, uri);
                        }
                    });
                }
            });
        };
        MainThreadDocuments.prototype.$unregisterTextContentProvider = function (handle) {
            var registration = this._resourceContentProvider[handle];
            if (registration) {
                registration.dispose();
                delete this._resourceContentProvider[handle];
            }
        };
        MainThreadDocuments.prototype.$onVirtualDocumentChange = function (uri, value) {
            var model = this._modelService.getModel(uri);
            if (model) {
                model.setValue(value);
            }
        };
        MainThreadDocuments.prototype._runDocumentCleanup = function () {
            var _this = this;
            var toBeDisposed = [];
            winjs_base_1.TPromise.join(Object.keys(this._virtualDocumentSet).map(function (key) {
                var resource = uri_1.default.parse(key);
                return _this._proxy.$isDocumentReferenced(resource).then(function (referenced) {
                    if (!referenced) {
                        return _this._editorService.inputToType({ resource: resource }).then(function (input) {
                            if (!_this._editorService.isVisible(input, true)) {
                                toBeDisposed.push(resource);
                            }
                        });
                    }
                });
            })).then(function () {
                for (var _i = 0, toBeDisposed_1 = toBeDisposed; _i < toBeDisposed_1.length; _i++) {
                    var resource = toBeDisposed_1[_i];
                    _this._modelService.destroyModel(resource);
                    delete _this._virtualDocumentSet[resource.toString()];
                }
            }, errors_1.onUnexpectedError);
        };
        MainThreadDocuments = __decorate([
            thread_1.Remotable.MainContext('MainThreadDocuments'),
            __param(0, thread_1.IThreadService),
            __param(1, modelService_1.IModelService),
            __param(2, modeService_1.IModeService),
            __param(3, event_2.IEventService),
            __param(4, files_1.ITextFileService),
            __param(5, editorService_1.IWorkbenchEditorService),
            __param(6, files_2.IFileService),
            __param(7, untitledEditorService_1.IUntitledEditorService)
        ], MainThreadDocuments);
        return MainThreadDocuments;
    }());
    exports.MainThreadDocuments = MainThreadDocuments;
});

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/workbench/api/node/extHostEditors", ["require", "exports", 'vs/base/common/event', 'vs/base/common/lifecycle', 'vs/base/common/winjs.base', 'vs/platform/thread/common/thread', 'vs/workbench/api/node/extHostDocuments', './extHostTypes', 'vs/editor/common/editorCommon', 'vs/editor/common/services/codeEditorService', 'vs/workbench/services/editor/common/editorService', 'vs/editor/common/services/modelService', 'vs/workbench/api/node/mainThreadEditors', './extHostTypeConverters', 'vs/workbench/common/events', 'vs/platform/telemetry/common/telemetry', 'vs/platform/event/common/event', 'vs/base/common/arrays', 'vs/base/common/objects'], function (require, exports, event_1, lifecycle_1, winjs_base_1, thread_1, extHostDocuments_1, extHostTypes_1, editorCommon_1, codeEditorService_1, editorService_1, modelService_1, mainThreadEditors_1, TypeConverters, events_1, telemetry_1, event_2, arrays_1, objects_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ExtHostEditors = (function () {
        function ExtHostEditors(threadService) {
            this._onDidChangeTextEditorSelection = new event_1.Emitter();
            this.onDidChangeTextEditorSelection = this._onDidChangeTextEditorSelection.event;
            this._onDidChangeTextEditorOptions = new event_1.Emitter();
            this.onDidChangeTextEditorOptions = this._onDidChangeTextEditorOptions.event;
            this._onDidChangeTextEditorViewColumn = new event_1.Emitter();
            this.onDidChangeTextEditorViewColumn = this._onDidChangeTextEditorViewColumn.event;
            this._modelService = threadService.getRemotable(extHostDocuments_1.ExtHostModelService);
            this._proxy = threadService.getRemotable(MainThreadEditors);
            this._onDidChangeActiveTextEditor = new event_1.Emitter();
            this._editors = Object.create(null);
            this._visibleEditorIds = [];
        }
        ExtHostEditors.prototype.getActiveTextEditor = function () {
            return this._activeEditorId && this._editors[this._activeEditorId];
        };
        ExtHostEditors.prototype.getVisibleTextEditors = function () {
            var _this = this;
            return this._visibleEditorIds.map(function (id) { return _this._editors[id]; });
        };
        Object.defineProperty(ExtHostEditors.prototype, "onDidChangeActiveTextEditor", {
            get: function () {
                return this._onDidChangeActiveTextEditor && this._onDidChangeActiveTextEditor.event;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostEditors.prototype.showTextDocument = function (document, column, preserveFocus) {
            var _this = this;
            return this._proxy._tryShowTextDocument(document.uri, TypeConverters.fromViewColumn(column), preserveFocus).then(function (id) {
                var editor = _this._editors[id];
                if (editor) {
                    return editor;
                }
                else {
                    throw new Error('Failed to create editor with id: ' + id);
                }
            });
        };
        ExtHostEditors.prototype.createTextEditorDecorationType = function (options) {
            return new TextEditorDecorationType(this._proxy, options);
        };
        // --- called from main thread
        ExtHostEditors.prototype._acceptTextEditorAdd = function (data) {
            var document = this._modelService.getDocumentData(data.document);
            var newEditor = new ExtHostTextEditor(this._proxy, data.id, document, data.selections.map(TypeConverters.toSelection), data.options, TypeConverters.toViewColumn(data.editorPosition));
            this._editors[data.id] = newEditor;
        };
        ExtHostEditors.prototype._acceptOptionsChanged = function (id, opts) {
            var editor = this._editors[id];
            editor._acceptOptions(opts);
            this._onDidChangeTextEditorOptions.fire({
                textEditor: editor,
                options: opts
            });
        };
        ExtHostEditors.prototype._acceptSelectionsChanged = function (id, _selections) {
            var selections = _selections.map(TypeConverters.toSelection);
            var editor = this._editors[id];
            editor._acceptSelections(selections);
            this._onDidChangeTextEditorSelection.fire({
                textEditor: editor,
                selections: selections
            });
        };
        ExtHostEditors.prototype._acceptActiveEditorAndVisibleEditors = function (id, visibleIds) {
            this._visibleEditorIds = visibleIds;
            if (this._activeEditorId === id) {
                // nothing to do
                return;
            }
            this._activeEditorId = id;
            this._onDidChangeActiveTextEditor.fire(this.getActiveTextEditor());
        };
        ExtHostEditors.prototype._acceptEditorPositionData = function (data) {
            for (var id in data) {
                var textEditor = this._editors[id];
                var viewColumn = TypeConverters.toViewColumn(data[id]);
                if (textEditor.viewColumn !== viewColumn) {
                    textEditor._acceptViewColumn(viewColumn);
                    this._onDidChangeTextEditorViewColumn.fire({ textEditor: textEditor, viewColumn: viewColumn });
                }
            }
        };
        ExtHostEditors.prototype._acceptTextEditorRemove = function (id) {
            // make sure the removed editor is not visible
            var newVisibleEditors = this._visibleEditorIds.filter(function (visibleEditorId) { return visibleEditorId !== id; });
            if (this._activeEditorId === id) {
                // removing the current active editor
                this._acceptActiveEditorAndVisibleEditors(undefined, newVisibleEditors);
            }
            else {
                this._acceptActiveEditorAndVisibleEditors(this._activeEditorId, newVisibleEditors);
            }
            var editor = this._editors[id];
            editor.dispose();
            delete this._editors[id];
        };
        ExtHostEditors = __decorate([
            thread_1.Remotable.ExtHostContext('ExtHostEditors'),
            __param(0, thread_1.IThreadService)
        ], ExtHostEditors);
        return ExtHostEditors;
    }());
    exports.ExtHostEditors = ExtHostEditors;
    var TextEditorDecorationType = (function () {
        function TextEditorDecorationType(proxy, options) {
            this.key = 'TextEditorDecorationType' + (++TextEditorDecorationType.LAST_ID);
            this._proxy = proxy;
            this._proxy._registerTextEditorDecorationType(this.key, options);
        }
        TextEditorDecorationType.prototype.dispose = function () {
            this._proxy._removeTextEditorDecorationType(this.key);
        };
        TextEditorDecorationType.LAST_ID = 0;
        return TextEditorDecorationType;
    }());
    var TextEditorEdit = (function () {
        function TextEditorEdit(document) {
            this._documentVersionId = document.version;
            this._collectedEdits = [];
            this._setEndOfLine = 0;
        }
        TextEditorEdit.prototype.finalize = function () {
            return {
                documentVersionId: this._documentVersionId,
                edits: this._collectedEdits,
                setEndOfLine: this._setEndOfLine
            };
        };
        TextEditorEdit.prototype.replace = function (location, value) {
            var range = null;
            if (location instanceof extHostTypes_1.Position) {
                range = new extHostTypes_1.Range(location, location);
            }
            else if (location instanceof extHostTypes_1.Range) {
                range = location;
            }
            else if (location instanceof extHostTypes_1.Selection) {
                range = new extHostTypes_1.Range(location.start, location.end);
            }
            else {
                throw new Error('Unrecognized location');
            }
            this._collectedEdits.push({
                range: range,
                text: value,
                forceMoveMarkers: false
            });
        };
        TextEditorEdit.prototype.insert = function (location, value) {
            this._collectedEdits.push({
                range: new extHostTypes_1.Range(location, location),
                text: value,
                forceMoveMarkers: true
            });
        };
        TextEditorEdit.prototype.delete = function (location) {
            var range = null;
            if (location instanceof extHostTypes_1.Range) {
                range = location;
            }
            else if (location instanceof extHostTypes_1.Selection) {
                range = new extHostTypes_1.Range(location.start, location.end);
            }
            else {
                throw new Error('Unrecognized location');
            }
            this._collectedEdits.push({
                range: range,
                text: null,
                forceMoveMarkers: true
            });
        };
        TextEditorEdit.prototype.setEndOfLine = function (endOfLine) {
            if (endOfLine !== extHostTypes_1.EndOfLine.LF && endOfLine !== extHostTypes_1.EndOfLine.CRLF) {
                throw illegalArg('endOfLine');
            }
            this._setEndOfLine = endOfLine;
        };
        return TextEditorEdit;
    }());
    exports.TextEditorEdit = TextEditorEdit;
    function readonly(name, alt) {
        var message = "The property '" + name + "' is readonly.";
        if (alt) {
            message += " Use '" + alt + "' instead.";
        }
        return new Error(message);
    }
    function illegalArg(name) {
        return new Error("illgeal argument '" + name + "'");
    }
    function deprecated(name, message) {
        if (message === void 0) { message = 'Refer to the documentation for further details.'; }
        return function (target, key, descriptor) {
            var originalMethod = descriptor.value;
            descriptor.value = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                console.warn("[Deprecation Warning] method '" + name + "' is deprecated and should no longer be used. " + message);
                return originalMethod.apply(this, args);
            };
            return descriptor;
        };
    }
    var ExtHostTextEditor = (function () {
        function ExtHostTextEditor(proxy, id, document, selections, options, viewColumn) {
            this._proxy = proxy;
            this._id = id;
            this._documentData = document;
            this._selections = selections;
            this._options = options;
            this._viewColumn = viewColumn;
        }
        ExtHostTextEditor.prototype.dispose = function () {
            this._documentData = null;
        };
        ExtHostTextEditor.prototype.show = function (column) {
            this._proxy._tryShowEditor(this._id, TypeConverters.fromViewColumn(column));
        };
        ExtHostTextEditor.prototype.hide = function () {
            this._proxy._tryHideEditor(this._id);
        };
        Object.defineProperty(ExtHostTextEditor.prototype, "document", {
            // ---- the document
            get: function () {
                return this._documentData.document;
            },
            set: function (value) {
                throw readonly('document');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTextEditor.prototype, "options", {
            // ---- options
            get: function () {
                return this._options;
            },
            set: function (value) {
                var _this = this;
                this._options = value;
                this._runOnProxy(function () {
                    return _this._proxy._trySetOptions(_this._id, _this._options);
                }, true);
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditor.prototype._acceptOptions = function (options) {
            this._options = options;
        };
        Object.defineProperty(ExtHostTextEditor.prototype, "viewColumn", {
            // ---- view column
            get: function () {
                return this._viewColumn;
            },
            set: function (value) {
                throw readonly('viewColumn');
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditor.prototype._acceptViewColumn = function (value) {
            this._viewColumn = value;
        };
        Object.defineProperty(ExtHostTextEditor.prototype, "selection", {
            // ---- selections
            get: function () {
                return this._selections && this._selections[0];
            },
            set: function (value) {
                if (!(value instanceof extHostTypes_1.Selection)) {
                    throw illegalArg('selection');
                }
                this._selections = [value];
                this._trySetSelection(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTextEditor.prototype, "selections", {
            get: function () {
                return this._selections;
            },
            set: function (value) {
                if (!Array.isArray(value) || value.some(function (a) { return !(a instanceof extHostTypes_1.Selection); })) {
                    throw illegalArg('selections');
                }
                this._selections = value;
                this._trySetSelection(true);
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditor.prototype.setDecorations = function (decorationType, ranges) {
            var _this = this;
            this._runOnProxy(function () { return _this._proxy._trySetDecorations(_this._id, decorationType.key, TypeConverters.fromRangeOrRangeWithMessage(ranges)); }, true);
        };
        ExtHostTextEditor.prototype.revealRange = function (range, revealType) {
            var _this = this;
            this._runOnProxy(function () { return _this._proxy._tryRevealRange(_this._id, TypeConverters.fromRange(range), revealType || mainThreadEditors_1.TextEditorRevealType.Default); }, true);
        };
        ExtHostTextEditor.prototype._trySetSelection = function (silent) {
            var _this = this;
            var selection = this._selections.map(TypeConverters.fromSelection);
            return this._runOnProxy(function () { return _this._proxy._trySetSelections(_this._id, selection); }, silent);
        };
        ExtHostTextEditor.prototype._acceptSelections = function (selections) {
            this._selections = selections;
        };
        // ---- editing
        ExtHostTextEditor.prototype.edit = function (callback) {
            var edit = new TextEditorEdit(this._documentData.document);
            callback(edit);
            return this._applyEdit(edit);
        };
        ExtHostTextEditor.prototype._applyEdit = function (editBuilder) {
            var editData = editBuilder.finalize();
            // prepare data for serialization
            var edits = editData.edits.map(function (edit) {
                return {
                    range: TypeConverters.fromRange(edit.range),
                    text: edit.text,
                    forceMoveMarkers: edit.forceMoveMarkers
                };
            });
            return this._proxy._tryApplyEdits(this._id, editData.documentVersionId, edits, editData.setEndOfLine);
        };
        // ---- util
        ExtHostTextEditor.prototype._runOnProxy = function (callback, silent) {
            var _this = this;
            return callback().then(function () { return _this; }, function (err) {
                if (!silent) {
                    return winjs_base_1.TPromise.wrapError(silent);
                }
                console.warn(err);
            });
        };
        __decorate([
            deprecated('TextEditor.show')
        ], ExtHostTextEditor.prototype, "show", null);
        __decorate([
            deprecated('TextEditor.hide')
        ], ExtHostTextEditor.prototype, "hide", null);
        return ExtHostTextEditor;
    }());
    var MainThreadEditors = (function () {
        function MainThreadEditors(threadService, workbenchEditorService, telemetryService, editorService, eventService, modelService) {
            var _this = this;
            this._proxy = threadService.getRemotable(ExtHostEditors);
            this._workbenchEditorService = workbenchEditorService;
            this._telemetryService = telemetryService;
            this._toDispose = [];
            this._textEditorsListenersMap = Object.create(null);
            this._textEditorsMap = Object.create(null);
            this._activeTextEditor = null;
            this._visibleEditors = [];
            this._editorPositionData = null;
            this._editorTracker = new mainThreadEditors_1.MainThreadEditorsTracker(editorService, modelService);
            this._toDispose.push(this._editorTracker);
            this._toDispose.push(this._editorTracker.onTextEditorAdd(function (textEditor) { return _this._onTextEditorAdd(textEditor); }));
            this._toDispose.push(this._editorTracker.onTextEditorRemove(function (textEditor) { return _this._onTextEditorRemove(textEditor); }));
            this._toDispose.push(this._editorTracker.onDidUpdateTextEditors(function () { return _this._updateActiveAndVisibleTextEditors(); }));
            this._toDispose.push(this._editorTracker.onChangedFocusedTextEditor(function (focusedTextEditorId) { return _this._updateActiveAndVisibleTextEditors(); }));
            this._toDispose.push(eventService.addListener2(events_1.EventType.EDITOR_INPUT_CHANGED, function () { return _this._updateActiveAndVisibleTextEditors(); }));
            this._toDispose.push(eventService.addListener2(events_1.EventType.EDITOR_POSITION_CHANGED, function () { return _this._updateActiveAndVisibleTextEditors(); }));
        }
        MainThreadEditors.prototype.dispose = function () {
            var _this = this;
            Object.keys(this._textEditorsListenersMap).forEach(function (editorId) {
                lifecycle_1.disposeAll(_this._textEditorsListenersMap[editorId]);
            });
            this._textEditorsListenersMap = Object.create(null);
            this._toDispose = lifecycle_1.disposeAll(this._toDispose);
        };
        MainThreadEditors.prototype._onTextEditorAdd = function (textEditor) {
            var _this = this;
            var id = textEditor.getId();
            var toDispose = [];
            toDispose.push(textEditor.onConfigurationChanged(function (opts) {
                _this._proxy._acceptOptionsChanged(id, opts);
            }));
            toDispose.push(textEditor.onSelectionChanged(function (selection) {
                _this._proxy._acceptSelectionsChanged(id, selection);
            }));
            this._proxy._acceptTextEditorAdd({
                id: id,
                document: textEditor.getModel().getAssociatedResource(),
                options: textEditor.getConfiguration(),
                selections: textEditor.getSelections(),
                editorPosition: this._findEditorPosition(textEditor)
            });
            this._textEditorsListenersMap[id] = toDispose;
            this._textEditorsMap[id] = textEditor;
        };
        MainThreadEditors.prototype._onTextEditorRemove = function (textEditor) {
            var id = textEditor.getId();
            lifecycle_1.disposeAll(this._textEditorsListenersMap[id]);
            delete this._textEditorsListenersMap[id];
            delete this._textEditorsMap[id];
            this._proxy._acceptTextEditorRemove(id);
        };
        MainThreadEditors.prototype._updateActiveAndVisibleTextEditors = function () {
            // active and visible editors
            var visibleEditors = this._editorTracker.getVisibleTextEditorIds();
            var activeEditor = this._findActiveTextEditorId();
            if (activeEditor !== this._activeTextEditor || !arrays_1.equals(this._visibleEditors, visibleEditors, function (a, b) { return a === b; })) {
                this._activeTextEditor = activeEditor;
                this._visibleEditors = visibleEditors;
                this._proxy._acceptActiveEditorAndVisibleEditors(this._activeTextEditor, this._visibleEditors);
            }
            // editor columns
            var editorPositionData = this._getTextEditorPositionData();
            if (!objects_1.equals(this._editorPositionData, editorPositionData)) {
                this._editorPositionData = editorPositionData;
                this._proxy._acceptEditorPositionData(this._editorPositionData);
            }
        };
        MainThreadEditors.prototype._findActiveTextEditorId = function () {
            var focusedTextEditorId = this._editorTracker.getFocusedTextEditorId();
            if (focusedTextEditorId) {
                return focusedTextEditorId;
            }
            var activeEditor = this._workbenchEditorService.getActiveEditor();
            if (!activeEditor) {
                return null;
            }
            var editor = activeEditor.getControl();
            // Substitute for (editor instanceof ICodeEditor)
            if (!editor || typeof editor.getEditorType !== 'function') {
                // Not a text editor...
                return null;
            }
            if (editor.getEditorType() === editorCommon_1.EditorType.ICodeEditor) {
                return this._editorTracker.findTextEditorIdFor(editor);
            }
            // Must be a diff editor => use the modified side
            return this._editorTracker.findTextEditorIdFor(editor.getModifiedEditor());
        };
        MainThreadEditors.prototype._findEditorPosition = function (editor) {
            for (var _i = 0, _a = this._workbenchEditorService.getVisibleEditors(); _i < _a.length; _i++) {
                var workbenchEditor = _a[_i];
                if (editor.matches(workbenchEditor)) {
                    return workbenchEditor.position;
                }
            }
        };
        MainThreadEditors.prototype._getTextEditorPositionData = function () {
            var result = Object.create(null);
            for (var _i = 0, _a = this._workbenchEditorService.getVisibleEditors(); _i < _a.length; _i++) {
                var workbenchEditor = _a[_i];
                var editor = workbenchEditor.getControl();
                // Substitute for (editor instanceof ICodeEditor)
                if (!editor || typeof editor.getEditorType !== 'function') {
                    // Not a text editor...
                    continue;
                }
                if (editor.getEditorType() === editorCommon_1.EditorType.ICodeEditor) {
                    var id = this._editorTracker.findTextEditorIdFor(editor);
                    if (id) {
                        result[id] = workbenchEditor.position;
                    }
                }
            }
            return result;
        };
        // --- from extension host process
        MainThreadEditors.prototype._tryShowTextDocument = function (resource, position, preserveFocus) {
            var _this = this;
            var input = {
                resource: resource,
                options: { preserveFocus: preserveFocus }
            };
            return this._workbenchEditorService.openEditor(input, position).then(function (editor) {
                return new winjs_base_1.TPromise(function (c) {
                    // not very nice but the way it is: changes to the editor state aren't
                    // send to the ext host as they happen but stuff is delayed a little. in
                    // order to provide the real editor on #openTextEditor we need to sync on
                    // that update
                    var subscription;
                    var handle;
                    function contd() {
                        subscription.dispose();
                        clearTimeout(handle);
                        c(undefined);
                    }
                    subscription = _this._editorTracker.onDidUpdateTextEditors(function () {
                        contd();
                    });
                    handle = setTimeout(function () {
                        contd();
                    }, 1000);
                }).then(function () {
                    // find the editor we have just opened and return the
                    // id we have assigned to it.
                    for (var id in _this._textEditorsMap) {
                        if (_this._textEditorsMap[id].matches(editor)) {
                            return id;
                        }
                    }
                });
            });
        };
        MainThreadEditors.prototype._tryShowEditor = function (id, position) {
            // check how often this is used
            this._telemetryService.publicLog('api.deprecated', { function: 'TextEditor.show' });
            var mainThreadEditor = this._textEditorsMap[id];
            if (mainThreadEditor) {
                var model = mainThreadEditor.getModel();
                return this._workbenchEditorService.openEditor({
                    resource: model.getAssociatedResource(),
                    options: { preserveFocus: false }
                }, position).then(function () { return; });
            }
        };
        MainThreadEditors.prototype._tryHideEditor = function (id) {
            // check how often this is used
            this._telemetryService.publicLog('api.deprecated', { function: 'TextEditor.hide' });
            var mainThreadEditor = this._textEditorsMap[id];
            if (mainThreadEditor) {
                var editors = this._workbenchEditorService.getVisibleEditors();
                for (var _i = 0, editors_1 = editors; _i < editors_1.length; _i++) {
                    var editor = editors_1[_i];
                    if (mainThreadEditor.matches(editor)) {
                        return this._workbenchEditorService.closeEditor(editor).then(function () { return; });
                    }
                }
            }
        };
        MainThreadEditors.prototype._trySetSelections = function (id, selections) {
            if (!this._textEditorsMap[id]) {
                return winjs_base_1.TPromise.wrapError('TextEditor disposed');
            }
            this._textEditorsMap[id].setSelections(selections);
            return winjs_base_1.TPromise.as(null);
        };
        MainThreadEditors.prototype._trySetDecorations = function (id, key, ranges) {
            if (!this._textEditorsMap[id]) {
                return winjs_base_1.TPromise.wrapError('TextEditor disposed');
            }
            this._textEditorsMap[id].setDecorations(key, ranges);
            return winjs_base_1.TPromise.as(null);
        };
        MainThreadEditors.prototype._tryRevealRange = function (id, range, revealType) {
            if (!this._textEditorsMap[id]) {
                return winjs_base_1.TPromise.wrapError('TextEditor disposed');
            }
            this._textEditorsMap[id].revealRange(range, revealType);
        };
        MainThreadEditors.prototype._trySetOptions = function (id, options) {
            if (!this._textEditorsMap[id]) {
                return winjs_base_1.TPromise.wrapError('TextEditor disposed');
            }
            this._textEditorsMap[id].setConfiguration(options);
            return winjs_base_1.TPromise.as(null);
        };
        MainThreadEditors.prototype._tryApplyEdits = function (id, modelVersionId, edits, setEndOfLine) {
            if (!this._textEditorsMap[id]) {
                return winjs_base_1.TPromise.wrapError('TextEditor disposed');
            }
            return winjs_base_1.TPromise.as(this._textEditorsMap[id].applyEdits(modelVersionId, edits, setEndOfLine));
        };
        MainThreadEditors.prototype._registerTextEditorDecorationType = function (key, options) {
            this._editorTracker.registerTextEditorDecorationType(key, options);
        };
        MainThreadEditors.prototype._removeTextEditorDecorationType = function (key) {
            this._editorTracker.removeTextEditorDecorationType(key);
        };
        MainThreadEditors = __decorate([
            thread_1.Remotable.MainContext('MainThreadEditors'),
            __param(0, thread_1.IThreadService),
            __param(1, editorService_1.IWorkbenchEditorService),
            __param(2, telemetry_1.ITelemetryService),
            __param(3, codeEditorService_1.ICodeEditorService),
            __param(4, event_2.IEventService),
            __param(5, modelService_1.IModelService)
        ], MainThreadEditors);
        return MainThreadEditors;
    }());
    exports.MainThreadEditors = MainThreadEditors;
});

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/workbench/api/node/extHostCommands", ["require", "exports", 'vs/platform/thread/common/thread', 'vs/base/common/types', 'vs/platform/keybinding/common/keybindingsRegistry', 'vs/platform/keybinding/common/keybindingService', 'vs/base/common/winjs.base', 'vs/workbench/api/node/extHostEditors', 'vs/workbench/api/node/extHostTypes', 'vs/workbench/api/node/extHostTypeConverters', 'vs/base/common/objects'], function (require, exports, thread_1, types_1, keybindingsRegistry_1, keybindingService_1, winjs_base_1, extHostEditors_1, extHostTypes, extHostTypeConverter, objects_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ExtHostCommands = (function () {
        function ExtHostCommands(threadService) {
            this._commands = Object.create(null);
            this._extHostEditors = threadService.getRemotable(extHostEditors_1.ExtHostEditors);
            this._proxy = threadService.getRemotable(MainThreadCommands);
        }
        ExtHostCommands.prototype.registerCommand = function (id, callback, thisArg, description) {
            var _this = this;
            if (!id.trim().length) {
                throw new Error('invalid id');
            }
            if (this._commands[id]) {
                throw new Error('command with id already exists');
            }
            this._commands[id] = { callback: callback, thisArg: thisArg, description: description };
            this._proxy.$registerCommand(id);
            return new extHostTypes.Disposable(function () { return delete _this._commands[id]; });
        };
        ExtHostCommands.prototype.executeCommand = function (id) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this._commands[id]) {
                // we stay inside the extension host and support
                // to pass any kind of parameters around
                return this.$executeContributedCommand.apply(this, [id].concat(args));
            }
            else {
                // automagically convert some argument types
                args = objects_1.cloneAndChange(args, function (value) {
                    if (value instanceof extHostTypes.Position) {
                        return extHostTypeConverter.fromPosition(value);
                    }
                    if (value instanceof extHostTypes.Range) {
                        return extHostTypeConverter.fromRange(value);
                    }
                    if (value instanceof extHostTypes.Location) {
                        return extHostTypeConverter.location.from(value);
                    }
                    if (!Array.isArray(value)) {
                        return value;
                    }
                });
                return this._proxy.$executeCommand(id, args);
            }
        };
        ExtHostCommands.prototype.$executeContributedCommand = function (id) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var command = this._commands[id];
            if (!command) {
                return Promise.reject("Contributed command '" + id + "' does not exist.");
            }
            try {
                var callback = command.callback, thisArg = command.thisArg, description = command.description;
                if (description) {
                    for (var i = 0; i < description.args.length; i++) {
                        types_1.validateConstraint(args[i], description.args[i].constraint);
                    }
                }
                var result = callback.apply(thisArg, args);
                return Promise.resolve(result);
            }
            catch (err) {
                // console.log(err);
                // try {
                // 	console.log(toErrorMessage(err));
                // } catch (err) {
                // 	//
                // }
                return Promise.reject("Running the contributed command:'" + id + "' failed.");
            }
        };
        ExtHostCommands.prototype.getCommands = function (filterUnderscoreCommands) {
            if (filterUnderscoreCommands === void 0) { filterUnderscoreCommands = false; }
            return this._proxy.$getCommands().then(function (result) {
                if (filterUnderscoreCommands) {
                    result = result.filter(function (command) { return command[0] !== '_'; });
                }
                return result;
            });
        };
        ExtHostCommands.prototype.$getContributedCommandHandlerDescriptions = function () {
            var result = Object.create(null);
            for (var id in this._commands) {
                var description = this._commands[id].description;
                if (description) {
                    result[id] = description;
                }
            }
            return winjs_base_1.TPromise.as(result);
        };
        ExtHostCommands = __decorate([
            thread_1.Remotable.ExtHostContext('ExtHostCommands'),
            __param(0, thread_1.IThreadService)
        ], ExtHostCommands);
        return ExtHostCommands;
    }());
    exports.ExtHostCommands = ExtHostCommands;
    var MainThreadCommands = (function () {
        function MainThreadCommands(threadService, keybindingService) {
            this._threadService = threadService;
            this._keybindingService = keybindingService;
            this._proxy = this._threadService.getRemotable(ExtHostCommands);
        }
        MainThreadCommands.prototype.$registerCommand = function (id) {
            var _this = this;
            keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc({
                id: id,
                handler: function (serviceAccessor) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    return (_a = _this._proxy).$executeContributedCommand.apply(_a, [id].concat(args));
                    var _a;
                },
                weight: undefined,
                context: undefined,
                win: undefined,
                mac: undefined,
                linux: undefined,
                primary: undefined,
                secondary: undefined
            });
            return undefined;
        };
        MainThreadCommands.prototype.$executeCommand = function (id, args) {
            return this._keybindingService.executeCommand(id, args);
        };
        MainThreadCommands.prototype.$getCommands = function () {
            return winjs_base_1.TPromise.as(Object.keys(keybindingsRegistry_1.KeybindingsRegistry.getCommands()));
        };
        MainThreadCommands = __decorate([
            thread_1.Remotable.MainContext('MainThreadCommands'),
            __param(0, thread_1.IThreadService),
            __param(1, keybindingService_1.IKeybindingService)
        ], MainThreadCommands);
        return MainThreadCommands;
    }());
    exports.MainThreadCommands = MainThreadCommands;
    // --- command doc
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc({
        id: '_generateCommandsDocumentation',
        handler: function (accessor) {
            return accessor.get(thread_1.IThreadService).getRemotable(ExtHostCommands).$getContributedCommandHandlerDescriptions().then(function (result) {
                // add local commands
                var commands = keybindingsRegistry_1.KeybindingsRegistry.getCommands();
                for (var id in commands) {
                    var description = commands[id].description;
                    if (description) {
                        result[id] = description;
                    }
                }
                // print all as markdown
                var all = [];
                for (var id in result) {
                    all.push('`' + id + '` - ' + _generateMarkdown(result[id]));
                }
                console.log(all.join('\n'));
            });
        },
        context: undefined,
        weight: keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.builtinExtension(0),
        primary: undefined
    });
    function _generateMarkdown(description) {
        if (typeof description === 'string') {
            return description;
        }
        else {
            var parts = [description.description];
            parts.push('\n\n');
            if (description.args) {
                for (var _i = 0, _a = description.args; _i < _a.length; _i++) {
                    var arg = _a[_i];
                    parts.push("* _" + arg.name + "_ " + (arg.description || '') + "\n");
                }
            }
            if (description.returns) {
                parts.push("* _(returns)_ " + description.returns);
            }
            parts.push('\n\n');
            return parts.join('');
        }
    }
});

define("vs/workbench/api/node/extHostApiCommands", ["require", "exports", 'vs/base/common/uri', 'vs/base/common/winjs.base', 'vs/workbench/api/node/extHostTypeConverters', 'vs/workbench/api/node/extHostTypes', 'vs/workbench/api/node/extHostCommands'], function (require, exports, uri_1, winjs_base_1, typeConverters, types, extHostCommands_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function registerApiCommands(threadService) {
        var commands = threadService.getRemotable(extHostCommands_1.ExtHostCommands);
        new ExtHostApiCommands(commands).registerCommands();
    }
    exports.registerApiCommands = registerApiCommands;
    var ExtHostApiCommands = (function () {
        function ExtHostApiCommands(commands) {
            this._disposables = [];
            this._commands = commands;
        }
        ExtHostApiCommands.prototype.registerCommands = function () {
            var _this = this;
            this._register('vscode.executeWorkspaceSymbolProvider', this._executeWorkspaceSymbolProvider, {
                description: 'Execute all workspace symbol provider.',
                args: [{ name: 'query', description: 'Search string', constraint: String }],
                returns: 'A promise that resolves to an array of SymbolInformation-instances.'
            });
            this._register('vscode.executeDefinitionProvider', this._executeDefinitionProvider, {
                description: 'Execute all definition provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position of a symbol', constraint: types.Position }
                ],
                returns: 'A promise that resolves to an array of Location-instances.'
            });
            this._register('vscode.executeHoverProvider', this._executeHoverProvider, {
                description: 'Execute all hover provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position of a symbol', constraint: types.Position }
                ],
                returns: 'A promise that resolves to an array of Hover-instances.'
            });
            this._register('vscode.executeDocumentHighlights', this._executeDocumentHighlights, {
                description: 'Execute document highlight provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position in a text document', constraint: types.Position }
                ],
                returns: 'A promise that resolves to an array of DocumentHighlight-instances.'
            });
            this._register('vscode.executeReferenceProvider', this._executeReferenceProvider, {
                description: 'Execute reference provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position in a text document', constraint: types.Position }
                ],
                returns: 'A promise that resolves to an array of Location-instances.'
            });
            this._register('vscode.executeDocumentRenameProvider', this._executeDocumentRenameProvider, {
                description: 'Execute rename provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position in a text document', constraint: types.Position },
                    { name: 'newName', description: 'The new symbol name', constraint: String }
                ],
                returns: 'A promise that resolves to a WorkspaceEdit.'
            });
            this._register('vscode.executeSignatureHelpProvider', this._executeSignatureHelpProvider, {
                description: 'Execute signature help provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position in a text document', constraint: types.Position }
                ],
                returns: 'A promise that resolves to SignatureHelp.'
            });
            this._register('vscode.executeDocumentSymbolProvider', this._executeDocumentSymbolProvider, {
                description: 'Execute document symbol provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default }
                ],
                returns: 'A promise that resolves to an array of SymbolInformation-instances.'
            });
            this._register('vscode.executeCompletionItemProvider', this._executeCompletionItemProvider, {
                description: 'Execute completion item provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position in a text document', constraint: types.Position }
                ],
                returns: 'A promise that resolves to a CompletionList-instance.'
            });
            this._register('vscode.executeCodeActionProvider', this._executeCodeActionProvider, {
                description: 'Execute code action provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'range', description: 'Range in a text document', constraint: types.Range }
                ],
                returns: 'A promise that resolves to an array of CompletionItem-instances.'
            });
            this._register('vscode.executeCodeLensProvider', this._executeCodeLensProvider, {
                description: 'Execute completion item provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default }
                ],
                returns: 'A promise that resolves to an array of Commands.'
            });
            this._register('vscode.executeFormatDocumentProvider', this._executeFormatDocumentProvider, {
                description: 'Execute document format provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'options', description: 'Formatting options' }
                ],
                returns: 'A promise that resolves to an array of TextEdits.'
            });
            this._register('vscode.executeFormatRangeProvider', this._executeFormatRangeProvider, {
                description: 'Execute range format provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'range', description: 'Range in a text document', constraint: types.Range },
                    { name: 'options', description: 'Formatting options' }
                ],
                returns: 'A promise that resolves to an array of TextEdits.'
            });
            this._register('vscode.executeFormatOnTypeProvider', this._executeFormatOnTypeProvider, {
                description: 'Execute document format provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position in a text document', constraint: types.Position },
                    { name: 'ch', description: 'Character that got typed', constraint: String },
                    { name: 'options', description: 'Formatting options' }
                ],
                returns: 'A promise that resolves to an array of TextEdits.'
            });
            this._register('vscode.previewHtml', function (uri, position) {
                return _this._commands.executeCommand('_workbench.previewHtml', uri, typeof position === 'number' ? typeConverters.fromViewColumn(position) : void 0);
            }, {
                description: 'Preview an html document.',
                args: [
                    { name: 'uri', description: 'Uri of the document to preview.', constraint: uri_1.default },
                    { name: 'column', description: '(optional) Column in which to preview.' },
                ]
            });
        };
        // --- command impl
        ExtHostApiCommands.prototype._register = function (id, handler, description) {
            var disposable = this._commands.registerCommand(id, handler, this, description);
            this._disposables.push(disposable);
        };
        /**
         * Execute workspace symbol provider.
         *
         * @param query Search string to match query symbol names
         * @return A promise that resolves to an array of symbol information.
         */
        ExtHostApiCommands.prototype._executeWorkspaceSymbolProvider = function (query) {
            return this._commands.executeCommand('_executeWorkspaceSymbolProvider', { query: query }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(typeConverters.toSymbolInformation);
                }
            });
        };
        ExtHostApiCommands.prototype._executeDefinitionProvider = function (resource, position) {
            var args = {
                resource: resource,
                position: position && typeConverters.fromPosition(position)
            };
            return this._commands.executeCommand('_executeDefinitionProvider', args).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(typeConverters.location.to);
                }
            });
        };
        ExtHostApiCommands.prototype._executeHoverProvider = function (resource, position) {
            var args = {
                resource: resource,
                position: position && typeConverters.fromPosition(position)
            };
            return this._commands.executeCommand('_executeHoverProvider', args).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(typeConverters.toHover);
                }
            });
        };
        ExtHostApiCommands.prototype._executeDocumentHighlights = function (resource, position) {
            var args = {
                resource: resource,
                position: position && typeConverters.fromPosition(position)
            };
            return this._commands.executeCommand('_executeDocumentHighlights', args).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(typeConverters.toDocumentHighlight);
                }
            });
        };
        ExtHostApiCommands.prototype._executeReferenceProvider = function (resource, position) {
            var args = {
                resource: resource,
                position: position && typeConverters.fromPosition(position)
            };
            return this._commands.executeCommand('_executeDocumentHighlights', args).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(typeConverters.location.to);
                }
            });
        };
        ExtHostApiCommands.prototype._executeDocumentRenameProvider = function (resource, position, newName) {
            var args = {
                resource: resource,
                position: position && typeConverters.fromPosition(position),
                newName: newName
            };
            return this._commands.executeCommand('_executeDocumentRenameProvider', args).then(function (value) {
                if (!value) {
                    return;
                }
                if (value.rejectReason) {
                    return winjs_base_1.TPromise.wrapError(value.rejectReason);
                }
                var workspaceEdit = new types.WorkspaceEdit();
                for (var _i = 0, _a = value.edits; _i < _a.length; _i++) {
                    var edit = _a[_i];
                    workspaceEdit.replace(edit.resource, typeConverters.toRange(edit.range), edit.newText);
                }
                return workspaceEdit;
            });
        };
        ExtHostApiCommands.prototype._executeSignatureHelpProvider = function (resource, position, triggerCharacter) {
            var args = {
                resource: resource,
                position: position && typeConverters.fromPosition(position),
                triggerCharacter: triggerCharacter
            };
            return this._commands.executeCommand('_executeSignatureHelpProvider', args).then(function (value) {
                if (value) {
                    return typeConverters.SignatureHelp.to(value);
                }
            });
        };
        ExtHostApiCommands.prototype._executeCompletionItemProvider = function (resource, position, triggerCharacter) {
            var args = {
                resource: resource,
                position: position && typeConverters.fromPosition(position),
                triggerCharacter: triggerCharacter
            };
            return this._commands.executeCommand('_executeCompletionItemProvider', args).then(function (value) {
                if (value) {
                    var items = [];
                    var incomplete = void 0;
                    for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
                        var group = value_1[_i];
                        for (var _a = 0, group_1 = group; _a < group_1.length; _a++) {
                            var suggestions = group_1[_a];
                            incomplete = suggestions.incomplete || incomplete;
                            for (var _b = 0, _c = suggestions.suggestions; _b < _c.length; _b++) {
                                var suggestion = _c[_b];
                                var item = typeConverters.Suggest.to(suggestions, position, suggestion);
                                items.push(item);
                            }
                        }
                    }
                    return new types.CompletionList(items, incomplete);
                }
            });
        };
        ExtHostApiCommands.prototype._executeDocumentSymbolProvider = function (resource) {
            var args = {
                resource: resource
            };
            return this._commands.executeCommand('_executeDocumentSymbolProvider', args).then(function (value) {
                if (value && Array.isArray(value.entries)) {
                    return value.entries.map(typeConverters.SymbolInformation.fromOutlineEntry);
                }
            });
        };
        ExtHostApiCommands.prototype._executeCodeActionProvider = function (resource, range) {
            var args = {
                resource: resource,
                range: typeConverters.fromRange(range)
            };
            return this._commands.executeCommand('_executeCodeActionProvider', args).then(function (value) {
                if (!Array.isArray(value)) {
                    return;
                }
                return value.map(function (quickFix) { return typeConverters.Command.to(quickFix.command); });
            });
        };
        ExtHostApiCommands.prototype._executeCodeLensProvider = function (resource) {
            var args = { resource: resource };
            return this._commands.executeCommand('_executeCodeLensProvider', args).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(function (item) {
                        return new types.CodeLens(typeConverters.toRange(item.symbol.range), typeConverters.Command.to(item.symbol.command));
                    });
                }
            });
        };
        ExtHostApiCommands.prototype._executeFormatDocumentProvider = function (resource, options) {
            var args = {
                resource: resource,
                options: options
            };
            return this._commands.executeCommand('_executeFormatDocumentProvider', args).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(function (edit) { return new types.TextEdit(typeConverters.toRange(edit.range), edit.text); });
                }
            });
        };
        ExtHostApiCommands.prototype._executeFormatRangeProvider = function (resource, range, options) {
            var args = {
                resource: resource,
                range: typeConverters.fromRange(range),
                options: options
            };
            return this._commands.executeCommand('_executeFormatRangeProvider', args).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(function (edit) { return new types.TextEdit(typeConverters.toRange(edit.range), edit.text); });
                }
            });
        };
        ExtHostApiCommands.prototype._executeFormatOnTypeProvider = function (resource, position, ch, options) {
            var args = {
                resource: resource,
                position: typeConverters.fromPosition(position),
                ch: ch,
                options: options
            };
            return this._commands.executeCommand('_executeFormatOnTypeProvider', args).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(function (edit) { return new types.TextEdit(typeConverters.toRange(edit.range), edit.text); });
                }
            });
        };
        return ExtHostApiCommands;
    }());
});

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/workbench/api/node/extHostLanguageFeatures", ["require", "exports", 'vs/editor/common/modes/modesFilters', 'vs/base/common/winjs.base', 'vs/base/common/lifecycle', 'vs/platform/thread/common/thread', 'vs/editor/common/core/range', 'vs/workbench/api/node/extHostTypeConverters', 'vs/workbench/api/node/extHostTypes', 'vs/workbench/api/node/extHostDocuments', 'vs/platform/markers/common/markers', 'vs/workbench/api/node/extHostCommands', 'vs/editor/contrib/goToDeclaration/common/goToDeclaration', 'vs/editor/contrib/hover/common/hover', 'vs/editor/contrib/wordHighlighter/common/wordHighlighter', 'vs/editor/contrib/referenceSearch/common/referenceSearch', 'vs/editor/contrib/quickFix/common/quickFix', 'vs/editor/contrib/quickOpen/common/quickOpen', 'vs/workbench/parts/search/common/search', 'vs/editor/contrib/rename/common/rename', 'vs/editor/contrib/format/common/format', 'vs/editor/contrib/codelens/common/codelens', 'vs/editor/contrib/parameterHints/common/parameterHints', 'vs/editor/contrib/suggest/common/suggest', 'vs/base/common/async'], function (require, exports, modesFilters_1, winjs_base_1, lifecycle_1, thread_1, range_1, TypeConverters, extHostTypes_1, extHostDocuments_1, markers_1, extHostCommands_1, goToDeclaration_1, hover_1, wordHighlighter_1, referenceSearch_1, quickFix_1, quickOpen_1, search_1, rename_1, format_1, codelens_1, parameterHints_1, suggest_1, async_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // --- adapter
    var OutlineAdapter = (function () {
        function OutlineAdapter(documents, provider) {
            this._documents = documents;
            this._provider = provider;
        }
        OutlineAdapter.prototype.getOutline = function (resource) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideDocumentSymbols(doc, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(TypeConverters.SymbolInformation.toOutlineEntry);
                }
            });
        };
        return OutlineAdapter;
    }());
    var CodeLensAdapter = (function () {
        function CodeLensAdapter(documents, commands, provider) {
            this._cache = Object.create(null);
            this._documents = documents;
            this._commands = commands;
            this._provider = provider;
        }
        CodeLensAdapter.prototype.findCodeLensSymbols = function (resource) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var version = doc.version;
            var key = resource.toString();
            // from cache
            var entry = this._cache[key];
            if (entry && entry.version === version) {
                return new async_1.ShallowCancelThenPromise(entry.data.then(function (cached) { return cached.symbols; }));
            }
            var newCodeLensData = async_1.asWinJsPromise(function (token) { return _this._provider.provideCodeLenses(doc, token); }).then(function (lenses) {
                if (!Array.isArray(lenses)) {
                    return;
                }
                var data = {
                    lenses: lenses,
                    symbols: [],
                    disposables: [],
                };
                lenses.forEach(function (lens, i) {
                    data.symbols.push({
                        id: String(i),
                        range: TypeConverters.fromRange(lens.range),
                        command: TypeConverters.Command.from(lens.command, { commands: _this._commands, disposables: data.disposables })
                    });
                });
                return data;
            });
            this._cache[key] = {
                version: version,
                data: newCodeLensData
            };
            return new async_1.ShallowCancelThenPromise(newCodeLensData.then(function (newCached) {
                if (entry) {
                    // only now dispose old commands et al
                    entry.data.then(function (oldCached) { return lifecycle_1.disposeAll(oldCached.disposables); });
                }
                return newCached && newCached.symbols;
            }));
        };
        CodeLensAdapter.prototype.resolveCodeLensSymbol = function (resource, symbol) {
            var _this = this;
            var entry = this._cache[resource.toString()];
            if (!entry) {
                return;
            }
            return entry.data.then(function (cachedData) {
                if (!cachedData) {
                    return;
                }
                var lens = cachedData.lenses[Number(symbol.id)];
                if (!lens) {
                    return;
                }
                var resolve;
                if (typeof _this._provider.resolveCodeLens !== 'function' || lens.isResolved) {
                    resolve = winjs_base_1.TPromise.as(lens);
                }
                else {
                    resolve = async_1.asWinJsPromise(function (token) { return _this._provider.resolveCodeLens(lens, token); });
                }
                return resolve.then(function (newLens) {
                    lens = newLens || lens;
                    var command = lens.command;
                    if (!command) {
                        command = {
                            title: '<<MISSING COMMAND>>',
                            command: 'missing',
                        };
                    }
                    symbol.command = TypeConverters.Command.from(command, { commands: _this._commands, disposables: cachedData.disposables });
                    return symbol;
                });
            });
        };
        return CodeLensAdapter;
    }());
    var DeclarationAdapter = (function () {
        function DeclarationAdapter(documents, provider) {
            this._documents = documents;
            this._provider = provider;
        }
        DeclarationAdapter.prototype.canFindDeclaration = function () {
            return true;
        };
        DeclarationAdapter.prototype.findDeclaration = function (resource, position) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = TypeConverters.toPosition(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideDefinition(doc, pos, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(DeclarationAdapter._convertLocation);
                }
                else if (value) {
                    return DeclarationAdapter._convertLocation(value);
                }
            });
        };
        DeclarationAdapter._convertLocation = function (location) {
            if (!location) {
                return;
            }
            return {
                resource: location.uri,
                range: TypeConverters.fromRange(location.range)
            };
        };
        return DeclarationAdapter;
    }());
    var ExtraInfoAdapter = (function () {
        function ExtraInfoAdapter(documents, provider) {
            this._documents = documents;
            this._provider = provider;
        }
        ExtraInfoAdapter.prototype.computeInfo = function (resource, position) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = TypeConverters.toPosition(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideHover(doc, pos, token); }).then(function (value) {
                if (!value) {
                    return;
                }
                if (!value.range) {
                    value.range = doc.getWordRangeAtPosition(pos);
                }
                if (!value.range) {
                    value.range = new extHostTypes_1.Range(pos, pos);
                }
                return TypeConverters.fromHover(value);
            });
        };
        return ExtraInfoAdapter;
    }());
    var OccurrencesAdapter = (function () {
        function OccurrencesAdapter(documents, provider) {
            this._documents = documents;
            this._provider = provider;
        }
        OccurrencesAdapter.prototype.findOccurrences = function (resource, position) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = TypeConverters.toPosition(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideDocumentHighlights(doc, pos, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(OccurrencesAdapter._convertDocumentHighlight);
                }
            });
        };
        OccurrencesAdapter._convertDocumentHighlight = function (documentHighlight) {
            return {
                range: TypeConverters.fromRange(documentHighlight.range),
                kind: extHostTypes_1.DocumentHighlightKind[documentHighlight.kind].toString().toLowerCase()
            };
        };
        return OccurrencesAdapter;
    }());
    var ReferenceAdapter = (function () {
        function ReferenceAdapter(documents, provider) {
            this._documents = documents;
            this._provider = provider;
        }
        ReferenceAdapter.prototype.canFindReferences = function () {
            return true;
        };
        ReferenceAdapter.prototype.findReferences = function (resource, position, includeDeclaration) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = TypeConverters.toPosition(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideReferences(doc, pos, { includeDeclaration: includeDeclaration }, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(ReferenceAdapter._convertLocation);
                }
            });
        };
        ReferenceAdapter._convertLocation = function (location) {
            return {
                resource: location.uri,
                range: TypeConverters.fromRange(location.range)
            };
        };
        return ReferenceAdapter;
    }());
    var QuickFixAdapter = (function () {
        function QuickFixAdapter(documents, commands, provider) {
            this._cachedCommands = [];
            this._documents = documents;
            this._commands = commands;
            this._provider = provider;
        }
        QuickFixAdapter.prototype.getQuickFixes = function (resource, range, markers) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var ran = TypeConverters.toRange(range);
            var diagnostics = markers.map(function (marker) {
                var diag = new extHostTypes_1.Diagnostic(TypeConverters.toRange(marker), marker.message);
                diag.code = marker.code;
                diag.severity = TypeConverters.toDiagnosticSeverty(marker.severity);
                return diag;
            });
            this._cachedCommands = lifecycle_1.disposeAll(this._cachedCommands);
            var ctx = { commands: this._commands, disposables: this._cachedCommands };
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideCodeActions(doc, ran, { diagnostics: diagnostics }, token); }).then(function (commands) {
                if (!Array.isArray(commands)) {
                    return;
                }
                return commands.map(function (command, i) {
                    return {
                        command: TypeConverters.Command.from(command, ctx),
                        score: i
                    };
                });
            });
        };
        QuickFixAdapter.prototype.runQuickFixAction = function (resource, range, quickFix) {
            var command = TypeConverters.Command.to(quickFix.command);
            return (_a = this._commands).executeCommand.apply(_a, [command.command].concat(command.arguments));
            var _a;
        };
        return QuickFixAdapter;
    }());
    var DocumentFormattingAdapter = (function () {
        function DocumentFormattingAdapter(documents, provider) {
            this._documents = documents;
            this._provider = provider;
        }
        DocumentFormattingAdapter.prototype.formatDocument = function (resource, options) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideDocumentFormattingEdits(doc, options, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(TypeConverters.TextEdit.from);
                }
            });
        };
        return DocumentFormattingAdapter;
    }());
    var RangeFormattingAdapter = (function () {
        function RangeFormattingAdapter(documents, provider) {
            this._documents = documents;
            this._provider = provider;
        }
        RangeFormattingAdapter.prototype.formatRange = function (resource, range, options) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var ran = TypeConverters.toRange(range);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideDocumentRangeFormattingEdits(doc, ran, options, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(TypeConverters.TextEdit.from);
                }
            });
        };
        return RangeFormattingAdapter;
    }());
    var OnTypeFormattingAdapter = (function () {
        function OnTypeFormattingAdapter(documents, provider) {
            this.autoFormatTriggerCharacters = []; // not here
            this._documents = documents;
            this._provider = provider;
        }
        OnTypeFormattingAdapter.prototype.formatAfterKeystroke = function (resource, position, ch, options) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = TypeConverters.toPosition(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideOnTypeFormattingEdits(doc, pos, ch, options, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(TypeConverters.TextEdit.from);
                }
            });
        };
        return OnTypeFormattingAdapter;
    }());
    var NavigateTypeAdapter = (function () {
        function NavigateTypeAdapter(provider) {
            this._provider = provider;
        }
        NavigateTypeAdapter.prototype.getNavigateToItems = function (search) {
            var _this = this;
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideWorkspaceSymbols(search, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(TypeConverters.fromSymbolInformation);
                }
            });
        };
        return NavigateTypeAdapter;
    }());
    var RenameAdapter = (function () {
        function RenameAdapter(documents, provider) {
            this._documents = documents;
            this._provider = provider;
        }
        RenameAdapter.prototype.rename = function (resource, position, newName) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = TypeConverters.toPosition(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideRenameEdits(doc, pos, newName, token); }).then(function (value) {
                if (!value) {
                    return;
                }
                var result = {
                    currentName: undefined,
                    edits: []
                };
                for (var _i = 0, _a = value.entries(); _i < _a.length; _i++) {
                    var entry = _a[_i];
                    var uri = entry[0], textEdits = entry[1];
                    for (var _b = 0, textEdits_1 = textEdits; _b < textEdits_1.length; _b++) {
                        var textEdit = textEdits_1[_b];
                        result.edits.push({
                            resource: uri,
                            newText: textEdit.newText,
                            range: TypeConverters.fromRange(textEdit.range)
                        });
                    }
                }
                return result;
            }, function (err) {
                if (typeof err === 'string') {
                    return {
                        currentName: undefined,
                        edits: undefined,
                        rejectReason: err
                    };
                }
                return winjs_base_1.TPromise.wrapError(err);
            });
        };
        return RenameAdapter;
    }());
    var SuggestAdapter = (function () {
        function SuggestAdapter(documents, provider) {
            this._cache = Object.create(null);
            this._documents = documents;
            this._provider = provider;
        }
        SuggestAdapter.prototype.suggest = function (resource, position) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = TypeConverters.toPosition(position);
            var ran = doc.getWordRangeAtPosition(pos);
            var key = resource.toString();
            delete this._cache[key];
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideCompletionItems(doc, pos, token); }).then(function (value) {
                var defaultSuggestions = {
                    suggestions: [],
                    currentWord: ran ? doc.getText(new extHostTypes_1.Range(ran.start.line, ran.start.character, pos.line, pos.character)) : '',
                };
                var allSuggestions = [defaultSuggestions];
                var list;
                if (Array.isArray(value)) {
                    list = new extHostTypes_1.CompletionList(value);
                }
                else if (value instanceof extHostTypes_1.CompletionList) {
                    list = value;
                    defaultSuggestions.incomplete = list.isIncomplete;
                }
                else {
                    return;
                }
                for (var i = 0; i < list.items.length; i++) {
                    var item = list.items[i];
                    var suggestion = TypeConverters.Suggest.from(item);
                    if (item.textEdit) {
                        var editRange = item.textEdit.range;
                        // invalid text edit
                        if (!editRange.isSingleLine || editRange.start.line !== pos.line) {
                            console.warn('INVALID text edit, must be single line and on the same line');
                            continue;
                        }
                        // insert the text of the edit and create a dedicated
                        // suggestion-container with overwrite[Before|After]
                        suggestion.codeSnippet = item.textEdit.newText;
                        suggestion.overwriteBefore = pos.character - editRange.start.character;
                        suggestion.overwriteAfter = editRange.end.character - pos.character;
                        allSuggestions.push({
                            currentWord: doc.getText(editRange),
                            suggestions: [suggestion],
                            incomplete: list.isIncomplete
                        });
                    }
                    else {
                        defaultSuggestions.suggestions.push(suggestion);
                    }
                    // assign identifier to suggestion
                    suggestion.id = String(i);
                }
                // cache for details call
                _this._cache[key] = list;
                return allSuggestions;
            });
        };
        SuggestAdapter.prototype.getSuggestionDetails = function (resource, position, suggestion) {
            var _this = this;
            if (typeof this._provider.resolveCompletionItem !== 'function') {
                return winjs_base_1.TPromise.as(suggestion);
            }
            var list = this._cache[resource.toString()];
            if (!list) {
                return winjs_base_1.TPromise.as(suggestion);
            }
            var item = list.items[Number(suggestion.id)];
            if (!item) {
                return winjs_base_1.TPromise.as(suggestion);
            }
            return async_1.asWinJsPromise(function (token) { return _this._provider.resolveCompletionItem(item, token); }).then(function (resolvedItem) {
                return TypeConverters.Suggest.from(resolvedItem || item);
            });
        };
        SuggestAdapter.prototype.getFilter = function () {
            throw new Error('illegal state');
        };
        SuggestAdapter.prototype.getTriggerCharacters = function () {
            throw new Error('illegal state');
        };
        SuggestAdapter.prototype.shouldShowEmptySuggestionList = function () {
            throw new Error('illegal state');
        };
        SuggestAdapter.prototype.shouldAutotriggerSuggest = function (context, offset, triggeredByCharacter) {
            throw new Error('illegal state');
        };
        return SuggestAdapter;
    }());
    var ParameterHintsAdapter = (function () {
        function ParameterHintsAdapter(documents, provider) {
            this._documents = documents;
            this._provider = provider;
        }
        ParameterHintsAdapter.prototype.getParameterHints = function (resource, position, triggerCharacter) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = TypeConverters.toPosition(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideSignatureHelp(doc, pos, token); }).then(function (value) {
                if (value instanceof extHostTypes_1.SignatureHelp) {
                    return TypeConverters.SignatureHelp.from(value);
                }
            });
        };
        ParameterHintsAdapter.prototype.getParameterHintsTriggerCharacters = function () {
            throw new Error('illegal state');
        };
        ParameterHintsAdapter.prototype.shouldTriggerParameterHints = function (context, offset) {
            throw new Error('illegal state');
        };
        return ParameterHintsAdapter;
    }());
    var ExtHostLanguageFeatures = (function () {
        function ExtHostLanguageFeatures(threadService) {
            this._adapter = Object.create(null);
            this._proxy = threadService.getRemotable(MainThreadLanguageFeatures);
            this._documents = threadService.getRemotable(extHostDocuments_1.ExtHostModelService);
            this._commands = threadService.getRemotable(extHostCommands_1.ExtHostCommands);
        }
        ExtHostLanguageFeatures.prototype._createDisposable = function (handle) {
            var _this = this;
            return new extHostTypes_1.Disposable(function () {
                delete _this._adapter[handle];
                _this._proxy.$unregister(handle);
            });
        };
        ExtHostLanguageFeatures.prototype._nextHandle = function () {
            return ExtHostLanguageFeatures._handlePool++;
        };
        ExtHostLanguageFeatures.prototype._withAdapter = function (handle, ctor, callback) {
            var adapter = this._adapter[handle];
            if (!(adapter instanceof ctor)) {
                return winjs_base_1.TPromise.wrapError(new Error('no adapter found'));
            }
            return callback(adapter);
        };
        // --- outline
        ExtHostLanguageFeatures.prototype.registerDocumentSymbolProvider = function (selector, provider) {
            var handle = this._nextHandle();
            this._adapter[handle] = new OutlineAdapter(this._documents, provider);
            this._proxy.$registerOutlineSupport(handle, selector);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$getOutline = function (handle, resource) {
            return this._withAdapter(handle, OutlineAdapter, function (adapter) { return adapter.getOutline(resource); });
        };
        // --- code lens
        ExtHostLanguageFeatures.prototype.registerCodeLensProvider = function (selector, provider) {
            var handle = this._nextHandle();
            this._adapter[handle] = new CodeLensAdapter(this._documents, this._commands, provider);
            this._proxy.$registerCodeLensSupport(handle, selector);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$findCodeLensSymbols = function (handle, resource) {
            return this._withAdapter(handle, CodeLensAdapter, function (adapter) { return adapter.findCodeLensSymbols(resource); });
        };
        ExtHostLanguageFeatures.prototype.$resolveCodeLensSymbol = function (handle, resource, symbol) {
            return this._withAdapter(handle, CodeLensAdapter, function (adapter) { return adapter.resolveCodeLensSymbol(resource, symbol); });
        };
        // --- declaration
        ExtHostLanguageFeatures.prototype.registerDefinitionProvider = function (selector, provider) {
            var handle = this._nextHandle();
            this._adapter[handle] = new DeclarationAdapter(this._documents, provider);
            this._proxy.$registerDeclaractionSupport(handle, selector);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$findDeclaration = function (handle, resource, position) {
            return this._withAdapter(handle, DeclarationAdapter, function (adapter) { return adapter.findDeclaration(resource, position); });
        };
        // --- extra info
        ExtHostLanguageFeatures.prototype.registerHoverProvider = function (selector, provider) {
            var handle = this._nextHandle();
            this._adapter[handle] = new ExtraInfoAdapter(this._documents, provider);
            this._proxy.$registerExtraInfoSupport(handle, selector);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$computeInfo = function (handle, resource, position) {
            return this._withAdapter(handle, ExtraInfoAdapter, function (adpater) { return adpater.computeInfo(resource, position); });
        };
        // --- occurrences
        ExtHostLanguageFeatures.prototype.registerDocumentHighlightProvider = function (selector, provider) {
            var handle = this._nextHandle();
            this._adapter[handle] = new OccurrencesAdapter(this._documents, provider);
            this._proxy.$registerOccurrencesSupport(handle, selector);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$findOccurrences = function (handle, resource, position) {
            return this._withAdapter(handle, OccurrencesAdapter, function (adapter) { return adapter.findOccurrences(resource, position); });
        };
        // --- references
        ExtHostLanguageFeatures.prototype.registerReferenceProvider = function (selector, provider) {
            var handle = this._nextHandle();
            this._adapter[handle] = new ReferenceAdapter(this._documents, provider);
            this._proxy.$registerReferenceSupport(handle, selector);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$findReferences = function (handle, resource, position, includeDeclaration) {
            return this._withAdapter(handle, ReferenceAdapter, function (adapter) { return adapter.findReferences(resource, position, includeDeclaration); });
        };
        // --- quick fix
        ExtHostLanguageFeatures.prototype.registerCodeActionProvider = function (selector, provider) {
            var handle = this._nextHandle();
            this._adapter[handle] = new QuickFixAdapter(this._documents, this._commands, provider);
            this._proxy.$registerQuickFixSupport(handle, selector);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$getQuickFixes = function (handle, resource, range, marker) {
            return this._withAdapter(handle, QuickFixAdapter, function (adapter) { return adapter.getQuickFixes(resource, range, marker); });
        };
        ExtHostLanguageFeatures.prototype.$runQuickFixAction = function (handle, resource, range, quickFix) {
            return this._withAdapter(handle, QuickFixAdapter, function (adapter) { return adapter.runQuickFixAction(resource, range, quickFix); });
        };
        // --- formatting
        ExtHostLanguageFeatures.prototype.registerDocumentFormattingEditProvider = function (selector, provider) {
            var handle = this._nextHandle();
            this._adapter[handle] = new DocumentFormattingAdapter(this._documents, provider);
            this._proxy.$registerDocumentFormattingSupport(handle, selector);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$formatDocument = function (handle, resource, options) {
            return this._withAdapter(handle, DocumentFormattingAdapter, function (adapter) { return adapter.formatDocument(resource, options); });
        };
        ExtHostLanguageFeatures.prototype.registerDocumentRangeFormattingEditProvider = function (selector, provider) {
            var handle = this._nextHandle();
            this._adapter[handle] = new RangeFormattingAdapter(this._documents, provider);
            this._proxy.$registerRangeFormattingSupport(handle, selector);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$formatRange = function (handle, resource, range, options) {
            return this._withAdapter(handle, RangeFormattingAdapter, function (adapter) { return adapter.formatRange(resource, range, options); });
        };
        ExtHostLanguageFeatures.prototype.registerOnTypeFormattingEditProvider = function (selector, provider, triggerCharacters) {
            var handle = this._nextHandle();
            this._adapter[handle] = new OnTypeFormattingAdapter(this._documents, provider);
            this._proxy.$registerOnTypeFormattingSupport(handle, selector, triggerCharacters);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$formatAfterKeystroke = function (handle, resource, position, ch, options) {
            return this._withAdapter(handle, OnTypeFormattingAdapter, function (adapter) { return adapter.formatAfterKeystroke(resource, position, ch, options); });
        };
        // --- navigate types
        ExtHostLanguageFeatures.prototype.registerWorkspaceSymbolProvider = function (provider) {
            var handle = this._nextHandle();
            this._adapter[handle] = new NavigateTypeAdapter(provider);
            this._proxy.$registerNavigateTypeSupport(handle);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$getNavigateToItems = function (handle, search) {
            return this._withAdapter(handle, NavigateTypeAdapter, function (adapter) { return adapter.getNavigateToItems(search); });
        };
        // --- rename
        ExtHostLanguageFeatures.prototype.registerRenameProvider = function (selector, provider) {
            var handle = this._nextHandle();
            this._adapter[handle] = new RenameAdapter(this._documents, provider);
            this._proxy.$registerRenameSupport(handle, selector);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$rename = function (handle, resource, position, newName) {
            return this._withAdapter(handle, RenameAdapter, function (adapter) { return adapter.rename(resource, position, newName); });
        };
        // --- suggestion
        ExtHostLanguageFeatures.prototype.registerCompletionItemProvider = function (selector, provider, triggerCharacters) {
            var handle = this._nextHandle();
            this._adapter[handle] = new SuggestAdapter(this._documents, provider);
            this._proxy.$registerSuggestSupport(handle, selector, triggerCharacters);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$suggest = function (handle, resource, position) {
            return this._withAdapter(handle, SuggestAdapter, function (adapter) { return adapter.suggest(resource, position); });
        };
        ExtHostLanguageFeatures.prototype.$getSuggestionDetails = function (handle, resource, position, suggestion) {
            return this._withAdapter(handle, SuggestAdapter, function (adapter) { return adapter.getSuggestionDetails(resource, position, suggestion); });
        };
        // --- parameter hints
        ExtHostLanguageFeatures.prototype.registerSignatureHelpProvider = function (selector, provider, triggerCharacters) {
            var handle = this._nextHandle();
            this._adapter[handle] = new ParameterHintsAdapter(this._documents, provider);
            this._proxy.$registerParameterHintsSupport(handle, selector, triggerCharacters);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$getParameterHints = function (handle, resource, position, triggerCharacter) {
            return this._withAdapter(handle, ParameterHintsAdapter, function (adapter) { return adapter.getParameterHints(resource, position, triggerCharacter); });
        };
        ExtHostLanguageFeatures._handlePool = 0;
        ExtHostLanguageFeatures = __decorate([
            thread_1.Remotable.ExtHostContext('ExtHostLanguageFeatures'),
            __param(0, thread_1.IThreadService)
        ], ExtHostLanguageFeatures);
        return ExtHostLanguageFeatures;
    }());
    exports.ExtHostLanguageFeatures = ExtHostLanguageFeatures;
    var MainThreadLanguageFeatures = (function () {
        function MainThreadLanguageFeatures(threadService, markerService) {
            this._registrations = Object.create(null);
            this._proxy = threadService.getRemotable(ExtHostLanguageFeatures);
            this._markerService = markerService;
        }
        MainThreadLanguageFeatures.prototype.$unregister = function (handle) {
            var registration = this._registrations[handle];
            if (registration) {
                registration.dispose();
                delete this._registrations[handle];
            }
            return undefined;
        };
        // --- outline
        MainThreadLanguageFeatures.prototype.$registerOutlineSupport = function (handle, selector) {
            var _this = this;
            this._registrations[handle] = quickOpen_1.OutlineRegistry.register(selector, {
                getOutline: function (resource) {
                    return _this._proxy.$getOutline(handle, resource);
                }
            });
            return undefined;
        };
        // --- code lens
        MainThreadLanguageFeatures.prototype.$registerCodeLensSupport = function (handle, selector) {
            var _this = this;
            this._registrations[handle] = codelens_1.CodeLensRegistry.register(selector, {
                findCodeLensSymbols: function (resource) {
                    return _this._proxy.$findCodeLensSymbols(handle, resource);
                },
                resolveCodeLensSymbol: function (resource, symbol) {
                    return _this._proxy.$resolveCodeLensSymbol(handle, resource, symbol);
                }
            });
            return undefined;
        };
        // --- declaration
        MainThreadLanguageFeatures.prototype.$registerDeclaractionSupport = function (handle, selector) {
            var _this = this;
            this._registrations[handle] = goToDeclaration_1.DeclarationRegistry.register(selector, {
                canFindDeclaration: function () {
                    return true;
                },
                findDeclaration: function (resource, position) {
                    return _this._proxy.$findDeclaration(handle, resource, position);
                }
            });
            return undefined;
        };
        // --- extra info
        MainThreadLanguageFeatures.prototype.$registerExtraInfoSupport = function (handle, selector) {
            var _this = this;
            this._registrations[handle] = hover_1.ExtraInfoRegistry.register(selector, {
                computeInfo: function (resource, position) {
                    return _this._proxy.$computeInfo(handle, resource, position);
                }
            });
            return undefined;
        };
        // --- occurrences
        MainThreadLanguageFeatures.prototype.$registerOccurrencesSupport = function (handle, selector) {
            var _this = this;
            this._registrations[handle] = wordHighlighter_1.OccurrencesRegistry.register(selector, {
                findOccurrences: function (resource, position) {
                    return _this._proxy.$findOccurrences(handle, resource, position);
                }
            });
            return undefined;
        };
        // --- references
        MainThreadLanguageFeatures.prototype.$registerReferenceSupport = function (handle, selector) {
            var _this = this;
            this._registrations[handle] = referenceSearch_1.ReferenceRegistry.register(selector, {
                canFindReferences: function () {
                    return true;
                },
                findReferences: function (resource, position, includeDeclaration) {
                    return _this._proxy.$findReferences(handle, resource, position, includeDeclaration);
                }
            });
            return undefined;
        };
        // --- quick fix
        MainThreadLanguageFeatures.prototype.$registerQuickFixSupport = function (handle, selector) {
            var _this = this;
            this._registrations[handle] = quickFix_1.QuickFixRegistry.register(selector, {
                getQuickFixes: function (resource, range) {
                    var markers = [];
                    _this._markerService.read({ resource: resource }).forEach(function (marker) {
                        if (range_1.Range.lift(marker).intersectRanges(range)) {
                            markers.push(marker);
                        }
                    });
                    return _this._proxy.$getQuickFixes(handle, resource, range, markers);
                },
                runQuickFixAction: function (resource, range, quickFix) {
                    return _this._proxy.$runQuickFixAction(handle, resource, range, quickFix);
                }
            });
            return undefined;
        };
        // --- formatting
        MainThreadLanguageFeatures.prototype.$registerDocumentFormattingSupport = function (handle, selector) {
            var _this = this;
            this._registrations[handle] = format_1.FormatRegistry.register(selector, {
                formatDocument: function (resource, options) {
                    return _this._proxy.$formatDocument(handle, resource, options);
                }
            });
            return undefined;
        };
        MainThreadLanguageFeatures.prototype.$registerRangeFormattingSupport = function (handle, selector) {
            var _this = this;
            this._registrations[handle] = format_1.FormatRegistry.register(selector, {
                formatRange: function (resource, range, options) {
                    return _this._proxy.$formatRange(handle, resource, range, options);
                }
            });
            return undefined;
        };
        MainThreadLanguageFeatures.prototype.$registerOnTypeFormattingSupport = function (handle, selector, autoFormatTriggerCharacters) {
            var _this = this;
            this._registrations[handle] = format_1.FormatOnTypeRegistry.register(selector, {
                autoFormatTriggerCharacters: autoFormatTriggerCharacters,
                formatAfterKeystroke: function (resource, position, ch, options) {
                    return _this._proxy.$formatAfterKeystroke(handle, resource, position, ch, options);
                }
            });
            return undefined;
        };
        // --- navigate type
        MainThreadLanguageFeatures.prototype.$registerNavigateTypeSupport = function (handle) {
            var _this = this;
            this._registrations[handle] = search_1.NavigateTypesSupportRegistry.register({
                getNavigateToItems: function (search) {
                    return _this._proxy.$getNavigateToItems(handle, search);
                }
            });
            return undefined;
        };
        // --- rename
        MainThreadLanguageFeatures.prototype.$registerRenameSupport = function (handle, selector) {
            var _this = this;
            this._registrations[handle] = rename_1.RenameRegistry.register(selector, {
                rename: function (resource, position, newName) {
                    return _this._proxy.$rename(handle, resource, position, newName);
                }
            });
            return undefined;
        };
        // --- suggest
        MainThreadLanguageFeatures.prototype.$registerSuggestSupport = function (handle, selector, triggerCharacters) {
            var _this = this;
            this._registrations[handle] = suggest_1.SuggestRegistry.register(selector, {
                suggest: function (resource, position, triggerCharacter) {
                    return _this._proxy.$suggest(handle, resource, position);
                },
                getSuggestionDetails: function (resource, position, suggestion) {
                    return _this._proxy.$getSuggestionDetails(handle, resource, position, suggestion);
                },
                getFilter: function () {
                    return modesFilters_1.DefaultFilter;
                },
                getTriggerCharacters: function () {
                    return triggerCharacters;
                },
                shouldShowEmptySuggestionList: function () {
                    return true;
                },
                shouldAutotriggerSuggest: function () {
                    return true;
                }
            });
            return undefined;
        };
        // --- parameter hints
        MainThreadLanguageFeatures.prototype.$registerParameterHintsSupport = function (handle, selector, triggerCharacter) {
            var _this = this;
            this._registrations[handle] = parameterHints_1.ParameterHintsRegistry.register(selector, {
                getParameterHints: function (resource, position, triggerCharacter) {
                    return _this._proxy.$getParameterHints(handle, resource, position, triggerCharacter);
                },
                getParameterHintsTriggerCharacters: function () {
                    return triggerCharacter;
                },
                shouldTriggerParameterHints: function (context, offset) {
                    return true;
                }
            });
            return undefined;
        };
        MainThreadLanguageFeatures = __decorate([
            thread_1.Remotable.MainContext('MainThreadLanguageFeatures'),
            __param(0, thread_1.IThreadService),
            __param(1, markers_1.IMarkerService)
        ], MainThreadLanguageFeatures);
        return MainThreadLanguageFeatures;
    }());
    exports.MainThreadLanguageFeatures = MainThreadLanguageFeatures;
});

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/workbench/api/node/extHost.api.impl", ["require", "exports", 'vs/base/common/event', 'vs/editor/common/modes/languageSelector', 'vs/base/common/platform', 'vs/base/common/strings', 'vs/platform/thread/common/thread', 'vs/base/common/errors', 'vs/workbench/api/node/extHostFileSystemEventService', 'vs/workbench/api/node/extHostDocuments', 'vs/workbench/api/node/extHostConfiguration', 'vs/workbench/api/node/extHostDiagnostics', 'vs/workbench/api/node/extHostWorkspace', 'vs/workbench/api/node/extHostQuickOpen', 'vs/workbench/api/node/extHostStatusBar', 'vs/workbench/api/node/extHostCommands', 'vs/workbench/api/node/extHostOutputService', 'vs/workbench/api/node/extHostMessageService', 'vs/workbench/api/node/extHostEditors', 'vs/workbench/api/node/extHostLanguages', 'vs/workbench/api/node/extHostLanguageFeatures', 'vs/workbench/api/node/extHostApiCommands', 'vs/workbench/api/node/extHostTypes', 'vs/editor/common/modes', 'vs/editor/common/services/modeService', 'vs/base/common/uri', 'vs/base/common/severity', 'vs/editor/common/editorCommon', 'vs/platform/extensions/common/extensions', 'vs/platform/extensions/common/extensionsRegistry', 'vs/platform/workspace/common/workspace', 'vs/base/common/cancellation', 'vs/workbench/api/node/mainThreadEditors', 'vs/base/common/paths', 'vs/platform/telemetry/common/telemetry'], function (require, exports, event_1, languageSelector_1, Platform, strings_1, thread_1, errors, extHostFileSystemEventService_1, extHostDocuments_1, extHostConfiguration_1, extHostDiagnostics_1, extHostWorkspace_1, extHostQuickOpen_1, extHostStatusBar_1, extHostCommands_1, extHostOutputService_1, extHostMessageService_1, extHostEditors_1, extHostLanguages_1, extHostLanguageFeatures_1, extHostApiCommands_1, extHostTypes, Modes, modeService_1, uri_1, severity_1, EditorCommon, extensions_1, extensionsRegistry_1, workspace_1, cancellation_1, mainThreadEditors_1, paths, telemetry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * This class implements the API described in vscode.d.ts,
     * for the case of the extensionHost host process
     */
    var ExtHostAPIImplementation = (function () {
        function ExtHostAPIImplementation(threadService, extensionService, contextService, telemetryService) {
            var _this = this;
            this._threadService = threadService;
            this._proxy = threadService.getRemotable(MainProcessVSCodeAPIHelper);
            this.version = contextService.getConfiguration().env.version;
            this.Uri = uri_1.default;
            this.Location = extHostTypes.Location;
            this.Diagnostic = extHostTypes.Diagnostic;
            this.DiagnosticSeverity = extHostTypes.DiagnosticSeverity;
            this.EventEmitter = event_1.Emitter;
            this.Disposable = extHostTypes.Disposable;
            this.TextEdit = extHostTypes.TextEdit;
            this.WorkspaceEdit = extHostTypes.WorkspaceEdit;
            this.Position = extHostTypes.Position;
            this.Range = extHostTypes.Range;
            this.Selection = extHostTypes.Selection;
            this.CancellationTokenSource = cancellation_1.CancellationTokenSource;
            this.Hover = extHostTypes.Hover;
            this.SymbolKind = extHostTypes.SymbolKind;
            this.SymbolInformation = extHostTypes.SymbolInformation;
            this.DocumentHighlightKind = extHostTypes.DocumentHighlightKind;
            this.DocumentHighlight = extHostTypes.DocumentHighlight;
            this.CodeLens = extHostTypes.CodeLens;
            this.ParameterInformation = extHostTypes.ParameterInformation;
            this.SignatureInformation = extHostTypes.SignatureInformation;
            this.SignatureHelp = extHostTypes.SignatureHelp;
            this.CompletionItem = extHostTypes.CompletionItem;
            this.CompletionItemKind = extHostTypes.CompletionItemKind;
            this.CompletionList = extHostTypes.CompletionList;
            this.ViewColumn = extHostTypes.ViewColumn;
            this.StatusBarAlignment = extHostTypes.StatusBarAlignment;
            this.IndentAction = Modes.IndentAction;
            this.OverviewRulerLane = EditorCommon.OverviewRulerLane;
            this.TextEditorRevealType = mainThreadEditors_1.TextEditorRevealType;
            this.EndOfLine = extHostTypes.EndOfLine;
            this.TextEditorCursorStyle = EditorCommon.TextEditorCursorStyle;
            errors.setUnexpectedErrorHandler(function (err) {
                _this._proxy.onUnexpectedExtHostError(errors.transformErrorForSerialization(err));
            });
            var extHostCommands = this._threadService.getRemotable(extHostCommands_1.ExtHostCommands);
            var extHostEditors = this._threadService.getRemotable(extHostEditors_1.ExtHostEditors);
            var extHostMessageService = new extHostMessageService_1.ExtHostMessageService(this._threadService, this.commands);
            var extHostQuickOpen = this._threadService.getRemotable(extHostQuickOpen_1.ExtHostQuickOpen);
            var extHostStatusBar = new extHostStatusBar_1.ExtHostStatusBar(this._threadService);
            var extHostOutputService = new extHostOutputService_1.ExtHostOutputService(this._threadService);
            // env namespace
            var telemetryInfo;
            this.env = Object.freeze({
                get machineId() { return telemetryInfo.machineId; },
                get sessionId() { return telemetryInfo.sessionId; },
                get language() { return Platform.language; }
            });
            telemetryService.getTelemetryInfo().then(function (info) { return telemetryInfo = info; }, errors.onUnexpectedError);
            // commands namespace
            this.commands = {
                registerCommand: function (id, command, thisArgs) {
                    return extHostCommands.registerCommand(id, command, thisArgs);
                },
                registerTextEditorCommand: function (id, callback, thisArg) {
                    var actualCallback = thisArg ? callback.bind(thisArg) : callback;
                    return extHostCommands.registerCommand(id, function () {
                        var activeTextEditor = extHostEditors.getActiveTextEditor();
                        if (!activeTextEditor) {
                            console.warn('Cannot execute ' + id + ' because there is no active text editor.');
                            return;
                        }
                        activeTextEditor.edit(function (edit) {
                            actualCallback(activeTextEditor, edit);
                        }).then(function (result) {
                            if (!result) {
                                console.warn('Edits from command ' + id + ' were not applied.');
                            }
                        }, function (err) {
                            console.warn('An error occured while running command ' + id, err);
                        });
                    });
                },
                executeCommand: function (id) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    return extHostCommands.executeCommand.apply(extHostCommands, [id].concat(args));
                },
                getCommands: function (filterInternal) {
                    if (filterInternal === void 0) { filterInternal = false; }
                    return extHostCommands.getCommands(filterInternal);
                }
            };
            this.window = {
                get activeTextEditor() {
                    return extHostEditors.getActiveTextEditor();
                },
                get visibleTextEditors() {
                    return extHostEditors.getVisibleTextEditors();
                },
                showTextDocument: function (document, column, preserveFocus) {
                    return extHostEditors.showTextDocument(document, column, preserveFocus);
                },
                createTextEditorDecorationType: function (options) {
                    return extHostEditors.createTextEditorDecorationType(options);
                },
                onDidChangeActiveTextEditor: extHostEditors.onDidChangeActiveTextEditor.bind(extHostEditors),
                onDidChangeTextEditorSelection: function (listener, thisArgs, disposables) {
                    return extHostEditors.onDidChangeTextEditorSelection(listener, thisArgs, disposables);
                },
                onDidChangeTextEditorOptions: function (listener, thisArgs, disposables) {
                    return extHostEditors.onDidChangeTextEditorOptions(listener, thisArgs, disposables);
                },
                onDidChangeTextEditorViewColumn: function (listener, thisArg, disposables) {
                    return extHostEditors.onDidChangeTextEditorViewColumn(listener, thisArg, disposables);
                },
                showInformationMessage: function (message) {
                    var items = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        items[_i - 1] = arguments[_i];
                    }
                    return extHostMessageService.showMessage(severity_1.default.Info, message, items);
                },
                showWarningMessage: function (message) {
                    var items = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        items[_i - 1] = arguments[_i];
                    }
                    return extHostMessageService.showMessage(severity_1.default.Warning, message, items);
                },
                showErrorMessage: function (message) {
                    var items = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        items[_i - 1] = arguments[_i];
                    }
                    return extHostMessageService.showMessage(severity_1.default.Error, message, items);
                },
                showQuickPick: function (items, options) {
                    return extHostQuickOpen.show(items, options);
                },
                showInputBox: extHostQuickOpen.input.bind(extHostQuickOpen),
                createStatusBarItem: function (position, priority) {
                    return extHostStatusBar.createStatusBarEntry(position, priority);
                },
                setStatusBarMessage: function (text, timeoutOrThenable) {
                    return extHostStatusBar.setStatusBarMessage(text, timeoutOrThenable);
                },
                createOutputChannel: function (name) {
                    return extHostOutputService.createOutputChannel(name);
                }
            };
            //
            var workspacePath = contextService.getWorkspace() ? contextService.getWorkspace().resource.fsPath : undefined;
            var extHostFileSystemEvent = threadService.getRemotable(extHostFileSystemEventService_1.ExtHostFileSystemEventService);
            var extHostWorkspace = new extHostWorkspace_1.ExtHostWorkspace(this._threadService, workspacePath);
            var extHostDocuments = this._threadService.getRemotable(extHostDocuments_1.ExtHostModelService);
            this.workspace = Object.freeze({
                get rootPath() {
                    return extHostWorkspace.getPath();
                },
                set rootPath(value) {
                    throw errors.readonly();
                },
                asRelativePath: function (pathOrUri) {
                    return extHostWorkspace.getRelativePath(pathOrUri);
                },
                findFiles: function (include, exclude, maxResults, token) {
                    return extHostWorkspace.findFiles(include, exclude, maxResults, token);
                },
                saveAll: function (includeUntitled) {
                    return extHostWorkspace.saveAll(includeUntitled);
                },
                applyEdit: function (edit) {
                    return extHostWorkspace.appyEdit(edit);
                },
                createFileSystemWatcher: function (pattern, ignoreCreate, ignoreChange, ignoreDelete) {
                    return extHostFileSystemEvent.createFileSystemWatcher(pattern, ignoreCreate, ignoreChange, ignoreDelete);
                },
                get textDocuments() {
                    return extHostDocuments.getAllDocumentData().map(function (data) { return data.document; });
                },
                set textDocuments(value) {
                    throw errors.readonly();
                },
                openTextDocument: function (uriOrFileName) {
                    var uri;
                    if (typeof uriOrFileName === 'string') {
                        uri = uri_1.default.file(uriOrFileName);
                    }
                    else if (uriOrFileName instanceof uri_1.default) {
                        uri = uriOrFileName;
                    }
                    else {
                        throw new Error('illegal argument - uriOrFileName');
                    }
                    return extHostDocuments.ensureDocumentData(uri).then(function () {
                        var data = extHostDocuments.getDocumentData(uri);
                        return data && data.document;
                    });
                },
                registerTextDocumentContentProvider: function (scheme, provider) {
                    return extHostDocuments.registerTextDocumentContentProvider(scheme, provider);
                },
                onDidOpenTextDocument: function (listener, thisArgs, disposables) {
                    return extHostDocuments.onDidAddDocument(listener, thisArgs, disposables);
                },
                onDidCloseTextDocument: function (listener, thisArgs, disposables) {
                    return extHostDocuments.onDidRemoveDocument(listener, thisArgs, disposables);
                },
                onDidChangeTextDocument: function (listener, thisArgs, disposables) {
                    return extHostDocuments.onDidChangeDocument(listener, thisArgs, disposables);
                },
                onDidSaveTextDocument: function (listener, thisArgs, disposables) {
                    return extHostDocuments.onDidSaveDocument(listener, thisArgs, disposables);
                },
                onDidChangeConfiguration: function (listener, thisArgs, disposables) {
                    return extHostConfiguration.onDidChangeConfiguration(listener, thisArgs, disposables);
                },
                getConfiguration: function (section) {
                    return extHostConfiguration.getConfiguration(section);
                }
            });
            //
            extHostApiCommands_1.registerApiCommands(threadService);
            //
            var languages = new extHostLanguages_1.ExtHostLanguages(this._threadService);
            var extHostDiagnostics = new extHostDiagnostics_1.ExtHostDiagnostics(this._threadService);
            var languageFeatures = threadService.getRemotable(extHostLanguageFeatures_1.ExtHostLanguageFeatures);
            this.languages = {
                createDiagnosticCollection: function (name) {
                    return extHostDiagnostics.createDiagnosticCollection(name);
                },
                getLanguages: function () {
                    return languages.getLanguages();
                },
                match: function (selector, document) {
                    return languageSelector_1.score(selector, document.uri, document.languageId);
                },
                registerCodeActionsProvider: function (selector, provider) {
                    return languageFeatures.registerCodeActionProvider(selector, provider);
                },
                registerCodeLensProvider: function (selector, provider) {
                    return languageFeatures.registerCodeLensProvider(selector, provider);
                },
                registerDefinitionProvider: function (selector, provider) {
                    return languageFeatures.registerDefinitionProvider(selector, provider);
                },
                registerHoverProvider: function (selector, provider) {
                    return languageFeatures.registerHoverProvider(selector, provider);
                },
                registerDocumentHighlightProvider: function (selector, provider) {
                    return languageFeatures.registerDocumentHighlightProvider(selector, provider);
                },
                registerReferenceProvider: function (selector, provider) {
                    return languageFeatures.registerReferenceProvider(selector, provider);
                },
                registerRenameProvider: function (selector, provider) {
                    return languageFeatures.registerRenameProvider(selector, provider);
                },
                registerDocumentSymbolProvider: function (selector, provider) {
                    return languageFeatures.registerDocumentSymbolProvider(selector, provider);
                },
                registerWorkspaceSymbolProvider: function (provider) {
                    return languageFeatures.registerWorkspaceSymbolProvider(provider);
                },
                registerDocumentFormattingEditProvider: function (selector, provider) {
                    return languageFeatures.registerDocumentFormattingEditProvider(selector, provider);
                },
                registerDocumentRangeFormattingEditProvider: function (selector, provider) {
                    return languageFeatures.registerDocumentRangeFormattingEditProvider(selector, provider);
                },
                registerOnTypeFormattingEditProvider: function (selector, provider, firstTriggerCharacter) {
                    var moreTriggerCharacters = [];
                    for (var _i = 3; _i < arguments.length; _i++) {
                        moreTriggerCharacters[_i - 3] = arguments[_i];
                    }
                    return languageFeatures.registerOnTypeFormattingEditProvider(selector, provider, [firstTriggerCharacter].concat(moreTriggerCharacters));
                },
                registerSignatureHelpProvider: function (selector, provider) {
                    var triggerCharacters = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        triggerCharacters[_i - 2] = arguments[_i];
                    }
                    return languageFeatures.registerSignatureHelpProvider(selector, provider, triggerCharacters);
                },
                registerCompletionItemProvider: function (selector, provider) {
                    var triggerCharacters = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        triggerCharacters[_i - 2] = arguments[_i];
                    }
                    return languageFeatures.registerCompletionItemProvider(selector, provider, triggerCharacters);
                },
                setLanguageConfiguration: function (language, configuration) {
                    return _this._setLanguageConfiguration(language, configuration);
                }
            };
            var extHostConfiguration = threadService.getRemotable(extHostConfiguration_1.ExtHostConfiguration);
            //
            this.extensions = {
                getExtension: function (extensionId) {
                    var desc = extensionsRegistry_1.ExtensionsRegistry.getExtensionDescription(extensionId);
                    if (desc) {
                        return new Extension(extensionService, desc);
                    }
                },
                get all() {
                    return extensionsRegistry_1.ExtensionsRegistry.getAllExtensionDescriptions().map(function (desc) { return new Extension(extensionService, desc); });
                }
            };
            // Intentionally calling a function for typechecking purposes
            defineAPI(this);
        }
        ExtHostAPIImplementation.generateDisposeToken = function () {
            return String(++ExtHostAPIImplementation._LAST_REGISTER_TOKEN);
        };
        ExtHostAPIImplementation.prototype._disposableFromToken = function (disposeToken) {
            var _this = this;
            return new extHostTypes.Disposable(function () { return _this._proxy.disposeByToken(disposeToken); });
        };
        ExtHostAPIImplementation.prototype._setLanguageConfiguration = function (modeId, configuration) {
            var wordPattern = configuration.wordPattern;
            // check for a valid word pattern
            if (wordPattern && strings_1.regExpLeadsToEndlessLoop(wordPattern)) {
                throw new Error("Invalid language configuration: wordPattern '" + wordPattern + "' is not allowed to match the empty string.");
            }
            // word definition
            if (wordPattern) {
                extHostDocuments_1.setWordDefinitionFor(modeId, wordPattern);
            }
            else {
                extHostDocuments_1.setWordDefinitionFor(modeId, null);
            }
            return this.Modes_RichEditSupport_register(modeId, configuration);
        };
        ExtHostAPIImplementation.prototype.Modes_RichEditSupport_register = function (modeId, configuration) {
            var disposeToken = ExtHostAPIImplementation.generateDisposeToken();
            this._proxy.Modes_RichEditSupport_register(disposeToken, modeId, configuration);
            return this._disposableFromToken(disposeToken);
        };
        ExtHostAPIImplementation._LAST_REGISTER_TOKEN = 0;
        ExtHostAPIImplementation = __decorate([
            __param(0, thread_1.IThreadService),
            __param(1, extensions_1.IExtensionService),
            __param(2, workspace_1.IWorkspaceContextService),
            __param(3, telemetry_1.ITelemetryService)
        ], ExtHostAPIImplementation);
        return ExtHostAPIImplementation;
    }());
    exports.ExtHostAPIImplementation = ExtHostAPIImplementation;
    var Extension = (function () {
        function Extension(extensionService, description) {
            this._extensionService = extensionService;
            this.id = description.id;
            this.extensionPath = paths.normalize(description.extensionFolderPath, true);
            this.packageJSON = description;
        }
        Object.defineProperty(Extension.prototype, "isActive", {
            get: function () {
                return this._extensionService.isActivated(this.id);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Extension.prototype, "exports", {
            get: function () {
                return this._extensionService.get(this.id);
            },
            enumerable: true,
            configurable: true
        });
        Extension.prototype.activate = function () {
            var _this = this;
            return this._extensionService.activateById(this.id).then(function () { return _this.exports; });
        };
        return Extension;
    }());
    function defineAPI(impl) {
        var node_module = require.__$__nodeRequire('module');
        var original = node_module._load;
        node_module._load = function load(request, parent, isMain) {
            if (request === 'vscode') {
                return impl;
            }
            return original.apply(this, arguments);
        };
        define('vscode', [], impl);
    }
    var MainProcessVSCodeAPIHelper = (function () {
        function MainProcessVSCodeAPIHelper(modeService) {
            this._modeService = modeService;
            this._token2Dispose = {};
        }
        MainProcessVSCodeAPIHelper.prototype.onUnexpectedExtHostError = function (err) {
            errors.onUnexpectedError(err);
        };
        MainProcessVSCodeAPIHelper.prototype.disposeByToken = function (disposeToken) {
            if (this._token2Dispose[disposeToken]) {
                this._token2Dispose[disposeToken].dispose();
                delete this._token2Dispose[disposeToken];
            }
        };
        MainProcessVSCodeAPIHelper.prototype.Modes_RichEditSupport_register = function (disposeToken, modeId, configuration) {
            this._token2Dispose[disposeToken] = this._modeService.registerRichEditSupport(modeId, configuration);
        };
        MainProcessVSCodeAPIHelper = __decorate([
            thread_1.Remotable.MainContext('MainProcessVSCodeAPIHelper'),
            __param(0, modeService_1.IModeService)
        ], MainProcessVSCodeAPIHelper);
        return MainProcessVSCodeAPIHelper;
    }());
    exports.MainProcessVSCodeAPIHelper = MainProcessVSCodeAPIHelper;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/base/node/zip", ["require", "exports", 'vs/nls!vs/base/node/zip', 'path', 'fs', 'vs/base/common/async', 'vs/base/node/pfs', 'vs/base/common/winjs.base', 'yauzl'], function (require, exports, nls, path, fs_1, async_1, pfs_1, winjs_base_1, yauzl_1) {
    "use strict";
    function modeFromEntry(entry) {
        var attr = entry.externalFileAttributes >> 16 || 33188;
        return [448 /* S_IRWXU */, 56 /* S_IRWXG */, 7 /* S_IRWXO */]
            .map(function (mask) { return attr & mask; })
            .reduce(function (a, b) { return a + b; }, attr & 61440 /* S_IFMT */);
    }
    function extractEntry(zipfile, entry, targetPath, options) {
        var fileName = entry.fileName.replace(options.sourcePathRegex, '');
        var dirName = path.dirname(fileName);
        var targetDirName = path.join(targetPath, dirName);
        var targetFileName = path.join(targetPath, fileName);
        var mode = modeFromEntry(entry);
        return async_1.ninvoke(zipfile, zipfile.openReadStream, entry)
            .then(function (ostream) { return pfs_1.mkdirp(targetDirName)
            .then(function () { return new winjs_base_1.Promise(function (c, e) {
            var istream = fs_1.createWriteStream(targetFileName, { mode: mode });
            istream.once('finish', function () { return c(null); });
            istream.once('error', e);
            ostream.once('error', e);
            ostream.pipe(istream);
        }); }); });
    }
    function extractZip(zipfile, targetPath, options) {
        return new winjs_base_1.Promise(function (c, e) {
            var promises = [];
            zipfile.once('error', e);
            zipfile.on('entry', function (entry) {
                if (!options.sourcePathRegex.test(entry.fileName)) {
                    return;
                }
                promises.push(extractEntry(zipfile, entry, targetPath, options));
            });
            zipfile.once('close', function () { return winjs_base_1.Promise.join(promises).done(c, e); });
        });
    }
    function extract(zipPath, targetPath, options) {
        var sourcePathRegex = new RegExp(options.sourcePath ? "^" + options.sourcePath : '');
        var promise = async_1.nfcall(yauzl_1.open, zipPath);
        if (options.overwrite) {
            promise = promise.then(function (zipfile) { pfs_1.rimraf(targetPath); return zipfile; });
        }
        return promise.then(function (zipfile) { return extractZip(zipfile, targetPath, { sourcePathRegex: sourcePathRegex }); });
    }
    exports.extract = extract;
    function read(zipPath, filePath) {
        return async_1.nfcall(yauzl_1.open, zipPath).then(function (zipfile) {
            return new winjs_base_1.TPromise(function (c, e) {
                zipfile.on('entry', function (entry) {
                    if (entry.fileName === filePath) {
                        async_1.ninvoke(zipfile, zipfile.openReadStream, entry).done(function (stream) { return c(stream); }, function (err) { return e(err); });
                    }
                });
                zipfile.once('close', function () { return e(new Error(nls.localize(0, null, filePath))); });
            });
        });
    }
    function buffer(zipPath, filePath) {
        return read(zipPath, filePath).then(function (stream) {
            return new winjs_base_1.TPromise(function (c, e) {
                var buffers = [];
                stream.once('error', e);
                stream.on('data', function (b) { return buffers.push(b); });
                stream.on('end', function () { return c(Buffer.concat(buffers)); });
            });
        });
    }
    exports.buffer = buffer;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/workbench/parts/extensions/node/extensionsService", ["require", "exports", 'vs/nls!vs/workbench/parts/extensions/node/extensionsService', 'os', 'path', 'vs/base/common/types', 'vs/base/common/service', 'vs/base/node/pfs', 'vs/base/common/objects', 'vs/base/common/arrays', 'vs/base/node/zip', 'vs/base/common/winjs.base', 'vs/workbench/parts/extensions/common/extensions', 'vs/base/node/request', 'vs/base/node/proxy', 'vs/workbench/services/workspace/common/contextService', 'vs/base/common/async', 'vs/base/common/event', 'vs/workbench/node/userSettings', 'semver', 'vs/base/common/collections', 'vs/platform/extensions/node/extensionValidator'], function (require, exports, nls, os_1, path, types, service_1, pfs, objects_1, arrays_1, zip_1, winjs_base_1, extensions_1, request_1, proxy_1, contextService_1, async_1, event_1, userSettings_1, semver, collections_1, extensionValidator_1) {
    'use strict';
    function parseManifest(raw) {
        return new winjs_base_1.Promise(function (c, e) {
            try {
                c(JSON.parse(raw));
            }
            catch (err) {
                e(new Error(nls.localize(0, null)));
            }
        });
    }
    function validate(zipPath, extension, version) {
        if (version === void 0) { version = extension && extension.version; }
        return zip_1.buffer(zipPath, 'extension/package.json')
            .then(function (buffer) { return parseManifest(buffer.toString('utf8')); })
            .then(function (manifest) {
            if (extension) {
                if (extension.name !== manifest.name) {
                    return winjs_base_1.Promise.wrapError(Error(nls.localize(1, null)));
                }
                if (extension.publisher !== manifest.publisher) {
                    return winjs_base_1.Promise.wrapError(Error(nls.localize(2, null)));
                }
                if (version !== manifest.version) {
                    return winjs_base_1.Promise.wrapError(Error(nls.localize(3, null)));
                }
            }
            return winjs_base_1.TPromise.as(manifest);
        });
    }
    function createExtension(manifest, galleryInformation, path) {
        var extension = {
            name: manifest.name,
            displayName: manifest.displayName || manifest.name,
            publisher: manifest.publisher,
            version: manifest.version,
            engines: { vscode: manifest.engines.vscode },
            description: manifest.description || ''
        };
        if (galleryInformation) {
            extension.galleryInformation = galleryInformation;
        }
        if (path) {
            extension.path = path;
        }
        return extension;
    }
    function getExtensionId(extension, version) {
        if (version === void 0) { version = extension.version; }
        return extension.publisher + "." + extension.name + "-" + version;
    }
    var ExtensionsService = (function () {
        function ExtensionsService(contextService) {
            this.contextService = contextService;
            this.serviceId = extensions_1.IExtensionsService;
            this._onInstallExtension = new event_1.Emitter();
            this.onInstallExtension = this._onInstallExtension.event;
            this._onDidInstallExtension = new event_1.Emitter();
            this.onDidInstallExtension = this._onDidInstallExtension.event;
            this._onUninstallExtension = new event_1.Emitter();
            this.onUninstallExtension = this._onUninstallExtension.event;
            this._onDidUninstallExtension = new event_1.Emitter();
            this.onDidUninstallExtension = this._onDidUninstallExtension.event;
            var env = contextService.getConfiguration().env;
            this.extensionsPath = env.userExtensionsHome;
            this.obsoletePath = path.join(this.extensionsPath, '.obsolete');
            this.obsoleteFileLimiter = new async_1.Limiter(1);
        }
        ExtensionsService.prototype.install = function (arg) {
            var _this = this;
            if (types.isString(arg)) {
                return this.installFromZip(arg);
            }
            var extension = arg;
            return this.isObsolete(extension).then(function (obsolete) {
                if (obsolete) {
                    return winjs_base_1.TPromise.wrapError(new Error(nls.localize(4, null, extension.name)));
                }
                return _this.installFromGallery(arg);
            });
        };
        ExtensionsService.prototype.installFromGallery = function (extension) {
            var _this = this;
            var galleryInformation = extension.galleryInformation;
            if (!galleryInformation) {
                return winjs_base_1.TPromise.wrapError(new Error(nls.localize(5, null)));
            }
            this._onInstallExtension.fire(extension);
            return this.getLastValidExtensionVersion(extension, extension.galleryInformation.versions).then(function (versionInfo) {
                var version = versionInfo.version;
                var url = versionInfo.downloadUrl;
                var headers = versionInfo.downloadHeaders;
                var zipPath = path.join(os_1.tmpdir(), galleryInformation.id);
                var extensionPath = path.join(_this.extensionsPath, getExtensionId(extension, version));
                var manifestPath = path.join(extensionPath, 'package.json');
                return _this.request(url)
                    .then(function (opts) { return objects_1.assign(opts, { headers: headers }); })
                    .then(function (opts) { return request_1.download(zipPath, opts); })
                    .then(function () { return validate(zipPath, extension, version); })
                    .then(function (manifest) { return zip_1.extract(zipPath, extensionPath, { sourcePath: 'extension', overwrite: true }).then(function () { return manifest; }); })
                    .then(function (manifest) { return objects_1.assign({ __metadata: galleryInformation }, manifest); })
                    .then(function (manifest) { return pfs.writeFile(manifestPath, JSON.stringify(manifest, null, '\t')); })
                    .then(function () { _this._onDidInstallExtension.fire({ extension: extension }); return extension; })
                    .then(null, function (error) { _this._onDidInstallExtension.fire({ extension: extension, error: error }); return winjs_base_1.TPromise.wrapError(error); });
            });
        };
        ExtensionsService.prototype.getLastValidExtensionVersion = function (extension, versions) {
            var _this = this;
            if (!versions.length) {
                return winjs_base_1.TPromise.wrapError(new Error(nls.localize(6, null, extension.displayName)));
            }
            var version = versions[0];
            return this.request(version.manifestUrl)
                .then(function (opts) { return request_1.json(opts); })
                .then(function (manifest) {
                var codeVersion = _this.contextService.getConfiguration().env.version;
                var desc = {
                    isBuiltin: false,
                    engines: { vscode: manifest.engines.vscode },
                    main: manifest.main
                };
                if (!extensionValidator_1.isValidExtensionVersion(codeVersion, desc, [])) {
                    return _this.getLastValidExtensionVersion(extension, versions.slice(1));
                }
                return version;
            });
        };
        ExtensionsService.prototype.installFromZip = function (zipPath) {
            var _this = this;
            return validate(zipPath).then(function (manifest) {
                var extensionPath = path.join(_this.extensionsPath, getExtensionId(manifest));
                _this._onInstallExtension.fire(manifest);
                return zip_1.extract(zipPath, extensionPath, { sourcePath: 'extension', overwrite: true })
                    .then(function () { return createExtension(manifest, manifest.__metadata, extensionPath); })
                    .then(function (extension) { _this._onDidInstallExtension.fire({ extension: extension }); return extension; });
            });
        };
        ExtensionsService.prototype.uninstall = function (extension) {
            var _this = this;
            var extensionPath = extension.path || path.join(this.extensionsPath, getExtensionId(extension));
            return pfs.exists(extensionPath)
                .then(function (exists) { return exists ? null : winjs_base_1.Promise.wrapError(new Error(nls.localize(7, null))); })
                .then(function () { return _this._onUninstallExtension.fire(extension); })
                .then(function () { return _this.setObsolete(extension); })
                .then(function () { return pfs.rimraf(extensionPath); })
                .then(function () { return _this.unsetObsolete(extension); })
                .then(function () { return _this._onDidUninstallExtension.fire(extension); });
        };
        ExtensionsService.prototype.getInstalled = function (includeDuplicateVersions) {
            if (includeDuplicateVersions === void 0) { includeDuplicateVersions = false; }
            var all = this.getAllInstalled();
            if (includeDuplicateVersions) {
                return all;
            }
            return all.then(function (extensions) {
                var byId = collections_1.values(collections_1.groupBy(extensions, function (p) { return (p.publisher + "." + p.name); }));
                return byId.map(function (p) { return p.sort(function (a, b) { return semver.rcompare(a.version, b.version); })[0]; });
            });
        };
        ExtensionsService.prototype.getAllInstalled = function () {
            var _this = this;
            var limiter = new async_1.Limiter(10);
            return this.getObsoleteExtensions()
                .then(function (obsolete) {
                return pfs.readdir(_this.extensionsPath)
                    .then(function (extensions) { return extensions.filter(function (e) { return !obsolete[e]; }); })
                    .then(function (extensions) { return winjs_base_1.Promise.join(extensions.map(function (e) {
                    var extensionPath = path.join(_this.extensionsPath, e);
                    return limiter.queue(function () { return pfs.readFile(path.join(extensionPath, 'package.json'), 'utf8')
                        .then(function (raw) { return parseManifest(raw); })
                        .then(function (manifest) { return createExtension(manifest, manifest.__metadata, extensionPath); })
                        .then(null, function () { return null; }); });
                })); })
                    .then(function (result) { return result.filter(function (a) { return !!a; }); });
            });
        };
        ExtensionsService.prototype.removeDeprecatedExtensions = function () {
            var _this = this;
            var outdated = this.getOutdatedExtensions()
                .then(function (extensions) { return extensions.map(function (e) { return getExtensionId(e); }); });
            var obsolete = this.getObsoleteExtensions()
                .then(function (obsolete) { return Object.keys(obsolete); });
            return winjs_base_1.TPromise.join([outdated, obsolete])
                .then(function (result) { return arrays_1.flatten(result); })
                .then(function (extensionsIds) {
                return winjs_base_1.TPromise.join(extensionsIds.map(function (id) {
                    return pfs.rimraf(path.join(_this.extensionsPath, id))
                        .then(function () { return _this.withObsoleteExtensions(function (obsolete) { return delete obsolete[id]; }); });
                }));
            });
        };
        ExtensionsService.prototype.getOutdatedExtensions = function () {
            return this.getAllInstalled().then(function (plugins) {
                var byId = collections_1.values(collections_1.groupBy(plugins, function (p) { return (p.publisher + "." + p.name); }));
                var extensions = arrays_1.flatten(byId.map(function (p) { return p.sort(function (a, b) { return semver.rcompare(a.version, b.version); }).slice(1); }));
                return extensions
                    .filter(function (e) { return !!e.path; });
            });
        };
        ExtensionsService.prototype.isObsolete = function (extension) {
            var id = getExtensionId(extension);
            return this.withObsoleteExtensions(function (obsolete) { return !!obsolete[id]; });
        };
        ExtensionsService.prototype.setObsolete = function (extension) {
            var id = getExtensionId(extension);
            return this.withObsoleteExtensions(function (obsolete) { return objects_1.assign(obsolete, (_a = {}, _a[id] = true, _a)); var _a; });
        };
        ExtensionsService.prototype.unsetObsolete = function (extension) {
            var id = getExtensionId(extension);
            return this.withObsoleteExtensions(function (obsolete) { return delete obsolete[id]; });
        };
        ExtensionsService.prototype.getObsoleteExtensions = function () {
            return this.withObsoleteExtensions(function (obsolete) { return obsolete; });
        };
        ExtensionsService.prototype.withObsoleteExtensions = function (fn) {
            var _this = this;
            return this.obsoleteFileLimiter.queue(function () {
                var result = null;
                return pfs.readFile(_this.obsoletePath, 'utf8')
                    .then(null, function (err) { return err.code === 'ENOENT' ? winjs_base_1.TPromise.as('{}') : winjs_base_1.TPromise.wrapError(err); })
                    .then(function (raw) { return JSON.parse(raw); })
                    .then(function (obsolete) { result = fn(obsolete); return obsolete; })
                    .then(function (obsolete) {
                    if (Object.keys(obsolete).length === 0) {
                        return pfs.rimraf(_this.obsoletePath);
                    }
                    else {
                        var raw = JSON.stringify(obsolete);
                        return pfs.writeFile(_this.obsoletePath, raw);
                    }
                })
                    .then(function () { return result; });
            });
        };
        // Helper for proxy business... shameful.
        // This should be pushed down and not rely on the context service
        ExtensionsService.prototype.request = function (url) {
            var settings = winjs_base_1.TPromise.join([
                userSettings_1.UserSettings.getValue(this.contextService, 'http.proxy'),
                userSettings_1.UserSettings.getValue(this.contextService, 'http.proxyStrictSSL')
            ]);
            return settings.then(function (settings) {
                var proxyUrl = settings[0];
                var strictSSL = settings[1];
                var agent = proxy_1.getProxyAgent(url, { proxyUrl: proxyUrl, strictSSL: strictSSL });
                return { url: url, agent: agent, strictSSL: strictSSL };
            });
        };
        __decorate([
            service_1.ServiceEvent
        ], ExtensionsService.prototype, "onInstallExtension", void 0);
        __decorate([
            service_1.ServiceEvent
        ], ExtensionsService.prototype, "onDidInstallExtension", void 0);
        __decorate([
            service_1.ServiceEvent
        ], ExtensionsService.prototype, "onUninstallExtension", void 0);
        __decorate([
            service_1.ServiceEvent
        ], ExtensionsService.prototype, "onDidUninstallExtension", void 0);
        ExtensionsService = __decorate([
            __param(0, contextService_1.IWorkspaceContextService)
        ], ExtensionsService);
        return ExtensionsService;
    }());
    exports.ExtensionsService = ExtensionsService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define("vs/workbench/node/extensionHostMain", ["require", "exports", 'vs/nls!vs/workbench/node/extensionHostMain', 'vs/base/node/pfs', 'vs/base/common/uri', 'vs/base/common/winjs.base', 'vs/base/common/paths', 'vs/platform/extensions/common/extensions', 'vs/platform/extensions/common/extensionsRegistry', 'vs/workbench/api/node/extHost.api.impl', 'vs/workbench/api/node/extHostDocuments', 'vs/platform/instantiation/common/instantiationService', 'vs/platform/extensions/common/nativeExtensionService', 'vs/platform/thread/common/extHostThreadService', 'vs/workbench/api/node/extHostTelemetry', 'vs/platform/request/common/baseRequestService', 'vs/platform/workspace/common/baseWorkspaceContextService', 'vs/editor/common/services/modeServiceImpl', 'vs/workbench/node/extensionPoints', 'vs/platform/workspace/common/workspace', 'vs/workbench/parts/extensions/common/extensions', 'vs/workbench/parts/extensions/node/extensionsService'], function (require, exports, nls, pfs, uri_1, winjs_base_1, paths, extensions_1, extensionsRegistry_1, extHost_api_impl_1, extHostDocuments_1, InstantiationService, nativeExtensionService_1, extHostThreadService_1, extHostTelemetry_1, baseRequestService_1, baseWorkspaceContextService_1, modeServiceImpl_1, extensionPoints_1, workspace_1, extensions_2, extensionsService_1) {
    'use strict';
    var DIRNAME = uri_1.default.parse(require.toUrl('./')).fsPath;
    var BASE_PATH = paths.normalize(paths.join(DIRNAME, '../../../..'));
    var BUILTIN_EXTENSIONS_PATH = paths.join(BASE_PATH, 'extensions');
    var nativeExit = process.exit.bind(process);
    process.exit = function () {
        var err = new Error('An extension called process.exit() and this was prevented.');
        console.warn(err.stack);
    };
    function exit(code) {
        nativeExit(code);
    }
    exports.exit = exit;
    function createServices(remoteCom, initData, sharedProcessClient) {
        var contextService = new baseWorkspaceContextService_1.BaseWorkspaceContextService(initData.contextService.workspace, initData.contextService.configuration, initData.contextService.options);
        var threadService = new extHostThreadService_1.ExtHostThreadService(remoteCom);
        threadService.setInstantiationService(InstantiationService.createInstantiationService({ threadService: threadService }));
        var telemetryService = new extHostTelemetry_1.ExtHostTelemetryService(threadService);
        var requestService = new baseRequestService_1.BaseRequestService(contextService, telemetryService);
        var modelService = threadService.getRemotable(extHostDocuments_1.ExtHostModelService);
        var extensionService = new nativeExtensionService_1.ExtHostExtensionService(threadService, telemetryService);
        var modeService = new modeServiceImpl_1.ModeServiceImpl(threadService, extensionService);
        var _services = {
            contextService: contextService,
            requestService: requestService,
            modelService: modelService,
            threadService: threadService,
            modeService: modeService,
            extensionService: extensionService,
            telemetryService: telemetryService
        };
        var instantiationService = InstantiationService.createInstantiationService(_services);
        threadService.setInstantiationService(instantiationService);
        // Create the monaco API
        instantiationService.createInstance(extHost_api_impl_1.ExtHostAPIImplementation);
        // Connect to shared process services
        instantiationService.addSingleton(extensions_2.IExtensionsService, sharedProcessClient.getService('ExtensionService', extensionsService_1.ExtensionsService));
        return instantiationService;
    }
    exports.createServices = createServices;
    var ExtensionHostMain = (function () {
        function ExtensionHostMain(contextService, extensionService) {
            this._isTerminating = false;
            this._contextService = contextService;
            this._extensionService = extensionService;
        }
        ExtensionHostMain.prototype.start = function () {
            return this.readExtensions();
        };
        ExtensionHostMain.prototype.terminate = function () {
            var _this = this;
            if (this._isTerminating) {
                // we are already shutting down...
                return;
            }
            this._isTerminating = true;
            try {
                var allExtensions = extensionsRegistry_1.ExtensionsRegistry.getAllExtensionDescriptions();
                var allExtensionsIds = allExtensions.map(function (ext) { return ext.id; });
                var activatedExtensions = allExtensionsIds.filter(function (id) { return _this._extensionService.isActivated(id); });
                activatedExtensions.forEach(function (extensionId) {
                    _this._extensionService.deactivate(extensionId);
                });
            }
            catch (err) {
            }
            // Give extensions 1 second to wrap up any async dispose, then exit
            setTimeout(function () {
                exit();
            }, 1000);
        };
        ExtensionHostMain.prototype.readExtensions = function () {
            var _this = this;
            var collector = new extensionPoints_1.MessagesCollector();
            var env = this._contextService.getConfiguration().env;
            return ExtensionHostMain.scanExtensions(collector, BUILTIN_EXTENSIONS_PATH, !env.disableExtensions ? env.userExtensionsHome : void 0, !env.disableExtensions ? env.extensionDevelopmentPath : void 0, env.version)
                .then(null, function (err) {
                collector.error('', err);
                return [];
            })
                .then(function (extensions) {
                // Register & Signal done
                extensionsRegistry_1.ExtensionsRegistry.registerExtensions(extensions);
                _this._extensionService.registrationDone(collector.getMessages());
            })
                .then(function () { return _this.handleEagerExtensions(); })
                .then(function () { return _this.handleExtensionTests(); });
        };
        ExtensionHostMain.scanExtensions = function (collector, builtinExtensionsPath, userInstallPath, extensionDevelopmentPath, version) {
            var builtinExtensions = extensionPoints_1.ExtensionScanner.scanExtensions(version, collector, builtinExtensionsPath, true);
            var userExtensions = !userInstallPath ? winjs_base_1.TPromise.as([]) : extensionPoints_1.ExtensionScanner.scanExtensions(version, collector, userInstallPath, false);
            var developedExtensions = !extensionDevelopmentPath ? winjs_base_1.TPromise.as([]) : extensionPoints_1.ExtensionScanner.scanOneOrMultipleExtensions(version, collector, extensionDevelopmentPath, false);
            return winjs_base_1.TPromise.join([builtinExtensions, userExtensions, developedExtensions]).then(function (_) {
                var builtinExtensions = _[0];
                var userExtensions = _[1];
                var developedExtensions = _[2];
                var result = {};
                builtinExtensions.forEach(function (builtinExtension) {
                    result[builtinExtension.id] = builtinExtension;
                });
                userExtensions.forEach(function (userExtension) {
                    if (result.hasOwnProperty(userExtension.id)) {
                        collector.warn(userExtension.extensionFolderPath, nls.localize(0, null, result[userExtension.id].extensionFolderPath, userExtension.extensionFolderPath));
                    }
                    result[userExtension.id] = userExtension;
                });
                developedExtensions.forEach(function (developedExtension) {
                    collector.info('', nls.localize(1, null, developedExtension.extensionFolderPath));
                    if (result.hasOwnProperty(developedExtension.id)) {
                        collector.warn(developedExtension.extensionFolderPath, nls.localize(2, null, result[developedExtension.id].extensionFolderPath, developedExtension.extensionFolderPath));
                    }
                    result[developedExtension.id] = developedExtension;
                });
                return Object.keys(result).map(function (name) { return result[name]; });
            });
        };
        // Handle "eager" activation extensions
        ExtensionHostMain.prototype.handleEagerExtensions = function () {
            this._extensionService.activateByEvent('*').then(null, function (err) {
                console.error(err);
            });
            return this.handleWorkspaceContainsEagerExtensions();
        };
        ExtensionHostMain.prototype.handleWorkspaceContainsEagerExtensions = function () {
            var _this = this;
            var workspace = this._contextService.getWorkspace();
            if (!workspace || !workspace.resource) {
                return winjs_base_1.TPromise.as(null);
            }
            var folderPath = workspace.resource.fsPath;
            var desiredFilesMap = {};
            extensionsRegistry_1.ExtensionsRegistry.getAllExtensionDescriptions().forEach(function (desc) {
                var activationEvents = desc.activationEvents;
                if (!activationEvents) {
                    return;
                }
                for (var i = 0; i < activationEvents.length; i++) {
                    if (/^workspaceContains:/.test(activationEvents[i])) {
                        var fileName = activationEvents[i].substr('workspaceContains:'.length);
                        desiredFilesMap[fileName] = true;
                    }
                }
            });
            return winjs_base_1.TPromise.join(Object.keys(desiredFilesMap).map(function (fileName) { return pfs.fileExistsWithResult(paths.join(folderPath, fileName), fileName); })).then(function (fileNames) {
                fileNames.forEach(function (existingFileName) {
                    if (!existingFileName) {
                        return;
                    }
                    var activationEvent = 'workspaceContains:' + existingFileName;
                    _this._extensionService.activateByEvent(activationEvent).then(null, function (err) {
                        console.error(err);
                    });
                });
            });
        };
        ExtensionHostMain.prototype.handleExtensionTests = function () {
            var _this = this;
            var env = this._contextService.getConfiguration().env;
            if (!env.extensionTestsPath || !env.extensionDevelopmentPath) {
                return winjs_base_1.TPromise.as(null);
            }
            // Require the test runner via node require from the provided path
            var testRunner;
            var requireError;
            try {
                testRunner = require.__$__nodeRequire(env.extensionTestsPath);
            }
            catch (error) {
                requireError = error;
            }
            // Execute the runner if it follows our spec
            if (testRunner && typeof testRunner.run === 'function') {
                return new winjs_base_1.TPromise(function (c, e) {
                    testRunner.run(env.extensionTestsPath, function (error, failures) {
                        if (error) {
                            e(error.toString());
                        }
                        else {
                            c(null);
                        }
                        // after tests have run, we shutdown the host
                        _this.gracefulExit(failures && failures > 0 ? 1 /* ERROR */ : 0 /* OK */);
                    });
                });
            }
            else {
                this.gracefulExit(1 /* ERROR */);
            }
            return winjs_base_1.TPromise.wrapError(requireError ? requireError.toString() : nls.localize(3, null, env.extensionTestsPath));
        };
        ExtensionHostMain.prototype.gracefulExit = function (code) {
            // to give the PH process a chance to flush any outstanding console
            // messages to the main process, we delay the exit() by some time
            setTimeout(function () { return exit(code); }, 500);
        };
        ExtensionHostMain = __decorate([
            __param(0, workspace_1.IWorkspaceContextService),
            __param(1, extensions_1.IExtensionService)
        ], ExtensionHostMain);
        return ExtensionHostMain;
    }());
    exports.ExtensionHostMain = ExtensionHostMain;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("vs/workbench/node/pluginHostProcess", ["require", "exports", 'vs/base/common/errors', 'vs/base/common/winjs.base', 'vs/workbench/node/extensionHostMain', 'vs/base/node/service.net', 'vs/platform/extensions/common/ipcRemoteCom', 'vs/base/common/marshalling'], function (require, exports, errors_1, winjs_base_1, extensionHostMain_1, service_net_1, ipcRemoteCom_1, marshalling) {
    'use strict';
    // This calls exit directly in case the initialization is not finished and we need to exit
    // Otherwise, if initialization completed we go to extensionHostMain.terminate()
    var onTerminate = function () {
        extensionHostMain_1.exit();
    };
    function connectToRenderer() {
        return new winjs_base_1.TPromise(function (c, e) {
            var stats = [];
            // Listen init data message
            process.once('message', function (raw) {
                var msg = marshalling.parse(raw);
                var remoteCom = ipcRemoteCom_1.create(function (data) {
                    process.send(data);
                    stats.push(data.length);
                });
                // Listen to all other messages
                process.on('message', function (msg) {
                    if (msg.type === '__$terminate') {
                        onTerminate();
                        return;
                    }
                    remoteCom.handle(msg);
                });
                // Print a console message when rejection isn't handled within N seconds. For details:
                // see https://nodejs.org/api/process.html#process_event_unhandledrejection
                // and https://nodejs.org/api/process.html#process_event_rejectionhandled
                var unhandledPromises = [];
                process.on('unhandledRejection', function (reason, promise) {
                    unhandledPromises.push(promise);
                    setTimeout(function () {
                        var idx = unhandledPromises.indexOf(promise);
                        if (idx >= 0) {
                            unhandledPromises.splice(idx, 1);
                            console.warn('rejected promise not handled with 1 second');
                            errors_1.onUnexpectedError(reason);
                        }
                    }, 1000);
                });
                process.on('rejectionHandled', function (promise) {
                    var idx = unhandledPromises.indexOf(promise);
                    if (idx >= 0) {
                        unhandledPromises.splice(idx, 1);
                    }
                });
                // Print a console message when an exception isn't handled.
                process.on('uncaughtException', function (err) {
                    errors_1.onUnexpectedError(err);
                });
                // Kill oneself if one's parent dies. Much drama.
                setInterval(function () {
                    try {
                        process.kill(msg.parentPid, 0); // throws an exception if the main process doesn't exist anymore.
                    }
                    catch (e) {
                        onTerminate();
                    }
                }, 5000);
                // Check stats
                setInterval(function () {
                    if (stats.length >= 250) {
                        var total = stats.reduce(function (prev, current) { return prev + current; }, 0);
                        console.warn("MANY messages are being SEND FROM the extension host!");
                        console.warn("SEND during 1sec: message_count=" + stats.length + ", total_len=" + total);
                    }
                    stats.length = 0;
                }, 1000);
                // Tell the outside that we are initialized
                process.send('initialized');
                c({ remoteCom: remoteCom, initData: msg });
            });
            // Tell the outside that we are ready to receive messages
            process.send('ready');
        });
    }
    function connectToSharedProcess() {
        return service_net_1.connect(process.env['VSCODE_SHARED_IPC_HOOK']);
    }
    winjs_base_1.TPromise.join([connectToRenderer(), connectToSharedProcess()])
        .done(function (result) {
        var renderer = result[0];
        var sharedProcessClient = result[1];
        var instantiationService = extensionHostMain_1.createServices(renderer.remoteCom, renderer.initData, sharedProcessClient);
        var extensionHostMain = instantiationService.createInstance(extensionHostMain_1.ExtensionHostMain);
        onTerminate = function () {
            extensionHostMain.terminate();
        };
        extensionHostMain.start()
            .done(null, function (err) { return console.error(err); });
    });
});

//# sourceMappingURL=pluginHostProcess.js.map
