/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var File = require("vinyl");
var lib_1 = require("./lib");
var event_stream_1 = require("event-stream");
var Is = require("is");
var xml2js = require("xml2js");
var glob = require("glob");
var https = require("https");
var util = require('gulp-util');
var iconv = require('iconv-lite');
function log(message) {
    var rest = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        rest[_i - 1] = arguments[_i];
    }
    util.log.apply(util, [util.colors.cyan('[i18n]'), message].concat(rest));
}
var NLS_JSON = '.nls.json';
var I18N_JSON = '.i18n.json';
function rewriteLocalizeCalls() {
    return event_stream_1.through(function (file) {
        if (!file.isBuffer()) {
            this.emit('error', "Failed to read file: " + file.relative);
        }
        var buffer = file.contents;
        var content = buffer.toString('utf8');
        var sourceMap = file.sourceMap;
        var result = lib_1.processFile(content, sourceMap);
        var bundleFile;
        if (result.errors && result.errors.length > 0) {
            result.errors.forEach(function (error) { return console.error("" + file.relative + error); });
            this.emit('error', "Failed to rewite file: " + file.relative);
        }
        else {
            if (result.contents) {
                file.contents = new Buffer(result.contents, 'utf8');
            }
            if (result.sourceMap) {
                file.sourceMap = JSON.parse(result.sourceMap);
            }
            if (result.bundle) {
                var ext = path.extname(file.path);
                bundleFile = new File({
                    base: file.base,
                    path: file.path.substr(0, file.path.length - ext.length) + NLS_JSON,
                    contents: new Buffer(JSON.stringify(result.bundle, null, '\t'), 'utf8')
                });
            }
        }
        this.emit('data', file);
        if (bundleFile) {
            this.emit('data', bundleFile);
        }
    });
}
exports.rewriteLocalizeCalls = rewriteLocalizeCalls;
/**
 * This map is used to map our 3 letter encoding in the
 * i18n folder to a file extension matching what is returned
 * from app.getOSLocale().
 */
var iso639_3_to_2 = {
    'chs': 'zh-cn',
    'cht': 'zh-tw',
    'csy': 'cs-cz',
    'deu': 'de',
    'enu': 'en',
    'esn': 'es',
    'fra': 'fr',
    'hun': 'hu',
    'ita': 'it',
    'jpn': 'ja',
    'kor': 'ko',
    'nld': 'nl',
    'plk': 'pl',
    'ptb': 'pt-br',
    'ptg': 'pt',
    'rus': 'ru',
    'sve': 'sv-se',
    'trk': 'tr'
};
exports.coreLanguages = ['chs', 'cht', 'jpn', 'kor', 'deu', 'fra', 'esn', 'rus', 'ita'];
function createAdditionalLanguageFiles(languages, i18nBaseDir, baseDir) {
    return event_stream_1.through(function (file) {
        var _this = this;
        var basename = path.basename(file.relative);
        if (basename.length < NLS_JSON.length || NLS_JSON !== basename.substr(basename.length - NLS_JSON.length)) {
            this.emit('data', file);
            return;
        }
        var filename = file.relative.substr(0, file.relative.length - NLS_JSON.length);
        var json;
        if (file.isBuffer()) {
            var buffer = file.contents;
            json = JSON.parse(buffer.toString('utf8'));
            var resolvedBundle_1 = lib_1.resolveMessageBundle(json);
            languages.forEach(function (language) {
                var result = lib_1.createLocalizedMessages(filename, resolvedBundle_1, language, i18nBaseDir, baseDir);
                if (result.problems && result.problems.length > 0) {
                    result.problems.forEach(function (problem) { return log(problem); });
                }
                if (result.messages) {
                    _this.emit('data', new File({
                        base: file.base,
                        path: path.join(file.base, filename) + '.nls.' + iso639_3_to_2[language] + '.json',
                        contents: new Buffer(JSON.stringify(result.messages, null, '\t').replace(/\r\n/g, '\n'), 'utf8')
                    }));
                }
            });
        }
        else {
            this.emit('error', "Failed to read component file: " + file.relative);
        }
        this.emit('data', file);
    });
}
exports.createAdditionalLanguageFiles = createAdditionalLanguageFiles;
/**
 * A stream the creates additional key/value pair files for structured nls files.
 *
 * @param commentSeparator - if provided comments will be joined into one string using
 *  the commentSeparator value. If omitted comments will be includes as a string array.
 */
function createKeyValuePairFile(commentSeparator) {
    if (commentSeparator === void 0) { commentSeparator = undefined; }
    return event_stream_1.through(function (file) {
        var basename = path.basename(file.relative);
        if (basename.length < NLS_JSON.length || NLS_JSON !== basename.substr(basename.length - NLS_JSON.length)) {
            this.emit('data', file);
            return;
        }
        var json;
        var kvpFile;
        var filename = file.relative.substr(0, file.relative.length - NLS_JSON.length);
        if (file.isBuffer()) {
            var buffer = file.contents;
            json = JSON.parse(buffer.toString('utf8'));
            if (lib_1.JavaScriptMessageBundle.is(json)) {
                var resolvedBundle = json;
                if (resolvedBundle.messages.length !== resolvedBundle.keys.length) {
                    this.emit('data', file);
                    return;
                }
                var kvpObject = lib_1.bundle2keyValuePair(resolvedBundle, commentSeparator);
                kvpFile = new File({
                    base: file.base,
                    path: path.join(file.base, filename) + I18N_JSON,
                    contents: new Buffer(JSON.stringify(kvpObject, null, '\t'), 'utf8')
                });
            }
            else {
                this.emit('error', "Not a valid JavaScript message bundle: " + file.relative);
            }
        }
        else {
            this.emit('error', "Failed to read JavaScript message bundle file: " + file.relative);
        }
        this.emit('data', file);
        if (kvpFile) {
            this.emit('data', kvpFile);
        }
    });
}
exports.createKeyValuePairFile = createKeyValuePairFile;
var LocalizeInfo;
(function (LocalizeInfo) {
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.key) && (Is.undef(candidate.comment) || (Is.array(candidate.comment) && candidate.comment.every(function (element) { return Is.string(element); })));
    }
    LocalizeInfo.is = is;
})(LocalizeInfo || (LocalizeInfo = {}));
var PackageJsonFormat;
(function (PackageJsonFormat) {
    function is(value) {
        if (Is.undef(value) || !Is.object(value)) {
            return false;
        }
        return Object.keys(value).every(function (key) {
            var element = value[key];
            return Is.string(element) || (Is.object(element) && Is.defined(element.message) && Is.defined(element.comment));
        });
    }
    PackageJsonFormat.is = is;
})(PackageJsonFormat || (PackageJsonFormat = {}));
var ModuleJsonFormat;
(function (ModuleJsonFormat) {
    function is(value) {
        var candidate = value;
        return Is.defined(candidate)
            && Is.array(candidate.messages) && candidate.messages.every(function (message) { return Is.string(message); })
            && Is.array(candidate.keys) && candidate.keys.every(function (key) { return Is.string(key) || LocalizeInfo.is(key); });
    }
    ModuleJsonFormat.is = is;
})(ModuleJsonFormat || (ModuleJsonFormat = {}));
var Line = (function () {
    function Line(indent) {
        if (indent === void 0) { indent = 0; }
        this.indent = indent;
        this.buffer = [];
        if (indent > 0) {
            this.buffer.push(new Array(indent + 1).join(' '));
        }
    }
    Line.prototype.append = function (value) {
        this.buffer.push(value);
        return this;
    };
    Line.prototype.toString = function () {
        return this.buffer.join('');
    };
    return Line;
}());
exports.Line = Line;
var XLF = (function () {
    function XLF(project) {
        this.project = project;
        this.buffer = [];
        this.files = Object.create(null);
    }
    XLF.prototype.toString = function () {
        this.appendHeader();
        for (var file in this.files) {
            this.appendNewLine("<file original=\"" + file + "\" source-language=\"en\" datatype=\"plaintext\"><body>", 2);
            for (var _i = 0, _a = this.files[file]; _i < _a.length; _i++) {
                var item = _a[_i];
                this.addStringItem(item);
            }
            this.appendNewLine('</body></file>', 2);
        }
        this.appendFooter();
        return this.buffer.join('\r\n');
    };
    XLF.prototype.addFile = function (original, keys, messages) {
        this.files[original] = [];
        var existingKeys = [];
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            // Ignore duplicate keys because Transifex does not populate those with translated values.
            if (existingKeys.indexOf(key) !== -1) {
                continue;
            }
            existingKeys.push(key);
            var message = encodeEntities(messages[keys.indexOf(key)]);
            var comment = undefined;
            // Check if the message contains description (if so, it becomes an object type in JSON)
            if (Is.string(key)) {
                this.files[original].push({ id: key, message: message, comment: comment });
            }
            else {
                if (key['comment'] && key['comment'].length > 0) {
                    comment = key['comment'].map(function (comment) { return encodeEntities(comment); }).join('\r\n');
                }
                this.files[original].push({ id: key['key'], message: message, comment: comment });
            }
        }
    };
    XLF.prototype.addStringItem = function (item) {
        if (!item.id || !item.message) {
            throw new Error('No item ID or value specified.');
        }
        this.appendNewLine("<trans-unit id=\"" + item.id + "\">", 4);
        this.appendNewLine("<source xml:lang=\"en\">" + item.message + "</source>", 6);
        if (item.comment) {
            this.appendNewLine("<note>" + item.comment + "</note>", 6);
        }
        this.appendNewLine('</trans-unit>', 4);
    };
    XLF.prototype.appendHeader = function () {
        this.appendNewLine('<?xml version="1.0" encoding="utf-8"?>', 0);
        this.appendNewLine('<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2">', 0);
    };
    XLF.prototype.appendFooter = function () {
        this.appendNewLine('</xliff>', 0);
    };
    XLF.prototype.appendNewLine = function (content, indent) {
        var line = new Line(indent);
        line.append(content);
        this.buffer.push(line.toString());
    };
    return XLF;
}());
XLF.parse = function (xlfString) {
    return new Promise(function (resolve, reject) {
        var parser = new xml2js.Parser();
        var files = [];
        parser.parseString(xlfString, function (err, result) {
            if (err) {
                reject("Failed to parse XLIFF string. " + err);
            }
            var fileNodes = result['xliff']['file'];
            if (!fileNodes) {
                reject('XLIFF file does not contain "xliff" or "file" node(s) required for parsing.');
            }
            fileNodes.forEach(function (file) {
                var originalFilePath = file.$.original;
                if (!originalFilePath) {
                    reject('XLIFF file node does not contain original attribute to determine the original location of the resource file.');
                }
                var language = file.$['target-language'].toLowerCase();
                if (!language) {
                    reject('XLIFF file node does not contain target-language attribute to determine translated language.');
                }
                var messages = {};
                var transUnits = file.body[0]['trans-unit'];
                transUnits.forEach(function (unit) {
                    var key = unit.$.id;
                    if (!unit.target) {
                        return; // No translation available
                    }
                    var val = unit.target.toString();
                    if (key && val) {
                        messages[key] = decodeEntities(val);
                    }
                    else {
                        reject('XLIFF file does not contain full localization data. ID or target translation for one of the trans-unit nodes is not present.');
                    }
                });
                files.push({ messages: messages, originalFilePath: originalFilePath, language: language });
            });
            resolve(files);
        });
    });
};
exports.XLF = XLF;
/**
 * This map is used to map the language of a Transifex Xlf file
 * to the folder representation in VS Code i18n folder.
 */
var iso639_2_to_3 = {
    'zh-cn': 'chs',
    'zh-tw': 'cht',
    'zh-hans': 'chs',
    'zh-hant': 'cht',
    'cs-cz': 'csy',
    'de': 'deu',
    'en': 'enu',
    'es': 'esn',
    'fr': 'fra',
    'hu': 'hun',
    'it': 'ita',
    'ja': 'jpn',
    'ko': 'kor',
    'nl': 'nld',
    'pl': 'plk',
    'pt-br': 'ptb',
    'pt': 'ptg',
    'ru': 'rus',
    'sv-se': 'sve',
    'tr': 'trk'
};
function prepareXlfFiles(projectName, extensionName) {
    return event_stream_1.through(function (file) {
        if (!file.isBuffer()) {
            log('Error', "Failed to read component file: " + file.relative);
        }
        var extension = path.extname(file.path);
        if (extension === '.json') {
            var json = JSON.parse(file.contents.toString('utf8'));
            if (PackageJsonFormat.is(json) || ModuleJsonFormat.is(json)) {
                importModuleOrPackageJson(file, json, projectName, this, extensionName);
            }
            else {
                log('Error', 'JSON format cannot be deduced.');
            }
        }
    });
}
exports.prepareXlfFiles = prepareXlfFiles;
var extensions = Object.create(null);
function importModuleOrPackageJson(file, json, projectName, stream, extensionName) {
    if (ModuleJsonFormat.is(json) && json['keys'].length !== json['messages'].length) {
        throw new Error("There is a mismatch between keys and messages in " + file.relative);
    }
    // Prepare the source path for <original/> attribute in XLF & extract messages from JSON
    var formattedSourcePath = file.relative.replace(/\\/g, '/');
    var messages = Object.keys(json).map(function (key) { return json[key].toString(); });
    // Stores the amount of localization files to be transformed to XLF before the emission
    var localizationFilesCount = glob.sync('**/*.nls.json').length;
    var originalFilePath = "" + formattedSourcePath.substr(0, formattedSourcePath.length - '.nls.json'.length);
    var extension = extensions[extensionName] ?
        extensions[extensionName] : extensions[extensionName] = { xlf: new XLF(projectName), processed: 0 };
    // .nls.json can come with empty array of keys and messages, check for it
    if (ModuleJsonFormat.is(json) && json.keys.length !== 0) {
        extension.xlf.addFile(originalFilePath, json.keys, json.messages);
    }
    else if (PackageJsonFormat.is(json) && Object.keys(json).length !== 0) {
        extension.xlf.addFile(originalFilePath, Object.keys(json), messages);
    }
    // Check if XLF is populated with file nodes to emit it
    if (++extensions[extensionName].processed === localizationFilesCount) {
        var newFilePath = path.join(projectName, extensionName + '.xlf');
        var xlfFile = new File({ path: newFilePath, contents: new Buffer(extension.xlf.toString(), 'utf-8') });
        stream.emit('data', xlfFile);
    }
}
function pushXlfFiles(apiHostname, username, password) {
    var tryGetPromises = [];
    var updateCreatePromises = [];
    return event_stream_1.through(function (file) {
        var project = path.dirname(file.relative);
        var fileName = path.basename(file.path);
        var slug = fileName.substr(0, fileName.length - '.xlf'.length);
        var credentials = username + ":" + password;
        // Check if resource already exists, if not, then create it.
        var promise = tryGetResource(project, slug, apiHostname, credentials);
        tryGetPromises.push(promise);
        promise.then(function (exists) {
            if (exists) {
                promise = updateResource(project, slug, file, apiHostname, credentials);
            }
            else {
                promise = createResource(project, slug, file, apiHostname, credentials);
            }
            updateCreatePromises.push(promise);
        });
    }, function () {
        var _this = this;
        // End the pipe only after all the communication with Transifex API happened
        Promise.all(tryGetPromises).then(function () {
            Promise.all(updateCreatePromises).then(function () {
                _this.emit('end');
            }).catch(function (reason) { throw new Error(reason); });
        }).catch(function (reason) { throw new Error(reason); });
    });
}
exports.pushXlfFiles = pushXlfFiles;
function tryGetResource(project, slug, apiHostname, credentials) {
    return new Promise(function (resolve, reject) {
        var options = {
            hostname: apiHostname,
            path: "/api/2/project/" + project + "/resource/" + slug + "/?details",
            auth: credentials,
            method: 'GET'
        };
        var request = https.request(options, function (response) {
            if (response.statusCode === 404) {
                resolve(false);
            }
            else if (response.statusCode === 200) {
                resolve(true);
            }
            else {
                reject("Failed to query resource " + project + "/" + slug + ". Response: " + response.statusCode + " " + response.statusMessage);
            }
        });
        request.on('error', function (err) {
            reject("Failed to get " + project + "/" + slug + " on Transifex: " + err);
        });
        request.end();
    });
}
function createResource(project, slug, xlfFile, apiHostname, credentials) {
    return new Promise(function (resolve, reject) {
        var data = JSON.stringify({
            'content': xlfFile.contents.toString(),
            'name': slug,
            'slug': slug,
            'i18n_type': 'XLIFF'
        });
        var options = {
            hostname: apiHostname,
            path: "/api/2/project/" + project + "/resources",
            headers: {
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(data)
            },
            auth: credentials,
            method: 'POST'
        };
        var request = https.request(options, function (res) {
            if (res.statusCode === 201) {
                log("Resource " + project + "/" + slug + " successfully created on Transifex.");
            }
            else {
                reject("Something went wrong in the request creating " + slug + " in " + project + ". " + res.statusCode);
            }
        });
        request.on('error', function (err) {
            reject("Failed to create " + project + "/" + slug + " on Transifex: " + err);
        });
        request.write(data);
        request.end();
    });
}
/**
 * The following link provides information about how Transifex handles updates of a resource file:
 * https://dev.befoolish.co/tx-docs/public/projects/updating-content#what-happens-when-you-update-files
 */
function updateResource(project, slug, xlfFile, apiHostname, credentials) {
    return new Promise(function (resolve, reject) {
        var data = JSON.stringify({ content: xlfFile.contents.toString() });
        var options = {
            hostname: apiHostname,
            path: "/api/2/project/" + project + "/resource/" + slug + "/content",
            headers: {
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(data)
            },
            auth: credentials,
            method: 'PUT'
        };
        var request = https.request(options, function (res) {
            if (res.statusCode === 200) {
                res.setEncoding('utf8');
                var responseBuffer_1 = '';
                res.on('data', function (chunk) {
                    responseBuffer_1 += chunk;
                });
                res.on('end', function () {
                    var response = JSON.parse(responseBuffer_1);
                    log("Resource " + project + "/" + slug + " successfully updated on Transifex. Strings added: " + response.strings_added + ", updated: " + response.strings_added + ", deleted: " + response.strings_added);
                    resolve();
                });
            }
            else {
                reject("Something went wrong in the request updating " + slug + " in " + project + ". " + res.statusCode);
            }
        });
        request.on('error', function (err) {
            reject("Failed to update " + project + "/" + slug + " on Transifex: " + err);
        });
        request.write(data);
        request.end();
    });
}
function pullXlfFiles(apiHostname, username, password, languages, resources) {
    if (!resources) {
        throw new Error('Transifex projects and resources must be defined to be able to pull translations from Transifex.');
    }
    var credentials = username + ":" + password;
    var expectedTranslationsCount = languages.length * resources.length;
    var translationsRetrieved = 0, called = false;
    return event_stream_1.readable(function (count, callback) {
        // Mark end of stream when all resources were retrieved
        if (translationsRetrieved === expectedTranslationsCount) {
            return this.emit('end');
        }
        if (!called) {
            called = true;
            var stream_1 = this;
            languages.map(function (language) {
                resources.map(function (resource) {
                    retrieveResource(language, resource, apiHostname, credentials).then(function (file) {
                        stream_1.emit('data', file);
                        translationsRetrieved++;
                    }).catch(function (error) { throw new Error(error); });
                });
            });
        }
        callback();
    });
}
exports.pullXlfFiles = pullXlfFiles;
function retrieveResource(language, resource, apiHostname, credentials) {
    return new Promise(function (resolve, reject) {
        var slug = resource.name.replace(/\//g, '_');
        var project = resource.project;
        var iso639 = language.toLowerCase();
        var options = {
            hostname: apiHostname,
            path: "/api/2/project/" + project + "/resource/" + slug + "/translation/" + iso639 + "?file&mode=onlyreviewed",
            auth: credentials,
            method: 'GET'
        };
        var request = https.request(options, function (res) {
            var xlfBuffer = [];
            res.on('data', function (chunk) { return xlfBuffer.push(chunk); });
            res.on('end', function () {
                if (res.statusCode === 200) {
                    resolve(new File({ contents: Buffer.concat(xlfBuffer), path: project + "/" + iso639_2_to_3[language] + "/" + slug + ".xlf" }));
                }
                reject(slug + " in " + project + " returned no data. Response code: " + res.statusCode + ".");
            });
        });
        request.on('error', function (err) {
            reject("Failed to query resource " + slug + " with the following error: " + err);
        });
        request.end();
    });
}
function prepareJsonFiles() {
    var parsePromises = [];
    return event_stream_1.through(function (xlf) {
        var stream = this;
        var parsePromise = XLF.parse(xlf.contents.toString());
        parsePromises.push(parsePromise);
        parsePromise.then(function (resolvedFiles) {
            resolvedFiles.forEach(function (file) {
                var messages = file.messages, translatedFile;
                translatedFile = createI18nFile(iso639_2_to_3[file.language], file.originalFilePath, messages);
                stream.emit('data', translatedFile);
            });
        }, function (rejectReason) {
            throw new Error("XLF parsing error: " + rejectReason);
        });
    }, function () {
        var _this = this;
        Promise.all(parsePromises)
            .then(function () { _this.emit('end'); })
            .catch(function (reason) { throw new Error(reason); });
    });
}
exports.prepareJsonFiles = prepareJsonFiles;
function createI18nFile(base, originalFilePath, messages) {
    var content = [
        '/*---------------------------------------------------------------------------------------------',
        ' *  Copyright (c) Microsoft Corporation. All rights reserved.',
        ' *  Licensed under the MIT License. See License.txt in the project root for license information.',
        ' *--------------------------------------------------------------------------------------------*/',
        '// Do not edit this file. It is machine generated.'
    ].join('\n') + '\n' + JSON.stringify(messages, null, '\t').replace(/\r\n/g, '\n');
    return new File({
        path: path.join(base, originalFilePath + '.i18n.json'),
        contents: new Buffer(content, 'utf8')
    });
}
function encodeEntities(value) {
    var result = [];
    for (var i = 0; i < value.length; i++) {
        var ch = value[i];
        switch (ch) {
            case '<':
                result.push('&lt;');
                break;
            case '>':
                result.push('&gt;');
                break;
            case '&':
                result.push('&amp;');
                break;
            default:
                result.push(ch);
        }
    }
    return result.join('');
}
function decodeEntities(value) {
    return value.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');
}
//# sourceMappingURL=main.js.map